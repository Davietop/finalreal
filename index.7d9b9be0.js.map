{"mappings":"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AA,KAAA,IAAA,CAAA,EAAA,EAAA,EAAA,EAAA,CAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,EAAA,OAAA,KAAA,IAAA,CAAA,KAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,GAAA,KAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,GAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,EAAA,MAAA,AAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAAA,SAAA,GAAA,CAAA,EAAA,MAAA,AAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,IAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,EAAA,GAAA,EAAA,CAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,OAAA,KAAA,GAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,GAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,OAAA,GAAA,KAAA,GAAA,CAAA,EAAA,GAAA,GAAA,GAAA,KAAA,GAAA,CAAA,EAAA,GAAA,CAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,GAAA,CAAA,AAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,GAAA,EAAA,GAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,AAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA,EAAA,AAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EA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AAA,CAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,SAAA,EAAA,CAAA,EAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,CAAA,GAAA,GAAA,IAAA,GAAA,EAAA,IAAA,AAAA,IAAA,EAAA,AAAA,CAAA,OAAA,CAAA,GAAA,EAAA,WAAA,CAAA,CAAA,EAAA,EAAA,EAAA,EAAA,AAAA,EAAA,IAAA,EAAA,CAAA,CAAA,EAAA,WAAA,GAAA,CAAA,OAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,AAAA,IAAA,EAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA,IAAA,CAAA,AAAA,MAAA,AAAA,EAAA,MAAA,CAAA,GAAA,AAAA,SAAA,CAAA,EAAA,IAAA,EAAA,GAAA,IAAA,CAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAAA,GAAA,CAAA,CAAA,EAAA,GAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,GAAA,GAAA,GAAA,AAAA,IAAA,EAAA,EAAA,IAAA,CAAA,OAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,GAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,GAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,GAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,GAAA,AAAA,SAAA,CAAA,EAAA,IAAA,EAAA,GAAA,IAAA,CAAA,GAAA,EAAA,IAAA,EAAA,GAAA,CAAA,EAAA,MAAA,CAAA,CAAA,CAAA,EAAA,GAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,GAAA,CAAA,C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AAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,MAAA,CAAA,EAAA,GAAA,GAAA,EAAA,EAAA,CAAA,GAAA,GAAA,EAAA,CAAA,GAAA,CAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,CAAA,GAAA,GAAA,EAAA,CAAA,GAAA,CAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,CAAA,GAAA,GAAA,EAAA,CAAA,GAAA,CAAA,IAAA,EAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,AAAA,CAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,IAAA,AAAA,CAAA,OAAA,CAAA,OAAA,IAAA,GAAA,IAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,OAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,GAAA,GAAA,IAAA,AAAA,CAAA,QAAA,CAAA,CAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,OAAA,EAAA,CAAA,EAAA,EAAA,EAAA,IAAA,AAAA,CAAA,WAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,EAAA,GAAA,AAAA,GAAA,EAAA,CAAA,CAAA,AAAA,IAAA,EAAA,CAAA,CAAA,AAAA,IAAA,EAAA,CAAA,EAAA,OAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,IAAA,AAAA,CAAA,QAAA,CAAA,CAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,OAAA,EAAA,CAAA,EAAA,EAAA,EAAA,IAAA,AAAA,CAAA,QAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,OAAA,EAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,IAAA,AAAA,CAAA,QAAA,CAAA,CAAA,CAAA,OAAA,GAAA,IAAA,CAAA,IAAA,CAAA,EAAA,GAAA,IAAA,AAAA,CAAA,OAAA,CAAA,C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AAA,gBAAA,EAAA,eAAA,CAAA,YAAA,EAAA,WAAA,CAAA,YAAA,EAAA,WAAA,AAAA,CAAA,C,I,G,I,M,a,C,I,C,Q,C,K,I,C,O,C,I,I,I,C,Q,C,C,E,I,C,S,C,K,C,C,Q,C,C,C,C,C,C,C,C,C,I,E,E,S,C,E,C,E,E,Q,C,E,O,C,A,G,E,C,M,E,Q,E,O,C,S,E,Y,K,G,C,E,E,K,C,E,G,C,U,C,I,C,Q,E,C,I,C,Q,C,C,E,I,C,Q,C,G,I,C,O,K,I,C,O,G,I,C,Q,C,K,I,C,Q,E,I,C,Q,E,E,C,C,Q,E,K,G,E,C,C,I,E,C,C,I,C,O,C,O,C,C,E,K,G,C,E,O,E,C,E,K,C,M,C,O,I,E,E,K,C,E,E,M,C,E,E,C,E,E,K,G,E,E,E,A,C,E,C,C,E,A,E,O,C,C,E,M,C,E,Q,E,C,E,Q,C,E,M,A,E,E,I,C,G,E,C,C,E,C,C,C,E,C,C,C,E,M,C,E,C,E,G,E,C,C,G,C,E,I,G,I,C,O,C,E,E,E,W,E,E,M,E,C,E,O,C,C,E,I,C,O,C,E,E,E,Y,E,O,C,C,C,E,G,E,M,A,G,I,C,S,C,E,A,I,G,C,I,C,Q,C,C,C,C,C,U,C,C,C,I,E,I,C,O,C,E,E,G,C,G,O,G,C,E,C,Q,C,E,Q,C,E,M,E,C,U,C,S,E,C,S,E,A,C,E,E,G,C,E,E,E,C,C,O,C,C,C,C,C,C,C,I,C,S,C,G,S,C,E,C,I,C,E,C,I,C,C,C,C,C,A,G,E,M,E,I,C,S,C,G,K,C,I,I,E,C,I,C,C,C,O,I,C,S,C,G,K,C,M,C,C,C,M,C,C,C,I,E,I,C,O,C,G,C,E,C,G,C,E,O,C,C,E,E,K,C,K,G,G,E,Q,C,E,K,C,M,C,C,E,I,K,G,C,E,E,S,E,G,I,C,Q,E,C,C,Q,C,C,C,G,C,I,C,Q,C,M,C,E,I,E,I,C,O,C,G,C,G,M,C,C,C,G,C,E,O,E,C,E,K,C,M,A,C,C,K,C,C,C,I,E,I,C,O,C,G,C,G,G,C,G,C,E,K,C,M,C,O,I,E,E,K,C,E,E,M,C,E,K,G,E,E,E,C,C,E,C,M,E,C,E,K,C,E,C,I,C,O,C,E,E,K,G,G,W,C,O,C,C,C,O,I,C,O,C,M,C,E,C,E,I,G,c,G,C,Q,C,E,E,I,E,G,E,E,M,C,C,C,C,C,E,I,E,G,G,I,E,E,K,E,G,G,I,O,G,E,K,C,E,G,C,E,G,S,G,C,E,O,C,E,E,I,E,A,C,E,C,E,C,C,O,G,Y,C,C,C,C,C,C,C,C,C,I,E,C,C,E,C,E,G,C,E,E,C,E,E,E,I,C,E,I,E,G,C,E,I,C,E,E,C,C,I,C,O,C,C,E,I,C,G,C,E,E,E,E,C,E,I,E,O,E,C,I,C,O,C,E,C,E,M,C,E,G,M,C,I,C,M,C,K,K,C,K,G,G,C,E,K,E,C,G,I,C,S,C,I,C,M,C,K,K,C,E,Q,E,I,C,K,C,C,C,E,I,C,I,C,O,C,E,I,C,K,C,E,I,C,K,C,E,I,C,G,C,E,I,C,S,C,K,C,C,Q,C,O,I,C,O,A,C,O,C,C,C,C,C,C,C,G,I,C,O,C,C,I,C,O,C,C,G,I,E,I,C,O,C,I,C,K,C,C,E,E,I,C,M,C,E,I,C,S,C,C,C,I,C,M,C,E,I,C,S,C,K,K,C,K,G,C,E,E,Q,G,I,C,M,E,E,I,C,K,C,C,C,E,I,C,I,C,G,C,G,C,E,E,C,E,E,E,I,C,E,I,C,K,C,G,C,E,I,C,E,E,C,C,C,Q,C,I,C,O,E,C,I,C,I,C,K,G,I,I,C,O,C,C,E,I,C,O,C,C,E,C,C,K,C,C,K,E,I,E,E,I,C,M,C,E,I,C,S,C,E,I,C,K,C,E,I,C,K,C,E,I,C,K,C,E,I,C,G,C,G,I,C,O,C,I,G,C,G,E,C,E,C,I,C,O,C,C,I,C,O,C,E,C,E,I,C,O,C,C,G,M,C,G,E,E,C,I,C,O,C,E,C,E,M,C,E,E,E,E,E,G,E,E,E,E,E,E,I,C,O,C,K,G,C,E,K,G,C,E,K,I,C,O,C,E,C,I,C,G,C,E,E,E,C,M,C,I,E,I,C,S,E,C,I,C,S,C,E,A,E,O,I,Q,C,E,K,E,I,C,C,I,E,I,C,E,E,C,Q,C,C,C,I,E,E,M,M,E,I,C,S,E,E,C,I,I,E,E,E,E,M,C,I,C,C,E,C,E,E,C,C,G,G,C,Y,C,M,K,E,S,I,O,e,G,K,E,K,K,E,K,K,E,G,K,E,K,K,C,G,I,G,O,I,C,G,S,C,C,G,Q,C,Y,C,U,C,E,W,C,E,Y,A,G,A,e,G,A,e,G,A,O,C,G,G,G,C,a,C,O,C,K,Q,W,C,Q,c,kB,A,E,Q,C,K,S,W,C,I,I,c,S,U,A,C,G,G,Q,C,a,C,U,W,G,G,G,C,c,C,O,C,U,C,S,G,C,E,O,C,U,C,S,C,C,E,K,C,W,C,O,C,K,a,E,Q,C,K,U,S,C,C,C,E,K,C,W,C,O,C,G,a,E,Q,C,K,U,O,S,G,A,G,A,E,C,C,C,C,E,O,G,Y,C,C,C,C,C,I,C,M,C,E,I,C,W,C,I,I,I,C,S,C,E,C,U,C,C,C,G,C,G,G,O,I,E,I,C,W,C,O,mB,C,G,O,C,A,I,I,E,C,C,E,C,G,C,G,G,O,I,E,C,E,I,I,K,G,C,C,E,C,C,C,E,C,A,C,G,E,U,G,E,U,E,C,E,A,E,O,C,A,I,A,I,G,E,G,C,I,E,G,C,E,E,E,E,C,gB,C,C,C,C,C,I,E,E,O,C,E,A,S,C,C,C,E,G,C,E,O,I,E,E,O,C,G,C,E,C,E,O,C,E,M,C,O,E,O,E,C,E,O,C,E,O,M,C,C,E,E,C,Q,C,E,Y,C,C,E,E,C,E,E,G,G,C,E,M,E,C,I,E,I,C,iB,C,E,G,O,E,O,E,A,C,S,C,C,C,E,I,E,E,C,E,O,I,C,G,I,I,E,E,E,E,M,C,I,C,I,E,C,C,C,C,E,C,A,C,G,E,M,I,E,I,C,E,I,G,C,O,Q,G,C,E,C,E,E,O,C,W,C,G,I,C,K,E,O,C,C,E,K,G,C,C,kB,C,C,C,C,K,E,I,E,I,C,W,C,E,E,C,E,E,W,E,C,E,W,C,C,C,E,E,O,I,C,G,E,K,G,G,I,E,E,M,C,E,G,E,E,E,C,I,E,C,C,E,C,G,A,M,E,M,C,G,S,G,A,Y,E,C,E,I,I,I,C,e,C,E,I,Q,C,I,E,C,C,E,C,E,C,C,E,C,E,E,G,C,G,G,E,C,G,G,E,M,G,C,E,M,C,E,E,G,Q,C,E,M,E,C,G,C,G,C,E,Q,C,C,C,C,E,C,E,Q,C,C,C,E,C,E,I,G,E,E,E,G,E,I,C,E,C,O,C,C,O,C,C,C,C,C,G,A,I,I,C,W,C,I,C,C,O,M,C,E,G,M,C,I,E,I,C,iB,C,E,G,G,E,M,C,O,G,G,C,I,C,M,C,G,C,C,C,C,S,G,C,C,C,E,I,E,G,E,O,E,C,E,E,E,O,C,E,A,K,I,E,G,C,E,E,E,A,K,I,E,G,C,E,E,M,C,M,E,E,E,I,E,E,C,C,C,S,G,C,C,C,M,E,E,I,E,E,C,E,E,sB,C,G,I,E,E,E,E,M,C,E,E,E,E,E,I,C,C,C,E,C,K,E,O,C,C,S,G,C,C,C,C,C,C,E,C,C,M,E,E,E,E,I,E,E,I,C,E,A,W,E,I,C,G,A,O,E,C,I,E,E,E,E,M,C,E,E,E,E,C,G,A,C,E,C,C,C,E,A,I,E,C,G,E,G,C,S,K,C,G,E,E,M,C,E,G,C,G,A,I,G,G,K,G,E,G,C,G,C,C,C,O,C,C,C,S,G,C,C,C,E,I,E,G,E,O,C,O,C,O,G,A,K,I,G,A,K,I,E,K,A,C,S,G,C,C,C,C,C,C,C,E,I,I,K,E,uB,C,G,O,G,C,I,E,C,C,E,K,C,C,G,G,E,G,C,G,E,E,O,E,K,A,C,O,I,C,S,G,C,C,C,M,E,G,C,M,C,C,Y,C,C,C,E,E,E,O,E,C,E,O,C,C,C,E,C,O,C,C,O,C,C,M,C,C,C,E,E,E,I,C,E,E,I,C,E,C,E,A,E,E,C,C,E,A,E,E,C,C,E,A,E,K,E,A,E,I,C,C,C,E,E,M,C,I,I,E,E,E,E,E,E,C,I,E,C,C,E,C,C,C,E,C,C,C,C,E,C,C,C,C,E,E,E,O,E,C,E,O,C,C,C,C,A,C,C,E,C,C,E,C,A,S,C,C,C,C,C,E,I,E,C,C,E,E,C,C,C,E,C,C,C,E,O,C,C,E,E,C,C,C,E,C,C,C,C,E,E,E,E,C,C,E,C,E,E,I,C,G,E,E,C,E,E,I,E,E,O,C,G,E,E,C,E,E,I,C,C,C,S,G,C,C,C,E,I,E,E,M,C,O,O,I,C,G,M,C,A,G,C,C,E,C,I,G,G,K,E,C,S,G,C,C,C,E,I,E,E,U,C,K,C,E,E,M,E,E,M,C,I,C,G,E,I,I,K,E,G,E,O,C,C,I,E,E,O,C,G,C,G,A,K,I,C,C,E,E,A,K,I,C,C,E,C,E,C,M,Q,C,C,E,C,E,A,C,C,I,G,A,G,A,U,G,A,S,E,G,C,E,I,E,E,O,M,C,C,E,G,G,C,E,E,I,G,C,E,M,E,E,Q,E,C,K,G,E,C,G,O,I,C,O,G,Y,C,C,C,C,C,I,C,K,C,E,I,C,I,C,E,G,C,I,C,K,C,E,I,C,e,C,C,E,I,C,W,C,I,C,O,G,I,C,K,C,I,C,W,C,I,C,I,C,O,C,K,E,I,C,Q,C,C,E,I,C,K,C,K,E,I,C,W,C,K,E,I,C,c,C,K,E,I,C,U,C,K,E,I,C,U,C,K,E,I,C,mB,C,C,E,I,C,kB,C,C,E,I,C,Q,C,K,E,I,C,S,C,E,C,I,C,U,E,C,Y,C,I,E,I,C,W,A,C,I,C,S,G,I,C,U,G,E,Q,C,G,E,M,C,G,I,C,W,E,C,Y,C,C,C,I,C,K,G,G,G,I,C,W,E,I,C,K,C,C,C,Y,C,I,E,I,C,K,C,E,I,C,W,C,E,I,C,U,G,E,C,E,E,E,I,A,M,E,E,A,M,E,E,E,E,E,O,C,G,E,O,C,G,E,M,E,E,O,C,G,E,O,C,G,E,M,E,E,O,C,G,E,O,C,G,E,M,E,E,S,C,E,E,O,C,E,E,E,E,G,E,E,O,C,E,E,E,E,E,C,E,M,C,I,C,a,C,G,E,M,C,I,C,a,C,G,E,M,C,I,C,a,C,G,E,M,C,I,C,a,C,G,E,M,C,I,C,a,C,E,C,Y,C,O,I,C,K,C,I,C,Q,C,I,C,K,C,A,C,S,C,O,I,C,K,C,c,C,I,C,K,C,C,c,C,C,C,O,I,C,K,C,M,C,E,A,C,e,C,C,C,I,E,I,C,W,C,O,I,E,M,C,E,M,C,E,M,A,C,O,C,I,C,O,C,Q,C,U,C,I,E,I,C,W,A,C,I,C,K,E,G,I,C,K,C,I,E,E,Q,E,G,E,C,Y,C,I,E,I,C,U,G,E,E,I,E,C,E,I,C,E,A,E,E,I,C,K,C,G,G,G,I,C,K,C,A,S,C,M,E,E,E,I,E,O,I,C,G,E,A,M,E,M,E,I,E,E,E,E,M,C,E,E,E,E,E,C,C,E,C,C,C,E,C,C,E,E,E,C,C,E,A,E,O,C,E,Q,G,I,E,C,G,E,C,G,E,I,E,I,E,I,C,W,A,C,G,G,E,O,C,E,A,C,G,O,Y,C,I,ADqvQwE,SAAA,CAAA,CAAA,CAAA,EAAA,GAAA,EAAA,QAAA,CAAA,CAAA,EAAA,QAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,MAAA,CAAA,OAAA,cAAA,CAAA,EAAA,WAAA,CAAA,aAAA,CAAA,EAAA,WAAA,CAAA,EAAA,MAAA,CAAA,UAAA,CAAA,EAAA,AAAA,CAAA,GAAA,GAAA,OAAA,CAAA,AAAA,IAAA,IAAA,EAAA,UAAA,GAAA,GAAA,EAAA,CAAA,CAAA,EAAA,CAAA,OAAA,cAAA,CAAA,EAAA,EAAA,CAAA,aAAA,CAAA,EAAA,WAAA,CAAA,EAAA,MAAA,GAAA,CAAA,EAAA,IAAA,EAAA,EAAA,KAAA,CAAA,IAAA,CAAA,GAAA,OAAA,EAAA,QAAA,CAAA,SAAA,CAAA,OAAA,CAAA,AAAA,IAAA,AAAA,YAAA,OAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,IAAA,EAAA,GAAA,CAAA,CAAA,EAAA,EAAA,E,E,I,E,I,C,S,C,E,C,I,C,K,C,C,C,C,a,C,I,E,I,C,W,A,C,I,C,U,G,I,C,kB,E,C,E,O,C,I,I,C,kB,A,C,C,sB,C,C,C,I,E,I,C,W,C,E,I,C,U,G,E,C,E,I,C,U,G,I,E,E,Q,A,C,E,Q,C,G,E,M,C,G,E,K,G,E,K,E,C,E,C,E,G,G,E,K,C,E,K,A,E,I,C,e,C,G,A,C,G,I,E,Q,A,G,G,I,C,E,O,C,C,W,C,I,E,I,C,K,C,M,C,E,E,gB,C,I,C,K,E,E,E,e,C,I,C,U,G,E,C,E,C,I,C,O,C,E,c,C,E,I,C,U,I,I,C,Q,C,I,C,O,C,O,C,I,C,e,C,C,C,C,M,C,C,C,C,C,G,C,Y,C,C,M,C,C,C,I,C,C,O,C,C,S,C,C,C,E,E,E,I,C,E,A,I,G,I,E,M,E,E,O,C,E,E,G,E,O,C,E,E,C,E,E,E,G,A,C,I,I,C,Q,C,E,O,C,E,E,O,C,C,E,E,M,C,E,G,C,C,E,E,I,C,c,C,E,E,E,G,G,C,C,E,E,I,C,e,C,E,E,E,G,I,C,kB,C,E,E,E,G,I,E,I,A,O,C,C,E,E,G,C,C,E,C,C,C,E,C,I,E,E,E,E,E,E,E,O,C,E,E,C,E,C,C,E,C,G,C,K,C,E,C,C,E,E,C,C,C,E,O,C,C,C,G,G,I,C,E,C,mB,C,C,C,C,C,C,C,C,K,E,E,G,C,O,C,C,O,C,C,C,E,E,E,I,C,E,E,I,C,E,E,S,G,E,I,E,E,A,M,G,I,E,E,E,E,E,E,E,E,E,C,C,E,C,C,C,E,C,G,E,K,C,C,C,E,C,G,C,E,C,E,K,C,C,C,E,C,E,E,O,C,C,e,C,C,C,C,C,C,C,C,K,E,E,E,G,C,O,C,C,O,C,C,C,E,E,A,M,G,I,E,E,E,E,E,E,A,E,C,C,E,E,E,C,C,C,E,C,C,E,E,K,C,C,C,E,C,G,E,E,K,C,C,C,E,C,E,E,O,C,C,gB,C,C,C,C,C,C,C,C,K,E,E,E,G,C,O,C,C,O,C,C,C,E,C,S,E,G,C,S,E,G,C,C,I,C,Q,C,E,A,M,G,I,E,E,E,E,E,E,A,E,C,C,E,E,E,C,C,C,E,C,C,E,E,K,C,G,E,G,G,E,E,K,C,G,E,G,E,E,O,C,C,U,C,C,C,O,I,C,W,C,O,C,E,A,C,e,C,C,C,O,I,C,W,C,I,C,E,A,C,W,C,C,C,C,C,C,C,I,E,I,C,K,C,E,I,C,W,C,E,C,C,E,I,C,C,E,C,K,G,E,C,G,O,E,O,C,E,I,C,A,E,O,G,E,E,E,K,C,C,K,C,E,C,sB,C,C,C,C,C,C,C,C,C,I,E,C,C,E,I,C,C,E,A,O,E,I,E,E,G,E,O,C,E,I,C,A,C,G,G,C,E,M,C,E,E,G,E,E,I,C,W,C,K,C,E,E,G,C,K,G,C,E,G,C,G,E,G,C,K,G,C,E,G,C,E,C,U,C,C,C,C,K,E,E,I,E,I,C,W,C,E,E,O,C,E,E,O,E,I,E,M,C,E,E,M,C,E,I,C,c,C,G,E,G,E,E,I,C,K,E,E,C,I,O,iB,C,I,O,iB,A,E,C,I,C,C,I,C,C,C,A,S,C,E,G,C,I,C,C,I,C,C,W,C,C,W,C,C,C,E,a,G,M,C,I,E,E,O,iB,C,I,E,E,O,iB,A,C,E,G,S,I,E,C,C,E,C,I,E,C,C,E,I,C,C,M,C,G,C,C,E,I,C,G,E,G,E,C,C,I,E,E,E,G,C,C,C,K,C,I,C,qB,C,E,E,E,G,C,C,E,E,G,G,E,C,I,E,E,E,G,E,E,E,G,C,I,C,I,C,qB,C,E,E,E,G,K,C,C,O,C,C,mB,C,C,K,E,E,E,I,E,I,C,W,C,O,C,E,E,C,I,E,E,E,E,M,C,E,E,E,E,G,E,C,C,E,C,E,I,C,G,E,I,C,G,O,C,C,gB,C,M,C,C,C,iB,C,C,C,I,E,I,C,W,C,E,E,M,C,E,E,M,C,E,I,C,S,C,G,M,C,M,E,G,E,gB,C,C,C,E,I,C,E,G,M,E,G,E,gB,C,C,C,E,I,C,E,E,C,C,Q,C,C,K,M,E,E,E,E,I,E,I,C,W,A,C,I,C,M,C,G,W,E,K,E,G,E,G,I,C,O,C,I,C,A,S,C,C,C,C,C,E,G,A,C,I,E,M,C,E,I,E,G,E,G,E,G,E,G,M,C,I,E,G,C,M,E,G,C,O,E,K,C,K,E,K,A,C,E,E,M,C,E,M,C,I,C,c,M,C,E,E,G,C,E,E,K,C,E,E,M,C,E,E,I,A,E,E,E,E,E,E,C,I,E,M,E,O,E,K,E,S,A,C,I,C,E,C,O,C,C,C,C,M,K,E,I,E,I,C,I,C,E,I,C,K,C,E,I,C,W,C,E,E,I,E,E,C,E,E,S,C,E,E,C,E,I,C,U,E,E,E,I,C,U,E,E,M,C,E,E,I,C,O,C,uB,C,I,E,O,E,E,O,C,I,C,E,E,E,G,E,E,E,E,E,E,E,C,I,E,C,C,E,A,C,E,M,E,C,E,M,E,E,E,I,C,G,E,I,C,E,E,C,C,I,E,E,E,E,M,C,E,E,C,C,E,C,I,C,E,E,C,S,C,C,C,C,C,I,E,E,S,U,O,A,K,I,G,I,C,W,C,O,C,I,C,4B,C,G,I,C,yB,C,G,E,E,C,W,C,C,C,C,C,C,K,M,E,I,E,I,C,U,G,G,G,G,E,I,C,W,C,I,C,M,C,C,I,E,I,C,W,C,I,C,E,A,A,C,C,E,E,Q,E,C,E,Q,C,G,I,C,U,G,C,O,C,E,U,E,O,K,E,I,K,E,Q,E,M,E,K,U,K,M,E,C,E,M,C,I,C,S,C,G,E,G,C,E,I,C,E,C,E,K,C,E,S,C,C,K,A,C,E,I,C,Q,E,C,I,C,Q,C,G,I,C,K,C,U,G,C,O,C,E,Q,K,E,Y,C,E,I,C,K,C,M,E,K,U,K,S,E,C,E,O,C,E,E,K,C,E,Y,C,I,C,K,C,O,E,M,C,C,C,E,E,I,C,E,C,C,6B,C,C,C,O,I,C,sB,C,I,C,kB,C,E,C,E,C,0B,C,C,C,C,C,O,I,C,sB,C,I,C,e,C,E,C,E,E,C,uB,C,C,E,S,C,C,C,C,I,E,A,W,E,E,I,C,e,C,E,E,I,E,E,C,C,E,C,E,I,C,mB,E,G,G,G,E,O,G,E,G,I,E,I,C,K,C,M,C,E,E,uB,C,I,C,K,C,G,E,E,C,C,E,E,K,C,C,Q,E,G,C,C,E,G,C,E,E,e,C,I,C,U,G,G,E,O,I,C,G,Q,C,E,E,E,E,mB,C,E,E,I,I,C,U,C,E,G,G,O,E,O,E,C,E,O,C,E,C,C,E,C,O,M,C,G,E,G,E,C,C,mB,C,C,C,C,C,C,K,E,I,E,I,C,K,C,E,I,C,e,C,E,C,U,E,E,C,C,E,C,C,E,C,G,E,O,E,G,A,C,I,E,O,C,S,C,C,I,E,I,C,K,C,M,C,E,E,yB,C,I,C,K,C,G,E,E,e,C,I,C,U,G,G,E,E,c,C,E,I,C,U,C,E,E,G,C,I,E,I,G,E,G,E,U,E,O,G,E,U,E,C,C,C,E,C,O,M,C,E,E,C,C,iB,C,C,C,G,E,O,C,O,I,C,c,E,C,I,C,c,C,O,M,C,C,E,E,C,C,e,C,C,C,C,C,M,C,G,G,I,I,C,K,C,mB,A,C,kB,C,C,C,C,C,I,E,I,C,yB,C,E,G,E,I,C,c,C,E,I,C,gB,C,G,E,I,C,c,C,E,I,I,E,O,I,C,mB,C,E,E,G,C,c,E,e,C,C,C,c,C,C,C,C,C,C,C,C,C,G,G,O,M,C,E,G,I,C,kB,C,E,G,M,C,E,E,C,oB,C,C,C,C,C,C,C,G,C,G,I,I,C,kB,C,K,E,G,M,C,E,E,C,U,C,C,C,C,C,C,C,C,C,E,M,C,E,I,E,I,C,Q,C,E,G,I,C,kB,C,E,E,G,M,C,E,C,Q,C,G,I,C,gB,C,I,C,E,C,iB,C,C,C,C,C,C,C,I,C,S,C,E,E,S,C,E,C,c,C,C,C,C,C,C,C,I,C,S,C,E,E,S,C,E,C,0B,C,I,E,I,C,W,C,O,A,C,G,I,C,S,C,E,K,E,S,C,E,C,uB,C,I,E,I,C,W,C,O,A,C,G,I,C,S,C,E,K,E,S,C,E,C,gB,C,C,C,I,E,I,C,K,C,E,I,C,W,C,I,C,I,G,C,E,E,E,G,I,C,S,C,I,C,E,C,E,E,C,I,C,S,C,E,C,I,E,E,M,C,E,E,M,C,E,K,G,C,E,E,C,G,I,C,K,C,E,G,E,E,I,C,e,C,E,E,E,G,E,G,I,C,e,C,E,E,E,C,gB,C,C,C,C,E,C,C,C,K,E,I,E,I,C,W,C,E,E,I,C,E,E,E,E,A,I,I,E,M,E,E,E,E,M,C,E,G,E,I,C,C,E,C,C,C,E,E,A,E,I,E,G,E,E,E,E,E,E,C,C,E,C,I,I,C,e,A,C,I,C,Q,E,E,E,O,E,I,C,K,C,E,G,G,I,C,c,C,E,E,E,Q,C,e,C,C,C,C,C,C,C,C,C,C,gB,C,C,C,C,C,I,E,I,C,W,C,G,I,C,Q,C,C,I,E,E,O,C,M,C,E,E,C,E,Q,E,G,E,E,C,E,I,C,M,C,E,E,C,M,C,C,C,G,I,C,Q,C,I,C,S,C,I,C,O,C,G,C,E,E,E,C,E,I,C,E,C,E,E,C,I,C,K,C,Y,C,I,C,C,I,C,K,I,E,C,C,a,C,I,E,U,M,C,I,C,K,C,C,kB,I,C,U,G,I,C,M,C,E,E,C,C,Y,C,I,C,K,C,C,kB,I,C,W,C,I,C,M,C,E,E,C,C,c,C,I,C,K,C,C,kB,E,E,C,C,c,C,C,C,C,C,G,I,C,K,C,C,kB,E,E,E,I,E,U,M,C,C,C,G,I,C,K,C,C,kB,E,E,C,C,gB,C,I,C,K,C,C,kB,E,U,M,C,C,C,C,S,G,C,C,C,C,C,C,C,E,O,G,G,A,S,C,C,C,C,C,C,C,E,I,E,E,K,C,C,C,E,C,G,E,E,K,C,C,C,E,C,G,E,K,G,C,E,G,E,K,G,C,E,G,E,E,E,C,C,K,G,C,G,K,G,C,I,C,E,E,E,C,E,C,C,E,I,C,C,E,E,O,C,C,S,E,O,E,M,E,I,E,I,E,I,C,C,E,E,E,E,G,C,C,E,I,C,C,E,K,C,E,G,C,C,S,G,C,C,C,C,C,C,C,M,E,E,E,E,I,E,E,M,C,E,E,M,C,E,E,S,G,E,I,E,E,E,C,I,E,E,E,E,E,E,E,E,E,E,C,C,E,C,A,C,E,C,C,C,C,E,I,C,C,G,E,K,C,C,C,E,C,G,E,I,C,G,E,E,E,I,O,C,C,S,G,C,E,O,G,A,K,I,E,Q,E,A,K,I,E,M,A,C,S,G,C,C,C,C,C,C,C,M,E,O,E,E,G,E,C,E,K,E,E,I,E,E,E,E,G,G,E,E,E,C,S,G,C,C,C,C,C,E,M,A,U,E,E,A,Q,E,E,C,C,G,Q,C,C,E,G,S,C,kB,C,K,G,S,C,e,C,I,O,W,G,mB,C,C,C,C,C,C,C,C,C,O,G,E,E,E,E,C,e,C,C,C,C,C,C,C,C,C,O,G,E,E,E,E,C,gB,C,C,C,C,C,C,C,C,K,E,E,E,E,G,C,O,C,C,O,C,C,C,E,C,S,E,G,C,S,E,G,C,C,I,C,Q,C,E,A,M,E,I,C,E,E,E,A,M,E,I,C,E,E,E,E,C,I,E,E,E,E,E,E,E,E,E,E,C,C,E,C,A,C,E,C,C,C,C,E,I,C,C,E,K,C,G,E,G,G,E,I,C,G,G,E,G,E,E,I,O,C,C,sB,C,C,C,C,C,C,C,C,C,K,C,sB,E,E,E,G,I,E,E,O,A,C,G,I,I,C,W,C,M,E,C,E,G,C,K,G,C,E,G,C,E,G,E,E,G,C,K,G,C,E,G,C,E,G,C,C,C,gB,C,O,C,C,iB,C,C,C,I,E,I,C,W,C,C,O,C,C,O,C,C,C,E,E,I,C,S,C,G,E,E,O,C,E,G,G,I,E,K,C,K,E,G,C,I,G,E,gB,C,C,C,E,I,C,E,M,C,M,G,E,gB,C,C,C,E,I,C,E,M,C,C,C,Y,C,I,C,mB,C,C,E,K,C,a,I,E,I,C,W,A,C,E,K,C,I,C,U,G,K,A,C,O,C,C,C,I,E,I,C,W,C,I,C,c,C,E,I,C,E,E,I,C,M,C,E,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,C,M,C,C,Y,C,O,C,C,C,C,I,C,E,E,Y,G,E,E,Y,G,E,I,C,S,G,C,c,C,C,e,C,C,C,I,C,iB,C,E,G,I,I,E,E,E,E,E,I,C,I,E,I,C,S,C,G,E,G,G,C,C,E,I,C,E,C,K,E,K,C,E,I,C,wB,C,G,E,I,C,wB,C,E,G,E,A,C,E,O,E,C,C,C,C,E,I,C,C,E,C,W,E,K,E,I,C,mB,C,G,G,E,O,G,I,E,I,E,I,E,O,C,E,E,E,I,C,E,M,C,E,E,E,M,C,E,I,C,O,E,E,I,C,K,G,C,E,I,E,M,E,K,G,C,E,I,E,E,I,A,C,C,G,C,E,O,C,G,I,C,yB,C,E,C,C,E,C,M,C,S,E,E,I,E,E,O,E,C,C,E,C,O,A,C,A,C,S,C,C,C,C,C,C,C,E,I,E,E,E,E,E,E,E,a,C,E,C,E,G,C,E,C,E,a,C,E,M,C,G,A,C,I,E,C,E,a,C,C,I,C,E,M,C,E,O,C,E,K,C,C,E,M,C,G,C,M,C,C,I,C,C,Q,C,C,I,C,C,O,C,C,E,A,E,U,C,C,E,A,E,I,C,A,E,C,C,E,O,E,O,E,C,E,A,E,I,C,A,E,C,C,E,S,E,K,E,E,C,E,M,E,O,E,C,E,Q,E,K,E,C,M,E,I,E,Q,E,I,E,O,C,E,A,C,W,G,G,C,E,kB,C,C,E,A,C,E,I,E,C,I,E,E,E,A,C,E,O,E,C,I,E,E,E,C,C,C,G,E,E,E,G,C,C,E,E,C,C,E,C,C,G,E,E,E,G,C,C,E,E,a,C,C,C,E,E,E,E,G,A,S,C,C,C,c,C,C,C,C,E,E,a,C,A,S,E,A,I,E,I,E,C,E,E,E,E,K,E,I,C,a,C,C,C,E,C,E,E,E,C,C,W,C,C,C,C,C,G,C,O,C,C,C,I,C,W,C,E,E,uB,C,I,C,K,E,M,C,A,G,E,U,C,O,C,O,E,E,E,O,C,O,C,E,E,C,E,A,I,I,E,E,U,C,S,C,G,E,G,C,C,E,M,C,I,C,C,G,G,I,M,G,M,C,C,E,I,I,K,E,G,C,C,A,K,I,G,E,E,G,C,A,C,A,C,I,G,A,K,E,O,C,E,K,G,A,K,I,G,A,K,I,E,K,A,G,E,I,C,E,K,E,E,K,G,C,E,M,O,E,M,E,E,I,C,K,G,C,C,e,C,C,C,O,I,C,U,C,K,E,G,M,A,C,e,C,C,C,C,C,C,C,I,E,I,C,U,C,E,G,E,A,K,I,E,E,O,C,G,G,O,A,K,E,E,M,C,E,C,C,W,K,E,E,I,E,I,C,O,C,E,I,C,W,C,E,E,M,C,E,E,C,I,E,E,E,E,I,C,M,C,E,E,E,E,E,I,C,E,gB,C,I,C,S,C,E,C,E,I,C,C,I,I,E,E,Y,C,M,C,I,G,A,S,C,E,I,E,E,M,C,E,A,S,C,C,C,E,G,C,E,M,C,I,C,C,I,E,E,uB,C,G,E,E,C,I,I,E,E,E,E,M,C,E,E,I,E,E,M,C,C,C,E,C,U,C,kB,C,G,C,E,M,C,I,C,G,E,I,C,C,E,I,E,G,C,O,E,M,C,I,A,E,E,E,I,E,E,E,O,C,E,E,E,E,E,K,A,Q,G,A,S,G,C,G,I,C,E,K,G,C,E,K,G,C,E,I,E,E,E,C,C,E,I,E,E,E,E,M,C,E,E,E,E,E,E,gB,C,C,C,E,E,I,I,E,K,E,E,E,E,E,K,C,M,C,E,E,E,E,E,E,e,C,G,I,O,C,E,G,O,E,M,E,W,C,I,E,S,C,W,I,C,c,G,M,E,Q,E,O,C,M,E,E,E,kB,C,E,a,A,C,C,yB,C,C,C,G,C,Y,C,O,C,C,S,C,C,C,Q,C,K,C,C,a,C,C,C,C,I,C,E,G,E,E,I,C,S,C,G,E,E,O,C,E,G,G,E,C,C,E,I,C,C,E,E,E,E,I,C,U,C,E,E,G,E,E,C,C,I,G,C,E,E,E,E,C,E,G,C,E,E,Q,C,E,E,M,C,E,Q,C,A,I,G,G,K,G,E,M,G,C,E,C,E,G,C,E,I,E,A,G,I,E,E,E,E,E,gB,C,G,G,K,G,C,E,C,E,I,C,K,C,iB,C,G,E,gB,C,E,G,G,G,E,K,C,C,E,C,A,K,E,G,G,G,A,C,A,E,Y,G,E,E,E,C,A,E,G,E,E,E,E,C,E,E,I,G,C,G,E,C,E,I,E,E,kB,C,G,E,E,kB,C,G,E,A,C,E,K,G,C,K,G,C,E,K,G,C,E,I,K,G,C,E,G,E,C,C,G,I,E,gB,C,G,C,I,E,G,G,E,oB,C,G,C,C,G,E,G,C,C,M,C,K,E,K,E,K,E,O,E,E,C,C,C,yB,C,C,C,C,K,E,E,I,E,E,K,C,E,I,C,O,C,E,E,Q,C,E,G,E,e,C,E,G,G,E,O,C,C,I,E,E,I,C,c,C,G,E,U,C,E,A,S,E,Y,C,A,S,C,C,C,C,C,C,C,E,I,E,E,M,C,E,C,C,E,C,E,E,E,C,C,E,E,C,K,E,E,E,M,C,E,C,C,E,E,C,K,E,E,kB,A,A,Q,G,C,E,E,C,A,O,E,E,G,C,E,K,C,E,C,C,E,A,O,G,C,E,E,E,C,E,I,E,E,A,C,E,K,G,C,E,E,E,E,E,M,C,M,K,G,C,E,G,E,E,E,M,E,a,C,M,C,C,E,E,E,E,G,A,S,C,C,C,C,C,C,C,M,E,E,I,E,E,Y,C,O,G,G,C,E,E,G,C,E,kB,C,E,E,a,A,E,C,E,E,E,E,C,E,C,M,E,E,M,E,M,E,M,C,E,C,E,C,C,E,E,E,E,G,E,I,C,c,C,I,C,K,C,I,C,W,C,K,C,E,E,K,E,C,E,E,K,C,E,K,C,E,E,K,C,E,E,K,G,C,E,E,K,C,E,K,C,M,E,E,gB,C,I,C,S,C,E,C,E,I,C,C,G,E,K,G,C,E,E,G,C,E,K,E,M,C,K,E,E,E,K,E,E,E,O,E,K,C,C,C,M,C,I,E,I,C,W,C,E,E,M,C,E,E,I,C,E,E,M,C,E,E,K,E,E,E,E,A,O,I,C,S,C,E,C,E,I,C,E,C,C,E,C,I,C,I,C,I,C,C,C,G,E,C,M,G,Q,C,C,mB,C,E,gB,M,mB,G,c,G,Q,C,E,W,C,Q,C,K,S,W,C,I,I,O,Q,S,A,C,C,E,G,S,C,C,O,C,Q,C,K,W,O,C,E,K,C,O,C,C,C,E,Q,C,K,S,Y,C,C,C,C,C,O,W,G,Y,C,I,C,mB,C,C,E,K,C,Y,C,mB,C,C,C,C,C,C,C,C,C,I,E,K,C,mB,E,E,E,G,I,I,E,E,E,E,M,C,I,C,C,E,C,O,C,I,C,yB,C,E,G,M,C,O,C,C,e,C,C,C,C,C,C,C,C,C,I,E,K,C,e,E,E,E,G,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,E,A,C,C,C,E,C,O,C,G,C,C,E,C,I,C,yB,C,E,G,M,C,C,O,C,C,gB,C,C,C,C,C,C,C,C,C,I,E,K,C,gB,E,E,E,G,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,E,A,C,C,C,E,C,O,C,G,G,E,C,E,C,E,C,C,I,C,yB,C,E,G,M,C,C,O,C,C,gB,C,I,E,I,C,W,C,I,C,E,E,I,I,E,E,M,C,E,G,E,E,E,E,K,G,C,E,C,C,E,C,I,C,I,C,yB,C,I,G,O,E,G,C,C,iB,C,C,C,I,E,I,C,W,C,C,O,C,C,O,C,C,C,E,E,I,C,S,C,G,E,E,gB,C,E,C,E,E,E,gB,C,E,C,E,E,E,O,C,M,C,M,E,K,C,M,I,E,K,E,C,E,K,E,E,E,G,C,C,O,C,C,C,I,E,I,C,W,C,I,C,I,C,c,C,E,E,E,M,C,E,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,C,O,C,C,O,C,C,C,I,C,W,C,C,c,C,C,e,C,C,C,I,C,iB,C,E,G,E,E,I,C,E,E,I,C,I,I,E,E,E,E,E,I,C,I,E,C,C,E,C,E,C,G,I,C,S,C,G,E,C,E,E,C,C,E,C,E,E,kB,C,I,E,gB,C,C,C,E,E,E,C,C,E,C,E,E,Y,G,E,gB,C,C,C,E,C,C,E,I,C,M,I,M,G,G,C,E,O,C,G,I,C,yB,C,E,E,M,C,S,G,G,C,E,O,C,M,C,C,C,E,I,C,a,C,E,E,E,E,C,C,0B,C,C,C,C,C,I,E,I,C,S,C,G,E,K,C,0B,E,E,C,E,O,E,C,E,O,M,C,C,E,E,C,Q,C,C,E,E,I,E,E,M,C,M,A,W,G,C,E,M,C,C,E,E,M,E,G,G,E,O,C,G,C,C,C,G,E,C,S,G,Q,C,C,mB,C,E,gB,Q,W,C,Q,C,K,S,W,C,I,I,c,S,A,C,C,E,G,S,C,C,O,C,E,C,K,Q,E,E,C,K,Q,C,E,Q,C,Q,C,U,C,M,I,E,C,C,C,C,O,W,G,Y,C,C,C,C,C,K,C,E,G,I,C,mB,C,C,E,I,C,W,C,K,E,I,C,W,C,K,E,I,C,O,C,K,E,I,C,O,C,K,C,C,Y,C,C,M,C,C,C,C,C,I,E,I,C,U,G,I,C,E,I,C,W,C,G,A,C,I,I,C,Q,C,E,O,C,M,C,I,E,E,E,A,G,C,C,C,E,C,G,G,C,C,E,E,C,G,C,I,E,O,C,C,I,C,Q,C,E,A,G,C,G,C,C,E,C,E,C,I,E,E,E,E,E,E,E,E,E,E,O,C,E,C,E,E,C,C,c,C,O,G,I,C,O,C,Q,C,G,C,mB,C,O,G,I,C,O,C,a,C,C,qB,C,I,E,G,E,C,G,I,I,E,E,E,I,C,K,C,I,C,Q,C,M,C,E,E,G,I,C,K,C,gB,C,G,C,I,E,I,C,K,C,c,C,G,U,C,E,E,Y,G,E,E,iB,E,C,E,K,G,C,E,G,E,K,G,C,E,E,E,C,M,C,S,E,c,E,C,C,C,O,C,C,C,I,E,I,C,K,C,C,U,C,C,C,E,E,I,C,W,C,E,E,I,C,E,I,C,iB,G,I,C,Y,C,G,I,C,O,C,O,C,E,K,G,C,A,C,K,G,C,E,K,C,E,M,E,C,E,E,G,E,K,G,C,G,I,C,O,C,M,C,G,G,E,I,C,c,C,I,C,K,E,C,c,C,C,S,C,C,C,I,C,mB,G,C,O,C,C,O,C,C,Q,C,C,Q,C,C,C,A,S,C,C,C,C,C,E,I,E,E,E,E,E,E,E,E,G,E,G,C,I,E,A,E,E,E,K,G,C,G,E,K,G,C,G,E,K,G,C,G,E,K,G,C,G,E,C,E,E,I,G,E,E,E,C,G,E,K,G,C,E,E,E,E,E,G,E,C,E,E,I,G,E,E,E,C,G,G,K,G,C,E,E,E,E,E,G,E,E,E,E,G,E,E,G,E,G,E,E,G,E,G,E,E,G,G,E,E,C,E,A,C,E,C,E,E,E,A,C,E,C,E,E,E,C,C,E,C,E,E,E,C,C,E,C,E,C,C,M,C,O,E,O,E,Q,E,Q,C,C,E,E,E,G,E,A,C,E,K,C,C,E,E,E,A,C,E,M,C,C,E,E,E,G,I,C,O,C,M,C,K,G,C,K,G,C,E,G,E,I,E,K,G,C,E,E,G,E,A,C,E,C,E,I,C,6B,E,C,I,C,O,C,E,E,I,C,O,C,E,E,E,K,C,I,C,c,G,I,C,W,C,E,E,I,C,oB,C,I,C,K,E,I,C,W,C,K,G,C,I,C,W,C,E,E,G,I,C,c,C,E,E,E,M,C,E,C,e,C,C,C,C,C,I,E,I,C,O,C,E,I,C,W,C,E,I,C,iB,G,O,G,E,S,C,a,E,C,I,C,K,C,iB,C,I,A,O,E,O,C,E,E,E,I,C,E,C,M,C,E,I,C,sB,C,E,O,C,E,C,E,G,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,E,I,C,K,C,E,E,S,C,E,E,O,C,S,C,E,A,C,E,I,C,E,K,A,E,E,E,A,C,E,G,C,E,M,A,E,E,E,G,E,Y,C,E,E,E,I,C,W,C,E,E,E,I,C,W,C,C,c,C,C,e,C,C,C,I,C,iB,C,E,G,E,I,C,Y,G,E,I,E,E,E,E,E,E,G,I,C,c,C,E,G,I,E,E,E,E,E,E,E,C,I,E,I,C,c,C,E,G,E,C,C,E,C,E,C,E,E,I,C,O,C,E,E,I,C,O,C,W,E,S,E,E,c,E,Y,E,Y,C,C,C,G,C,E,O,C,G,I,C,yB,C,E,E,M,C,S,E,E,G,E,I,C,a,C,E,E,E,E,C,C,gB,C,I,E,I,C,W,C,E,E,I,C,E,E,E,I,E,E,E,E,M,C,I,C,I,E,E,O,C,E,A,A,Q,G,C,M,I,I,C,K,C,iB,C,I,C,C,C,E,C,M,E,C,G,K,G,C,E,C,C,O,C,C,uB,C,C,C,I,E,I,C,W,C,K,C,O,E,G,C,M,G,G,C,K,G,C,G,C,E,C,C,iB,C,C,C,I,E,I,C,W,C,E,I,C,K,C,E,G,E,O,C,E,C,E,O,C,M,E,M,C,M,A,C,E,I,C,M,E,E,A,C,C,E,E,G,M,C,C,C,kB,C,C,C,I,E,E,E,E,E,E,E,E,I,C,K,C,G,C,E,C,I,E,E,E,E,I,C,Q,C,M,C,E,E,E,E,G,E,gB,C,G,C,A,E,A,C,E,E,c,C,E,E,I,C,E,E,U,C,K,C,C,G,C,E,O,E,I,E,E,E,E,M,C,E,E,E,E,A,U,A,C,E,E,yB,C,E,E,W,E,C,E,K,G,C,E,E,W,E,E,E,gB,E,E,E,O,C,C,a,C,C,C,I,E,E,I,I,E,E,E,E,M,C,E,E,E,E,C,I,E,I,C,yB,C,G,E,K,G,C,E,E,M,E,E,E,W,E,E,C,O,C,C,qB,C,C,C,I,E,E,I,I,E,E,E,E,E,E,I,C,K,C,gB,C,I,C,G,I,C,c,C,E,E,O,C,C,e,C,C,C,O,K,G,C,G,I,C,K,C,I,C,Q,C,E,C,M,C,G,E,C,+B,C,O,I,C,oB,C,I,C,K,C,I,C,Q,C,M,G,C,C,C,G,E,C,W,G,Q,C,C,mB,C,E,gB,M,U,C,c,C,E,a,C,C,E,W,C,Q,C,K,S,W,C,gB,W,c,c,a,I,I,S,c,U,A,C,E,O,M,S,E,c,I,O,O,Q,E,U,G,E,G,W,C,C,Y,A,G,A,Y,E,W,A,G,A,Y,C,E,G,S,C,C,Y,E,Q,C,O,C,O,C,e,C,E,I,E,E,I,C,G,E,M,C,M,E,E,Q,C,M,C,C,G,C,O,C,W,C,C,C,C,E,M,C,O,C,O,E,M,C,G,C,C,E,K,I,E,E,c,C,G,U,C,Q,C,G,M,C,K,E,U,E,e,C,Y,E,W,C,U,E,W,C,W,E,O,C,E,iB,C,G,M,C,C,E,C,M,E,A,C,E,Q,C,C,C,C,C,E,E,K,C,oB,C,E,K,E,E,K,C,M,E,C,E,Q,C,U,C,M,I,G,M,C,E,I,E,E,K,C,E,K,E,c,C,O,G,G,C,E,E,K,G,C,C,E,E,C,E,G,E,C,C,C,C,C,C,O,W,G,Y,C,I,C,mB,C,C,E,I,C,kB,C,C,E,K,C,Y,C,O,C,C,C,I,E,I,C,W,C,C,Q,C,C,K,E,E,C,S,C,C,C,E,E,I,C,K,C,mB,C,C,M,C,C,M,C,C,C,G,E,E,E,C,I,C,U,C,E,I,C,U,C,E,G,I,C,E,E,E,E,M,A,E,E,M,C,I,C,K,C,E,a,C,I,C,K,C,E,U,C,C,C,E,U,C,E,M,C,E,I,E,I,C,4B,C,E,C,I,C,O,C,Q,E,C,E,W,C,C,E,E,O,C,I,C,O,C,O,C,I,C,a,C,E,K,E,C,S,C,E,Q,C,E,G,I,C,c,C,E,E,E,E,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,C,O,C,C,O,C,C,S,C,C,S,C,C,C,I,C,W,C,C,c,C,C,e,C,C,C,I,C,iB,C,E,G,E,E,I,C,E,E,I,C,C,S,C,C,Q,C,C,C,I,C,O,C,E,G,G,E,O,iB,C,E,I,C,K,C,mB,E,G,A,S,E,E,E,G,I,C,S,C,E,G,I,I,E,E,E,E,E,E,E,C,I,E,C,C,E,C,E,I,C,S,C,G,E,E,E,C,E,E,G,C,C,E,E,E,C,C,E,C,E,gB,C,C,C,E,C,G,E,C,C,E,C,G,E,E,Y,G,E,gB,C,E,I,C,U,C,E,E,G,C,C,E,C,E,C,E,I,C,M,I,M,I,E,E,I,C,E,G,K,G,C,C,C,E,C,C,C,E,E,E,G,C,E,M,C,E,E,G,C,E,I,C,E,A,E,G,C,E,O,C,G,I,C,yB,C,E,E,M,C,S,E,E,G,I,C,a,C,E,E,E,G,E,C,C,C,gB,C,I,E,I,C,W,C,E,E,O,C,E,E,O,E,E,O,C,W,E,E,E,E,I,E,E,C,G,C,E,M,C,O,E,I,E,C,C,E,C,I,C,I,C,yB,C,I,E,C,C,E,M,C,E,C,I,C,I,C,yB,C,E,M,C,I,O,K,G,C,E,E,G,C,C,M,C,I,E,I,C,W,A,C,E,O,C,mB,C,I,C,K,C,S,C,E,M,C,I,E,K,C,M,C,C,G,E,C,O,G,Q,C,C,mB,O,gB,Q,S,C,E,S,C,C,E,G,S,C,C,O,C,Q,C,K,U,E,Q,C,K,Q,C,C,C,O,W,G,Y,C,C,C,C,C,K,C,E,G,I,C,W,C,K,E,I,C,W,C,K,C,C,iB,C,C,C,I,E,I,C,W,C,E,I,C,K,C,E,G,E,O,C,E,C,C,C,E,O,C,M,E,M,C,M,A,C,E,I,C,M,E,E,A,C,C,E,E,G,M,C,C,C,gB,C,C,C,C,C,C,C,C,C,O,G,I,C,I,E,E,E,E,E,C,O,C,C,C,I,E,I,C,W,C,I,A,C,I,C,a,G,I,C,c,C,E,E,E,M,C,E,C,W,C,I,E,I,C,W,C,E,C,I,O,iB,C,I,O,iB,A,E,O,E,I,C,O,C,C,E,K,I,E,I,C,S,C,G,C,A,E,M,I,I,C,K,C,iB,C,I,C,E,E,G,E,C,E,G,C,C,E,E,E,G,E,C,E,G,C,C,C,C,G,C,C,e,C,I,E,I,C,K,C,E,E,S,C,E,E,O,C,E,K,G,C,E,K,C,E,I,C,E,M,C,E,G,E,E,K,G,C,E,E,G,E,K,G,C,E,gB,C,E,I,E,gB,C,E,G,E,A,C,E,C,E,E,sB,E,C,I,C,W,C,E,E,I,C,K,C,I,C,W,C,I,C,W,C,C,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,E,I,C,K,C,E,E,O,C,S,C,E,I,C,W,C,M,C,E,E,O,C,E,E,O,C,E,E,a,C,G,G,G,E,E,E,E,I,I,C,oB,G,I,E,E,E,E,E,E,G,I,C,a,C,E,E,G,I,E,E,E,E,E,I,C,I,E,C,C,E,C,E,E,E,E,I,C,a,C,E,E,G,E,E,iB,C,G,E,6B,C,I,C,S,C,G,C,E,C,C,E,E,G,C,E,Y,E,C,E,C,E,E,a,E,C,E,E,C,C,E,I,E,C,E,E,E,E,Y,E,Y,E,W,E,S,E,Q,I,C,yB,C,E,E,M,C,S,E,E,I,C,a,C,E,E,E,E,C,C,sB,C,I,E,I,C,W,C,E,E,O,E,I,C,O,C,C,E,K,C,M,I,C,S,C,G,C,G,I,C,K,C,iB,C,I,G,G,C,C,c,C,C,C,C,C,C,C,O,I,C,K,C,iB,C,G,G,I,C,yB,C,E,G,K,E,G,C,C,C,G,E,C,Y,G,Q,C,C,gB,M,U,C,c,C,E,a,C,C,E,W,C,Q,C,K,S,W,C,I,I,a,W,c,c,A,C,E,U,I,W,C,E,G,S,C,C,Y,E,Q,C,O,C,O,C,e,C,E,I,E,E,I,C,G,E,M,C,M,E,E,Q,C,M,C,C,G,C,O,C,W,C,C,C,C,E,M,C,O,C,O,E,M,C,G,C,C,E,K,I,E,E,c,C,G,U,C,Q,C,G,M,C,K,E,U,E,e,C,Y,E,W,C,U,E,W,C,W,E,O,C,E,iB,C,G,M,C,C,E,C,M,E,A,C,E,Q,C,C,C,C,C,E,E,K,C,oB,C,E,K,E,E,K,C,M,E,C,E,Q,C,U,C,M,I,G,M,A,G,E,K,C,I,C,M,C,E,S,C,C,K,E,c,A,C,C,E,O,C,E,C,K,e,W,C,Q,C,C,E,Y,C,E,K,C,S,C,C,E,Y,C,Q,C,C,E,W,C,C,C,C,O,W,G,C,G,E,C,M,G,Q,C,C,O,E,S,E,c,I,O,M,C,O,W,G,iB,C,C,C,I,E,I,C,W,C,M,C,E,I,C,S,C,G,M,C,M,E,S,E,C,E,C,M,G,E,gB,C,C,C,E,I,C,C,C,C,gB,C,C,C,C,C,C,C,C,C,O,G,I,C,I,E,E,E,E,E,C,O,C,C,C,I,E,I,C,W,C,E,E,O,C,E,E,I,E,E,C,E,E,M,C,S,G,G,E,M,C,E,A,W,E,C,I,E,I,C,4B,C,E,C,I,C,O,C,Q,E,C,E,W,C,C,E,I,E,C,M,C,E,U,E,M,G,E,M,C,Q,C,E,I,C,a,C,E,K,E,E,E,C,I,C,c,C,E,E,E,M,C,E,C,e,C,C,C,C,C,C,C,C,C,I,E,I,C,W,C,M,C,E,A,U,E,I,I,E,E,E,E,E,I,C,I,E,C,C,E,C,E,I,C,yB,C,E,E,M,C,S,G,E,E,wB,C,E,I,C,S,C,G,C,E,E,E,E,O,C,E,C,C,E,E,E,O,C,E,C,C,E,C,E,E,E,E,M,E,K,C,K,M,I,M,G,Q,C,E,I,C,a,C,E,E,E,E,C,C,C,G,E,C,Q,G,Q,C,C,mB,O,gB,Q,U,I,S,C,E,S,C,K,C,K,O,C,C,E,G,S,C,C,Y,E,O,C,E,C,K,c,C,C,E,I,G,M,a,C,I,C,C,C,K,E,I,C,C,C,K,E,I,C,M,C,C,E,I,C,O,C,K,E,I,C,W,C,K,C,C,gB,C,C,C,G,C,E,C,C,E,C,C,C,I,C,Q,C,C,I,I,C,G,M,C,E,E,E,C,C,C,U,C,O,G,I,C,C,G,G,I,C,C,C,C,S,C,C,C,C,C,I,E,I,C,W,C,G,C,G,C,E,O,I,C,I,E,C,E,O,E,O,C,A,I,C,C,E,C,C,C,E,E,C,C,E,C,M,G,C,C,E,C,G,C,I,C,E,A,G,C,C,C,C,G,Q,C,C,E,G,a,C,K,E,I,G,C,O,A,G,G,G,E,G,E,Q,C,C,C,C,C,E,G,A,I,E,M,I,I,E,I,C,K,C,O,C,M,C,E,E,E,G,E,M,C,E,K,E,I,E,K,G,C,K,G,C,C,C,E,C,K,E,K,G,C,C,C,E,M,C,E,C,K,E,C,C,E,M,E,I,G,C,E,Y,E,K,G,C,E,A,E,M,C,E,A,C,C,E,C,K,C,A,C,C,E,C,K,C,A,C,C,E,C,K,C,A,C,C,E,C,K,G,G,A,I,K,K,C,I,C,E,A,E,K,K,C,E,E,E,C,C,I,E,G,K,G,C,I,E,K,G,C,K,G,C,G,K,K,C,G,I,G,E,C,S,E,sB,E,sB,C,E,O,O,M,C,E,I,C,O,C,K,C,M,E,G,E,E,E,E,Y,C,C,C,C,C,E,G,A,I,E,M,I,I,E,E,K,G,C,G,K,K,C,G,K,O,A,I,G,A,I,G,A,I,E,G,O,C,I,C,I,C,E,E,G,E,C,E,I,G,C,W,E,E,S,G,C,C,C,C,C,C,C,C,C,E,I,E,G,E,G,E,K,G,C,G,E,E,M,E,E,M,E,E,E,E,E,E,I,E,K,I,C,G,G,C,E,A,C,E,E,C,E,K,K,C,E,E,E,E,E,E,G,E,K,K,C,G,E,E,G,I,E,K,G,C,E,G,E,E,I,I,G,C,E,I,C,C,C,E,E,E,K,K,C,G,E,E,E,C,C,G,G,C,Q,C,Q,C,E,O,C,E,Q,C,E,Y,C,E,O,Q,M,E,K,C,Q,C,E,U,E,W,C,E,gB,C,E,U,C,E,W,E,U,C,E,I,E,S,C,U,C,E,I,E,K,C,O,C,E,W,E,C,iB,E,Y,C,E,M,C,Q,C,E,K,G,Q,C,I,E,O,C,C,E,M,C,Y,E,Y,G,O,C,E,gB,E,gB,G,Q,E,Q,C,E,S,C,E,gB,E,Y,E,S,G,U,C,M,C,M,C,E,M,C,E,M,S,W,O,kB,C,E,c,4B,gB,C,C,G,G,K,C,c,Q,G,S,G,K,C,a,Q,G,e,G,K,C,a,c,G,e,G,K,C,c,Q,G,S,G,Q,C,Q,C,U,C,E,Y,A,G,C,E,U,C,W,C,E,U,C,U,A,a,G,A,W,E,W,A,G,A,e,G,A,mB,C,G,G,Q,C,S,C,U,O,G,G,Q,C,c,C,Y,A,G,A,oB,G,A,a,E,W,A,G,A,oB,C,G,I,G,A,G,A,S,E,Q,A,U,E,O,E,G,C,E,E,I,A,Q,G,A,S,E,C,C,E,C,E,C,C,E,C,E,S,G,C,C,C,E,I,E,E,C,E,E,M,C,E,E,E,M,C,E,E,K,E,E,G,E,E,I,C,C,C,K,K,C,G,E,O,C,C,S,G,C,E,O,E,S,C,E,U,C,C,C,S,G,C,C,C,E,G,C,E,O,C,O,E,I,E,G,E,I,C,G,E,G,E,O,E,M,A,C,G,E,I,E,E,I,C,M,C,C,E,E,U,C,E,M,A,C,M,W,G,Y,C,C,C,K,G,I,C,E,C,E,E,C,I,C,I,C,E,I,C,I,C,O,C,K,E,I,C,G,C,E,G,C,I,C,K,C,E,K,C,I,C,G,C,K,E,I,C,M,C,K,E,I,C,I,C,K,E,I,C,K,C,K,E,I,C,K,C,K,E,I,C,M,C,K,E,I,C,Q,C,C,K,E,M,E,I,E,O,C,E,I,C,Q,C,K,E,I,C,S,C,K,E,I,C,U,C,K,E,I,C,a,C,K,E,I,C,W,C,K,E,I,C,Y,C,K,E,I,C,I,C,K,E,I,C,a,C,K,E,I,C,G,C,K,E,I,C,G,C,K,E,I,C,M,C,K,E,I,C,K,C,E,C,I,C,c,C,K,I,C,W,C,K,I,C,W,C,K,I,C,O,C,E,I,C,U,C,E,I,C,iB,C,C,E,I,C,W,C,K,E,I,C,S,C,K,E,I,C,c,C,C,E,I,C,Q,C,K,E,I,C,Q,C,K,E,I,C,a,C,K,E,I,C,a,C,K,E,I,C,Y,C,E,I,C,Y,C,E,I,C,M,C,C,E,I,C,iB,C,C,E,I,C,Q,C,K,C,C,K,C,C,C,I,C,O,C,E,U,C,I,C,U,I,I,C,I,C,E,I,C,I,C,Q,C,I,C,K,C,E,G,E,I,C,Q,C,I,C,K,C,E,G,E,I,C,a,C,I,C,K,C,E,Y,E,I,C,a,C,I,C,K,C,E,Y,C,C,M,C,C,C,C,C,O,C,C,e,C,G,C,S,C,C,S,C,C,c,C,C,c,C,C,C,I,C,O,E,G,E,O,iB,E,E,G,E,O,iB,E,E,G,E,O,iB,E,E,G,E,O,iB,E,C,I,G,E,G,I,G,E,G,W,G,G,W,G,E,C,C,U,C,C,C,G,C,I,C,C,I,C,C,W,C,C,W,C,C,C,I,C,a,G,E,G,G,E,M,C,I,E,I,C,E,I,E,I,C,uB,G,I,I,E,E,E,E,M,C,E,E,E,E,E,C,C,E,C,U,C,S,C,I,C,G,G,C,E,K,G,C,E,E,G,C,E,G,C,E,K,G,C,E,E,G,C,E,O,E,G,E,E,E,E,E,G,E,E,E,E,C,I,G,E,G,E,I,I,G,E,G,E,G,C,C,Y,C,M,C,K,I,C,W,E,E,I,I,C,U,E,E,M,I,C,Y,E,E,O,I,C,a,E,C,C,C,U,C,O,I,C,K,A,C,W,C,I,E,I,C,K,C,I,C,O,I,C,O,C,M,E,C,I,C,Y,G,E,O,C,E,O,A,G,E,M,E,E,A,C,c,C,I,C,M,C,C,E,I,C,iB,C,C,C,C,c,C,G,I,C,O,C,Y,C,C,I,C,C,C,O,C,C,C,C,C,C,C,G,C,Y,C,C,M,C,C,M,C,C,C,I,C,O,C,E,E,U,A,C,I,C,Y,G,I,C,Q,C,E,I,C,S,C,E,I,C,Q,C,E,O,M,C,C,K,E,M,E,I,E,O,C,E,G,I,C,K,C,K,I,C,W,C,K,I,C,c,C,K,I,C,W,C,K,I,C,mB,G,I,C,a,G,I,C,kB,G,I,C,U,C,I,C,Y,G,I,C,K,C,E,I,C,E,K,C,I,C,M,C,E,G,C,E,M,C,I,C,iB,E,C,I,C,gB,G,I,C,mB,G,I,C,e,G,I,C,M,C,ACrvQxE,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,GAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,EAAA,GAAA,EAAA,AAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,IAAA,GAAA,AAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,IAAA,EAAA,EAAA,CAAA,KAAA,GAAA,CAAA,IAAA,IAAA,EAAA,EAAA,EAAA,CAAA,E,I,C,E,G,I,C,iB,C,C,C,E,I,C,gB,G,I,C,K,C,I,C,U,I,E,C,I,C,e,G,I,E,E,I,C,K,C,M,A,C,I,C,qB,C,E,G,I,C,K,C,G,I,C,K,E,I,C,S,G,I,C,4B,G,I,C,sB,G,I,C,2B,G,E,O,E,C,E,Q,E,A,S,E,M,A,G,C,I,C,K,C,A,S,C,C,C,E,I,E,E,O,C,K,C,E,E,a,E,A,S,C,E,I,E,E,O,C,M,C,E,E,S,G,E,E,O,C,E,C,E,E,C,E,E,E,U,C,E,O,K,K,C,K,G,C,E,G,E,G,E,E,K,C,O,C,A,S,C,M,E,E,I,E,E,C,I,E,E,E,E,M,C,E,E,I,C,C,E,C,K,E,E,I,C,G,O,C,E,G,E,C,E,E,M,C,E,C,C,E,C,E,C,C,E,E,C,E,E,C,G,E,E,O,A,S,C,C,C,C,C,C,C,E,I,E,E,E,C,C,E,C,E,I,E,K,I,C,G,E,E,E,E,M,C,I,I,G,C,E,I,C,C,C,E,E,E,C,C,E,E,E,A,C,E,E,E,E,E,G,E,I,E,A,S,C,C,C,C,C,E,I,E,A,S,C,M,E,E,I,E,E,M,C,G,E,E,M,C,E,I,E,C,C,E,C,E,E,E,E,E,E,G,C,C,E,C,C,C,E,E,G,E,M,C,E,O,C,E,G,E,E,M,C,E,G,C,E,O,K,G,C,E,G,I,E,ADqvQwE,SAAA,CAAA,MAAA,EAAA,IAAA,EAAA,EAAA,CAAA,EAAA,KAAA,IAAA,CAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,CAAA,EAAA,IAAA,CAAA,GAAA,EAAA,IAAA,CAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,AAAA,EAAA,CAAA,GAAA,EAAA,IAAA,CAAA,GAAA,EAAA,IAAA,CAAA,CAAA,EAAA,IAAA,EAAA,GAAA,GAAA,GAAA,CAAA,E,G,I,I,E,E,E,E,M,C,E,E,E,I,C,I,E,C,C,E,C,G,E,E,O,C,C,O,K,G,C,E,E,E,E,E,G,G,E,E,K,E,E,I,E,E,E,K,K,C,A,C,E,C,E,C,E,C,G,K,I,G,E,E,E,G,G,E,E,E,G,E,E,E,E,E,E,E,I,G,E,E,E,C,C,E,C,C,C,E,E,E,O,G,E,E,E,E,G,G,E,M,C,E,G,C,C,O,G,E,E,G,C,E,I,C,I,C,K,E,I,C,W,C,K,I,C,a,E,E,G,I,C,qB,C,I,C,K,E,I,C,S,G,I,C,G,G,I,C,Q,G,I,C,W,E,C,W,C,I,E,I,C,O,C,O,C,E,C,C,I,C,Y,G,C,E,I,C,I,C,E,I,C,K,A,E,C,E,I,C,G,C,E,I,C,M,C,E,C,C,E,I,C,W,C,E,I,C,S,C,E,I,C,c,C,E,I,C,O,C,E,E,I,C,c,C,I,C,O,C,a,A,C,a,C,G,I,C,O,C,W,C,C,I,C,C,C,qB,C,G,I,C,O,C,mB,C,C,I,C,C,C,e,C,I,C,Y,G,C,I,C,K,C,I,C,Q,C,I,C,I,C,E,I,C,K,C,I,C,K,A,E,C,I,C,M,C,I,C,S,C,I,C,G,C,E,I,C,M,C,I,C,M,A,E,I,C,W,C,E,I,C,U,C,E,I,C,Y,C,E,I,C,a,C,C,C,oB,C,G,I,C,O,C,kB,C,C,I,C,C,C,W,C,C,C,I,C,K,C,a,C,E,I,C,U,I,G,I,C,O,C,E,C,C,I,C,C,C,kB,C,I,C,U,C,mB,C,qB,C,C,iB,C,I,C,U,C,kB,C,kB,C,I,C,U,C,mB,C,Y,C,M,E,A,C,iB,C,I,C,U,C,kB,C,6B,C,G,I,C,O,C,2B,C,C,I,C,C,C,mB,C,C,K,E,E,E,I,E,I,C,O,C,K,C,I,E,E,E,E,M,C,E,E,I,A,C,E,C,C,E,A,E,K,C,G,E,Q,C,C,E,K,C,E,E,C,I,C,C,4B,C,G,I,C,O,C,0B,C,C,I,C,C,C,8B,C,G,I,C,O,C,4B,C,C,I,C,C,C,wB,C,I,E,I,C,O,C,E,E,K,C,E,I,C,K,C,M,C,E,E,W,E,E,E,E,W,C,E,E,E,E,E,G,C,I,C,U,I,C,E,O,E,G,G,G,G,C,I,C,Y,G,C,I,C,a,C,E,M,C,I,E,I,C,c,G,E,E,M,C,K,C,E,E,O,C,M,C,E,G,I,C,K,C,K,C,E,E,I,C,Q,C,A,C,E,E,C,E,E,M,C,I,C,Q,C,E,E,C,E,C,C,G,C,E,E,C,E,C,E,M,C,G,C,C,E,E,I,C,S,C,G,E,I,E,E,O,C,G,E,K,C,I,C,K,C,O,C,I,E,E,K,I,C,E,E,E,G,E,K,G,C,E,K,G,C,E,EAAA,A,K,G,C,K,I,C,G,A,C,E,O,C,M,C,C,E,E,G,I,K,I,C,G,E,E,G,I,K,I,C,G,E,E,G,KAAA,CAAA,IAAA,EAAA,G,E,I,C,a,C,C,C,6B,C,G,I,C,O,C,2B,C,C,I,C,C,C,e,C,C,W,C,G,I,C,O,C,S,C,C,I,C,C,C,K,C,I,E,C,M,E,O,C,E,C,M,C,C,Q,C,M,C,C,M,C,C,K,C,C,C,C,I,C,E,I,C,U,G,E,I,C,Y,G,G,E,C,I,E,G,E,E,O,C,I,E,G,E,C,E,K,C,I,C,Q,C,E,M,C,G,G,C,E,C,E,M,C,I,C,S,C,E,K,C,G,G,C,E,E,O,E,I,C,K,C,M,C,C,G,C,M,C,C,K,C,C,O,C,C,Q,C,C,C,I,C,c,G,E,A,E,E,O,C,E,G,I,C,a,E,E,K,G,C,G,E,K,G,C,G,G,E,C,I,E,E,M,C,E,E,E,K,C,E,E,M,A,C,E,M,C,K,G,C,I,C,S,C,E,M,C,E,E,K,C,I,E,E,M,C,E,E,E,K,C,E,E,M,A,C,E,K,C,K,G,C,I,C,Q,C,E,K,C,E,E,C,I,C,iB,C,E,E,E,E,C,C,I,C,c,G,E,C,I,C,K,C,I,C,O,C,E,K,C,I,C,Q,C,I,C,I,C,Q,C,K,C,I,C,M,C,E,M,A,E,C,I,C,K,C,E,K,C,I,C,M,C,I,C,O,C,E,M,C,I,C,Q,C,G,C,I,C,Q,C,M,A,C,C,kB,C,C,C,C,C,C,C,C,C,G,C,M,C,M,C,C,Q,C,C,C,S,C,C,C,I,C,O,C,E,A,I,I,C,a,C,E,A,Q,G,A,M,I,C,I,C,G,I,C,Y,G,C,I,E,I,C,e,C,G,I,C,I,C,E,I,C,K,C,I,C,e,C,I,C,K,C,M,C,G,E,E,E,C,C,E,E,C,E,E,E,K,C,E,E,E,M,A,E,C,E,E,E,M,C,E,E,E,K,A,E,A,U,E,E,E,K,C,A,Q,E,E,E,K,C,A,U,G,C,E,E,K,C,E,E,E,K,C,C,E,I,C,W,C,K,G,C,A,C,E,E,C,E,I,C,K,C,C,I,C,K,C,C,E,G,I,C,Y,C,K,G,C,A,C,E,E,C,E,I,C,K,C,C,I,C,K,C,C,E,E,K,C,I,E,E,M,C,E,E,E,M,C,C,A,C,U,E,C,E,E,E,E,M,A,E,A,Q,G,C,E,E,M,C,E,C,E,I,C,U,C,E,E,I,C,a,C,E,C,C,C,gB,C,I,C,Q,E,C,I,C,Q,C,I,C,K,G,C,I,C,W,C,I,C,Q,C,I,E,I,C,Q,C,G,C,K,G,C,I,C,U,C,I,C,Q,C,G,E,I,C,Q,C,K,C,K,G,C,I,C,Y,C,I,C,Q,C,K,E,I,C,Q,C,M,C,K,G,C,I,C,a,C,I,C,Q,C,M,C,C,C,U,C,G,I,C,O,C,Q,C,C,I,C,C,C,c,C,G,C,K,C,C,S,C,C,C,I,C,O,C,M,A,Q,G,A,W,G,A,M,C,C,Y,C,O,I,C,O,C,Q,A,C,sB,C,C,K,E,E,I,A,I,C,2B,G,I,C,kB,C,G,E,E,E,E,M,C,E,E,I,G,C,C,E,C,K,G,C,E,M,C,E,G,I,G,E,I,C,0B,E,C,gB,C,I,E,I,C,W,C,G,C,E,C,I,E,I,C,O,C,K,C,U,C,E,I,C,K,A,C,E,E,M,E,C,E,G,E,E,E,I,C,W,C,E,I,C,kB,C,E,E,M,C,C,O,C,C,mB,C,C,C,C,C,G,C,I,C,C,kB,C,C,C,I,C,E,E,C,E,E,C,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,I,E,E,E,E,E,E,C,G,E,C,C,E,C,K,C,E,I,C,uB,C,G,E,I,C,E,E,M,C,E,C,C,E,C,C,C,E,E,C,K,C,E,G,E,A,E,E,E,U,C,E,E,E,A,G,I,G,G,C,G,G,G,I,E,E,E,E,M,C,E,E,E,E,A,G,E,C,C,E,G,G,I,C,E,G,E,E,I,C,E,E,C,E,G,G,C,C,M,E,G,E,E,I,C,E,E,C,E,G,E,C,C,E,I,C,G,E,I,C,G,E,K,G,C,E,G,E,K,G,C,E,E,C,G,E,A,Q,E,I,E,E,E,C,E,E,M,C,E,G,E,E,C,I,E,E,E,E,E,E,O,E,I,C,C,C,E,C,C,E,M,C,E,E,C,G,I,E,E,O,C,G,E,E,O,C,G,E,A,G,C,C,M,C,C,E,E,E,O,C,C,E,E,C,C,E,M,C,M,E,G,K,E,E,G,O,E,G,Q,E,G,O,E,Q,C,C,C,iB,C,C,C,O,C,C,iB,C,C,C,C,C,O,G,C,iB,C,C,C,C,gB,C,C,C,I,E,I,C,K,C,O,E,G,E,E,M,C,E,K,I,C,gB,C,C,C,E,C,K,C,C,mB,C,C,C,I,C,c,E,C,E,E,C,E,I,E,I,C,W,C,E,I,C,O,C,OAAA,G,I,C,c,C,G,I,C,K,C,E,G,EAAA,OAAA,M,C,mB,C,C,C,I,E,A,C,E,I,C,W,A,E,I,C,O,C,O,I,C,c,C,E,E,C,C,c,C,O,I,C,gB,C,I,C,Y,G,C,c,C,G,C,I,C,C,I,C,C,C,I,C,O,E,G,E,E,E,E,G,E,E,E,C,C,W,C,C,C,I,E,I,C,K,E,E,C,G,G,G,E,E,M,C,C,I,E,C,C,E,C,O,E,Q,E,C,E,Q,C,G,I,C,U,G,C,K,E,M,E,K,M,E,C,C,O,I,C,Q,E,C,I,C,Q,C,G,I,C,K,C,U,G,C,M,I,C,K,O,E,C,C,W,C,I,E,I,C,O,C,K,C,E,G,I,C,a,E,E,K,G,C,K,G,C,I,E,K,G,C,K,G,C,I,E,I,C,c,G,E,E,e,E,E,E,E,E,M,C,K,C,E,E,E,E,E,O,C,M,C,E,E,O,I,C,Y,G,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,C,C,Y,C,I,E,I,C,O,C,O,C,M,A,S,E,C,C,E,I,C,uB,G,M,C,C,C,sB,C,C,K,E,E,E,E,E,E,E,E,E,E,E,E,I,E,I,C,I,C,E,I,C,K,C,E,I,C,O,C,C,K,C,C,S,C,C,C,E,E,E,M,C,E,I,C,Y,G,E,I,C,K,C,M,C,C,E,E,C,E,E,G,G,E,E,C,E,E,U,C,I,C,U,I,E,E,U,C,E,W,C,E,E,E,E,E,S,C,E,O,G,E,E,E,E,G,A,Q,E,E,E,I,C,M,E,E,I,C,M,C,E,E,E,E,E,E,E,G,E,E,E,E,M,M,G,A,W,E,E,E,I,C,G,E,E,E,G,C,E,E,E,M,E,E,E,E,E,E,I,C,G,C,O,G,A,S,E,E,E,I,C,K,E,E,I,C,K,C,E,E,E,E,E,E,E,I,E,E,E,E,K,M,G,A,U,E,E,E,I,C,I,E,E,E,I,C,E,E,E,K,E,E,E,E,E,E,I,C,I,C,O,G,A,M,E,C,G,A,W,E,E,E,A,C,E,G,C,E,M,A,E,E,S,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,E,I,C,K,C,M,C,E,C,gB,C,G,C,E,E,G,C,E,E,M,C,E,A,C,E,E,C,E,C,M,G,A,M,E,C,G,A,W,E,E,E,A,C,E,I,C,E,K,A,E,Q,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,E,I,C,K,C,M,C,E,C,gB,C,G,C,A,E,A,C,E,E,C,E,E,E,E,I,C,E,E,K,A,C,I,E,G,E,K,C,a,C,G,E,K,G,C,E,K,I,C,E,I,I,E,E,E,E,G,E,C,I,E,E,U,C,I,C,U,C,I,E,E,S,C,E,E,K,C,E,E,U,E,E,C,E,E,gB,C,E,E,S,C,E,E,S,C,E,E,c,E,E,C,E,E,oB,A,A,M,I,C,E,A,S,C,C,C,C,C,E,I,E,E,K,C,M,C,E,K,G,C,E,E,G,E,E,W,C,E,E,S,C,E,E,e,C,G,E,G,C,C,G,C,A,E,A,I,E,K,G,C,E,E,E,G,A,I,E,A,C,E,e,C,G,C,E,E,A,C,E,E,e,C,E,E,E,E,A,C,G,E,E,E,C,C,E,E,M,E,E,I,C,E,O,C,E,I,C,E,E,G,C,E,G,E,E,G,E,E,E,E,E,E,E,E,E,E,E,E,I,C,C,I,E,I,E,I,E,I,E,G,E,G,E,G,E,G,E,M,E,M,E,W,E,iB,E,U,E,U,E,e,E,qB,C,E,C,C,O,I,C,Y,C,E,I,C,Y,C,E,C,C,mB,C,C,C,I,E,I,C,I,C,E,I,C,O,C,C,S,C,C,M,C,C,C,E,E,I,C,Y,G,E,I,C,K,C,C,M,C,C,W,C,C,Q,C,C,O,C,C,C,E,E,G,E,I,E,E,E,E,E,E,C,E,E,E,C,G,I,C,a,E,E,E,C,E,E,E,E,E,E,E,E,E,E,E,E,S,G,A,Q,E,E,I,C,M,C,E,E,I,C,uB,Q,G,A,W,E,E,I,C,G,C,E,E,I,C,uB,Q,G,A,S,E,C,I,E,I,C,uB,C,E,C,E,E,S,C,E,E,C,A,M,G,A,U,E,C,I,E,I,C,uB,C,E,C,E,E,S,C,E,E,C,A,M,G,A,M,E,C,G,A,W,E,E,A,C,E,G,C,E,M,A,E,E,O,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,I,C,K,C,M,C,E,C,gB,C,G,C,C,E,I,C,uB,E,M,G,A,M,E,C,G,A,W,E,E,A,C,E,I,C,E,K,A,E,E,O,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,I,C,K,C,M,C,E,C,gB,C,E,C,E,I,C,uB,C,G,S,A,C,A,M,G,C,A,U,E,E,M,A,Q,G,C,E,Q,C,E,I,E,I,C,c,G,I,E,E,E,E,M,C,E,E,E,E,K,E,E,A,C,C,E,C,K,C,I,E,E,U,C,I,C,U,C,G,C,E,I,C,e,C,G,E,W,C,E,A,C,E,I,C,uB,C,E,E,U,C,E,G,G,E,M,C,E,I,E,E,E,E,E,K,C,E,E,e,C,E,E,e,C,E,E,G,E,C,E,E,A,U,I,E,I,E,E,I,C,O,C,O,C,O,Q,A,I,E,I,C,O,C,O,C,Q,O,U,E,A,Q,E,A,S,G,A,I,E,C,E,E,E,E,A,W,E,C,E,O,C,M,C,E,E,E,E,C,E,O,C,M,C,E,E,A,S,G,A,I,E,E,E,A,W,E,E,O,C,M,C,E,E,E,E,O,C,M,C,E,E,G,C,G,E,C,E,C,E,E,E,A,C,E,C,E,E,C,E,E,iB,C,C,I,E,G,E,e,E,E,E,O,C,E,C,E,E,M,C,E,C,E,E,E,E,G,C,E,E,E,I,C,O,G,I,S,G,E,E,K,K,S,G,C,C,O,G,I,S,G,E,E,K,K,Q,G,C,C,E,C,K,E,I,E,M,E,E,K,C,O,E,E,M,C,M,E,a,A,C,C,E,I,C,C,S,E,M,E,K,E,M,E,Y,E,Y,E,W,E,U,E,a,E,Y,C,E,E,C,S,C,E,C,O,C,C,yB,C,G,C,S,C,C,M,C,C,C,I,C,O,C,G,C,G,I,C,a,E,M,A,Q,E,O,Q,I,E,S,M,A,U,E,K,C,E,O,A,Q,E,K,C,E,Q,A,U,E,K,E,C,E,O,E,C,C,wB,C,C,K,E,E,G,C,S,C,C,M,C,W,C,C,O,C,C,Q,C,C,C,C,I,C,O,C,E,I,C,c,G,E,E,E,E,E,M,C,K,C,M,A,S,E,E,C,E,I,C,K,C,E,A,S,E,E,O,A,W,E,C,E,S,G,E,C,E,C,E,Q,G,C,C,E,C,E,I,C,K,C,E,A,S,E,E,Q,A,W,E,C,E,S,G,E,C,E,C,E,O,E,I,C,I,A,C,E,A,U,E,E,C,E,I,C,I,C,E,A,S,E,E,Q,A,W,E,C,E,S,G,E,C,E,C,E,O,G,C,C,E,C,E,I,C,I,C,E,A,S,E,E,O,A,W,E,C,E,S,G,E,C,E,C,E,Q,E,I,C,K,A,C,E,E,Q,C,U,E,E,C,C,C,mB,C,G,I,C,O,C,K,C,M,C,O,I,E,I,C,K,C,E,I,C,O,C,Q,O,A,A,S,G,A,U,E,C,I,E,K,I,C,I,C,O,E,M,C,M,I,C,K,A,E,A,Q,G,A,W,E,C,I,I,C,G,C,K,E,O,I,C,M,C,M,E,K,A,Q,C,gB,C,G,C,I,C,C,Q,C,gB,C,C,C,K,C,C,I,C,C,M,C,C,O,C,C,C,I,A,C,G,C,E,I,G,E,S,C,E,E,Q,C,E,E,E,G,E,O,E,C,C,qB,C,C,C,I,E,I,C,O,C,I,C,G,C,I,C,U,I,C,E,O,C,O,E,I,E,I,C,K,C,S,C,A,G,E,K,G,G,O,G,E,E,U,C,I,C,U,C,I,S,C,C,C,S,C,C,K,E,E,I,E,I,C,O,C,I,C,E,I,C,G,C,E,I,C,c,E,C,I,C,c,C,I,C,qB,C,E,E,E,C,E,E,K,A,E,K,E,E,K,E,C,E,I,G,E,S,C,E,K,C,E,W,C,E,K,C,E,W,C,E,U,E,E,E,E,c,C,E,gB,C,E,S,G,E,M,C,E,C,C,E,C,E,E,M,C,E,C,C,E,C,E,E,M,G,E,O,E,C,E,G,E,O,C,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,A,C,E,e,E,E,C,E,E,E,C,E,E,E,A,E,C,E,E,E,C,E,E,E,A,E,G,E,S,E,E,C,E,E,G,C,E,E,G,A,E,C,E,E,G,C,E,E,G,A,E,C,M,E,S,C,M,E,S,C,W,E,c,C,iB,E,oB,A,E,C,C,Y,K,E,E,E,E,G,C,M,C,C,I,C,C,Q,C,K,C,C,C,C,I,C,E,E,U,C,I,C,U,I,E,E,U,C,E,W,C,E,G,C,E,O,I,E,E,U,C,I,C,U,C,I,S,C,E,I,C,Y,A,C,I,C,Y,G,C,E,G,E,I,C,I,C,G,E,E,E,G,E,I,C,K,C,G,E,E,E,E,C,E,C,E,G,E,I,C,G,C,G,E,E,E,G,E,I,C,M,C,G,E,E,E,E,C,E,E,I,G,E,S,C,E,W,C,E,W,C,E,W,C,E,S,G,E,M,C,E,G,E,M,C,E,G,E,M,G,E,O,E,C,W,C,C,K,E,E,G,C,I,C,O,C,K,C,O,C,O,I,E,I,C,G,C,E,I,C,iB,E,C,G,G,E,G,I,E,I,C,W,E,C,I,C,W,C,I,C,kB,C,E,E,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,C,E,E,I,C,E,E,K,A,C,E,Q,E,C,E,S,C,E,Q,C,K,C,E,Q,C,E,Q,C,I,C,E,Q,C,G,C,E,Q,C,K,C,E,Q,C,M,C,E,G,E,E,E,E,U,C,E,E,C,G,G,E,C,W,K,E,G,C,I,C,C,Q,C,S,C,C,M,C,C,Q,C,C,C,C,I,C,G,C,E,O,C,O,I,E,G,E,I,E,E,G,E,O,E,E,E,K,C,E,E,U,C,C,A,C,W,G,A,W,G,G,G,C,G,E,M,C,G,E,I,G,C,G,E,U,C,C,E,I,C,M,C,C,C,C,E,G,E,G,C,G,C,O,C,C,O,C,C,S,C,C,S,C,C,C,A,S,C,C,C,C,C,C,C,E,G,C,I,C,C,K,C,C,O,C,C,M,C,C,M,C,C,C,E,C,U,C,C,O,C,C,C,E,E,E,E,E,E,E,E,E,E,E,E,G,E,Y,G,C,G,E,G,E,E,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,C,C,E,C,gB,C,G,E,C,M,E,A,W,E,A,C,E,M,C,E,G,A,E,E,E,E,G,E,E,G,E,E,C,K,C,G,G,G,C,I,E,O,I,C,E,C,E,C,E,C,C,E,C,E,C,C,E,C,gB,C,G,E,C,M,E,A,W,E,A,C,E,I,C,E,K,A,E,E,E,E,G,E,E,E,C,E,G,E,E,G,E,A,S,E,C,G,E,C,M,C,O,E,O,E,S,E,S,C,C,E,I,C,E,E,G,G,E,E,I,C,E,E,E,C,M,E,K,C,S,E,S,E,S,E,E,G,G,A,C,A,G,A,U,G,C,G,A,U,C,G,C,E,G,E,E,G,a,S,Y,C,E,E,A,E,C,K,C,C,C,I,C,U,I,C,I,C,c,G,I,C,Q,C,G,I,C,U,G,I,C,S,G,I,C,U,C,E,C,C,S,C,I,E,I,C,O,C,E,E,K,E,E,K,C,C,E,E,E,G,E,I,E,E,I,C,C,C,I,O,A,I,C,U,I,I,C,I,G,G,S,C,I,C,C,C,E,E,K,A,I,I,C,c,G,I,C,Q,C,G,I,C,S,E,C,E,C,E,E,E,K,K,I,C,U,E,C,E,C,E,E,K,A,I,I,C,U,C,E,C,E,C,C,C,E,E,K,A,I,I,C,I,C,E,C,E,A,C,wB,C,C,K,E,E,I,E,I,C,K,C,4B,G,E,I,C,I,C,S,E,E,C,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,A,C,C,C,E,G,I,C,E,E,A,G,E,I,G,G,E,I,C,E,C,O,C,C,wB,C,C,C,I,E,I,C,O,C,K,C,U,C,I,C,U,C,I,O,G,E,I,C,C,Y,C,I,E,I,C,uB,C,G,U,C,M,A,C,I,C,Y,G,I,C,K,C,I,C,M,A,E,C,C,C,M,G,Y,C,C,C,C,C,C,C,I,C,I,C,E,I,C,K,C,E,I,C,Q,C,E,I,C,K,C,O,M,C,K,C,U,C,C,C,O,O,S,C,a,C,I,C,I,C,I,C,S,C,E,S,C,C,S,C,C,K,E,I,E,O,c,C,E,A,C,O,G,a,G,C,E,I,C,Q,C,E,E,I,E,I,C,K,C,E,E,E,C,E,I,C,K,C,I,E,G,C,E,M,A,M,2B,G,O,K,G,C,C,C,E,C,E,A,S,C,C,C,C,C,E,I,E,G,O,M,C,M,C,E,G,G,C,G,C,E,G,G,C,G,E,Q,C,C,C,G,G,C,E,G,E,a,E,A,S,C,C,C,E,O,I,C,G,O,C,A,I,I,E,E,K,C,K,E,E,G,G,E,C,E,C,M,C,G,I,C,K,E,C,C,E,C,K,C,K,E,E,G,G,E,E,I,C,K,G,K,C,E,E,E,E,E,E,E,E,a,E,E,W,E,G,Q,C,E,E,W,C,E,E,E,G,I,C,Q,E,G,Q,C,E,E,C,E,S,C,E,C,C,I,C,C,C,O,I,C,K,C,E,A,C,W,C,C,C,I,E,I,C,K,C,E,E,E,C,E,I,C,K,A,C,K,G,O,C,C,E,C,G,K,E,C,E,E,C,O,E,C,E,C,E,C,I,C,Q,E,O,E,C,E,A,C,C,C,I,G,I,M,a,C,I,C,W,C,I,G,G,W,C,G,I,C,Q,C,I,G,G,Y,I,C,O,C,I,G,O,W,I,C,M,C,I,G,G,U,I,C,gB,C,C,I,C,W,C,I,C,M,C,I,C,Q,C,A,C,I,G,C,C,C,I,C,K,C,W,E,C,O,G,C,C,C,I,C,K,C,a,E,C,e,G,C,C,C,I,C,K,C,W,E,I,C,W,C,C,Y,G,C,C,C,I,C,K,C,W,E,I,C,Q,C,C,W,G,C,C,C,I,C,K,C,W,E,I,C,O,C,C,U,G,C,C,C,I,C,K,C,W,E,I,C,M,C,C,c,C,C,C,O,I,C,I,C,E,I,C,W,C,a,C,W,C,C,C,O,I,C,I,C,E,I,C,Q,C,U,C,U,C,C,C,O,I,C,I,C,E,I,C,O,C,S,C,S,C,C,C,O,I,C,I,C,E,I,C,M,C,Q,C,kB,G,C,C,C,I,C,K,C,a,E,I,C,W,C,C,e,G,C,C,C,I,C,K,C,a,E,I,C,Q,C,C,c,G,C,C,C,I,C,K,C,a,E,I,C,O,C,C,a,G,C,C,C,I,C,K,C,a,E,I,C,M,C,C,M,C,C,C,C,C,C,C,I,E,C,O,C,A,I,I,E,G,I,C,mB,C,E,C,G,E,S,C,I,I,I,C,O,E,E,E,C,I,C,K,C,E,E,G,G,E,A,I,I,E,G,I,C,mB,C,G,I,C,K,C,E,E,E,E,E,C,M,C,C,C,C,C,C,C,I,E,G,E,C,G,C,C,S,E,C,E,C,G,C,C,E,C,G,G,C,C,Q,E,C,E,C,E,C,oB,C,C,C,I,I,E,E,E,I,C,gB,C,M,C,I,C,I,E,I,C,gB,C,E,C,G,E,S,C,G,O,C,C,O,I,C,O,A,C,K,C,C,C,C,C,C,C,I,E,E,G,C,G,G,A,K,I,E,M,A,M,I,E,yB,E,K,O,C,C,C,O,W,G,O,C,C,C,I,E,I,C,W,C,C,K,E,E,C,C,E,E,I,C,K,C,mB,C,C,M,C,C,M,C,C,C,G,E,E,G,G,I,C,U,C,E,I,C,U,C,E,G,I,C,E,E,E,E,M,A,E,I,C,O,C,Q,C,C,G,C,Q,C,C,S,C,C,C,C,C,E,M,C,I,C,K,C,E,a,C,I,C,K,C,E,U,C,C,C,E,U,C,E,M,C,E,I,E,I,C,4B,C,E,C,E,O,C,I,C,O,C,O,C,I,C,a,C,E,K,E,C,S,C,E,Q,C,E,E,C,I,C,c,C,E,E,E,E,C,a,C,G,C,S,C,C,C,I,C,O,A,E,I,C,kB,E,G,C,I,C,kB,C,G,U,C,O,E,K,C,a,C,e,C,C,C,C,C,C,C,C,C,I,E,A,U,E,C,O,C,C,O,C,C,S,C,C,S,C,C,C,I,C,W,C,E,I,C,yB,C,E,G,E,I,C,gB,C,G,E,I,C,c,C,E,G,E,E,I,C,E,E,I,C,C,S,C,C,Q,C,C,C,I,C,O,C,E,G,G,E,O,iB,C,E,I,C,K,C,mB,E,G,A,S,E,E,E,G,I,C,S,C,E,G,I,I,E,E,E,E,E,E,E,C,I,E,C,C,E,C,E,I,C,S,C,G,E,E,E,C,E,E,G,C,C,E,E,E,C,C,E,C,E,gB,C,C,C,E,C,G,E,C,C,E,C,G,E,E,Y,G,E,gB,C,E,I,C,U,C,E,E,G,C,C,E,C,E,C,E,I,C,M,I,M,I,E,E,I,C,E,G,K,G,C,C,C,E,C,C,C,E,E,E,G,C,E,M,C,E,E,G,C,E,I,C,E,A,E,G,C,E,O,C,G,I,C,yB,C,E,E,M,C,S,E,E,G,I,C,a,C,E,E,E,G,E,C,C,I,C,mB,C,E,E,E,C,gB,C,I,E,I,C,W,C,E,E,I,E,E,C,G,C,I,C,O,C,Q,C,C,I,E,E,I,I,E,E,M,C,E,G,E,E,E,E,K,G,C,E,C,C,E,C,I,C,I,C,yB,C,I,G,O,E,G,C,C,I,E,E,O,C,E,E,O,E,E,O,C,W,E,E,G,C,E,M,C,O,E,I,E,C,C,E,C,I,C,I,C,yB,C,I,E,C,C,E,M,C,E,C,I,C,I,C,yB,C,E,M,C,I,O,K,G,C,E,E,G,C,C,C,G,E,C,U,G,Q,C,C,mB,C,E,gB,Q,S,C,E,K,C,C,E,G,S,C,C,Y,C,K,O,E,Q,C,Q,C,U,C,M,I,G,M,A,G,I,E,K,C,K,E,c,C,G,C,C,E,O,C,E,C,K,Q,E,E,C,K,Q,C,C,E,I,G,O,M,C,C,U,K,c,G,iB,G,mB,G,e,G,oB,G,c,G,gB,G,kB,E,G,S,K,M,A,M,kF,C,M,G,Y,C,C,C,I,C,O,C,G,C,C,C,K,C,C,C,C,S,C,O,I,C,M,C,C,C,C,C,O,I,C,O,C,C,C,C,C,O,I,C,I,C,C,C,C,C,C,C,O,I,C,K,C,C,C,C,C,C,C,O,I,C,Q,C,C,C,C,C,C,C,O,I,C,M,C,C,C,C,C,O,I,C,C,G,Q,C,S,C,E,O,M,C,G,S,C,E,E,I,G,C,M,E,E,S,G,C,C,C,C,C,C,C,C,C,E,I,E,E,4B,G,E,C,C,E,C,I,I,E,E,E,E,M,C,E,E,E,E,C,G,C,M,C,C,K,C,C,C,C,C,E,C,C,G,C,C,G,C,C,C,A,S,C,C,C,C,C,C,C,E,G,C,W,C,C,K,C,C,Q,C,C,C,E,E,E,W,C,M,C,G,G,I,E,I,E,A,M,G,G,E,M,C,C,I,E,E,c,C,G,G,I,E,O,E,E,E,G,G,E,c,C,C,I,E,C,C,E,C,E,A,Y,O,E,Q,E,E,Q,C,G,G,E,C,I,E,E,E,E,E,G,E,E,E,E,E,G,M,C,G,E,E,C,G,E,E,A,C,C,C,C,M,C,G,E,G,E,M,C,C,C,E,C,C,E,C,E,E,G,I,I,E,E,G,E,E,E,C,I,E,C,C,E,A,C,E,I,E,E,E,E,E,C,C,C,S,G,C,C,C,C,C,C,C,C,C,E,I,E,E,C,M,C,A,G,E,a,C,E,G,G,E,E,E,S,C,C,C,C,C,E,C,A,G,G,E,E,S,C,E,G,E,O,C,E,C,C,E,C,C,I,E,I,C,C,Q,E,a,E,M,C,E,E,C,G,C,C,S,G,C,C,C,C,C,C,C,C,C,C,C,M,E,O,A,G,E,a,C,G,A,M,G,E,A,S,C,C,C,C,C,C,C,C,C,C,C,E,I,E,E,C,E,A,S,C,E,I,E,A,K,E,O,C,K,E,A,K,E,O,C,K,O,S,C,C,C,E,I,E,E,K,G,C,E,C,C,E,C,E,E,E,E,K,G,C,E,C,C,E,C,E,E,O,K,I,C,K,G,C,E,G,K,G,C,E,G,C,E,G,E,O,iB,C,O,G,E,E,E,S,C,C,C,C,C,E,I,E,E,O,C,E,C,C,E,C,C,G,G,G,C,E,O,I,E,E,c,C,G,G,C,C,A,G,E,a,C,E,G,C,E,O,I,E,E,E,E,C,E,E,C,E,C,C,Q,E,a,E,M,C,E,C,E,C,E,I,G,E,I,C,C,Q,E,a,E,M,C,E,G,C,E,E,E,E,E,E,I,E,E,C,G,E,E,E,S,C,C,C,C,C,E,G,C,W,C,C,S,C,C,C,E,Q,C,C,a,W,C,G,C,M,C,C,C,G,E,C,E,A,E,C,C,E,A,E,C,A,E,C,G,E,E,I,E,I,C,C,Q,E,a,E,M,C,E,G,G,E,A,C,S,G,C,C,C,C,C,C,C,C,C,E,I,E,E,C,E,A,M,E,W,W,E,C,E,O,G,E,E,E,C,E,E,K,C,C,E,C,C,C,E,C,I,C,E,I,C,C,Q,E,a,E,M,C,G,E,G,E,O,C,E,C,C,E,C,C,E,C,G,G,C,E,E,C,C,C,I,G,C,yB,G,M,C,M,C,C,C,C,C,C,C,E,I,E,G,E,G,E,E,I,E,I,E,E,gB,E,C,E,E,E,S,C,G,E,E,E,E,G,G,E,E,E,C,E,E,G,E,E,C,O,E,M,C,C,E,4B,G,O,C,A,I,I,E,C,C,E,C,K,C,E,E,I,C,E,A,C,G,C,E,I,E,E,I,C,C,Q,E,a,E,K,C,M,C,E,G,C,E,E,A,E,Q,C,C,C,C,C,C,C,E,I,E,G,E,G,E,E,I,E,K,E,E,gB,E,C,E,E,E,S,C,G,E,E,E,E,G,G,E,E,E,C,E,E,G,G,E,M,C,E,C,I,E,C,C,E,C,Y,C,E,E,c,C,G,I,C,E,E,C,I,I,E,E,E,E,M,C,E,E,E,I,C,C,Q,C,C,E,C,a,E,M,C,E,C,O,C,E,M,C,C,C,C,C,C,C,E,I,E,G,E,G,E,E,I,E,K,E,E,gB,E,C,E,O,G,E,E,E,E,E,E,Q,C,C,C,C,C,C,C,E,I,E,G,E,G,E,E,I,E,K,E,E,gB,E,C,E,O,G,E,E,E,E,S,C,E,E,E,E,C,C,C,C,C,C,C,E,I,E,G,E,G,O,G,E,E,I,E,S,C,E,E,E,C,C,C,C,C,C,C,E,I,E,G,E,G,O,G,E,E,I,E,S,C,E,C,C,E,I,G,C,O,M,Q,S,C,S,G,C,C,C,E,O,E,M,C,A,G,E,G,G,E,C,S,G,C,C,C,E,O,E,M,C,A,G,A,K,G,O,C,E,G,G,E,G,C,I,G,E,C,S,G,C,C,C,E,O,E,I,C,C,E,K,I,E,E,E,E,E,E,E,E,O,E,M,G,E,M,C,E,K,C,E,K,C,E,M,C,E,M,A,E,C,S,G,C,C,C,C,C,C,C,E,O,K,G,C,C,C,E,C,C,C,E,E,K,G,C,C,C,E,C,C,C,E,C,C,S,G,C,C,C,E,E,G,C,K,G,C,E,G,C,E,G,E,E,I,C,K,G,C,E,I,C,E,I,E,E,M,C,K,G,C,E,M,C,E,M,E,E,K,C,K,G,C,E,K,C,E,K,C,C,S,G,C,C,C,C,C,C,C,M,E,E,E,E,E,E,I,E,E,C,I,E,E,E,E,M,C,E,E,E,E,E,E,C,A,C,E,A,C,E,C,C,E,A,E,G,A,E,M,C,E,K,E,E,C,C,E,M,E,E,C,C,A,S,C,C,C,E,I,E,E,U,C,O,A,S,C,E,I,E,C,K,E,I,E,M,E,O,C,E,O,E,O,C,A,I,C,C,E,C,K,G,C,C,C,E,C,C,C,E,C,G,C,E,E,C,O,Q,C,C,M,S,C,E,E,U,C,I,G,C,K,C,C,M,C,C,C,A,S,C,C,C,C,C,C,C,E,G,C,I,C,C,I,C,C,C,E,E,E,U,C,G,C,G,G,C,E,I,E,C,C,C,E,E,E,I,A,E,I,E,C,C,E,K,C,E,C,K,E,M,C,C,C,E,I,C,K,G,C,E,I,C,E,U,C,E,M,C,E,K,E,E,I,C,E,I,C,E,K,C,C,C,E,E,E,I,A,C,E,U,E,G,E,E,U,I,I,E,K,G,C,E,E,U,C,G,E,E,O,U,E,K,G,C,E,E,W,C,G,E,E,M,W,E,I,E,C,C,E,I,E,C,C,O,E,C,C,E,E,C,C,E,E,U,C,C,K,E,M,C,E,C,K,E,M,C,C,E,E,E,E,E,C,G,G,E,M,C,E,G,E,E,Q,E,E,I,C,E,C,O,G,G,E,E,E,I,C,C,S,G,C,C,C,C,C,C,C,C,C,E,E,G,C,E,E,I,C,E,E,K,C,E,E,E,M,C,E,E,E,K,C,E,E,M,C,C,C,S,G,C,C,C,C,C,C,C,E,I,E,E,O,C,C,E,C,C,E,C,C,C,E,I,I,K,E,C,I,E,E,G,C,E,C,C,E,K,C,E,C,M,E,O,E,O,C,E,E,E,W,C,E,M,E,E,G,E,U,C,C,I,E,E,C,C,E,E,E,I,E,E,M,A,C,G,E,K,G,C,E,E,K,A,E,E,Q,C,G,E,E,I,C,E,E,U,C,E,K,C,E,I,C,G,G,E,E,I,C,E,M,C,E,E,G,E,K,C,E,E,M,E,E,E,E,M,A,K,C,I,E,E,C,C,E,E,E,I,E,E,K,A,C,G,E,K,G,C,E,E,K,A,E,E,Q,C,G,E,E,E,G,C,E,E,W,C,E,M,C,E,G,E,G,E,E,E,G,C,E,M,C,E,G,E,K,C,E,E,M,E,E,E,E,K,A,C,C,E,C,C,E,E,C,C,C,C,G,G,C,S,C,Y,C,E,Q,C,I,E,M,E,O,E,K,C,C,G,I,G,C,O,C,C,C,E,E,K,E,C,E,K,C,E,A,E,E,Q,C,E,Q,E,C,E,E,Q,C,E,Q,E,M,E,M,C,E,M,E,E,E,O,C,E,O,E,W,M,C,C,E,E,K,C,E,E,I,C,E,C,E,A,E,E,K,C,I,C,E,E,U,C,C,C,E,I,E,E,K,C,E,K,C,O,C,G,E,A,C,K,G,E,K,C,M,C,E,E,E,U,C,C,C,C,C,E,E,Q,C,E,Q,C,E,Q,C,E,Q,C,E,M,C,E,M,A,E,O,C,C,C,C,C,C,C,E,G,C,E,O,I,E,G,E,O,C,M,C,O,E,E,K,G,C,E,E,K,C,G,E,K,G,C,E,E,M,C,G,E,A,S,C,E,I,E,A,S,C,M,E,E,E,E,E,E,I,E,E,C,I,E,E,E,A,C,G,E,A,E,M,C,E,E,E,E,E,C,C,E,C,C,C,S,C,C,Q,C,M,C,C,Y,E,C,C,C,C,C,E,E,I,C,C,M,E,I,E,I,E,W,E,Y,G,O,E,M,C,M,G,E,E,Y,C,G,O,C,E,G,E,G,E,M,C,A,G,E,G,C,Q,E,C,G,E,G,G,E,Q,C,G,E,G,G,E,U,E,G,G,E,O,C,G,E,G,G,E,W,E,G,E,K,E,G,E,K,M,C,S,E,W,E,M,C,G,e,E,M,C,G,M,C,G,M,C,G,U,G,E,a,S,E,M,C,G,M,C,G,W,E,M,C,G,M,C,E,C,E,E,K,E,E,E,Q,C,E,E,U,C,G,E,K,C,A,I,A,Y,O,E,Y,E,E,Y,E,G,I,E,E,M,C,C,E,I,E,G,C,O,E,A,C,I,E,G,C,O,C,O,C,E,E,E,I,E,E,O,M,C,C,W,E,Y,E,Q,E,e,E,gB,E,a,E,E,E,c,E,C,G,E,O,M,C,C,E,G,G,E,G,I,I,E,O,M,C,C,W,E,E,E,E,E,E,E,I,C,E,E,G,A,E,G,E,A,S,C,C,C,M,E,E,E,I,E,A,S,C,E,I,E,C,E,I,I,K,E,C,G,C,M,C,C,I,C,C,Y,C,C,C,E,G,C,G,C,G,Q,C,G,S,I,E,C,C,E,E,C,C,C,E,C,C,M,E,O,E,O,E,K,C,C,C,C,E,K,G,E,M,E,C,C,O,C,E,G,C,a,C,C,c,C,C,C,E,I,E,E,E,E,M,C,E,E,E,E,C,E,C,C,E,C,G,C,S,C,C,C,E,G,C,E,C,C,E,K,C,C,E,G,E,W,C,E,M,A,C,E,U,C,C,E,K,C,E,E,E,G,E,c,C,E,M,C,C,E,C,E,K,C,E,E,M,C,E,E,E,G,E,e,A,C,C,O,C,E,E,M,C,G,E,C,G,E,Q,C,E,E,G,G,E,E,E,G,G,E,E,E,I,G,E,E,E,G,A,S,C,E,I,E,E,U,C,S,E,C,E,I,E,K,G,C,C,C,E,C,C,C,E,C,G,O,C,C,E,E,E,C,C,E,C,E,E,O,E,C,E,E,Q,E,S,E,S,E,G,G,E,U,C,E,E,G,E,C,E,E,C,C,E,C,E,E,C,C,G,E,c,C,E,E,G,E,S,C,C,K,E,I,C,I,E,G,C,M,E,I,C,E,C,C,O,E,G,C,E,C,C,O,E,C,C,M,E,C,A,E,G,E,S,C,A,I,I,E,E,G,A,C,O,M,C,E,E,S,E,E,M,C,E,C,C,E,C,C,C,K,E,I,E,M,E,O,C,E,E,C,C,O,G,e,C,C,C,C,C,C,e,C,C,C,M,C,C,C,iB,C,C,C,C,C,C,C,C,oB,C,C,C,C,C,C,C,C,qB,C,O,C,C,e,C,C,C,C,C,C,C,C,C,O,E,K,G,C,E,G,E,K,E,E,G,E,M,C,C,M,E,O,K,G,C,E,E,K,K,C,E,G,E,C,C,W,C,C,C,M,C,C,C,a,C,C,C,C,C,M,W,G,e,C,C,C,O,G,E,U,E,E,U,C,O,I,C,a,C,C,C,E,O,C,S,C,C,C,C,C,I,G,W,G,C,W,Y,U,Y,S,U,a,a,Y,Y,Y,Y,U,U,a,W,W,U,E,G,A,G,A,O,G,A,K,E,G,E,I,C,Q,C,C,E,S,G,C,C,C,C,C,E,E,M,C,mB,C,E,E,G,C,S,G,C,C,C,E,I,I,K,E,G,I,G,E,Q,C,G,M,C,C,C,S,G,C,C,C,C,C,E,I,E,E,M,C,E,I,iB,A,I,I,E,C,E,I,I,K,E,E,A,C,E,G,G,E,U,C,E,G,C,G,E,Y,C,E,C,G,G,G,O,E,O,C,S,C,U,C,E,Q,C,C,G,C,C,S,G,C,C,C,C,C,E,I,E,E,M,C,E,I,iB,A,I,I,E,C,E,I,I,K,E,E,A,C,E,G,G,E,Y,C,E,G,C,G,E,U,C,E,C,G,G,G,O,E,O,C,S,C,U,C,E,Q,C,C,G,C,C,I,G,I,I,G,E,S,K,I,E,O,gB,A,C,I,I,C,G,E,G,O,C,C,E,K,E,uB,G,G,G,E,C,C,S,G,C,C,C,C,C,E,I,E,E,M,C,E,G,G,G,G,C,E,O,I,E,G,C,E,K,I,E,E,W,A,C,E,E,G,E,E,W,E,G,E,Q,E,I,e,A,I,I,E,C,C,E,C,E,E,W,C,K,C,E,E,W,C,M,A,A,C,I,G,A,I,G,E,E,E,G,O,E,O,C,G,G,I,E,O,gB,C,S,I,G,G,C,E,G,C,C,S,G,C,C,C,C,C,E,G,E,U,G,A,W,I,G,M,C,G,G,I,E,O,mB,C,S,I,C,S,G,C,C,C,C,C,E,I,E,E,M,C,E,G,A,I,A,O,E,G,E,E,A,S,C,C,C,E,I,E,E,C,E,I,C,E,E,I,C,C,E,C,C,E,C,C,C,G,E,G,M,C,K,E,M,E,O,E,E,A,K,I,E,E,K,E,A,K,I,E,E,I,C,E,E,G,E,E,A,I,I,E,C,C,E,C,M,C,E,E,O,C,E,O,C,A,G,O,A,S,C,C,C,C,C,E,E,gB,C,E,E,G,E,E,E,G,C,C,M,W,G,e,C,C,C,C,C,I,E,G,E,U,E,E,U,C,M,O,G,E,M,G,E,C,A,S,C,C,C,E,I,E,E,K,C,E,E,Y,C,U,E,E,Y,C,S,G,C,C,G,C,C,Q,C,O,E,M,E,M,C,Q,E,O,C,O,E,M,C,M,E,K,A,C,C,E,E,O,C,E,O,E,Q,E,S,C,E,S,E,a,G,G,C,I,E,G,E,Q,A,M,I,G,C,E,K,C,C,C,C,G,G,I,G,A,K,E,K,C,M,C,E,M,C,E,K,C,C,G,C,M,C,I,E,G,E,S,A,M,I,G,C,E,M,C,C,C,E,E,E,G,C,E,I,C,e,C,C,C,I,E,E,M,C,G,C,C,C,G,C,M,C,E,I,E,C,C,G,C,O,C,C,S,Q,C,O,C,A,I,I,E,C,C,E,A,C,G,G,E,e,C,G,E,Y,C,E,E,G,I,E,E,K,E,C,E,O,O,I,C,G,O,C,A,I,E,K,C,E,C,C,C,E,A,G,E,K,C,E,K,C,O,C,C,G,C,C,C,C,iB,C,C,C,C,C,C,C,I,C,mB,C,E,G,I,E,E,Q,E,C,E,Q,C,C,C,E,E,C,O,G,O,G,O,E,C,C,E,E,E,C,C,C,E,C,E,E,E,E,C,oB,C,C,C,C,C,I,E,E,Q,E,C,E,Q,C,C,C,E,E,C,C,E,C,G,C,A,C,A,C,C,O,G,O,G,O,E,C,C,C,E,E,E,E,E,E,G,C,C,E,C,K,C,C,C,qB,C,O,O,gB,A,C,e,C,C,C,C,C,C,C,C,C,O,ACrvQxE,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,UAAA,EAAA,GAAA,EAAA,QAAA,CAAA,EAAA,gBAAA,GAAA,EAAA,GAAA,EAAA,SAAA,CAAA,EAAA,iBAAA,GAAA,EAAA,AAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,GAAA,AAAA,KAAA,IAAA,GAAA,AAAA,KAAA,IAAA,EAAA,CAAA,IAAA,EAAA,GAAA,GAAA,GAAA,EAAA,CAAA,IAAA,EAAA,EAAA,qBAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,SAAA,SAAA,EAAA,GAAA,EAAA,UAAA,CAAA,EAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAAA,EAAA,GAAA,EAAA,QAAA,CAAA,EAAA,eAAA,EAAA,GAAA,EAAA,SAAA,CAAA,EAAA,eAAA,MAAA,EAAA,EAAA,WAAA,CAAA,EAAA,EAAA,YAAA,AAAA,CAAA,MAAA,CAAA,MAAA,EAAA,OAAA,EAAA,SAAA,GAAA,GAAA,UAAA,GAAA,EAAA,CAAA,EAAA,EAAA,EAAA,GAAA,CAAA,MAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,GAAA,AAAA,gBAAA,EAAA,SAAA,CAAA,CAAA,IAAA,EAAA,GAAA,EAAA,SAAA,SAAA,EAAA,GAAA,EAAA,UAAA,CAAA,GAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA,AAAA,CAAA,OAAA,EAAA,KAAA,GAAA,CAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,GAAA,CAAA,EAAA,EAAA,KAAA,KAAA,CAAA,EAAA,GAAA,EAAA,EAAA,MAAA,EAAA,EAAA,GAAA,KAAA,GAAA,CAAA,EAAA,EAAA,EAAA,QAAA,GAAA,EAAA,GAAA,KAAA,GAAA,CAAA,EAAA,EAAA,EAAA,SAAA,GAAA,GAAA,CAAA,GAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,CAAA,MAAA,EAAA,OAAA,CAAA,CAAA,E,E,E,E,E,C,W,C,C,C,I,E,G,G,M,C,C,C,G,E,W,A,C,C,C,S,G,C,E,M,C,M,A,I,O,iB,a,gB,G,E,C,M,G,a,C,I,C,K,C,E,A,C,O,C,C,C,C,C,C,C,C,C,A,e,G,C,I,C,K,C,I,C,kB,C,E,C,G,I,C,O,C,I,C,K,C,E,U,E,I,E,E,I,C,Y,C,G,M,C,G,I,C,Y,C,G,E,I,C,O,C,E,E,E,G,M,A,iB,G,C,I,C,O,C,E,E,Q,I,C,O,C,I,C,K,C,E,Y,E,C,C,Q,C,C,C,C,C,C,C,C,C,I,I,K,E,G,C,E,G,C,I,E,E,M,C,E,C,C,E,C,E,C,E,E,E,O,C,C,G,A,C,I,G,E,E,I,E,U,C,M,C,C,C,M,C,C,C,Y,C,G,I,C,M,G,C,I,C,S,C,I,C,M,C,I,C,M,C,K,C,C,C,a,C,C,C,G,I,C,M,C,O,I,C,M,C,I,E,I,C,M,C,I,C,kB,C,G,O,I,C,mB,C,G,C,C,mB,C,C,C,C,C,I,E,G,E,M,C,E,G,E,O,E,E,O,C,O,C,C,G,E,A,S,C,E,I,E,C,E,E,E,C,E,O,I,C,G,O,C,K,E,I,I,E,E,E,E,M,C,I,E,I,C,G,S,C,C,C,E,G,I,E,E,O,E,E,C,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,A,A,C,K,E,O,C,I,C,E,I,C,G,C,C,E,E,C,C,C,C,C,C,M,C,Q,E,S,C,C,E,G,M,A,C,I,G,E,A,S,C,C,C,Q,C,C,S,C,C,C,C,C,C,E,I,E,E,C,E,E,U,G,I,I,K,E,K,E,I,E,E,E,C,G,E,C,C,E,C,A,G,A,C,I,E,A,C,I,E,C,E,E,K,A,Q,G,E,I,C,C,O,E,Q,A,S,C,C,C,O,C,C,M,C,C,C,C,C,C,E,I,E,E,e,C,G,E,E,e,C,E,G,O,G,E,Q,E,E,I,C,E,Q,E,E,c,C,E,E,C,G,C,C,W,C,E,U,C,E,Q,C,C,E,E,E,M,C,C,O,E,M,C,C,E,A,E,E,E,E,C,O,C,E,E,E,E,G,E,A,C,oB,C,C,C,I,E,I,C,S,E,E,C,E,I,C,M,C,E,C,E,I,E,M,C,A,G,C,E,I,C,A,G,E,M,C,E,G,E,M,C,E,E,C,I,C,O,C,E,E,G,E,Q,I,C,O,C,E,E,G,E,Q,C,C,S,G,C,C,C,E,I,E,G,Q,C,E,E,C,E,M,A,C,A,C,E,Q,E,C,C,C,C,E,E,C,C,E,S,E,E,S,E,E,S,E,G,C,S,G,C,C,C,M,E,M,A,M,G,A,M,E,E,E,I,E,C,A,A,S,E,E,Q,G,A,W,E,I,A,S,G,A,U,E,U,G,E,M,C,G,W,E,C,S,G,C,E,I,E,E,O,E,C,E,O,C,C,C,C,C,E,O,C,G,E,O,C,C,G,E,M,C,A,S,C,C,C,E,I,E,E,C,E,I,C,E,C,O,C,C,E,E,E,M,E,C,E,E,G,E,I,C,G,E,O,M,C,M,E,O,M,C,M,O,O,I,C,G,O,C,A,I,I,E,C,C,E,C,G,C,G,G,O,Q,K,C,C,uC,E,E,C,E,G,E,M,C,O,Q,I,C,C,+C,E,E,C,E,I,E,G,E,G,E,A,I,E,U,U,E,E,M,E,C,C,C,C,C,E,C,C,C,E,E,E,C,C,E,C,G,O,M,C,M,C,C,K,C,E,E,C,C,E,C,C,C,E,C,C,G,E,I,C,Q,C,O,C,A,I,I,E,E,I,E,E,I,C,E,E,S,E,G,E,G,E,A,C,E,C,E,E,C,C,E,M,E,C,E,O,I,C,G,O,C,A,Q,E,I,G,E,E,A,Y,E,E,E,A,Y,G,C,E,A,M,E,I,G,E,G,E,C,C,E,S,E,C,C,E,E,C,C,C,C,E,C,C,C,E,E,O,M,C,M,G,C,C,E,C,C,C,K,C,E,C,C,E,C,C,C,E,C,C,E,G,O,I,C,G,O,C,A,I,I,E,C,C,E,C,G,E,C,G,M,C,E,I,C,C,G,K,C,C,G,C,E,E,E,C,S,G,C,E,M,A,C,E,G,C,C,E,Q,C,E,Q,E,E,C,E,M,C,E,M,E,E,C,C,C,I,G,I,I,G,I,I,S,G,C,C,C,E,I,E,G,G,C,G,O,G,C,E,I,G,G,C,E,G,G,G,C,E,E,C,C,I,G,C,E,E,K,I,E,G,E,E,A,M,I,G,E,G,C,E,C,O,G,Y,C,C,K,C,C,I,C,O,E,A,C,E,C,E,I,C,C,E,I,C,G,E,I,E,G,G,G,I,C,W,C,I,I,I,C,c,C,I,G,C,I,U,C,O,I,C,O,C,Q,A,C,I,M,C,O,I,C,O,C,I,A,C,I,K,C,C,C,I,C,O,C,I,C,C,C,I,M,C,O,I,C,O,C,I,A,C,I,K,C,C,C,I,C,O,C,I,C,G,E,C,I,S,C,O,I,C,O,C,O,A,C,I,Q,C,C,C,I,C,O,C,O,C,C,C,I,S,C,O,I,C,O,C,O,A,C,Q,C,I,E,I,C,O,A,C,I,C,U,G,G,E,C,Y,C,I,C,W,C,K,G,I,C,c,C,K,E,C,iB,C,C,C,O,G,E,I,C,C,C,S,E,E,C,C,G,C,C,C,0B,C,C,C,C,C,O,G,C,E,E,Y,E,E,C,C,I,C,C,C,S,E,E,a,E,E,C,C,C,Y,E,E,C,C,C,C,C,S,E,E,C,C,G,C,C,C,wB,C,C,C,C,C,O,G,C,E,E,C,E,E,C,C,I,C,C,C,S,E,E,U,E,E,C,C,C,S,E,E,C,C,C,S,E,E,C,C,G,C,C,C,gB,C,C,C,I,E,E,E,C,E,I,C,I,C,O,G,C,E,E,Q,E,E,C,C,I,C,C,C,Q,E,E,C,I,E,sB,E,E,C,C,C,C,c,C,C,C,C,C,I,E,I,C,W,C,E,E,G,C,G,M,A,C,C,G,C,G,C,E,I,I,E,G,C,E,E,E,C,C,gB,C,C,C,C,C,C,C,G,C,Q,C,C,K,C,C,C,I,C,E,I,C,a,C,E,G,E,E,G,C,G,G,E,O,E,I,E,I,I,E,O,C,A,I,G,C,E,G,C,G,E,O,C,A,G,G,E,E,G,E,E,O,C,A,G,G,E,E,I,E,O,C,A,G,G,E,E,C,E,E,C,E,I,E,O,C,A,G,G,E,G,I,E,O,C,A,G,G,E,G,G,G,I,E,M,I,C,G,O,A,I,E,M,E,E,I,C,O,M,C,O,G,G,C,I,E,G,C,E,G,C,C,mB,C,G,C,Q,C,C,K,C,C,C,I,C,M,C,E,E,C,E,E,C,E,G,Q,C,E,E,C,E,C,K,C,E,G,G,A,C,oB,C,C,C,C,C,C,E,C,G,C,C,I,E,C,Q,C,C,E,C,S,C,C,Y,C,C,C,G,I,C,c,C,E,G,E,E,G,A,S,C,C,C,E,G,C,a,C,C,Y,C,C,C,G,G,I,I,K,E,C,I,E,E,G,E,E,G,E,A,C,G,C,G,C,C,E,C,G,G,C,G,I,G,E,G,G,G,G,M,C,C,C,M,C,C,E,E,G,C,E,O,C,C,E,E,G,G,I,E,I,E,I,C,c,C,E,E,G,E,G,E,E,E,C,I,I,K,E,C,C,E,C,C,C,E,C,O,C,C,e,C,C,C,C,E,C,G,C,C,C,C,G,C,S,C,C,C,G,I,C,c,C,E,G,O,G,G,G,E,E,K,E,G,C,C,C,S,G,C,C,C,C,C,E,I,E,E,G,C,E,C,G,C,E,I,I,E,G,C,E,E,E,I,E,E,I,G,E,E,G,C,G,O,G,C,E,C,S,G,E,G,Y,E,M,C,A,G,C,E,W,G,Q,C,S,E,E,G,C,E,E,E,C,C,I,G,A,G,G,I,O,mB,C,G,M,C,C,E,I,G,G,C,C,E,E,C,G,G,C,M,S,O,Q,Y,C,S,G,C,C,C,E,M,A,Q,G,A,W,G,A,K,G,O,C,I,A,M,C,C,S,G,C,C,C,E,O,S,C,C,C,E,O,C,C,E,G,C,C,E,C,C,C,E,C,C,C,E,C,C,C,E,C,C,C,E,A,C,C,S,G,C,E,I,E,E,K,C,E,E,O,C,S,A,C,E,a,C,e,G,G,E,U,C,C,E,C,E,C,S,G,C,E,I,E,E,K,C,E,E,O,C,S,C,G,G,E,U,C,C,E,C,E,C,S,G,C,E,O,M,A,U,O,E,E,S,c,C,G,G,E,M,E,C,E,C,C,E,A,E,G,E,M,E,C,E,E,M,A,E,C,C,I,G,C,E,G,A,I,I,E,G,G,O,O,M,C,I,M,C,A,G,E,M,G,G,G,E,C,O,G,Y,C,C,C,C,KDqvQwE,EAAA,MAAA,E,I,E,I,C,M,C,I,G,G,E,G,G,E,G,G,G,E,M,A,M,4C,E,E,C,kD,E,M,C,E,C,oB,I,E,E,c,C,E,iB,G,I,C,U,G,C,I,C,Q,C,G,C,E,Q,E,G,E,E,I,C,Q,C,Y,C,G,I,E,I,C,Q,C,c,C,E,E,W,E,E,G,E,M,C,E,G,E,M,C,E,G,E,K,C,G,I,C,E,C,K,I,C,G,C,E,I,C,M,C,E,I,C,K,C,E,I,C,M,C,E,I,C,Q,C,E,I,C,Y,C,I,C,W,C,I,C,O,C,E,C,I,C,S,C,E,C,I,C,O,C,K,E,I,C,K,C,E,C,I,C,uB,C,K,E,I,C,S,C,K,E,I,C,O,C,E,C,I,C,U,C,K,E,I,C,U,C,C,E,I,C,oB,C,K,E,I,C,e,C,E,C,I,C,M,C,C,E,I,C,Q,C,I,G,I,C,Q,C,C,E,I,C,c,C,C,E,I,C,Q,C,C,E,I,C,mB,C,K,E,I,C,Q,C,K,E,I,C,S,EAAA,E,A,G,I,C,M,C,GAAA,E,E,W,E,EAAA,SAAA,GAAA,CAAA,EAAA,OAAA,EAAA,CAAA,aAAA,GAAA,EAAA,WAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,CAAA,IAAA,CAAA,GAAA,CAAA,G,I,C,Y,C,E,C,E,C,I,C,E,C,C,I,C,C,G,C,E,C,Q,K,C,qE,M,C,G,M,C,I,C,W,I,G,M,C,I,C,W,I,I,C,W,G,I,C,Q,E,I,C,M,E,C,I,a,C,G,C,Q,C,Y,C,C,oB,C,C,C,M,C,C,O,C,C,a,C,C,C,I,C,O,G,G,G,E,E,E,E,E,K,C,C,I,M,C,O,I,C,M,C,I,A,C,I,K,C,C,C,I,C,M,C,I,C,C,C,I,S,C,O,I,C,Q,A,C,I,Q,C,C,C,I,C,M,C,O,C,C,C,a,C,O,I,C,a,C,c,I,C,O,C,U,C,I,C,M,G,G,I,C,I,C,O,C,gB,E,I,C,U,G,I,C,a,C,a,I,A,C,O,C,O,G,I,C,M,C,I,C,G,E,I,A,C,M,C,O,G,I,C,I,E,I,A,C,O,C,C,C,C,C,G,O,C,I,E,I,C,iB,C,C,M,E,O,C,E,I,C,O,C,E,E,C,Q,C,C,C,C,C,I,E,I,C,O,C,E,I,C,M,C,E,E,mB,E,I,C,W,C,E,I,C,Q,C,c,C,E,E,E,G,E,E,gB,E,I,C,Q,C,mB,G,E,I,C,K,C,S,Q,C,I,C,K,C,E,K,C,I,C,M,C,E,M,C,I,C,Y,C,I,C,W,C,G,I,C,E,C,I,C,I,C,a,C,S,C,K,C,G,G,E,Q,C,C,I,C,E,C,I,E,I,C,Q,E,I,C,S,C,I,I,C,M,E,C,C,qB,C,I,E,I,C,O,C,M,E,C,E,G,E,C,E,K,E,E,C,C,E,C,qB,C,I,E,I,C,O,C,E,E,M,C,E,I,C,M,C,E,O,I,C,G,M,C,C,E,I,C,C,C,E,C,C,E,C,E,C,G,E,E,A,C,G,C,E,E,M,C,O,I,C,G,G,C,A,I,I,E,C,C,E,C,E,G,E,G,E,A,M,E,E,A,M,E,M,C,Q,E,U,E,Y,E,S,O,M,E,e,E,W,Q,C,G,E,G,E,A,I,I,E,E,O,C,E,E,E,C,E,G,E,G,E,G,E,I,C,E,K,C,C,C,A,K,I,E,Q,E,G,E,Q,C,K,G,E,S,C,G,C,E,Q,C,E,S,A,E,C,C,E,C,C,E,I,E,K,G,K,G,C,C,E,C,I,G,E,E,C,C,E,K,C,I,E,G,Q,C,E,C,C,C,A,C,E,I,E,C,G,E,K,E,I,I,C,G,C,M,I,A,E,E,E,C,C,C,C,E,I,C,E,E,G,G,E,C,E,K,G,O,C,C,E,A,G,G,E,A,I,G,S,C,I,C,E,E,O,E,G,M,C,I,C,E,E,C,iB,C,I,E,I,C,S,C,E,I,C,I,C,Q,C,M,C,E,E,M,C,G,E,I,C,C,E,I,E,K,C,E,K,E,E,E,C,I,I,E,E,E,E,E,E,I,C,mB,C,G,E,M,C,E,E,E,C,I,C,e,C,E,K,C,G,I,C,G,Q,S,C,6B,C,G,C,U,C,C,K,C,S,C,C,C,C,I,A,C,E,M,C,E,M,E,O,I,C,O,C,E,O,C,C,E,K,A,I,E,M,C,A,G,I,E,Q,E,M,E,I,C,mB,C,E,E,C,0B,K,E,E,I,E,E,C,E,I,C,I,C,Q,C,I,I,C,2B,G,E,E,E,E,M,C,E,E,I,C,I,E,C,C,E,C,E,I,C,c,C,G,E,E,I,E,I,C,M,C,I,C,G,E,I,E,E,I,G,G,C,I,C,mB,C,G,E,I,C,c,C,E,E,E,I,C,E,E,S,C,E,S,E,G,E,I,C,O,E,E,K,C,E,K,E,E,E,K,C,E,E,K,C,G,E,K,C,E,O,C,I,C,gB,C,G,E,U,C,E,U,C,W,C,G,E,U,C,U,O,C,I,E,G,a,C,G,C,mB,C,C,gB,C,C,C,G,Q,C,E,A,C,O,M,C,E,S,C,C,gB,G,U,C,G,mB,G,G,U,C,E,G,E,U,C,I,E,I,C,G,E,I,C,E,U,C,C,C,O,I,C,e,G,C,C,gB,C,G,I,C,I,C,Q,C,C,E,K,I,C,c,C,G,U,C,K,E,E,I,C,C,O,C,I,C,c,G,I,C,a,C,Q,C,O,C,C,C,I,E,I,C,M,C,E,M,G,I,E,I,C,Q,C,E,c,C,E,iB,G,I,C,U,I,E,I,C,mB,C,C,E,S,C,G,I,C,a,G,I,C,mB,G,I,C,oB,G,I,C,Q,C,U,G,A,C,I,I,C,a,C,e,C,K,E,W,C,C,G,O,I,E,I,C,wB,G,I,C,a,C,wB,I,E,E,I,I,E,E,E,I,C,I,C,Q,C,M,C,E,E,I,C,G,C,W,C,C,C,I,C,c,C,G,E,C,G,A,K,E,O,C,E,C,E,qB,C,G,E,K,G,C,C,E,c,G,E,C,E,I,C,W,C,E,M,C,W,C,E,E,I,C,a,C,G,G,G,E,A,I,E,K,E,G,I,C,e,C,G,I,C,a,C,c,C,K,C,G,I,C,O,C,I,C,G,I,S,G,C,Q,C,C,W,C,C,C,I,A,C,E,I,C,a,C,E,C,G,E,M,E,I,C,kB,C,E,E,C,G,I,C,M,E,C,e,C,G,I,C,M,C,A,I,G,S,C,I,C,E,G,I,C,mB,G,I,C,mB,E,C,qB,C,I,E,I,C,O,C,E,I,I,O,I,C,I,C,U,G,E,I,I,E,M,C,C,G,E,I,C,C,I,C,oB,G,E,U,E,C,I,C,Y,G,I,C,U,E,C,C,sB,C,G,C,e,C,C,C,I,C,E,I,C,sB,I,E,C,I,G,C,O,C,C,M,C,C,M,C,C,G,E,C,I,E,A,oB,E,C,E,G,A,S,C,C,C,C,C,E,I,E,O,I,C,G,I,I,K,E,C,I,E,C,E,G,G,E,C,I,E,C,C,E,A,Q,C,C,E,C,A,C,E,G,E,C,G,C,C,C,E,E,C,C,C,C,C,E,E,E,E,C,C,wB,C,I,E,I,C,Y,C,G,C,G,C,E,M,C,M,C,I,C,Y,C,E,C,I,E,I,C,I,C,Q,C,M,C,E,A,G,I,I,E,M,C,A,G,C,C,E,G,G,G,C,C,E,I,E,I,E,M,C,G,I,C,O,E,E,G,I,I,E,E,E,E,I,G,C,G,E,E,I,O,O,M,I,C,G,G,C,A,G,E,K,C,M,G,C,A,G,C,C,O,C,C,E,C,M,C,C,C,E,C,M,C,C,C,E,A,C,E,C,c,C,C,C,G,A,C,I,I,C,a,C,e,C,W,C,C,G,O,G,M,C,I,C,I,C,K,C,I,C,M,C,G,I,E,I,C,S,C,E,E,K,E,G,E,M,E,C,C,I,C,O,C,E,C,G,I,C,K,C,A,I,G,A,c,E,Q,E,C,E,S,E,E,S,G,I,C,O,C,I,I,E,O,G,C,E,I,E,I,C,O,C,O,C,C,E,K,E,I,C,C,G,I,C,a,C,c,C,gB,C,C,C,G,A,C,I,I,C,a,C,uB,C,K,E,W,C,C,G,C,I,I,E,E,E,I,C,I,C,Q,C,M,C,E,E,E,E,I,C,c,C,G,U,C,S,G,I,I,E,E,E,I,C,I,C,Q,C,M,C,E,E,E,E,I,C,c,C,E,G,G,E,C,a,C,G,G,I,C,a,C,sB,C,K,C,E,C,C,e,C,C,C,C,C,I,E,I,C,c,C,G,E,C,K,E,M,E,K,E,W,C,C,C,A,E,I,I,C,a,C,sB,I,C,E,U,C,O,C,G,E,U,C,C,E,I,C,a,C,qB,E,C,C,Q,C,A,C,I,I,C,a,C,e,C,W,C,C,I,C,G,G,C,I,E,I,C,Q,E,C,G,O,C,I,G,G,K,C,I,E,C,I,C,I,G,G,C,M,I,A,E,C,C,C,M,K,E,G,I,C,iB,C,C,G,C,M,C,C,O,C,C,C,I,C,iB,A,C,I,C,O,C,E,G,I,C,iB,C,I,C,G,I,C,K,G,I,C,K,E,G,I,C,M,E,G,A,C,I,I,C,a,C,a,C,W,C,C,G,O,I,E,I,C,O,C,I,E,E,E,E,M,E,C,C,E,C,C,E,E,E,E,C,C,E,C,I,C,I,C,S,E,I,I,C,a,G,E,E,M,C,E,E,C,C,E,C,I,C,I,C,S,E,I,C,a,C,Y,C,uB,C,C,K,E,E,I,E,I,C,e,C,E,E,C,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,A,C,C,C,G,E,O,A,G,E,I,C,E,C,O,C,C,8B,C,O,I,C,sB,C,C,E,C,e,C,G,A,C,I,I,C,a,C,qB,C,W,C,C,G,O,I,E,I,C,4B,G,I,I,E,E,M,C,E,G,E,E,E,I,C,Y,C,C,C,E,E,I,C,a,C,oB,C,a,C,C,C,I,E,I,C,G,C,E,E,K,C,E,C,E,Q,C,E,I,C,S,C,E,C,K,E,M,E,K,C,W,C,C,C,A,E,I,I,C,a,C,oB,I,C,G,G,E,C,K,A,C,I,E,I,C,E,E,I,C,E,I,C,M,A,C,I,E,K,C,I,C,K,C,E,K,C,E,K,C,I,A,C,I,E,G,C,E,E,G,C,E,G,C,O,A,C,I,E,M,C,I,C,M,C,E,M,C,E,M,A,G,E,U,C,I,G,G,G,G,E,U,C,C,E,I,C,a,C,mB,E,C,C,c,C,C,C,O,G,E,I,C,S,C,I,C,W,C,C,0B,C,C,C,C,C,C,C,C,C,I,E,G,K,C,E,C,M,A,Y,O,E,E,I,C,E,E,G,E,A,C,e,C,C,C,I,E,I,C,I,C,Q,C,E,C,E,I,C,S,C,E,E,M,C,A,G,G,E,Q,G,G,G,G,O,G,C,E,C,K,K,K,E,C,Q,K,W,K,O,K,Q,K,Q,K,M,G,E,K,E,E,M,E,S,E,Q,E,C,Q,C,C,E,E,I,C,E,E,C,C,Y,C,O,I,C,Q,E,C,I,C,Q,C,G,K,C,M,I,C,K,O,E,C,C,wB,C,O,I,C,4B,G,M,A,C,iB,C,C,C,I,E,I,C,I,C,Q,C,E,C,G,C,E,M,C,E,I,E,I,C,c,C,G,M,A,W,O,E,M,C,C,E,M,C,C,E,M,A,C,qB,C,C,C,C,C,I,E,I,C,c,C,E,C,E,M,C,C,C,C,qB,C,C,C,I,C,c,C,E,C,C,I,C,c,C,E,A,C,kB,C,C,C,M,C,I,C,c,C,E,A,C,kB,C,C,C,C,C,C,C,I,E,E,O,O,E,I,C,c,C,G,E,E,U,C,kB,C,K,E,E,C,G,G,C,E,I,C,E,C,M,C,C,E,I,C,M,E,E,C,I,C,oB,C,E,G,E,M,C,E,C,Q,C,G,I,C,M,C,A,G,E,Y,G,E,E,K,E,C,C,K,C,C,C,C,C,I,C,iB,C,E,E,C,E,C,K,C,C,C,C,C,I,C,iB,C,E,E,C,E,C,oB,C,C,C,I,E,I,C,S,C,E,A,C,G,E,U,E,E,U,C,Q,G,O,I,C,S,C,E,A,C,O,C,I,E,E,I,I,C,I,G,G,M,C,I,E,E,E,E,I,C,I,C,Q,C,M,C,E,E,E,E,I,C,mB,C,E,C,S,C,I,C,a,C,iB,G,C,O,C,C,I,C,C,C,I,A,C,I,C,K,G,I,C,M,C,U,G,G,C,I,C,Y,G,G,E,G,I,C,Q,C,c,C,G,I,C,M,C,K,I,C,G,C,I,E,I,C,a,C,W,O,E,C,I,C,E,C,C,I,C,a,C,e,C,c,G,C,C,C,O,I,C,M,C,S,I,E,C,Y,C,I,C,c,G,I,C,O,C,U,C,I,C,oB,G,I,C,Q,C,C,C,C,gB,C,I,E,I,C,U,C,E,I,C,Q,C,E,C,E,K,E,gB,C,I,C,E,G,C,C,E,C,C,E,E,C,E,E,K,E,O,C,E,E,O,C,E,I,C,a,C,E,E,G,I,C,O,C,M,C,A,G,E,E,G,C,sB,K,C,C,I,C,oB,E,C,I,C,oB,C,C,C,E,I,E,I,C,oB,C,E,I,C,Q,C,E,C,E,K,E,gB,C,I,C,E,G,C,C,E,C,C,E,E,C,E,K,C,C,E,E,C,E,mB,C,I,C,E,G,O,C,C,E,A,C,E,E,C,E,K,I,C,M,E,I,C,M,C,E,E,E,E,K,E,S,G,I,C,Q,C,C,E,I,C,M,G,E,S,G,E,S,E,C,C,E,K,I,C,Q,C,C,E,E,S,G,I,C,K,G,I,C,O,C,E,G,E,S,E,E,E,U,C,I,C,M,E,I,G,C,c,C,G,I,C,U,C,C,E,K,I,C,Q,C,mB,C,I,C,E,E,G,I,C,U,C,C,E,G,I,C,oB,C,C,E,K,I,C,Q,C,mB,C,I,C,E,E,G,I,C,oB,C,K,C,C,iB,C,C,C,C,C,C,K,E,E,E,I,E,E,M,S,I,A,Y,G,A,I,C,c,C,C,C,E,C,Y,E,U,C,I,E,oB,G,E,E,E,E,M,C,E,E,E,E,C,E,C,C,E,C,I,E,G,I,C,c,C,E,Y,E,U,A,C,G,C,C,E,a,C,E,O,C,E,Y,C,E,K,C,C,C,mB,C,O,I,C,O,E,E,A,C,kB,C,C,C,I,E,I,C,O,E,E,C,E,E,G,C,C,C,a,C,C,M,C,C,I,I,E,I,C,c,C,G,G,C,E,M,A,M,6B,G,M,C,a,E,Q,E,I,C,E,C,M,C,C,E,C,G,E,I,C,I,C,O,C,E,I,C,U,C,K,I,C,kB,C,E,E,C,C,c,C,C,C,C,C,C,C,O,I,C,Q,C,M,C,I,C,E,E,E,C,mB,C,C,C,C,C,C,C,I,E,I,C,O,C,K,C,E,C,E,I,E,M,C,A,G,C,E,I,C,A,G,E,Y,G,E,Y,E,E,K,G,E,K,G,E,E,E,G,E,E,E,E,E,E,C,E,M,E,I,C,gB,C,E,E,I,C,C,G,E,M,E,E,I,E,I,C,gB,C,E,E,I,C,C,E,C,c,C,C,C,C,C,I,E,C,M,E,O,E,W,C,E,Y,I,C,a,C,E,E,E,A,G,A,C,E,O,C,M,E,I,C,O,C,M,A,E,Q,C,E,M,C,I,E,G,A,C,I,I,C,a,C,c,E,G,O,I,E,I,C,Y,C,E,E,E,W,E,O,E,U,C,C,E,I,C,a,C,a,E,G,A,C,G,E,O,A,G,I,C,M,G,I,A,C,a,C,C,C,C,C,C,K,E,G,C,Q,E,E,C,Q,C,C,C,I,C,E,I,C,kB,C,E,E,E,G,EAAA,AAAA,YAAA,A,EAAA,IAAA,EAAA,AAAA,UAAA,A,EAAA,IAAA,EAAA,AAAA,gBAAA,A,EAAA,IAAA,C,G,E,I,C,U,C,A,G,A,a,A,E,I,C,A,E,E,E,K,C,G,C,I,C,U,C,K,G,E,O,C,C,E,E,I,C,C,I,E,G,G,E,O,C,C,E,E,I,C,C,I,C,E,I,E,C,G,E,G,M,A,C,G,C,G,C,I,C,O,C,E,I,C,kB,C,E,E,E,E,I,C,U,C,E,C,C,mB,C,C,C,C,C,C,C,C,C,G,A,a,E,I,C,M,E,C,G,C,E,O,E,I,E,I,C,O,C,K,C,O,I,C,yB,C,E,E,I,C,E,E,C,C,I,G,I,G,G,S,C,A,G,E,Q,C,U,I,S,G,C,C,C,C,C,E,G,C,W,C,C,Y,C,C,E,C,C,E,C,C,Y,C,C,Y,C,C,C,E,E,E,C,C,E,S,G,E,G,C,E,E,E,E,E,E,G,E,E,C,E,E,E,E,G,C,E,E,E,E,E,E,E,C,E,E,E,G,C,E,E,E,E,G,E,I,E,S,G,E,I,E,C,S,G,C,C,C,C,C,C,C,E,M,C,E,E,E,K,G,C,G,E,E,E,K,G,C,E,C,C,S,G,C,C,C,C,C,C,C,C,C,C,C,E,G,C,E,C,C,E,C,C,W,C,C,Y,C,C,Y,C,C,C,E,E,K,G,C,E,W,C,E,E,E,G,E,E,E,E,E,E,E,E,E,E,E,E,E,G,E,C,I,E,E,E,E,E,E,E,A,C,A,C,E,E,E,E,C,E,C,E,E,E,A,C,E,C,A,I,E,E,E,C,E,C,E,C,C,E,C,C,I,E,K,G,C,K,E,E,E,I,E,E,A,C,E,C,E,E,E,E,E,E,E,E,E,E,C,W,C,C,S,C,C,W,C,C,S,C,C,C,A,S,C,C,C,C,C,C,C,E,I,E,G,E,O,C,Y,C,C,a,W,a,W,E,E,A,C,E,C,E,E,E,K,G,C,E,E,E,G,E,A,I,I,E,A,C,E,K,G,C,E,E,E,E,E,O,G,E,E,K,G,C,E,G,E,M,C,W,E,E,U,E,S,E,E,Q,E,W,G,E,U,C,E,G,S,G,E,Q,C,E,E,C,E,E,E,E,E,G,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,G,E,S,G,E,C,G,E,G,C,E,E,E,E,G,E,E,C,I,E,G,E,E,E,G,E,G,C,E,C,C,E,C,C,E,E,E,G,C,I,E,G,E,E,E,G,G,E,M,C,E,C,C,E,C,E,E,E,C,I,E,G,E,E,E,G,E,G,C,E,C,C,E,C,C,E,E,G,E,K,E,C,C,G,E,G,C,E,E,E,E,E,E,E,E,E,C,G,E,E,C,I,E,G,E,E,E,G,E,G,C,E,C,C,E,C,C,E,E,K,E,C,E,G,C,I,E,G,E,E,E,G,G,E,M,C,E,C,C,E,C,E,E,E,C,I,E,G,E,E,E,G,E,G,C,E,C,C,E,C,C,E,E,G,E,C,K,C,E,M,C,E,G,I,E,K,G,C,G,E,E,E,K,G,C,G,E,E,E,M,C,E,G,I,E,K,G,C,G,E,E,E,K,G,C,G,E,E,E,M,C,E,E,C,E,S,E,C,O,gB,C,G,C,S,C,W,C,E,M,E,E,U,C,W,C,E,M,E,E,U,C,W,C,E,M,E,E,S,C,W,C,E,M,E,E,Q,C,W,C,E,M,O,E,S,C,W,C,E,M,E,E,S,C,W,C,E,M,C,G,K,G,G,I,G,I,C,E,W,C,W,C,E,M,C,G,K,G,M,I,G,I,C,C,E,O,W,G,Y,C,C,C,K,G,I,C,O,C,K,E,I,C,a,C,K,E,I,C,U,C,K,E,I,C,Q,C,K,E,I,C,W,C,K,E,I,C,W,C,K,E,I,C,W,C,E,I,C,W,C,E,G,O,M,C,I,C,E,C,Q,C,C,C,C,C,C,C,I,E,I,C,Q,C,C,I,I,C,G,C,M,C,C,S,C,C,C,G,E,C,E,E,E,C,G,C,W,C,C,S,C,C,Y,C,C,Y,C,C,c,C,C,C,I,C,Q,C,C,a,W,c,c,gB,C,G,E,I,C,O,C,O,C,E,E,G,E,E,I,I,G,E,E,G,E,G,E,E,E,E,G,O,G,C,C,e,C,C,C,G,C,E,C,C,E,C,C,W,C,C,S,C,C,Y,C,C,Y,C,C,C,I,C,Q,C,C,I,I,a,W,c,c,gB,C,G,C,O,C,C,Q,C,C,C,I,C,O,C,E,A,C,E,C,E,E,E,A,C,E,E,E,C,E,E,M,C,E,E,K,G,C,G,E,E,E,K,G,C,G,C,C,C,gB,C,C,C,O,I,C,c,C,E,C,K,C,C,C,G,C,Q,C,C,c,C,C,C,I,C,E,A,C,E,M,E,C,E,E,E,A,C,E,O,E,C,E,E,E,E,Q,C,G,I,C,W,C,A,U,E,W,C,I,E,I,C,W,C,E,G,K,K,C,E,I,E,A,I,G,I,C,W,C,G,I,C,W,C,E,O,E,I,G,I,E,E,G,E,C,E,E,E,I,E,A,C,I,C,U,C,I,C,Q,A,E,C,C,E,S,C,K,G,C,G,E,K,G,C,G,G,I,C,a,E,I,C,E,C,C,C,E,S,C,E,e,C,E,W,C,E,W,C,I,E,A,S,C,C,C,C,C,C,C,C,C,E,G,C,Y,C,C,W,C,C,c,C,C,C,E,E,E,Q,C,G,E,C,G,E,E,E,E,E,G,G,I,I,E,E,E,E,E,E,E,I,E,C,M,I,C,E,E,E,G,E,I,G,C,G,E,C,C,C,O,G,E,E,E,E,E,G,E,I,G,C,E,E,I,C,E,E,E,C,A,C,S,C,C,C,C,C,C,C,C,C,C,C,E,G,C,Q,C,C,C,E,C,Y,C,C,gB,C,C,C,E,E,A,U,E,W,A,C,G,C,E,C,E,S,C,A,E,E,E,Q,C,G,O,E,C,E,S,C,E,E,Q,C,G,O,E,E,W,E,A,S,C,C,C,C,C,M,E,G,C,E,C,C,E,C,C,W,C,C,Y,C,C,Y,C,C,C,E,E,K,G,C,E,W,C,E,G,E,E,W,C,E,I,G,G,E,E,E,I,E,S,G,E,G,C,E,E,E,E,G,E,C,G,E,E,E,E,E,E,E,M,G,I,E,S,G,E,G,C,E,E,E,E,E,I,E,E,E,E,E,E,E,M,E,E,E,E,G,G,G,E,E,G,G,E,E,E,E,E,G,E,M,E,C,C,E,E,I,C,E,E,E,G,E,O,E,C,C,S,G,C,C,C,C,E,C,E,E,O,C,G,E,c,C,E,c,E,E,W,C,G,E,U,C,E,U,G,E,c,C,G,E,gB,C,E,gB,E,E,Q,C,G,E,e,C,E,e,E,E,S,C,G,E,W,C,E,W,E,E,W,C,G,E,W,C,E,W,C,C,S,G,C,C,C,C,C,E,E,M,C,E,C,C,E,C,C,C,S,G,C,C,C,C,E,C,C,E,I,E,E,M,C,C,M,E,C,C,I,E,E,C,C,C,E,C,M,C,C,I,C,C,C,E,E,K,G,C,E,G,E,K,G,C,E,G,M,C,M,E,M,E,K,E,I,C,K,E,G,C,C,E,G,E,G,E,G,E,C,E,E,E,E,E,C,C,C,S,G,C,C,C,C,C,C,C,E,G,C,O,C,C,Q,C,C,C,E,C,M,C,C,M,C,C,K,C,C,K,C,C,C,G,E,E,G,E,A,E,O,C,G,A,E,O,E,A,a,A,E,sB,C,G,G,C,K,E,C,C,C,Q,C,C,C,G,C,E,E,E,E,I,E,E,G,E,E,E,A,A,C,E,C,C,A,C,E,C,E,E,E,C,C,E,E,A,E,I,E,C,E,C,E,M,C,E,C,C,E,C,E,E,C,C,E,E,E,E,E,E,E,O,E,E,C,E,O,G,E,E,E,E,C,C,A,C,E,C,E,E,C,C,E,E,C,E,E,O,E,C,C,C,C,S,G,C,C,C,C,C,C,C,E,I,E,E,M,C,C,M,C,C,M,C,C,K,C,C,C,G,E,E,G,C,K,E,C,C,C,Q,C,C,C,G,C,E,E,E,E,E,E,E,E,E,E,E,E,A,G,A,C,E,C,E,E,E,C,C,E,E,E,K,I,G,C,E,M,C,E,G,E,M,C,E,G,E,M,C,E,E,C,E,I,G,C,E,C,C,E,G,C,E,M,C,E,C,C,E,C,C,E,E,E,G,E,E,E,C,G,A,C,E,C,C,E,G,A,E,I,C,S,I,E,E,C,C,E,E,C,C,E,A,E,C,C,I,E,C,E,E,E,E,E,G,C,E,C,E,E,A,C,E,E,C,E,E,C,E,C,I,E,M,C,E,G,E,E,E,E,E,E,C,E,E,C,C,G,C,S,G,C,E,I,E,E,O,C,E,E,U,E,E,U,C,M,C,O,A,E,U,E,E,K,E,E,O,E,A,a,E,sB,E,E,O,E,E,G,E,C,G,E,C,M,G,Q,C,C,Y,S,Y,O,gB,K,E,a,E,Y,E,O,E,Q,E,M,K,E,S,C,C,E,G,a,C,C,gB,iB,E,I,G,A,Y,O,M,O,W,G,Y,C,C,C,K,G,I,C,Q,C,C,E,I,C,O,C,K,E,I,C,M,C,K,E,I,C,K,C,K,E,I,C,S,C,K,E,I,C,K,C,K,E,I,C,O,C,K,E,I,C,S,C,K,E,I,C,U,C,C,E,I,C,c,C,C,E,I,C,a,C,K,E,G,O,M,C,I,C,E,C,oB,C,C,C,C,C,I,E,I,C,O,C,G,A,C,E,O,E,A,a,E,sB,A,G,C,E,O,E,C,I,C,c,C,C,I,E,E,Q,C,I,C,K,C,I,C,S,A,C,ACrvQxE,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,QAAA,EAAA,CAAA,EAAA,EAAA,MAAA,CAAA,AAAA,GAAA,CAAA,EAAA,IAAA,CAAA,EAAA,AAAA,aAAA,EAAA,sBAAA,EAAA,AAAA,SAAA,CAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,CAAA,EAAA,MAAA,GAAA,IAAA,CAAA,GAAA,EAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,CAAA,GAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,CAAA,AAAA,IAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,AAAA,EAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA,GAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAA,CAAA,CAAA,EAAA,EAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,AAAA,EAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,AAAA,CAAA,AAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,GAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,EAAA,QAAA,CAAA,AAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,KAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,GAAA,GAAA,CAAA,EAAA,EAAA,KAAA,IAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,EAAA,EAAA,GAAA,AAAA,SAAA,CAAA,CAAA,CAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,CAAA,EAAA,SAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,AAAA,CAAA,GAAA,CAAA,EAAA,AAAA,CAAA,EAAA,CAAA,CAAA,EAAA,AAAA,EAAA,EAAA,CAAA,CAAA,CAAA,GAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,GAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,AAAA,EAAA,GAAA,CAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,GAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,GAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,AAAA,CAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,CAAA,IAAA,EAAA,EAAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,AAAA,EAAA,AAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,CAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,MAAA,GAAA,EAAA,EAAA,EAAA,MAAA,GAAA,EAAA,EAA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AAA,CAAA,EAAA,IAAA,EAAA,CAAA,EAAA,CAAA,EAAA,EAAA,IAAA,CAAA,CAAA,MAAA,EAAA,EAAA,IAAA,AAAA,CAAA,EAAA,CAAA,EAAA,EAAA,KAAA,CAAA,GAAA,EAAA,EAAA,EAAA,IAAA,CAAA,EAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,IAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,OAAA,AAAA,OAAA,GAAA,EAAA,IAAA,CAAA,CAAA,MAAA,EAAA,EAAA,IAAA,EAAA,EAAA,KAAA,CAAA,GAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,E,I,C,I,C,O,C,O,C,C,C,O,C,I,E,I,C,Q,C,E,I,C,M,C,O,E,M,E,C,C,C,C,E,C,K,C,A,C,M,C,I,E,I,C,Q,C,E,I,C,M,C,E,E,M,C,O,G,C,C,C,C,E,E,C,G,C,A,C,Y,C,C,C,C,K,E,E,I,E,I,C,O,C,E,C,C,E,C,E,I,C,M,C,E,G,I,C,C,S,E,M,E,I,C,G,G,C,E,M,C,O,I,E,E,C,E,A,E,O,C,G,A,E,O,E,A,a,A,E,sB,C,G,G,I,E,E,E,E,M,C,E,E,E,E,C,G,C,M,C,C,I,C,C,C,C,C,E,C,E,C,C,E,C,E,C,C,E,C,G,I,E,C,E,I,C,G,Q,C,I,E,K,G,C,A,C,E,C,C,E,A,E,C,C,C,E,C,C,C,E,A,G,E,E,E,E,E,E,O,C,C,C,C,E,C,C,C,E,C,E,I,C,E,C,O,A,I,E,M,C,C,C,E,C,C,C,Y,C,C,C,C,C,C,C,O,G,I,E,E,I,C,E,E,C,K,C,C,C,C,C,C,C,I,E,I,C,Q,C,E,G,I,E,E,I,C,K,C,I,I,K,E,G,E,E,G,I,C,M,C,M,C,E,G,G,E,E,I,C,E,C,M,E,I,E,E,C,G,M,C,C,C,C,K,C,C,C,C,C,C,C,C,K,E,I,E,I,C,O,E,C,C,C,C,I,C,M,E,E,A,E,M,E,E,W,E,C,E,I,G,I,C,A,I,C,O,C,O,E,C,E,A,I,C,K,G,C,E,A,I,C,K,C,I,O,A,I,C,I,C,E,E,I,E,S,E,E,G,E,A,I,C,O,E,A,E,M,C,I,A,S,C,C,C,C,C,C,C,E,G,C,S,C,C,Q,C,C,C,E,E,G,G,I,I,K,E,G,E,E,E,K,E,E,S,G,E,E,E,E,C,M,E,I,E,E,C,I,E,S,G,E,M,E,E,E,I,C,E,G,E,O,E,E,I,C,Q,E,C,I,C,c,C,C,E,I,C,K,C,K,C,C,C,C,S,G,C,C,C,C,C,C,C,E,I,E,E,O,C,C,C,E,C,C,C,C,E,Q,C,C,E,C,G,O,K,G,C,E,G,E,M,C,E,S,A,C,G,E,C,O,G,Q,C,C,e,O,W,E,C,iB,E,gB,Q,Y,E,gB,C,E,uB,U,K,C,E,S,C,E,Q,C,E,Q,C,E,G,a,C,C,gB,kB,Y,a,E,G,W,C,C,Y,C,E,W,A,G,A,e,G,A,S,C,C,O,W,G,Y,C,C,C,K,G,I,C,O,C,K,E,I,C,M,C,K,E,I,C,I,C,K,E,I,C,I,C,K,E,G,O,M,C,I,C,E,C,Q,C,C,C,C,C,C,C,I,E,I,C,O,C,C,E,C,C,E,C,C,C,I,C,Q,C,C,I,I,C,G,O,K,G,C,E,E,G,K,G,C,E,E,G,K,G,C,E,S,C,E,M,C,E,C,S,C,C,C,C,C,O,G,I,C,E,I,E,C,S,C,C,C,C,C,O,G,I,C,E,I,E,C,e,C,C,C,G,C,E,C,C,E,C,C,C,I,C,Q,C,C,I,I,C,G,M,C,E,E,E,C,C,C,K,C,C,C,I,E,A,C,E,G,I,C,O,E,C,C,E,M,E,E,E,K,G,C,E,G,E,W,E,G,I,E,G,E,W,E,E,M,A,C,E,C,E,C,C,K,C,C,C,C,C,I,E,I,C,O,A,C,I,C,I,E,E,M,C,I,C,G,I,C,E,I,C,I,C,G,I,C,E,W,C,E,W,C,E,S,C,E,W,C,E,S,C,E,e,C,G,E,E,I,C,C,C,I,C,C,C,C,C,U,C,I,E,I,C,O,E,C,E,O,E,M,C,E,S,A,C,C,S,G,C,C,C,M,E,E,E,E,E,G,C,E,C,C,E,C,C,K,C,C,M,C,C,O,C,C,C,E,Q,C,C,I,I,O,Q,S,C,G,O,E,U,C,C,E,E,E,E,K,G,C,E,G,E,K,G,C,E,G,E,E,E,E,E,C,E,C,A,E,E,C,E,E,C,E,E,E,E,E,K,G,C,E,G,E,K,G,C,E,E,E,C,K,E,I,E,M,E,O,C,C,C,S,G,C,C,C,C,C,C,C,E,O,E,E,G,E,E,E,C,S,G,C,C,C,C,C,C,C,E,I,E,A,O,E,E,A,O,E,E,G,C,C,G,C,G,G,E,G,O,G,C,G,G,E,E,I,C,E,K,C,G,C,G,G,E,E,G,C,E,M,C,C,C,S,G,C,C,C,E,E,I,C,E,C,C,E,C,C,E,C,C,E,C,C,C,S,G,C,C,C,C,E,C,C,E,I,E,E,C,G,E,C,C,C,E,E,E,E,C,G,E,C,C,C,E,E,E,A,C,E,C,C,E,C,G,E,C,C,E,C,C,E,C,E,E,E,A,C,E,C,C,E,C,G,E,C,C,E,C,C,E,C,E,E,M,C,E,E,C,C,E,E,E,C,C,E,E,E,C,C,E,E,E,C,C,E,O,E,M,A,C,C,G,E,C,Q,G,Q,C,C,Y,E,U,E,iB,E,Y,E,W,S,O,E,S,C,E,G,a,C,C,gB,kB,Y,a,C,O,W,G,Y,C,C,C,K,G,I,C,O,C,K,E,I,C,U,C,K,E,I,C,I,C,K,E,I,C,K,C,K,E,I,C,M,C,K,E,I,C,a,C,K,E,G,O,M,C,I,C,E,C,K,C,C,K,E,G,C,c,C,C,Q,C,Y,C,C,gB,C,C,C,C,I,C,C,M,C,C,M,C,C,C,A,S,C,E,I,E,G,G,E,E,K,C,E,I,C,E,E,M,C,E,G,C,E,A,S,C,C,C,C,C,E,I,E,E,O,C,W,C,E,E,a,C,E,G,G,M,C,E,G,E,G,C,E,G,C,E,G,E,G,E,K,C,E,K,C,E,G,E,G,E,M,C,E,M,C,E,G,E,G,E,I,C,E,I,C,E,E,C,E,E,E,E,E,G,E,A,S,C,C,C,C,C,E,G,C,mB,C,C,C,E,Q,C,C,qB,E,E,E,O,C,Y,C,E,G,G,E,K,G,C,E,G,E,E,a,C,E,G,G,G,M,C,Q,G,C,G,E,G,E,E,I,C,E,O,C,E,G,S,G,C,G,E,G,E,E,K,C,E,Q,C,E,G,W,G,C,G,E,M,E,E,I,C,E,U,C,E,G,Y,G,C,G,E,M,E,E,K,C,E,W,C,E,E,C,E,E,E,E,E,G,M,C,M,C,E,E,I,C,E,E,G,C,E,E,E,E,O,C,E,M,C,E,E,I,C,E,C,C,E,E,G,C,E,C,C,E,E,E,C,C,E,C,C,E,E,E,C,C,E,C,C,O,C,Q,K,G,C,E,E,O,C,K,G,C,E,C,C,E,C,G,S,K,G,C,E,E,Q,C,K,G,C,E,C,C,E,C,G,W,K,G,C,E,E,U,C,K,G,C,E,C,C,E,C,G,Y,K,G,C,E,E,W,C,K,G,C,E,C,C,E,C,E,C,C,C,E,I,E,E,A,C,E,E,M,E,O,E,E,Q,E,E,U,E,E,W,C,G,E,C,E,I,G,A,C,E,C,G,E,C,E,E,C,G,E,C,A,G,C,E,S,G,E,E,G,E,E,I,E,I,G,E,E,G,E,C,E,I,E,S,C,E,E,I,C,U,E,E,S,G,E,E,G,E,I,E,S,C,E,E,I,G,E,O,E,C,Q,C,C,C,C,C,C,C,O,G,I,C,E,E,E,C,S,C,C,C,C,C,O,G,I,C,E,K,E,C,S,C,C,C,C,C,O,G,I,C,K,E,E,C,e,C,C,C,G,C,E,C,C,E,C,C,K,C,C,W,C,C,C,I,C,Q,C,C,I,I,O,a,C,G,M,C,E,E,A,C,E,C,E,E,E,E,E,E,A,C,E,C,E,C,C,C,S,C,C,C,M,A,M,E,I,C,K,C,E,I,C,M,C,C,C,C,G,E,C,M,G,Q,C,C,c,Q,Y,E,a,E,c,O,W,K,C,E,G,a,C,C,gB,kB,Y,a,E,I,G,O,M,C,C,U,K,W,G,Y,G,a,G,W,E,G,S,G,C,E,G,E,U,C,C,I,E,E,K,A,Q,E,U,C,O,E,K,C,O,c,C,E,O,C,M,C,E,C,C,S,G,C,E,E,I,C,Q,C,O,C,A,I,G,E,E,C,I,G,C,G,a,S,C,U,U,Q,C,C,E,qB,C,E,E,K,G,C,E,O,C,C,G,G,M,C,I,E,E,K,C,E,I,C,Q,C,O,C,C,E,S,E,G,C,M,C,C,U,C,C,C,E,E,E,c,C,G,E,G,E,I,C,G,A,M,G,C,E,E,O,C,S,C,G,C,E,U,C,kB,C,O,I,E,E,M,C,E,O,C,C,G,A,W,E,I,E,A,S,E,I,E,E,O,C,O,C,O,G,C,M,C,C,M,C,C,C,A,S,C,C,C,E,I,E,E,M,C,E,E,E,C,O,C,C,C,E,C,I,C,C,I,C,C,W,C,C,W,C,C,C,E,a,G,O,G,C,E,G,G,E,E,I,C,G,E,C,E,E,E,E,E,E,G,G,E,E,I,C,G,E,C,E,E,G,E,E,E,C,M,E,M,C,C,E,E,G,E,E,S,E,E,E,G,G,E,C,G,G,M,C,O,G,I,C,E,K,C,E,O,E,I,C,O,c,C,E,O,C,a,C,E,W,C,E,I,W,O,I,C,U,A,E,I,S,C,E,I,C,K,C,C,C,E,E,E,S,E,I,O,E,A,S,C,C,C,C,C,C,C,C,C,E,I,E,E,O,E,E,G,G,E,O,E,K,C,E,E,G,I,E,E,C,E,A,C,E,C,E,C,E,C,E,E,E,E,E,E,E,E,E,E,E,E,E,E,I,C,C,I,C,C,C,E,C,E,E,E,E,E,I,C,I,E,E,E,E,E,E,K,K,C,A,C,E,C,E,G,E,E,E,K,G,C,K,K,C,A,C,E,C,E,G,E,G,E,E,E,E,I,E,E,E,E,I,G,C,C,E,C,C,C,G,C,C,E,C,C,A,C,G,E,G,E,I,E,K,K,C,E,G,E,E,E,K,G,C,K,K,C,A,C,E,C,E,G,E,G,E,C,E,C,C,E,C,C,C,C,C,E,C,I,E,E,G,E,E,E,E,I,A,C,E,G,K,G,C,A,C,E,C,E,C,C,C,E,C,C,C,C,E,A,C,E,C,C,E,C,C,A,E,C,E,C,E,E,G,C,E,E,E,C,C,E,C,E,C,C,C,C,C,I,C,E,E,C,C,O,C,C,I,C,C,C,E,C,C,E,E,E,E,E,G,K,K,U,E,A,S,C,C,C,C,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,C,E,C,C,E,C,C,C,E,C,C,E,E,E,C,C,C,E,I,E,E,E,E,E,E,E,C,A,E,A,C,A,C,E,C,C,E,A,E,C,C,C,E,E,E,E,E,C,C,I,E,A,E,E,G,I,E,E,E,C,E,E,E,C,E,E,G,C,E,E,E,C,E,E,A,C,E,E,E,C,A,E,E,M,C,I,E,E,E,G,C,G,I,C,G,G,C,I,E,K,G,C,E,G,E,K,G,C,E,E,C,I,G,I,G,E,I,C,C,G,C,C,E,C,E,C,G,I,G,I,G,E,I,C,C,G,C,C,E,C,E,C,E,C,E,G,I,G,E,I,C,C,C,E,E,E,I,C,G,E,E,E,E,E,E,E,E,E,E,C,C,C,O,C,E,E,E,E,G,K,S,M,A,M,C,kC,E,E,S,C,C,C,C,C,E,U,C,C,E,E,Q,C,E,G,E,C,E,S,G,C,C,C,C,C,C,C,E,G,E,O,I,E,C,C,E,C,E,C,C,E,C,M,A,U,G,C,E,G,G,E,G,E,E,C,S,E,M,E,I,C,C,C,S,G,C,C,C,C,C,E,K,E,E,I,C,I,E,C,C,E,C,G,C,M,E,C,G,C,M,E,C,E,K,C,O,C,C,S,G,C,C,C,C,C,C,C,E,O,G,E,E,C,C,E,C,C,C,E,E,E,C,C,E,C,E,C,C,E,C,C,C,S,G,C,C,C,E,I,E,E,C,E,C,E,O,G,G,C,E,C,E,E,C,E,E,A,S,C,C,C,E,G,C,E,E,I,C,E,E,I,C,C,G,C,E,E,E,M,C,E,E,C,O,E,Q,C,O,C,C,C,M,C,C,I,C,C,I,E,G,E,E,G,I,E,C,C,E,C,E,C,C,E,A,A,Q,E,C,E,I,C,C,E,E,C,C,E,C,G,E,I,C,C,E,E,C,C,E,C,E,E,A,O,G,C,E,I,C,C,E,E,E,E,C,A,G,E,I,C,C,E,E,E,E,C,A,E,C,G,C,E,E,G,E,M,C,I,G,C,O,E,Q,C,Q,C,E,M,E,U,C,G,I,C,S,G,C,E,O,G,A,C,I,E,I,A,C,M,G,Y,C,C,C,I,C,C,C,E,C,C,I,C,C,C,E,C,C,I,C,M,C,E,M,A,C,Y,C,C,C,C,C,C,C,G,C,E,C,C,E,C,C,O,C,C,C,I,C,O,E,G,C,M,E,I,E,E,E,G,C,E,E,E,E,G,C,E,K,C,C,G,C,E,M,A,C,Y,C,C,C,G,C,E,C,C,E,C,C,O,C,C,C,I,C,E,E,K,C,M,C,E,E,K,G,C,G,E,E,E,K,G,C,G,E,M,C,C,C,C,S,G,C,C,C,C,C,E,I,E,A,S,C,E,G,C,M,C,C,K,C,C,K,C,C,C,E,G,G,G,O,A,S,C,C,C,E,I,E,E,c,C,G,O,G,E,gB,C,G,E,O,C,I,E,E,G,G,A,U,E,O,A,S,C,E,G,C,M,C,C,M,C,C,K,C,C,C,E,E,E,C,E,E,Q,C,E,E,M,C,E,A,S,C,C,C,E,I,E,E,C,E,E,uB,C,Q,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,C,G,E,K,G,E,K,C,E,M,E,E,O,C,E,O,C,C,O,C,E,E,G,E,I,C,G,C,E,K,E,E,M,A,E,I,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,C,I,I,E,E,K,C,G,E,G,C,K,A,S,C,C,C,C,C,E,I,E,E,C,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,C,C,M,C,C,K,C,C,M,C,C,C,A,S,C,C,C,C,C,E,I,E,E,W,C,E,G,G,C,E,M,C,E,I,E,C,C,E,C,E,E,Q,C,E,E,M,C,E,C,E,E,C,E,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,C,E,C,C,E,K,C,C,E,C,E,C,C,E,G,C,C,E,C,G,G,E,E,G,C,E,I,E,E,I,E,K,C,C,M,C,M,E,K,E,M,C,C,E,E,E,K,G,C,C,C,G,G,C,G,G,E,E,O,C,Q,G,E,I,C,G,C,E,M,C,E,I,I,E,E,E,C,C,E,C,E,C,O,I,G,C,O,E,Q,C,C,E,E,G,G,A,U,E,M,C,E,I,E,A,C,A,E,K,E,C,C,E,wB,C,A,S,C,E,G,C,M,C,C,K,C,C,C,E,E,E,O,C,E,E,S,G,M,C,E,E,O,C,E,G,C,E,G,C,E,A,U,E,E,A,Q,E,A,E,O,C,O,C,A,E,G,C,A,E,G,C,G,G,A,E,K,C,A,E,Y,G,E,E,C,G,E,I,C,Q,C,C,I,E,E,wB,C,E,G,O,I,G,C,E,E,C,C,E,E,C,C,O,E,6B,C,E,E,C,I,I,E,E,E,E,E,E,E,I,C,E,wB,C,E,I,O,C,E,G,A,S,C,M,E,G,C,M,E,C,C,C,K,C,C,C,E,G,E,K,A,U,E,E,A,E,M,C,A,Q,E,E,A,E,G,C,G,G,E,A,E,gB,C,A,E,K,E,A,E,Y,E,C,E,A,E,Y,E,E,G,G,G,G,C,I,E,E,Y,G,M,C,E,E,E,K,E,E,K,C,C,C,O,I,E,G,O,a,G,E,G,E,E,E,G,C,K,C,C,M,C,C,K,C,C,C,E,E,E,O,C,E,E,I,C,E,E,e,C,C,M,E,C,C,M,E,C,C,C,G,C,C,C,G,E,M,C,M,E,C,G,E,G,A,S,C,C,C,E,G,C,K,C,C,O,C,C,M,C,C,M,C,C,K,C,C,M,C,C,C,E,E,E,K,C,Q,E,I,A,C,E,I,G,A,M,G,I,G,C,G,E,E,E,G,E,G,E,C,K,E,O,E,M,E,M,E,S,C,G,E,O,G,E,I,G,G,E,E,E,M,C,E,G,E,C,K,E,O,E,M,E,M,E,S,C,G,E,O,E,E,E,C,K,E,O,E,M,E,M,E,K,E,M,E,K,C,G,G,E,C,C,S,G,C,C,C,C,C,E,G,C,S,C,C,O,C,C,C,E,E,C,E,E,C,E,I,I,K,E,S,G,G,C,G,C,M,C,C,I,C,C,C,E,E,C,C,E,C,E,C,C,G,E,E,G,A,C,E,C,E,M,C,E,C,C,E,C,E,E,C,C,E,C,E,M,C,E,C,C,G,E,M,C,E,C,C,E,C,C,E,A,C,E,C,C,E,W,C,E,E,C,K,C,E,E,E,S,G,E,M,C,E,C,C,E,C,E,M,C,E,K,G,C,C,G,E,S,G,E,I,E,C,S,G,C,C,C,E,G,C,K,C,C,O,C,C,S,C,C,M,C,C,M,C,C,C,E,E,A,S,C,C,C,C,C,E,I,E,E,Q,C,E,E,M,C,E,E,M,C,E,E,C,I,I,K,E,C,G,C,M,C,C,I,C,C,C,E,E,G,E,E,G,I,E,G,E,C,C,E,C,C,C,E,C,E,I,E,G,C,E,Q,C,C,E,I,C,C,O,E,O,E,M,C,C,E,C,I,C,C,E,A,G,Q,C,I,E,G,E,G,I,I,K,E,C,I,E,G,E,C,C,E,K,C,C,C,C,E,G,C,C,E,I,E,E,G,E,E,G,I,I,K,E,E,I,C,C,O,E,O,E,M,C,C,E,C,G,E,E,Q,K,G,C,E,I,C,C,E,C,G,E,E,M,K,G,C,C,E,C,C,O,C,E,E,E,G,I,G,C,O,C,C,O,C,C,M,C,C,I,C,C,G,E,K,E,G,C,M,C,gB,E,C,C,C,C,C,C,C,E,E,A,C,I,C,C,E,I,G,E,S,C,E,A,S,C,C,C,C,C,E,G,C,I,C,C,O,C,C,C,E,K,C,S,C,C,S,C,C,M,C,C,I,C,C,C,G,C,C,A,C,M,G,C,E,S,G,E,I,C,E,E,E,E,E,G,E,I,E,C,E,E,E,G,G,E,E,I,E,S,G,I,E,C,C,E,W,C,E,G,G,E,C,E,E,S,G,G,E,E,E,G,I,E,C,C,E,W,C,E,E,C,K,E,Q,C,C,E,C,C,E,G,C,G,G,E,E,E,E,C,E,S,G,E,I,C,E,U,W,E,O,E,C,C,S,G,C,C,C,C,C,C,C,E,I,E,E,W,C,E,E,C,G,E,M,C,E,C,C,E,C,C,C,I,G,C,G,S,oB,C,C,C,C,C,M,E,E,E,E,I,E,A,C,E,I,C,Q,E,E,A,E,M,C,E,E,C,I,E,E,E,E,E,E,A,E,A,C,E,E,c,C,E,E,O,C,E,K,G,E,O,E,a,I,C,E,C,Q,E,gB,C,G,M,E,K,A,S,C,C,C,C,C,M,E,E,I,E,A,S,C,E,I,E,E,O,C,E,E,I,C,E,G,G,E,M,C,G,O,A,K,I,G,C,E,C,C,E,e,A,E,A,C,I,G,A,O,G,C,A,C,I,E,S,C,C,E,G,G,G,G,M,C,M,E,K,G,E,I,E,W,G,O,G,I,K,K,C,K,G,E,C,C,E,C,E,E,A,C,A,M,G,A,M,C,G,C,E,A,E,C,E,I,I,C,E,C,I,C,G,C,G,G,C,S,Q,M,Q,Q,C,O,C,I,G,C,E,E,E,G,M,E,K,E,U,C,O,C,S,C,M,E,M,C,K,C,C,E,E,O,C,E,E,I,C,G,I,E,E,E,E,E,E,A,C,E,C,C,E,A,G,A,C,I,E,I,E,C,E,I,C,A,S,C,C,C,C,C,E,I,E,E,C,C,E,C,I,C,E,C,E,C,G,C,E,O,E,K,A,C,I,G,A,K,E,O,C,I,C,G,C,G,G,O,E,G,C,C,E,C,C,E,A,E,M,G,E,O,C,O,C,C,E,I,C,G,E,E,I,A,C,M,C,C,E,E,E,E,S,C,C,E,W,C,C,C,C,C,E,I,E,A,e,E,Q,C,E,E,4B,G,E,E,S,C,I,I,E,E,M,C,E,G,E,E,E,C,I,E,C,C,E,C,O,A,C,G,C,E,I,C,mB,C,E,E,I,E,G,E,I,E,G,E,G,C,E,E,C,C,E,mB,C,C,C,C,C,E,G,A,uB,E,Q,C,O,I,E,E,4B,G,I,I,E,E,M,C,E,G,E,E,E,C,I,E,C,C,E,C,O,A,C,G,I,G,E,G,C,E,E,S,C,C,E,kB,C,C,C,C,C,E,I,E,E,I,C,O,A,C,G,I,A,sB,E,Q,E,G,E,G,C,E,E,S,C,E,S,C,U,C,E,S,mB,C,E,I,G,C,E,K,G,C,U,E,C,C,S,E,C,C,C,E,O,E,a,E,C,E,K,G,C,E,G,E,E,e,E,K,G,C,E,E,E,C,S,E,U,E,W,K,G,C,E,E,C,E,G,C,E,I,A,O,G,A,O,G,E,Y,G,E,Y,E,E,K,G,E,K,A,O,W,G,Y,C,C,C,K,G,I,C,M,C,C,E,I,C,c,C,E,C,I,C,Y,C,K,I,C,Y,C,C,E,I,C,K,C,E,K,C,I,C,O,C,E,O,C,I,C,G,C,E,G,C,I,C,W,C,K,E,I,C,W,C,K,E,I,C,U,C,K,E,I,C,S,C,K,E,I,C,Q,C,K,E,I,C,G,C,K,E,I,C,M,C,K,E,I,C,I,C,K,E,I,C,K,C,K,E,I,C,M,C,K,E,I,C,K,C,K,E,I,C,Q,C,K,E,I,C,Q,C,K,E,I,C,M,C,K,E,I,C,Q,C,K,C,C,O,C,C,C,C,C,C,C,I,C,Q,C,E,I,C,S,C,E,I,C,Q,C,E,I,C,a,G,I,C,W,G,I,C,G,E,C,e,C,I,C,Y,G,C,I,C,K,C,I,C,Q,C,I,C,I,C,I,C,Q,C,I,C,I,C,K,C,I,C,K,A,E,C,I,C,M,C,I,C,S,C,I,C,G,C,I,C,Q,C,G,C,I,C,M,C,I,C,M,A,C,C,a,C,I,E,I,C,O,C,M,E,C,E,E,G,E,c,C,C,I,C,K,C,C,I,G,E,A,C,E,M,E,C,E,E,M,C,A,G,E,M,C,E,I,C,K,C,I,E,E,E,I,E,C,E,E,I,C,C,E,I,E,I,C,E,E,I,C,K,C,I,E,E,I,C,O,C,O,E,E,O,G,I,C,W,C,C,C,K,K,E,E,G,C,Q,C,C,I,C,C,C,I,C,G,C,E,O,C,C,I,C,K,C,I,C,M,C,E,M,C,I,E,E,M,C,E,G,E,I,E,E,E,I,C,E,I,C,mB,G,C,S,C,C,W,C,C,C,G,E,E,C,E,I,C,E,M,C,I,C,Y,G,C,E,I,C,Q,C,E,I,C,Q,C,E,E,E,G,E,E,C,E,I,C,S,C,E,I,C,Q,C,E,E,E,G,E,E,I,C,K,C,K,G,C,E,E,Q,E,I,C,Q,E,I,C,M,C,K,G,C,E,E,S,E,I,C,S,C,C,S,C,C,C,C,C,C,C,C,C,G,C,I,C,C,S,C,C,Q,C,O,C,Q,C,C,C,C,C,I,C,E,I,C,c,C,E,C,E,I,C,U,C,C,E,C,E,E,E,E,C,C,E,S,C,O,E,Y,C,S,I,E,G,E,C,E,O,I,C,W,C,O,C,C,E,K,I,E,E,E,E,E,W,C,E,I,E,K,A,C,C,A,I,G,C,C,E,M,C,E,C,E,E,E,C,G,C,G,E,C,C,E,M,C,C,E,E,E,C,E,C,E,G,E,G,E,C,C,E,C,C,K,E,I,E,I,E,M,E,O,C,E,C,C,E,M,C,E,E,E,C,G,C,C,S,C,C,C,C,C,C,C,C,C,G,C,I,C,C,U,C,C,Q,C,O,C,Q,C,C,C,C,C,I,C,E,I,C,c,C,E,C,E,I,C,W,C,E,C,E,E,E,E,E,E,E,E,E,E,E,E,E,O,I,C,W,C,O,C,C,E,K,I,E,E,E,E,E,W,C,E,I,E,K,A,C,E,G,E,E,E,E,G,C,G,E,E,E,I,C,C,M,E,O,C,G,G,E,E,I,E,E,C,E,C,C,E,C,C,K,E,I,E,I,E,M,E,O,C,E,E,K,G,C,E,G,G,E,C,G,G,E,E,I,C,C,M,E,O,C,G,C,C,gB,C,G,C,I,C,O,C,O,C,O,I,E,I,C,mB,G,C,e,C,C,Q,C,M,C,C,O,C,Q,C,C,C,I,C,C,C,C,I,C,E,G,E,I,C,I,C,I,C,K,E,G,I,C,Y,G,C,I,E,E,E,G,E,I,C,I,C,E,I,C,K,C,I,C,U,C,E,E,I,I,K,E,I,E,G,E,C,E,E,G,C,E,G,E,I,C,I,C,E,I,C,K,C,I,C,U,C,E,C,E,E,G,E,I,C,G,C,E,E,E,I,C,E,U,C,E,C,C,G,E,K,E,G,E,K,C,C,K,C,I,E,E,E,G,E,I,C,G,C,E,E,I,C,M,C,I,C,W,C,E,C,M,E,I,I,K,E,E,G,G,G,C,E,E,G,C,E,G,E,I,C,G,C,E,E,I,C,M,C,I,C,W,C,E,C,M,C,E,E,G,C,E,E,I,E,I,C,I,C,E,E,I,C,E,U,C,E,C,C,E,I,E,E,K,E,G,E,M,C,C,C,C,c,C,M,A,Q,I,C,O,C,Q,E,A,W,I,C,O,C,Q,A,C,M,C,G,I,C,O,C,O,C,C,I,E,I,C,G,A,C,G,E,I,E,I,C,K,G,G,E,C,C,O,K,E,G,C,Q,C,C,Y,C,C,W,C,C,I,C,C,C,I,C,C,M,C,C,O,C,C,C,E,E,G,K,C,E,G,E,G,C,I,C,I,C,I,C,K,E,E,G,E,I,E,C,M,C,C,Q,C,C,C,E,E,E,I,C,E,E,C,C,I,C,S,G,E,S,C,E,S,C,Q,E,Y,C,S,E,S,C,G,E,I,C,E,M,C,G,C,S,C,C,U,C,C,W,C,C,C,G,E,G,E,S,C,C,C,C,C,E,G,M,I,G,G,M,I,E,E,O,E,I,G,I,E,G,E,S,C,G,G,E,S,C,G,E,S,C,G,E,O,C,G,E,O,C,Q,E,c,C,G,E,c,C,G,E,Q,C,G,E,Q,C,S,E,S,C,E,E,W,C,G,E,W,C,G,E,W,C,G,E,Q,C,E,G,E,a,C,C,I,E,C,O,E,K,K,C,E,W,E,U,C,S,E,Q,C,Y,C,E,E,E,K,C,E,E,G,E,E,E,G,E,E,E,E,E,e,E,E,K,C,I,E,E,K,G,C,A,C,E,C,E,E,G,E,E,U,C,E,G,E,G,E,Y,C,C,E,S,G,O,M,C,G,I,C,A,G,A,I,G,G,E,C,E,E,E,E,E,E,E,E,O,C,G,E,I,C,E,E,E,G,E,I,G,A,I,G,E,M,E,C,E,O,E,E,E,S,C,C,C,C,C,E,G,E,E,I,C,E,E,E,E,E,C,c,E,M,C,U,E,S,C,E,S,C,E,E,E,I,C,Y,G,E,I,C,mB,E,C,E,E,C,E,G,E,I,C,I,C,E,I,C,K,C,C,C,E,E,E,I,C,G,C,E,E,K,C,E,C,E,I,C,I,C,E,E,G,E,I,C,G,C,E,E,I,C,M,C,C,C,E,C,M,E,K,C,E,G,I,C,G,C,E,a,E,I,E,E,C,C,I,C,W,C,O,C,C,E,K,E,W,C,E,S,E,E,E,S,C,E,S,E,E,I,E,E,W,C,E,I,E,K,C,E,E,S,C,E,S,E,C,E,S,C,E,S,A,G,E,E,E,E,E,E,C,C,E,E,C,A,C,E,Q,C,I,C,K,E,E,E,G,E,E,E,I,C,K,E,C,E,E,C,E,E,E,I,G,E,E,C,C,G,E,I,C,I,C,E,I,C,K,C,C,C,E,I,C,C,E,E,G,E,E,I,C,M,E,C,E,E,C,C,E,C,C,E,I,C,C,K,C,E,E,I,G,E,E,C,C,G,E,I,C,G,C,E,E,I,C,M,C,C,C,E,I,C,C,M,C,E,I,E,E,C,C,E,C,E,E,E,G,E,G,E,E,E,E,E,E,E,I,C,K,C,E,G,E,E,E,C,C,G,E,G,E,E,C,E,E,E,E,C,E,C,G,G,I,C,G,C,E,a,C,C,W,C,I,E,I,C,O,C,E,E,K,C,E,G,E,I,E,E,G,E,O,E,G,C,E,O,C,O,I,E,G,E,G,C,I,C,I,C,I,C,K,E,E,I,C,G,C,E,E,Q,C,E,E,I,C,E,E,E,G,C,E,E,E,I,C,I,C,E,I,C,K,C,G,I,C,Y,G,E,K,G,I,I,C,U,E,E,I,C,G,C,E,E,G,E,K,C,E,I,C,K,C,O,C,I,E,I,C,W,C,M,C,C,E,I,K,G,C,E,E,M,E,G,E,E,G,E,K,C,I,C,G,C,I,C,M,C,E,E,M,C,O,C,I,C,mB,G,C,I,E,G,E,E,E,E,C,E,S,C,E,S,C,G,I,E,Y,C,S,E,W,C,E,K,C,E,S,C,E,K,C,E,I,C,E,M,C,G,E,E,I,C,E,E,E,C,qB,C,I,E,I,C,O,C,K,C,E,G,E,I,E,E,G,E,O,E,O,E,O,C,E,U,C,E,M,C,C,C,iB,C,C,C,C,C,I,E,E,E,G,G,E,I,C,I,C,I,C,K,G,G,E,I,C,G,C,I,C,M,E,C,I,E,I,C,c,C,E,E,E,E,M,C,E,E,G,G,E,A,C,E,C,C,E,A,E,I,C,E,I,C,E,K,G,G,E,E,G,C,E,G,C,E,M,E,O,I,C,W,C,E,C,O,I,C,Y,C,C,K,E,I,E,I,C,O,C,G,C,A,e,E,E,I,G,A,a,G,C,A,E,O,G,A,E,O,G,C,C,A,E,O,E,A,U,G,A,Y,C,E,O,I,E,I,C,gB,C,E,C,C,E,C,E,G,A,c,E,I,E,A,a,E,I,C,C,I,E,I,C,Y,C,E,G,E,E,C,G,C,G,G,E,O,C,C,E,E,I,C,C,I,E,I,C,Y,C,E,G,C,G,G,E,O,C,C,E,E,I,C,C,I,C,M,G,G,E,O,C,C,E,E,I,C,C,I,C,C,C,I,G,C,G,S,S,G,M,C,C,C,C,C,E,I,E,E,M,C,I,G,C,I,E,G,C,Q,E,M,C,E,C,G,S,C,E,E,G,G,M,C,E,E,E,K,C,E,G,S,C,E,E,M,E,O,E,M,A,E,a,C,C,C,C,C,E,I,E,E,M,A,C,G,S,C,E,E,G,E,O,C,C,E,Y,C,E,I,E,E,M,A,C,E,W,G,E,c,E,E,W,C,C,C,E,E,M,E,E,M,C,W,C,E,K,C,E,S,C,Q,C,E,S,M,M,S,S,C,E,Q,C,E,O,I,Q,C,C,C,C,C,E,I,E,E,Y,C,E,E,K,A,C,E,gB,C,G,C,E,I,C,G,E,M,C,C,C,E,C,E,I,C,G,E,M,C,C,C,C,E,Q,K,Q,K,O,C,M,A,G,E,K,C,O,C,K,C,S,G,Q,G,e,C,E,I,E,E,I,C,Q,C,C,O,C,c,C,C,W,C,C,U,C,C,M,C,C,C,C,E,M,C,O,C,O,E,sB,G,G,C,A,I,I,E,E,U,C,Q,C,E,E,K,G,E,G,E,W,E,M,C,K,C,C,E,K,C,C,K,C,U,E,e,C,U,E,O,C,E,O,C,Q,E,c,C,S,E,U,C,e,E,gB,C,S,E,e,C,U,A,C,E,K,C,E,M,A,E,E,Y,E,W,C,W,G,E,U,C,S,E,Q,C,U,G,E,S,C,a,E,a,E,K,A,C,E,I,C,C,E,M,C,M,A,G,E,K,C,O,C,K,C,Q,C,E,S,S,K,E,C,E,Y,C,Y,A,G,C,E,U,C,M,O,C,Y,A,G,C,C,iB,S,O,C,Q,C,E,C,C,C,O,W,G,Y,C,C,C,K,G,I,C,K,C,E,K,C,I,C,O,C,E,O,C,I,C,G,C,E,G,C,I,C,Q,C,K,E,I,C,G,C,K,E,I,C,M,C,K,E,I,C,I,C,K,E,I,C,K,C,K,E,I,C,K,C,K,E,I,C,M,C,K,E,I,C,Q,C,K,E,I,C,M,C,K,E,I,C,Q,C,K,C,C,O,C,C,C,C,C,I,E,I,C,O,C,G,I,C,I,C,E,I,C,G,C,E,C,E,O,C,C,I,C,K,C,I,C,M,C,I,C,K,C,I,C,M,C,E,M,C,I,C,K,C,I,C,K,C,E,I,C,M,C,I,C,M,C,E,I,E,G,E,I,E,E,I,C,M,C,C,C,I,C,Q,C,G,E,O,E,I,E,E,G,E,I,E,U,C,I,C,Q,C,M,A,C,I,C,Y,G,I,C,M,C,E,I,C,K,C,C,C,c,C,I,E,I,C,O,C,Q,C,M,A,Q,G,A,W,C,C,U,C,C,C,G,C,I,C,C,K,C,C,O,C,C,M,C,C,Q,C,C,C,I,C,E,E,K,C,E,E,E,E,E,O,I,C,Y,G,C,E,G,E,E,G,E,E,E,E,E,C,E,C,A,S,E,Q,C,C,E,E,E,E,G,E,E,G,E,A,I,E,E,C,E,E,E,E,G,E,E,G,E,A,G,E,E,E,E,C,E,C,O,E,O,E,S,E,S,C,C,C,M,C,I,E,I,C,G,C,E,I,C,O,C,G,C,E,O,C,O,I,E,G,E,I,E,E,E,U,C,E,I,C,Q,C,G,C,C,O,C,C,O,C,C,S,C,C,S,C,C,C,I,C,S,C,G,G,E,E,I,C,E,E,E,C,M,E,K,C,S,E,S,E,U,G,E,K,E,a,S,Y,C,E,E,A,E,C,C,I,G,C,G,Q,S,G,M,C,C,C,C,C,G,A,S,C,C,C,E,I,E,I,G,C,I,E,G,C,Q,E,M,C,E,C,G,S,C,E,E,G,G,M,C,E,G,E,U,C,C,E,E,E,E,K,C,E,I,E,E,U,A,C,G,S,C,E,G,O,E,U,A,E,a,C,C,C,C,C,E,I,E,E,U,A,C,G,S,C,E,E,G,E,O,C,C,E,S,C,M,S,Q,C,E,K,C,O,M,E,S,C,E,Q,G,S,M,K,G,O,G,E,c,C,M,O,E,Y,C,Y,C,E,W,C,C,C,E,I,G,I,Q,I,G,C,G,W,M,C,C,C,C,C,E,I,E,I,G,C,I,E,G,C,Q,E,M,C,E,C,G,S,C,E,E,G,G,M,C,E,G,G,G,C,E,E,E,K,C,E,G,S,C,E,G,G,C,I,G,M,C,E,E,a,C,C,C,C,C,E,I,E,G,G,C,E,C,G,S,C,E,E,G,E,O,C,C,E,S,C,M,S,Q,C,E,K,C,O,Q,E,S,C,E,Q,E,S,M,K,G,O,I,E,c,C,M,O,E,Y,C,Y,C,E,W,C,C,C,E,I,G,C,Q,C,E,G,C,E,M,C,M,C,E,I,E,E,E,E,E,E,E,E,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,C,O,C,G,G,E,Q,G,C,I,E,E,e,E,C,G,E,C,C,G,E,C,C,E,C,C,C,M,C,E,E,E,E,E,C,C,E,Q,C,C,C,E,G,C,E,M,C,M,C,E,I,E,E,C,C,E,E,C,C,E,O,iB,C,E,E,E,I,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,C,O,C,G,G,E,Q,G,C,I,E,E,c,G,E,G,E,E,C,E,G,C,E,E,E,C,C,C,C,G,E,C,I,E,E,e,E,C,E,E,C,C,E,E,C,A,C,M,C,E,E,E,C,C,C,E,S,G,C,C,C,E,O,G,C,G,G,M,S,C,I,C,K,C,E,G,E,I,C,E,E,C,C,S,G,C,E,M,A,C,A,U,O,G,a,M,G,E,O,C,C;A,C,E,G,E,K,C,C;A,C,E,C,C,S,G,C,C,C,E,I,E,E,K,C,G,C,C,K,C,C,O,C,C,M,C,C,C,E,C,S,C,C,U,C,C,C,E,E,G,E,Q,E,E,G,E,S,E,E,G,E,U,E,E,E,M,C,E,E,M,C,E,E,M,C,E,G,E,O,E,E,E,M,C,E,E,E,E,M,C,C,E,I,E,E,M,C,M,C,E,K,C,M,C,E,K,C,M,C,G,G,G,E,U,C,M,C,E,S,C,M,C,G,C,G,E,E,U,C,A,C,E,C,E,E,Y,C,E,iB,A,E,E,C,I,E,E,a,C,K,G,C,E,E,U,E,E,U,C,G,E,E,A,C,E,C,E,E,U,C,A,C,E,C,E,E,W,A,C,G,C,G,E,e,C,E,E,U,C,A,C,E,C,E,E,a,A,E,I,E,E,E,S,C,E,E,K,G,C,E,E,W,C,G,K,C,E,E,O,E,I,G,E,I,C,E,M,C,G,E,K,C,G,E,I,C,E,M,C,G,E,U,C,M,C,E,S,E,G,E,E,a,C,E,E,E,U,C,E,G,E,A,I,G,E,M,C,G,G,E,K,C,G,G,E,K,C,E,G,E,E,E,I,C,E,M,C,G,E,M,C,G,E,O,G,C,M,G,E,K,C,O,C,C,C,S,G,C,C,C,C,C,E,I,E,E,M,E,E,M,E,A,S,C,C,C,E,G,C,E,C,C,O,C,C,C,E,O,E,E,E,M,E,E,M,C,E,E,S,Q,E,E,G,M,C,O,E,M,E,E,M,E,A,S,C,C,C,C,C,C,C,E,G,C,E,C,C,M,C,C,C,E,C,M,C,C,U,C,K,C,C,M,C,C,C,C,E,E,S,M,A,W,E,E,G,A,C,E,C,E,E,O,Q,G,E,E,E,O,G,E,E,G,C,E,O,E,A,S,C,C,C,C,C,C,C,E,G,C,E,C,C,M,C,C,C,E,E,E,S,C,E,Y,C,G,A,S,G,E,E,E,E,K,E,A,U,G,E,E,E,E,M,C,C,E,E,E,E,I,C,E,Q,E,C,E,E,E,E,G,O,C,C,C,S,G,C,C,C,C,C,C,C,E,G,C,U,C,C,a,C,C,a,C,C,C,E,C,O,C,C,O,C,C,C,E,E,E,E,C,Q,C,C,S,C,C,W,C,C,Y,C,C,C,G,G,E,A,S,C,C,C,E,G,C,E,C,C,M,C,C,C,E,M,A,U,E,G,E,A,W,G,C,G,E,C,E,C,E,E,G,E,A,S,C,C,C,C,C,E,G,C,E,C,C,O,C,C,C,E,M,A,Q,E,G,E,A,W,E,G,E,E,G,E,E,C,E,E,E,G,M,A,W,E,A,S,E,G,E,A,U,G,C,G,C,E,A,S,E,G,K,G,C,E,G,E,A,U,G,C,G,K,G,C,E,G,C,E,C,E,G,E,E,E,K,C,E,K,E,E,G,E,E,E,M,C,E,M,C,C,C,S,G,C,C,C,C,C,E,I,E,G,E,O,E,M,A,W,E,E,C,C,E,K,C,E,A,U,E,E,C,C,E,K,C,E,K,C,E,C,C,E,I,A,C,S,G,C,C,C,E,I,E,G,E,O,E,E,O,C,O,E,E,O,C,O,C,S,C,O,E,E,Q,C,G,C,C,M,W,G,Y,C,C,C,K,G,I,C,O,C,E,I,C,O,C,E,C,I,C,c,C,K,E,I,C,K,C,K,E,I,C,iB,C,K,E,I,C,a,C,E,C,I,C,W,C,K,E,I,C,Q,C,K,E,I,C,K,C,E,K,E,E,M,C,I,C,M,C,I,C,K,C,I,C,O,C,E,O,C,I,C,U,C,K,E,I,C,K,C,K,E,I,C,U,C,K,E,I,C,I,C,K,E,I,C,S,C,K,E,I,C,M,C,K,E,I,C,M,C,K,E,I,C,M,C,K,E,I,C,C,C,K,E,I,C,C,C,K,E,I,C,M,C,K,E,I,C,K,C,K,E,I,C,M,C,K,E,I,C,M,C,K,E,I,C,W,C,K,E,I,C,gB,C,K,E,I,C,e,C,K,C,C,W,C,C,C,I,C,O,C,E,I,C,iB,C,K,E,I,C,Q,C,K,C,C,oB,C,I,E,I,C,iB,C,G,E,O,E,I,E,I,C,K,C,E,I,C,O,C,U,C,I,C,U,I,E,E,O,E,E,O,C,S,E,E,U,C,E,I,G,I,C,K,C,G,O,E,U,E,C,I,C,iB,C,O,M,C,E,E,C,C,Y,C,O,I,C,Q,E,C,I,C,Q,C,G,I,C,K,C,U,G,C,Q,I,C,a,I,C,a,C,K,S,E,C,C,S,C,C,C,C,C,G,C,U,C,C,C,E,E,E,W,C,K,C,I,C,C,E,E,E,E,K,C,K,C,I,C,C,E,E,E,E,U,C,K,C,I,C,C,E,E,E,E,C,O,E,G,E,G,I,E,G,E,G,I,E,G,E,G,G,C,c,C,C,C,C,C,O,G,E,C,G,E,S,C,U,C,K,C,I,C,C,E,G,C,Q,C,C,C,C,C,G,C,U,C,C,C,E,E,E,C,O,G,E,A,I,I,E,C,O,E,C,M,E,C,M,E,A,E,E,G,E,E,C,G,E,M,C,G,E,W,C,I,C,I,C,K,G,E,K,C,E,K,C,I,C,I,C,I,G,E,K,C,G,E,U,C,I,C,I,C,K,E,I,C,E,G,C,C,a,C,C,C,C,C,O,G,E,C,G,E,S,C,S,C,K,C,I,C,C,E,G,C,U,C,C,C,C,C,G,C,U,C,C,C,E,E,E,Y,C,K,C,I,C,C,E,E,E,E,M,C,K,C,I,C,C,E,E,E,E,W,C,K,C,I,C,C,E,E,E,E,C,O,E,G,E,G,I,E,G,E,G,I,E,G,E,G,G,C,a,C,C,C,I,E,I,C,O,C,E,I,C,K,C,I,C,E,E,C,E,E,C,E,E,C,E,E,C,E,E,I,E,E,E,E,M,C,E,E,E,E,E,I,C,A,S,C,C,C,E,G,C,Q,C,C,a,C,C,M,C,C,C,E,E,E,c,C,G,U,C,C,M,C,C,M,C,C,C,E,gB,C,G,M,C,M,E,M,E,O,E,S,C,G,I,E,I,C,Q,C,E,C,I,C,E,C,e,E,Q,E,U,G,U,E,a,E,Q,C,C,E,I,C,K,C,C,C,E,G,O,E,M,E,C,E,E,M,C,C,E,E,I,E,M,C,E,E,E,G,E,E,Q,E,C,E,E,I,C,C,E,I,E,Q,C,E,E,G,E,G,E,A,I,I,E,G,E,S,C,E,C,E,I,C,E,U,C,I,C,I,C,I,E,I,C,E,e,C,I,C,I,C,I,E,I,C,E,c,C,I,C,I,C,G,G,I,C,W,C,E,I,C,gB,C,E,I,C,e,C,E,I,C,U,C,E,C,C,O,C,C,C,C,C,I,E,I,C,O,C,U,C,I,C,U,I,E,I,C,O,C,E,E,E,C,G,E,M,C,C,I,E,E,C,E,Q,C,C,I,C,I,C,E,I,C,c,C,C,E,I,C,Y,C,G,I,C,K,C,I,C,Q,C,E,G,I,C,U,C,I,C,a,C,E,G,I,C,I,C,I,C,O,C,E,G,I,C,S,C,I,C,Y,C,E,G,I,C,M,C,I,C,S,C,E,G,I,E,I,C,K,C,G,I,C,G,E,O,M,C,C,E,E,G,E,G,I,C,K,C,E,G,E,G,E,E,E,I,C,K,C,C,I,C,M,C,E,M,C,I,C,M,C,E,M,C,E,C,Q,E,E,E,C,C,E,E,C,C,M,E,K,C,O,E,M,C,O,E,C,C,O,E,C,A,C,M,A,I,I,C,O,E,C,E,C,Q,C,C,C,C,I,C,a,C,E,I,C,Q,C,K,E,G,I,C,kB,G,M,C,I,C,G,G,E,Q,E,E,Q,C,I,C,I,C,C,M,I,C,K,C,Q,I,C,O,C,E,C,U,C,C,C,C,C,C,C,C,C,I,E,I,C,gB,C,E,E,E,C,E,M,C,E,E,C,E,E,E,E,M,C,E,E,C,E,E,E,E,M,C,E,E,C,E,E,C,C,iB,C,C,C,C,C,C,K,E,E,E,E,E,E,G,C,O,C,C,O,C,C,C,I,C,C,U,C,C,a,C,C,C,E,C,Q,C,C,S,C,C,W,C,C,Y,C,C,C,G,G,C,E,C,C,E,C,C,C,E,C,M,C,C,O,C,C,C,E,M,A,W,E,C,E,E,E,E,A,S,E,C,A,E,A,C,E,C,E,E,E,E,E,E,E,C,E,C,A,E,A,C,E,E,C,E,E,E,E,E,E,E,C,E,E,C,E,C,A,E,A,S,E,E,K,G,C,E,G,E,A,U,E,E,E,K,G,C,E,G,E,I,C,M,C,A,Q,E,C,A,E,A,C,E,C,E,E,E,E,E,E,E,C,E,C,A,E,A,C,E,E,C,E,E,E,E,E,E,E,C,E,E,C,E,C,G,E,G,E,G,E,G,E,G,E,G,C,C,C,U,C,C,C,C,C,C,K,E,E,E,I,E,I,C,K,C,E,E,M,C,G,E,C,I,E,G,E,G,C,I,C,C,C,I,C,K,E,I,E,C,C,G,I,C,E,U,C,G,E,S,C,E,S,C,E,U,E,E,Y,C,S,E,G,E,S,E,E,E,Y,C,E,S,C,E,U,C,E,I,C,E,M,C,E,E,E,E,E,E,E,Q,C,C,C,E,C,E,C,C,E,C,E,E,C,C,E,U,C,G,E,C,E,E,U,C,E,E,I,G,C,E,C,E,E,iB,C,C,C,C,C,c,C,C,C,C,C,C,C,C,C,C,C,I,E,I,C,W,C,E,C,E,I,C,gB,C,E,C,C,U,C,C,S,C,C,W,C,C,C,E,E,G,E,Q,E,E,G,I,C,O,G,E,E,C,C,G,E,E,E,U,C,A,C,E,U,C,C,E,E,E,E,E,C,C,E,G,E,a,C,C,I,E,C,O,K,G,C,E,G,E,W,E,U,C,S,E,Q,C,Y,C,E,E,E,U,C,E,G,E,E,E,E,E,C,C,E,W,C,E,kB,C,E,S,C,E,kB,C,G,E,E,E,G,E,W,C,E,W,C,E,S,C,E,e,C,G,E,E,E,E,K,C,E,S,C,G,E,W,E,K,G,I,O,M,C,E,W,G,E,W,E,E,E,W,C,E,W,C,E,W,C,E,U,E,E,E,E,c,C,E,gB,E,E,I,E,E,U,C,E,E,G,E,E,U,C,E,K,C,E,G,E,E,G,E,G,E,Y,C,C,O,M,C,G,I,C,A,G,A,I,G,C,E,S,G,E,S,C,E,kB,C,G,E,C,E,E,E,E,E,E,E,E,O,C,G,E,I,G,E,M,G,E,S,C,E,e,C,E,S,G,G,E,C,E,E,E,E,E,E,E,E,E,E,E,O,C,G,E,I,E,E,C,E,S,C,E,kB,C,E,Q,C,E,E,E,G,E,U,C,E,E,E,G,E,S,C,E,e,C,E,Q,C,E,E,E,E,E,E,E,C,C,E,S,C,I,C,e,C,E,A,C,S,C,C,C,C,C,C,K,E,E,E,E,E,E,E,G,C,K,C,C,C,I,C,C,Y,C,C,U,C,C,c,C,C,U,C,C,S,C,C,W,C,C,C,E,E,G,E,Q,E,E,E,U,C,E,E,E,G,E,G,C,I,C,C,C,I,C,K,E,E,S,C,E,E,Q,C,E,E,C,C,E,C,C,G,E,C,C,E,G,E,C,E,E,C,E,E,E,S,C,G,I,E,S,C,E,E,Y,C,S,E,I,C,E,M,C,E,C,C,G,I,C,E,G,E,S,C,E,S,C,G,I,C,U,C,G,E,G,A,U,E,A,W,E,E,E,E,E,E,E,E,E,E,E,E,M,C,E,E,E,E,C,I,E,C,C,E,C,E,I,C,e,C,E,C,E,S,C,E,G,E,M,C,G,E,E,K,C,G,E,M,E,C,I,C,a,C,E,E,E,E,G,E,K,G,C,E,U,C,E,E,E,E,E,E,M,C,E,E,E,E,E,C,C,E,E,E,E,U,C,G,E,K,C,E,C,E,E,E,E,U,C,G,I,C,S,C,G,E,C,E,C,C,W,C,C,C,C,C,C,K,E,E,I,E,I,C,M,C,E,E,M,C,G,E,C,I,E,G,E,G,C,I,C,C,C,I,C,K,E,I,E,C,C,G,I,C,E,W,C,G,E,C,E,E,e,C,E,S,C,E,S,C,E,W,E,E,Y,C,S,E,G,E,U,E,E,S,C,E,W,C,E,I,C,E,M,C,E,E,E,E,E,E,E,Q,C,C,C,E,C,E,C,C,E,C,E,E,C,C,E,U,C,G,E,C,E,E,U,C,E,a,A,C,C,e,C,C,C,C,C,C,C,C,C,G,C,O,C,C,O,C,C,C,I,C,C,E,C,C,E,C,C,C,E,C,M,C,C,O,C,C,C,E,C,Q,C,C,S,C,C,W,C,C,Y,C,C,C,G,E,Y,C,C,E,S,C,E,e,C,E,W,C,E,W,C,E,S,C,E,W,C,E,S,G,E,M,C,E,E,G,A,Q,G,I,C,S,C,E,E,E,G,E,M,C,E,E,E,G,E,gB,C,E,E,E,E,E,E,G,A,W,G,A,U,G,I,C,S,C,E,E,E,G,E,M,C,E,E,E,E,G,E,gB,C,E,E,E,E,E,E,E,E,G,A,W,G,I,C,S,C,E,E,E,G,E,M,C,E,E,E,G,E,gB,C,E,E,E,E,E,E,G,A,W,G,A,S,G,I,C,S,C,E,E,E,G,E,M,C,E,E,G,E,gB,C,E,E,E,E,G,E,S,G,E,I,G,E,W,C,G,E,M,E,C,uB,C,C,C,I,E,I,C,K,C,E,I,C,W,C,E,G,E,C,C,E,G,E,C,C,G,G,E,C,I,E,E,C,E,Q,C,C,I,C,I,C,I,C,O,C,I,C,c,E,G,C,E,O,I,E,I,C,K,C,G,I,C,G,E,O,M,C,C,E,E,I,C,K,E,E,G,E,E,G,E,G,E,E,E,E,C,C,E,G,G,E,C,E,E,G,G,E,C,A,G,C,I,C,M,C,E,M,C,I,C,M,C,E,M,C,I,C,K,C,E,K,C,I,C,M,C,E,M,C,I,C,M,C,E,C,C,I,C,M,C,E,C,C,I,C,kB,G,M,C,I,C,E,C,C,C,a,C,M,C,C,I,C,O,A,C,K,C,C,C,I,E,I,C,O,C,U,C,I,C,U,I,E,I,C,O,C,G,C,E,O,I,C,sB,C,G,I,E,C,M,I,C,K,C,O,I,C,M,A,E,E,C,E,I,C,C,C,E,I,C,C,A,E,E,A,K,K,G,C,G,E,E,I,E,G,E,O,E,E,I,C,K,C,M,E,I,C,U,C,M,E,I,C,I,C,M,E,I,C,S,C,M,E,I,C,M,C,M,A,C,E,O,E,G,C,E,I,G,E,W,C,E,I,C,c,C,E,E,E,G,G,E,E,a,E,E,C,E,E,G,C,I,C,S,C,E,E,G,I,C,Q,C,E,E,G,I,C,U,C,E,E,G,G,E,E,a,E,E,O,E,C,C,mB,C,O,I,C,O,E,E,A,C,kB,C,C,C,C,C,I,E,I,C,O,C,E,E,G,C,C,C,a,C,C,M,C,C,I,I,E,I,C,K,C,c,C,G,G,C,E,M,A,M,kC,G,M,C,a,E,Q,E,I,C,E,C,M,C,C,G,E,C,G,E,G,E,I,C,gB,C,E,E,C,C,G,C,G,C,I,C,O,C,E,I,C,c,C,E,I,C,mB,C,C,E,I,C,M,C,C,E,C,C,Y,C,C,C,C,E,C,C,C,C,G,G,I,C,mB,C,M,C,C,C,I,C,mB,C,C,E,I,E,I,C,O,C,E,I,C,O,E,E,C,E,I,C,kB,C,E,E,E,G,E,I,C,gB,C,E,G,E,G,C,G,E,I,E,O,G,C,I,C,O,C,E,A,C,E,O,E,E,Q,A,G,C,I,C,c,C,C,E,E,C,C,E,E,C,A,E,I,C,M,C,C,E,E,C,E,C,C,mB,C,C,C,C,C,C,C,C,C,I,E,I,C,O,C,G,A,a,E,I,C,M,E,C,G,C,E,O,E,I,E,I,C,K,C,yB,C,E,E,I,C,E,G,O,E,O,E,E,O,G,C,C,iB,C,C,C,C,C,G,C,O,C,C,O,C,C,Q,C,C,C,I,C,E,E,C,E,Q,C,C,I,C,I,C,E,G,M,A,C,I,G,C,I,E,C,E,I,E,C,A,C,C,C,G,W,C,G,I,G,C,G,U,S,G,Y,G,U,C,C,C,C,C,E,G,C,E,O,C,I,G,C,M,E,Q,C,E,C,E,a,C,C,C,C,C,E,E,O,E,E,O,C,U,C,E,E,M,C,C,C,C,C,E,E,O,E,E,O,C,U,C,E,E,U,C,E,I,E,E,O,C,G,G,E,W,G,C,I,E,C,Q,C,E,G,A,C,I,E,a,C,oB,G,M,C,E,I,C,E,G,E,E,a,C,mB,E,C,E,W,C,C,C,E,G,E,O,C,C,I,E,E,M,A,C,E,O,C,W,C,E,K,C,E,E,W,G,C,E,O,C,C,C,C,C,E,S,C,Q,C,E,S,K,S,U,gB,kB,W,O,U,C,O,M,E,a,E,kB,E,W,O,U,O,Y,E,S,C,E,U,O,Y,O,c,E,gB,E,W,C,O,M,E,Y,O,Q,E,a,E,U,E,a,E,U,C,E,I,E,Q,C,I,C,S,C,E,I,E,Q,C,I,C,mB,O,c,C,E,W,E,Y,gB,Y,E,U,C,S,I,O,c,E,W,C,Q,C,K,S,W,C,I,I,Q,S,S,S,A,E,Q,C,O,S,S,G,C,E,U,C,Y,G,M,C,E,G,E,M,C,E,C,I,E,C,C,E,C,E,E,K,C,I,C,M,C,E,E,E,M,C,E,G,I,E,I,C,O,E,A,Y,I,C,O,C,I,C,O,E,O,C,K,E,G,G,E,K,C,O,E,K,C,G,E,G,E,S,C,E,O,C,C,E,S,C,A,C,M,E,E,W,G,W,G,Y,G,M,C,E,G,I,E,I,C,O,E,A,Y,I,C,O,C,I,C,O,E,K,C,K,E,c,E,E,c,C,I,E,E,O,C,K,E,E,C,G,C,G,I,E,I,E,E,c,C,O,G,I,C,G,C,E,C,E,W,C,E,I,E,E,K,C,c,C,E,Y,E,U,C,Q,C,E,S,E,M,C,Y,E,W,C,gB,E,e,C,Y,E,W,C,W,E,U,C,iB,E,gB,C,a,C,C,E,iB,O,I,C,O,C,S,A,E,gB,C,E,I,E,E,K,C,c,C,E,Y,E,U,C,Q,C,E,S,E,M,C,W,E,U,C,S,E,Q,A,C,E,W,G,U,G,a,G,O,G,Y,E,C,E,c,C,S,O,W,O,U,M,E,Y,C,Y,A,G,A,W,G,A,a,G,A,a,E,W,C,E,U,C,Y,C,E,W,C,C,E,U,C,U,C,C,E,W,C,U,W,C,E,uB,C,c,A,E,G,O,M,C,C,U,K,W,G,O,G,O,G,S,G,M,G,Q,E,G,I,G,C,E,E,E,I,C,A,U,O,E,C,E,E,I,C,G,E,E,O,C,C,M,E,M,C,E,E,M,I,C,E,I,E,C,E,G,C,E,I,A,O,E,K,G,K,K,C,G,E,E,O,W,G,Y,C,C,C,K,C,G,I,C,W,C,K,E,I,C,W,C,E,I,C,Y,C,E,A,C,K,C,C,C,I,E,I,C,Y,C,G,E,M,C,C,I,E,I,C,S,G,I,G,C,M,C,C,M,C,C,G,E,C,C,E,G,G,E,M,C,E,E,C,I,C,Y,C,E,A,C,K,C,K,E,C,M,C,C,C,C,C,G,G,G,O,K,I,E,I,C,S,G,O,G,E,S,I,C,C,E,G,E,E,A,S,C,C,C,C,C,C,C,E,I,E,E,O,C,G,G,A,K,E,O,G,E,E,E,G,I,E,E,W,C,G,O,I,E,E,C,E,E,E,G,E,G,I,C,Y,E,E,M,C,E,C,qB,C,G,C,W,C,C,W,C,C,C,I,C,a,G,C,I,C,C,I,C,C,C,I,C,S,C,C,E,A,C,U,I,C,O,C,M,E,C,G,C,E,C,E,G,C,E,I,C,S,G,M,C,C,C,E,I,C,G,C,E,I,C,G,C,C,C,Y,C,I,E,I,C,G,C,E,I,C,G,C,E,I,C,O,C,M,C,E,E,C,E,I,C,S,E,C,E,A,I,G,I,E,M,C,E,E,E,K,C,E,E,G,I,C,W,C,K,G,C,E,M,C,C,E,E,C,E,G,I,C,W,C,I,C,G,C,C,E,G,C,E,I,I,E,E,G,E,I,E,I,C,C,M,C,G,O,C,C,iB,C,C,C,I,E,I,C,S,G,O,G,G,E,E,M,C,C,C,E,C,C,C,W,C,K,C,Y,I,C,Y,I,C,I,C,c,C,C,I,C,c,A,C,C,iB,C,C,C,M,A,U,O,G,C,E,I,C,K,C,E,E,A,O,E,I,I,C,kB,C,A,C,E,I,C,W,A,E,I,C,W,C,C,gB,C,C,C,I,E,I,C,K,C,O,E,G,E,E,M,C,E,K,I,C,gB,C,C,C,E,C,K,C,C,iB,C,C,C,O,K,K,C,I,C,W,C,I,C,kB,C,G,I,C,W,C,C,c,C,O,I,C,M,A,C,C,S,G,C,C,C,C,C,W,C,C,Y,C,C,E,I,E,G,G,E,I,E,A,C,G,C,E,M,C,O,K,G,C,E,C,A,C,E,K,G,C,G,K,G,C,E,G,I,E,E,C,G,E,C,W,G,Q,C,C,M,C,S,G,S,C,gB,A,C,C,O,W,G,Y,C,C,C,K,C,G,I,C,K,C,K,E,I,C,G,C,K,E,I,C,W,C,K,E,I,C,S,C,K,E,I,C,W,C,C,C,M,C,C,C,C,C,O,G,I,A,C,A,U,O,G,a,M,G,C,S,C,G,K,C,C,C,wB,C,G,C,Y,C,C,C,I,C,O,C,C,W,C,C,W,C,C,C,I,C,a,G,C,I,C,C,I,C,C,C,I,C,E,A,G,E,E,E,E,E,A,G,E,E,E,E,G,E,C,I,E,G,G,E,G,E,C,E,G,E,E,E,G,E,G,E,G,E,E,C,G,I,E,C,I,E,C,C,C,G,O,gB,E,G,O,gB,A,G,C,E,K,G,C,A,I,E,E,E,E,G,G,E,E,E,C,I,C,G,C,E,I,C,G,C,C,C,c,C,I,E,I,C,O,C,K,C,C,c,C,C,S,C,C,C,E,E,O,E,A,C,E,K,I,C,I,C,G,C,G,K,K,C,I,C,G,C,G,C,E,K,C,Q,I,C,C,O,E,I,C,E,C,iB,E,E,+B,E,E,yB,C,E,E,G,E,C,E,I,C,gB,G,E,G,E,E,G,C,E,K,G,C,E,E,E,C,C,kB,C,O,O,iB,A,C,Y,C,I,E,I,C,O,C,E,E,K,C,E,I,C,Y,G,E,K,G,C,E,G,I,E,C,S,E,O,E,M,C,I,E,G,C,I,E,G,C,U,E,S,C,K,E,Q,C,M,E,K,C,U,I,C,U,G,W,I,C,Y,G,Y,E,W,E,E,c,A,C,I,E,a,A,E,E,I,C,M,E,I,C,E,A,S,C,C,C,E,I,E,E,C,C,O,C,C,K,C,C,I,C,C,I,C,C,U,C,C,M,C,C,S,C,C,U,C,C,c,C,C,C,E,E,G,E,E,E,E,C,I,C,C,I,C,C,C,E,E,C,G,G,E,C,G,G,E,C,G,G,E,A,C,E,C,E,C,E,C,E,E,G,A,C,E,C,E,E,G,E,E,E,E,E,G,E,O,C,G,C,E,M,C,C,M,C,E,C,M,C,E,A,A,C,C,E,K,I,C,E,G,K,K,C,E,E,E,G,C,E,G,E,E,E,G,C,E,G,I,C,E,K,I,C,E,C,E,K,G,C,G,E,G,C,E,A,U,E,C,E,K,K,C,E,G,E,E,K,I,C,E,G,C,E,C,E,E,E,C,E,G,G,G,ADqvQwE,SAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,OAAA,EAAA,GAAA,GAAA,EAAA,GAAA,CAAA,E,A,C,E,C,E,E,E,K,C,E,K,K,C,K,G,C,A,C,E,C,E,E,I,E,A,C,E,C,E,E,E,E,E,C,E,E,C,E,E,E,E,E,A,C,A,C,E,E,E,C,E,C,E,C,E,E,C,C,E,E,G,E,A,C,E,C,E,E,K,K,C,G,E,K,K,K,C,G,K,I,C,G,I,E,K,G,C,G,G,G,G,C,E,K,G,C,G,G,G,E,G,E,K,K,C,E,G,E,E,K,K,C,E,G,E,I,E,E,I,G,C,G,I,E,C,E,I,C,C,M,C,G,E,G,I,G,K,K,C,A,C,E,E,C,E,G,E,E,G,E,E,K,G,E,E,G,G,E,E,E,E,E,E,I,C,C,M,K,K,C,A,C,E,E,C,E,G,C,G,O,G,G,I,E,E,M,E,G,C,C,E,M,C,E,C,K,C,E,G,E,E,I,C,C,E,M,C,E,C,K,C,E,E,I,C,C,M,C,G,A,G,I,G,E,I,C,C,M,C,G,C,E,E,G,M,A,U,E,M,E,G,E,I,C,S,E,O,C,C,E,O,G,I,C,K,C,I,C,G,C,I,C,G,C,I,C,G,A,E,C,I,C,K,C,I,C,G,C,I,C,G,C,I,C,G,A,E,C,C,W,C,I,E,I,C,K,C,E,I,C,G,C,E,I,C,G,C,G,K,C,Y,I,C,O,C,M,E,E,M,C,C,I,E,A,C,E,C,E,K,G,C,E,M,C,E,G,C,C,G,E,G,C,C,I,C,W,C,E,I,C,S,C,E,I,C,W,C,E,C,C,iB,C,C,C,O,G,E,I,C,K,C,O,C,M,C,I,C,O,C,K,C,M,C,C,C,M,W,G,qB,C,G,C,I,C,C,I,C,C,C,I,C,S,C,C,E,C,I,C,G,C,G,G,E,E,I,C,G,C,G,G,E,E,I,C,sB,E,C,kB,C,I,E,I,C,Y,G,E,E,I,C,K,C,I,C,M,C,E,G,I,C,O,C,K,C,W,E,E,I,C,uB,C,G,O,K,I,C,E,K,G,C,G,E,U,C,C,A,C,E,K,G,C,G,K,G,C,E,G,I,G,C,iB,C,C,C,O,A,O,E,I,I,C,kB,C,A,C,E,I,C,W,A,E,I,C,W,C,C,iB,C,C,C,O,I,C,W,C,I,C,kB,C,G,I,C,W,A,C,C,S,G,C,E,O,E,K,G,C,G,K,K,C,G,M,C,C,G,E,C,S,G,Q,C,C,M,C,S,G,U,C,O,A,C,C,O,W,G,Y,C,C,C,K,C,G,I,C,K,C,K,E,I,C,G,C,K,E,I,C,W,C,K,E,I,C,W,C,C,C,M,C,C,C,C,C,I,E,G,S,C,K,C,K,C,I,C,C,E,E,E,G,A,I,E,C,I,C,K,C,C,E,M,C,O,G,I,E,E,E,I,C,qB,C,G,C,I,C,C,I,C,C,C,I,C,S,C,C,E,C,I,C,G,C,G,G,K,G,C,E,G,K,I,C,G,C,G,G,K,G,C,E,G,K,I,C,O,C,W,E,C,I,C,K,C,C,C,E,I,C,sB,E,C,wB,C,G,C,W,C,C,W,C,C,C,I,C,a,G,E,I,C,G,C,E,I,C,G,C,E,A,G,E,E,E,E,E,A,G,E,E,E,E,E,C,E,I,K,G,C,G,K,K,C,G,I,E,C,I,G,C,G,E,C,E,G,E,G,E,C,E,E,E,K,E,E,E,G,C,E,G,G,E,E,E,K,G,G,E,E,E,I,I,C,K,E,I,C,G,G,I,C,a,E,I,E,I,C,G,C,I,E,E,E,K,I,C,G,C,E,I,C,G,C,C,C,Y,C,I,E,I,C,O,C,E,C,I,I,C,Q,C,I,I,C,Q,A,E,E,A,S,C,C,C,E,I,E,K,K,C,G,E,G,G,E,K,I,C,E,G,C,K,G,C,G,I,E,E,C,E,G,E,G,C,K,G,C,G,K,K,C,G,E,G,K,E,K,K,C,G,I,E,K,K,C,E,K,G,C,G,I,E,E,E,K,G,C,G,K,G,C,I,E,G,E,I,C,C,M,E,M,G,E,G,A,M,G,C,E,E,E,E,G,E,E,C,E,E,K,K,C,E,K,G,C,G,G,G,Q,E,G,I,G,E,E,A,I,E,G,E,G,C,G,O,E,I,C,C,M,E,M,G,E,G,C,E,E,I,E,M,A,U,E,M,E,G,E,I,C,S,E,O,C,C,E,O,G,I,C,K,C,I,C,G,C,I,C,G,C,I,C,G,A,E,C,I,C,K,C,I,C,G,C,I,C,G,C,I,C,G,A,E,C,C,iB,C,C,C,O,A,K,I,E,I,G,E,I,C,K,C,O,C,M,C,I,C,O,C,K,C,M,C,C,W,C,I,E,I,C,G,A,C,K,C,Y,I,C,W,C,G,G,I,C,W,C,G,I,C,G,E,G,E,C,iB,C,C,C,M,A,C,A,K,I,G,A,I,C,G,C,E,I,C,G,A,E,A,O,G,M,G,I,I,C,kB,C,I,I,C,G,C,E,A,C,G,G,I,C,W,A,E,I,C,W,C,C,iB,C,C,C,I,E,I,C,kB,C,G,O,K,G,C,G,I,C,W,C,E,I,C,W,C,C,C,S,G,C,E,I,E,E,K,C,G,E,O,E,E,O,C,C,I,E,G,E,e,E,O,G,E,I,E,E,I,C,I,C,G,I,C,I,E,E,M,A,C,O,C,C,S,G,C,C,C,C,C,C,C,C,C,E,O,I,G,I,E,C,M,E,E,E,I,E,E,C,E,E,G,E,E,C,M,E,E,I,C,E,C,M,E,I,E,C,C,C,S,G,C,C,C,C,C,C,C,E,G,C,I,C,C,C,E,G,E,E,G,C,E,O,C,E,O,C,E,E,Q,C,I,E,E,gB,C,E,G,E,M,C,E,C,C,E,C,E,I,I,E,E,E,E,I,E,E,gB,C,E,G,E,M,C,E,C,C,E,C,C,C,C,G,E,C,c,G,Q,C,C,M,C,S,G,U,C,W,C,M,C,Q,C,C,C,C,C,O,W,G,Y,C,C,C,K,C,G,I,C,O,C,K,E,I,C,O,C,K,E,I,C,W,C,K,E,I,C,Y,C,E,C,I,C,gB,C,E,A,C,e,C,I,E,I,C,Q,C,G,G,I,C,O,E,G,E,I,C,K,C,I,C,Q,C,E,K,C,E,I,C,M,C,I,C,S,C,E,M,A,C,I,C,O,C,K,K,C,I,C,I,C,E,E,E,I,E,I,C,O,C,K,K,C,I,C,G,C,E,E,E,G,E,I,C,W,C,K,K,C,K,G,C,E,G,E,C,qB,C,G,C,I,C,C,I,C,C,C,I,C,S,C,C,E,C,I,C,G,C,G,I,C,M,G,E,E,I,C,G,C,G,I,C,M,G,E,E,I,C,sB,E,C,kB,C,O,K,I,C,I,C,W,C,G,I,C,O,E,C,mB,C,C,C,G,S,C,kB,C,I,C,I,C,G,I,C,Y,C,I,C,S,G,G,C,C,E,K,I,E,G,I,C,O,C,W,C,Q,C,C,E,E,C,I,E,O,G,A,I,E,E,E,G,M,C,C,E,I,I,C,K,C,iB,C,G,C,K,C,I,E,I,C,O,A,C,E,O,E,E,W,C,O,C,A,S,C,E,I,E,C,E,E,I,C,E,Q,C,I,C,E,E,K,C,E,Q,C,K,C,E,E,G,C,E,Q,C,G,C,E,E,M,C,E,Q,C,M,A,E,E,O,M,C,C,E,G,E,E,C,E,E,C,E,E,Y,C,M,C,E,E,O,C,W,C,E,E,iB,C,G,E,E,I,I,E,E,E,E,I,K,E,E,I,E,E,U,C,E,oB,C,G,C,C,C,E,C,E,O,C,I,E,E,gB,C,E,E,W,C,C,C,E,C,G,E,G,E,I,E,G,E,E,G,C,E,G,E,E,Y,C,E,E,E,C,E,C,C,E,ACrvQxE,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,AAAA,CAAA,EAAA,GAAA,CAAA,CAAA,EAAA,IAAA,CAAA,EAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,cAAA,CAAA,EAAA,cAAA,EAAA,EAAA,AAAA,CAAA,EAAA,IAAA,GAAA,GAAA,CAAA,EAAA,EAAA,IAAA,CAAA,CAAA,EAAA,EAAA,EAAA,cAAA,CAAA,EAAA,CAAA,EAAA,IAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAA,EAAA,IAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,AAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAA,AAAA,GAAA,AAAA,CAAA,IAAA,GAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,IAAA,AAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAA,AAAA,GAAA,GAAA,IAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,IAAA,EAAA,EAAA,MAAA,CAAA,EAAA,GAAA,EAAA,EAAA,MAAA,CAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,OAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,EAAA,CAAA,OAAA,CAAA,E,E,A,E,M,C,G,E,E,M,C,A,E,U,A,E,C,C,C,E,C,E,I,E,G,E,a,C,G,G,E,K,K,CDqvQwE,A,EAAA,CAAA,IAAA,EAAA,G,E,G,E,E,C,C,E,C,C,E,K,E,G,E,E,C,C,E,C,C,G,M,A,S,C,C,C,C,C,C,C,C,C,E,I,E,K,G,C,K,G,C,I,E,K,G,C,K,G,C,I,E,E,E,C,C,E,K,C,E,C,C,C,E,A,C,E,C,C,E,K,A,E,E,E,C,C,K,G,C,E,C,C,E,C,C,E,E,E,G,C,E,C,E,C,E,A,C,E,G,C,E,C,A,E,E,E,C,C,K,G,C,E,C,C,E,C,C,E,E,E,K,C,E,C,C,C,E,A,C,E,C,C,E,K,A,E,E,E,C,C,K,G,C,E,C,C,E,C,C,E,E,E,G,C,E,C,E,C,E,A,C,E,G,C,E,C,A,E,E,E,C,C,K,G,C,E,C,C,E,C,C,E,C,E,E,E,E,E,E,C,E,c,C,E,C,C,E,C,C,E,C,C,E,C,C,E,C,C,E,C,C,E,C,C,E,C,E,E,gB,C,A,S,C,C,C,C,C,E,I,E,E,C,E,E,Y,C,M,C,E,E,O,C,E,G,G,E,E,E,W,C,E,E,W,C,iB,C,G,E,E,I,I,E,E,E,E,I,K,E,E,E,E,I,E,E,gB,C,E,E,E,C,C,E,C,G,E,K,K,CAAA,A,G,E,K,C,IAAA,CAAA,IAAA,EAAA,G,E,C,C,E,C,G,E,E,C,C,E,E,C,C,A,K,G,A,M,E,G,E,E,A,C,A,E,K,A,E,E,G,C,G,C,E,G,E,A,I,G,A,M,E,S,A,E,I,O,Q,G,E,E,C,C,E,E,C,C,A,U,E,G,E,A,W,G,C,G,E,C,E,G,E,I,C,C,E,E,C,C,E,E,U,E,K,E,I,E,M,E,E,C,C,O,E,E,C,A,E,C,O,C,E,E,E,E,E,I,E,I,C,c,C,E,E,E,E,C,e,C,C,C,C,C,C,C,C,C,I,C,O,E,K,K,C,A,C,E,C,E,G,I,C,O,E,K,K,C,A,C,E,C,E,G,I,C,W,E,K,G,C,I,C,W,C,E,K,G,C,E,E,E,G,C,c,C,C,C,I,E,G,C,I,C,Y,C,M,E,C,E,E,I,C,O,C,U,E,E,O,G,E,E,G,G,C,8B,C,C,C,G,G,G,O,I,I,E,I,C,W,C,C,I,C,G,C,I,C,G,A,E,O,I,C,O,C,O,C,A,C,I,C,G,C,C,E,E,A,C,E,I,C,G,A,E,C,C,8B,C,C,C,G,G,G,O,I,I,E,E,C,I,C,W,C,C,I,C,G,C,I,C,G,A,C,E,O,I,C,O,C,O,C,I,C,G,C,E,I,C,G,C,C,C,qB,C,C,C,I,E,I,C,Y,E,E,C,G,G,G,E,E,M,C,C,I,E,C,C,E,C,O,G,I,C,U,G,C,M,E,M,E,K,Y,E,C,C,iB,C,C,C,C,E,C,C,C,I,E,I,C,a,C,G,G,E,M,C,E,K,G,C,G,E,I,C,O,C,E,K,G,C,G,E,I,C,O,C,M,C,C,C,yB,C,C,C,C,C,O,I,C,gB,C,E,I,C,6B,C,G,C,gB,C,C,C,O,I,C,wB,C,G,E,I,C,Y,G,C,sB,C,C,C,G,C,K,C,C,I,C,C,M,C,C,O,C,C,C,I,C,gB,C,E,C,M,C,K,E,I,E,M,E,O,C,C,C,gB,C,G,C,gB,C,C,K,C,S,C,C,C,C,I,C,O,C,G,E,C,I,E,I,C,G,A,C,E,I,G,E,S,G,G,I,C,I,C,6B,C,I,C,S,E,E,I,C,Y,C,M,E,E,S,G,E,S,C,E,E,I,G,E,O,E,C,C,U,K,E,E,E,I,E,I,C,G,C,E,I,C,O,C,C,W,C,C,K,C,C,C,E,E,I,C,Y,C,M,C,G,E,W,C,O,E,A,S,C,C,C,E,G,C,I,C,C,Q,C,Y,C,C,C,C,E,I,I,E,E,E,G,E,I,C,I,E,E,U,C,E,oB,C,I,E,G,E,I,E,C,E,C,C,E,C,C,U,C,C,K,C,C,I,C,C,M,C,C,O,C,C,C,E,gB,C,E,C,C,c,C,C,C,E,G,C,G,G,C,I,E,G,E,Y,E,E,G,E,e,C,C,E,S,C,E,I,E,E,E,I,C,E,E,E,G,C,E,E,E,E,K,C,E,E,E,E,M,A,C,O,M,C,G,I,C,A,G,A,I,G,C,E,S,G,G,E,C,E,E,E,E,E,E,E,E,O,C,G,E,I,E,E,E,Q,C,E,E,E,E,C,G,E,E,Y,C,E,C,E,E,E,U,C,E,E,C,M,E,K,C,U,E,a,Q,E,C,E,I,C,G,E,O,E,I,C,K,C,O,C,C,E,K,G,A,I,E,C,E,I,C,6B,C,E,K,E,I,E,E,U,C,I,C,U,C,E,I,A,C,S,C,C,C,C,C,C,C,E,I,E,E,G,C,E,E,Q,C,C,M,C,C,U,C,C,C,C,C,C,A,G,C,G,G,I,C,E,C,G,C,E,I,G,E,W,C,E,E,S,C,E,E,W,C,E,U,E,E,c,C,E,gB,C,E,S,G,G,E,E,E,G,E,S,G,E,M,G,E,O,E,C,C,E,I,C,E,E,E,C,G,E,O,C,C,I,E,I,G,E,E,E,G,E,I,C,I,E,E,U,C,I,C,oB,C,I,C,M,C,C,U,C,C,C,C,C,G,G,C,E,S,C,E,E,W,C,E,E,W,C,E,U,E,E,c,C,E,gB,C,E,I,C,6B,C,E,K,C,O,C,I,C,G,C,I,C,G,E,E,I,C,gB,C,E,G,E,S,G,E,M,C,I,C,O,C,I,C,O,E,E,M,C,E,C,C,E,C,E,E,M,E,C,C,E,O,E,C,C,Y,C,C,Y,K,E,E,I,E,I,C,G,C,E,I,C,O,C,E,E,K,C,G,C,E,O,C,O,I,E,I,C,a,C,E,C,E,I,G,E,S,C,I,C,O,C,I,C,O,E,E,M,C,G,E,S,C,S,E,Y,C,S,I,C,K,C,O,C,C,E,K,G,A,I,G,C,E,O,C,O,I,E,E,U,C,I,C,U,C,I,E,G,E,I,E,G,E,I,C,6B,C,I,C,K,C,E,C,K,E,E,iB,C,C,E,I,C,E,M,C,E,E,W,C,E,K,E,K,C,E,S,C,E,a,C,I,E,G,E,e,E,E,Q,C,C,E,E,E,I,C,C,E,E,I,C,E,E,G,C,E,E,K,C,E,I,C,E,M,C,C,G,E,E,K,C,E,C,E,E,C,M,E,K,A,E,G,E,O,E,C,W,C,C,C,G,E,C,e,G,Q,C,C,Q,C,E,Q,C,E,S,Y,W,C,Q,C,E,U,E,W,E,C,iB,C,E,K,C,S,C,C,E,W,E,M,C,kB,C,E,S,G,U,C,O,A,E,Y,C,c,K,E,gB,E,Q,C,E,K,C,K,E,E,S,A,G,E,Q,E,kB,C,C,C,E,G,a,C,C,mB,c,oB,Q,c,O,E,G,W,C,C,W,C,U,M,C,E,I,G,C,Y,C,O,C,E,K,E,M,G,E,O,C,O,C,E,K,I,M,E,E,O,C,O,C,E,K,I,M,E,E,K,C,O,C,E,K,K,M,E,E,I,C,O,C,E,K,M,M,E,E,K,C,O,C,E,K,O,M,C,E,M,C,O,C,E,K,O,M,E,E,Q,C,O,C,E,K,O,M,C,E,K,C,O,C,E,K,M,C,E,G,O,I,C,I,S,G,C,C,C,E,O,E,C,C,S,G,C,C,C,E,G,G,G,O,K,I,E,E,Q,C,C,O,C,C,M,C,C,W,C,C,C,E,U,C,E,E,M,A,Y,O,G,C,E,E,E,E,G,I,C,E,A,U,O,E,E,K,C,E,G,E,K,C,E,E,A,O,E,K,C,G,C,E,A,S,G,C,G,I,A,C,I,C,E,E,O,C,E,U,G,E,O,C,E,E,E,C,C,C,C,S,G,C,C,C,C,C,C,C,E,I,E,G,M,C,I,I,E,G,O,C,G,E,E,E,E,E,C,I,E,E,C,E,C,E,C,C,E,E,K,C,E,K,C,O,gB,C,G,E,M,E,K,I,C,A,C,E,C,E,C,E,E,I,A,I,E,O,E,C,E,A,C,O,E,C,E,E,A,C,S,G,C,C,C,C,C,E,G,E,C,G,E,M,C,C,G,C,G,C,C,G,C,C,C,G,E,G,E,C,C,E,E,E,C,C,E,C,C,C,E,A,C,C,C,E,C,C,C,C,M,C,C,E,C,C,C,C,S,G,C,C,C,C,C,M,E,E,I,E,E,C,E,C,E,E,E,M,C,I,E,E,E,E,E,E,A,C,C,E,C,C,E,C,C,E,E,I,C,C,M,E,M,C,C,G,O,A,I,G,E,A,S,C,C,C,C,C,C,C,M,E,E,I,E,E,Q,C,E,C,E,O,C,C,C,E,C,K,C,G,E,C,C,E,M,C,E,C,K,C,I,E,E,G,E,E,C,E,G,C,E,E,G,A,C,E,C,C,E,A,G,G,C,C,C,E,C,K,C,C,C,E,O,C,E,E,E,E,G,C,C,M,W,G,Y,C,C,C,K,C,G,I,C,M,C,C,K,E,C,O,E,C,I,E,A,E,I,C,K,C,M,I,C,U,C,K,E,I,C,Q,C,C,E,I,C,W,C,C,E,I,C,U,C,K,C,C,K,C,C,C,C,C,I,E,E,I,E,C,E,I,C,C,C,E,E,I,C,Q,C,I,G,K,C,E,Q,C,I,C,C,E,I,C,G,G,E,c,C,E,O,I,I,C,U,C,C,O,E,M,C,M,E,K,C,W,E,U,A,E,K,C,K,G,I,C,W,C,E,U,A,C,M,C,C,C,C,C,O,A,K,I,E,K,G,I,C,E,C,c,C,K,C,e,I,C,M,C,C,K,E,C,O,E,C,I,E,A,C,C,qB,C,I,E,I,C,O,C,E,I,C,Q,C,E,E,I,C,I,E,M,C,I,C,C,I,C,C,W,C,C,W,C,C,C,I,C,a,G,S,E,C,E,A,G,M,E,G,G,C,E,K,G,C,E,E,G,C,E,A,G,M,E,G,G,C,E,K,G,C,E,E,G,C,C,C,A,G,G,C,E,I,C,e,I,A,C,A,U,E,M,E,A,W,E,K,C,M,A,G,E,I,C,S,C,C,G,E,E,G,I,C,M,G,E,C,E,O,C,K,G,G,G,E,G,I,C,M,G,E,C,E,K,C,K,G,G,G,E,I,C,G,C,K,G,C,E,E,G,I,C,G,C,K,G,C,E,E,E,C,iB,C,I,E,I,C,kB,G,E,O,iB,C,E,O,iB,C,O,E,M,E,C,E,C,C,E,C,E,C,C,E,M,C,E,A,E,C,I,E,I,C,C,C,Y,C,I,E,I,C,O,C,E,E,I,C,E,E,K,C,E,A,W,E,M,C,I,C,kB,G,I,C,S,E,A,C,U,E,M,E,E,M,E,C,I,C,G,C,I,C,Q,E,C,C,E,C,I,C,G,C,I,C,Q,E,C,C,E,M,C,E,A,E,I,E,I,C,G,C,E,I,C,G,C,E,AAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,KAAA,EAAA,GAAA,CAAA,CAAA,EAAA,CAAA,GAAA,IAAA,KAAA,EAAA,GAAA,CAAA,CAAA,EAAA,EAAA,CAAA,GAAA,IAAA,OAAA,EAAA,GAAA,EAAA,EAAA,MAAA,CAAA,EAAA,KAAA,CAAA,EAAA,GAAA,CAAA,E,E,E,G,O,I,C,K,C,E,I,E,C,E,Q,C,G,E,O,C,I,C,G,C,I,C,G,C,I,C,iB,C,I,A,S,C,C,C,C,C,C,C,C,C,E,I,I,E,G,M,C,E,G,G,O,C,G,I,C,I,E,E,C,E,C,G,E,C,E,C,M,E,E,Q,C,I,C,E,E,I,E,E,O,C,C,O,E,C,E,G,O,C,G,E,A,E,I,C,E,M,C,E,O,C,I,C,G,C,I,C,G,C,E,I,C,U,C,A,E,K,C,O,E,A,S,I,C,K,C,A,S,C,E,I,I,E,G,O,C,G,E,E,G,M,C,E,E,E,E,G,E,C,E,C,E,C,C,M,C,O,E,C,E,A,E,I,C,K,E,K,E,I,C,W,C,G,E,O,E,E,O,G,G,I,C,E,I,C,U,C,C,e,C,I,C,O,C,mB,E,I,C,W,C,I,C,K,C,G,C,A,G,C,E,K,E,C,Y,C,C,C,I,E,E,E,E,E,C,C,I,C,O,C,M,E,E,M,E,C,E,I,C,kB,C,C,C,E,E,E,A,I,E,M,C,E,E,A,C,I,C,kB,C,C,C,E,E,C,E,E,E,I,C,kB,C,C,C,E,M,C,E,E,E,A,I,E,M,C,E,A,C,E,I,C,kB,C,C,C,E,M,C,E,C,E,C,E,I,E,E,M,C,E,G,G,C,E,G,E,E,G,E,G,E,E,G,I,C,Q,C,C,M,E,I,E,O,E,C,E,E,C,C,C,C,W,C,I,E,I,C,Q,C,E,I,C,G,C,E,I,C,G,C,E,I,C,O,C,E,E,I,C,E,E,I,E,G,E,O,C,E,E,I,C,iB,C,I,E,G,E,Q,C,G,E,A,S,G,E,U,C,E,G,I,A,C,I,E,E,C,E,E,E,E,E,G,G,C,E,C,E,O,C,E,U,E,E,E,C,E,O,C,E,E,M,G,E,I,C,E,E,G,I,E,M,A,M,E,Q,E,uC,E,I,G,I,E,A,S,E,K,C,M,E,I,C,iB,G,I,E,E,E,E,E,E,E,C,E,G,C,E,E,G,I,G,E,E,G,M,A,C,I,G,A,U,E,M,E,A,I,C,G,G,E,E,G,O,I,C,G,I,C,C,E,I,E,G,G,C,A,G,C,E,C,iB,C,C,C,I,E,I,C,Q,C,E,I,C,O,C,I,C,O,E,a,C,E,M,C,E,E,a,E,E,M,C,E,E,c,C,Q,C,C,oB,C,C,C,C,C,C,C,C,C,I,E,I,C,O,C,E,E,I,C,c,C,E,I,C,K,C,E,I,C,U,C,E,G,C,C,E,C,E,G,C,C,E,C,E,C,C,E,C,E,G,G,G,E,K,C,E,I,C,Q,C,M,C,E,G,C,E,E,C,G,E,E,K,C,Q,C,O,E,G,E,C,E,E,E,C,I,E,C,C,mB,C,C,C,I,E,E,E,I,E,E,E,E,M,C,E,E,E,E,A,C,E,C,C,E,A,E,K,C,I,C,mB,C,E,K,C,E,E,C,mB,C,C,C,O,A,O,E,I,A,C,E,I,C,G,A,E,C,I,C,G,C,I,C,G,A,C,C,iB,C,C,C,I,E,I,C,Q,C,E,I,C,kB,C,G,O,I,C,kB,C,A,C,E,K,C,C,E,E,M,C,C,iB,C,C,C,I,E,I,C,Q,C,E,I,C,kB,C,G,E,M,C,E,G,C,O,I,C,G,C,E,C,I,C,G,C,I,C,G,A,C,C,c,C,C,C,I,E,I,C,O,C,K,C,E,I,C,G,C,W,C,G,K,C,E,G,I,C,Y,G,E,W,C,E,W,E,E,K,G,C,G,E,K,G,C,G,E,I,C,uB,C,G,I,C,M,C,E,E,E,E,E,E,E,E,E,C,C,C,kB,C,C,C,I,E,I,C,O,C,I,C,E,E,c,C,E,C,C,E,I,C,E,E,W,C,E,I,C,mB,C,E,E,G,I,C,C,E,C,I,C,U,E,G,E,I,C,a,C,G,E,K,K,C,I,C,Y,G,I,C,K,C,E,C,C,I,C,M,C,E,C,E,E,O,E,E,E,C,C,mB,C,I,E,I,C,M,C,I,E,E,C,E,E,G,E,M,C,O,E,I,E,I,C,uB,G,G,I,C,W,E,E,M,C,O,I,C,M,C,I,C,C,C,E,C,U,C,kB,C,I,E,I,E,E,E,E,M,C,E,E,E,E,E,E,M,C,C,C,E,C,U,C,kB,C,I,G,O,I,C,M,C,I,C,I,C,S,C,E,C,oB,K,E,E,I,E,I,C,M,C,M,E,E,C,G,E,M,C,O,E,I,E,I,C,S,G,I,E,E,E,E,M,C,E,E,E,E,E,I,C,G,I,C,C,C,E,G,O,I,C,M,C,M,C,I,C,W,C,E,I,C,S,C,E,C,U,C,C,C,O,G,E,I,C,I,C,C,S,G,C,C,C,C,C,E,I,E,E,E,E,M,C,E,E,E,E,C,C,E,C,G,C,C,E,C,G,E,G,C,C,E,C,G,E,C,C,G,C,C,G,C,C,C,G,E,M,E,E,C,I,C,C,K,C,C,C,C,C,E,C,C,I,C,C,K,C,C,C,C,C,E,A,E,C,G,C,C,E,C,I,E,G,C,C,E,C,I,E,C,C,G,C,C,G,C,C,C,G,E,O,E,E,C,K,C,C,I,C,C,C,C,C,E,C,C,K,C,C,I,C,C,C,C,C,E,A,E,I,E,E,E,O,E,E,A,C,E,C,E,C,E,C,E,E,C,C,G,E,C,O,G,Q,C,C,O,O,S,C,E,K,C,O,C,E,K,C,E,M,C,E,W,C,E,Q,c,e,C,C,E,M,C,O,O,M,C,Q,C,C,C,C,C,O,W,G,Y,C,C,C,K,C,G,I,C,M,C,E,C,I,C,O,C,K,E,I,C,W,C,K,C,C,a,C,I,E,I,C,sB,G,E,I,C,M,C,I,C,gB,C,E,C,I,C,O,C,G,E,I,C,G,E,I,C,W,C,G,E,I,C,G,E,I,C,O,C,K,C,Y,E,C,iB,C,C,K,E,E,E,G,C,I,C,C,I,C,C,C,I,C,E,E,C,E,E,C,I,E,E,E,E,M,C,E,E,E,E,A,C,E,C,C,E,A,G,G,G,G,E,I,C,G,G,E,M,C,E,M,C,C,K,E,I,C,E,C,K,E,I,C,E,C,I,E,E,E,E,M,C,E,E,E,E,K,K,C,A,C,A,C,C,E,E,C,C,C,E,E,A,E,K,C,E,C,C,E,A,G,E,I,C,C,K,E,I,E,C,E,C,C,G,O,C,C,wB,C,I,E,I,C,M,C,G,E,E,C,G,E,M,C,O,E,I,E,I,C,iB,G,E,I,C,kB,G,O,A,E,E,M,E,E,M,C,I,C,S,C,E,M,C,I,E,M,C,E,E,E,I,C,M,C,G,C,C,C,mB,C,C,C,M,A,C,G,I,C,M,C,G,I,C,O,A,E,I,C,W,A,C,iB,C,C,C,I,E,I,C,Q,C,E,I,C,kB,C,G,E,M,C,E,G,C,O,G,I,C,M,C,E,I,C,W,C,I,C,O,C,C,E,C,C,G,E,C,a,G,Q,C,G,Q,C,I,G,O,M,C,C,U,K,c,G,Y,G,iB,G,kB,G,U,G,gB,E,G,I,G,O,M,C,O,c,C,C,U,K,U,G,W,G,W,G,c,G,W,G,a,G,c,G,iB,G,c,G,M,G,kB,G,W,G,Y,G,mB,G,Q,G,O,G,Y,G,O,G,e,G,Y,G,Y,G,iB,G,c,G,a,G,oB,G,gB,G,kB,G,M,G,kB,G,S,G,M,G,U,G,gB,G,M,G,Q,G,U,G,gB,G,S,G,Y,G,S,G,S,G,Q,G,Q,G,c,C,G,G,G,G,C,S,G,O,E,E,O,W,C,C,M,Q,I,I,G,W,G,A,I,O,O,C,G,O,gB,C,O,O,gB,C,I,E,O,M,C,G,E,M,A,C,E,U,E,C,E,C,E,W,E,C,C,C,O,C,I,G,C,Y,S,C,E,I,E,E,E,C,I,E,E,C,M,C,G,E,M,E,A,U,M,C,E,E,G,E,E,E,O,C,K,C,E,E,K,C,C;A,C,G,M,O,C,G,E,I,C,K,C,E,G,G,I,E,O,C,G,G,O,C,E,S,S,C,C,C,C,C,E,I,E,E,E,C,M,C,G,E,E,M,C,E,E,I,C,E,E,I,E,I,C,E,M,C,E,E,E,E,E,E,E,K,G,C,E,W,C,C,C,E,E,K,C,G,O,E,I,C,E,C,O,E,E,U,C,M,C,C,E,M,S,C,C,C,C,C,E,O,K,G,C,E,K,G,C,E,G,E,U,S,C,C,C,E,I,E,E,E,E,E,E,K,G,E,E,C,I,E,E,E,E,M,C,E,E,E,E,E,C,C,E,C,A,K,C,E,E,O,C,E,E,E,I,C,C,E,E,E,E,M,C,E,G,I,E,E,E,E,M,C,E,E,E,E,E,I,C,C,C,C,E,C,G,E,O,C,E,U,S,C,E,O,K,K,C,E,I,E,C,E,S,G,C,C,C,E,I,E,E,C,C,E,E,C,C,G,A,O,E,M,C,E,E,E,E,E,G,A,O,E,M,C,E,E,E,C,E,I,E,E,C,C,E,E,E,C,C,E,E,K,I,C,E,E,E,G,M,C,E,E,E,E,E,E,E,E,E,E,C,C,S,G,C,C,C,C,C,E,I,E,E,O,E,E,I,C,G,E,E,E,K,E,C,G,C,E,E,E,G,C,G,E,E,E,M,E,C,G,C,E,C,C,S,G,C,C,C,E,I,E,E,E,E,M,C,E,E,O,E,K,E,C,E,A,S,C,C,C,E,I,I,E,E,E,E,E,E,C,E,E,E,C,E,E,E,C,E,E,E,C,E,G,E,E,G,E,G,E,E,G,C,C,C,C,E,C,G,E,C,G,A,A,E,C,E,G,C,E,C,E,E,A,C,E,C,E,C,E,G,C,C,E,C,E,C,E,E,E,G,A,E,A,E,E,C,E,E,A,C,E,C,E,C,E,M,C,C,E,C,E,C,E,E,E,M,A,E,A,E,E,C,E,E,A,C,E,C,E,C,E,K,C,C,E,C,E,C,E,E,E,K,A,E,A,E,G,C,E,E,A,C,E,C,E,C,E,I,C,C,E,C,E,C,E,E,E,I,A,E,I,E,E,G,E,E,E,E,G,E,G,E,E,E,E,G,M,C,G,E,G,E,G,E,G,C,C,E,E,E,I,C,E,A,U,E,C,E,E,E,C,E,E,E,A,E,A,Q,E,C,E,E,E,C,E,E,E,A,E,C,E,A,C,E,E,C,E,E,A,E,E,E,A,C,E,E,C,E,E,A,E,C,E,A,S,C,C,C,C,C,C,C,C,C,E,O,G,I,S,E,E,E,K,K,S,E,E,E,E,K,K,Q,E,E,E,E,K,K,O,E,G,E,E,K,K,M,E,E,E,G,K,K,Q,E,C,E,E,C,E,K,K,M,K,S,G,K,E,C,I,E,K,G,C,G,E,K,G,C,E,C,M,C,E,E,E,E,G,E,G,C,C,E,E,E,E,E,C,E,E,C,E,K,C,C,I,G,C,I,S,C,C,C,E,I,E,A,C,E,U,C,E,Q,A,E,E,E,K,G,C,G,E,K,G,C,G,E,E,W,C,E,E,W,C,O,G,C,G,E,C,C,E,E,G,E,C,C,E,E,G,E,C,C,E,E,G,E,C,C,E,E,G,E,G,C,E,E,E,M,S,C,C,C,E,I,E,G,E,E,M,E,E,E,C,C,E,O,C,M,C,E,E,C,C,E,O,C,M,C,O,G,C,G,E,C,C,E,G,E,C,C,E,G,E,C,C,E,G,E,C,C,E,G,E,C,C,G,E,C,A,E,E,E,I,S,C,C,C,E,I,E,G,E,E,M,E,E,E,C,C,E,E,C,C,E,E,E,E,O,E,U,C,C,E,K,G,C,E,C,C,E,I,E,E,K,G,C,E,I,C,E,C,C,E,C,E,K,G,C,E,C,C,E,I,E,E,K,G,C,E,I,C,E,C,C,E,G,C,G,E,G,E,E,G,E,E,G,E,G,E,C,C,G,E,C,A,E,E,E,S,S,C,C,C,E,I,E,G,E,E,M,E,O,G,C,G,E,C,C,G,E,C,C,G,E,C,C,C,E,K,E,C,E,G,E,C,C,C,E,M,E,C,E,G,E,C,C,G,E,C,A,E,E,C,E,G,G,S,C,G,S,C,C,C,C,C,C,C,E,A,I,C,O,C,E,A,I,C,M,C,E,A,I,C,M,C,K,A,I,C,M,C,K,A,I,C,I,C,E,A,I,C,G,C,C,E,G,G,S,C,C,U,S,C,C,C,C,C,C,C,E,I,E,E,A,I,C,M,C,E,G,G,C,E,I,C,C,E,C,E,I,E,G,C,E,K,C,G,K,C,C,E,G,M,C,M,G,C,E,K,C,S,C,E,G,O,G,C,E,M,C,S,C,E,G,K,E,K,C,S,C,gB,G,C,E,e,C,K,C,E,G,Y,G,C,E,W,C,K,C,E,G,a,G,C,E,Y,C,E,C,E,G,Y,G,C,E,W,C,E,C,E,G,M,G,C,E,K,C,C,E,C,E,G,K,G,C,E,I,C,C,E,C,E,G,M,E,Q,E,K,E,M,E,O,G,C,E,M,C,E,C,E,G,Q,G,C,E,O,C,E,C,E,G,O,A,S,C,C,C,E,I,E,E,K,C,c,C,E,Y,E,M,C,G,C,E,O,K,G,A,K,I,E,O,E,A,K,I,E,O,C,M,C,E,E,O,C,E,E,O,A,E,I,E,E,Y,G,O,E,U,C,C,E,E,E,I,E,C,E,K,E,C,C,E,A,I,C,G,C,G,Q,G,G,C,E,O,C,E,C,E,I,W,C,E,A,I,C,G,Y,G,G,G,C,a,G,G,K,C,a,G,G,G,C,G,Q,C,S,G,C,E,Q,C,E,C,E,G,C,K,E,C,G,E,K,G,Q,C,A,I,C,I,C,E,G,U,G,C,E,S,C,Q,C,E,G,e,G,C,E,c,C,E,C,E,G,gB,G,C,E,e,C,E,C,E,G,gB,G,C,E,e,C,E,C,E,G,gB,G,C,E,e,C,E,C,E,E,C,E,O,S,C,E,I,E,E,E,E,E,E,E,E,E,E,E,K,E,K,E,A,I,C,M,C,E,A,I,C,O,C,E,G,C,E,O,C,C,E,C,E,E,C,G,C,E,E,O,C,I,C,E,C,A,C,E,G,E,G,G,E,S,C,C,E,E,E,I,E,C,G,W,C,E,E,M,E,C,A,E,C,E,E,A,I,C,S,C,E,E,E,I,W,E,E,E,E,O,C,E,E,I,C,M,C,E,E,E,E,I,C,K,E,E,E,C,E,E,E,C,M,C,E,E,E,I,C,E,E,E,E,G,C,E,E,E,E,K,C,A,E,E,E,E,E,M,C,A,E,C,E,K,C,E,E,E,E,E,E,E,C,C,C,C,E,A,I,C,M,C,E,A,I,C,M,C,C,E,S,W,O,I,C,M,C,I,C,M,C,K,C,C,C,E,S,W,O,I,C,M,C,I,C,M,C,Q,C,C,E,Q,W,O,I,C,M,E,I,C,M,C,O,A,E,M,W,O,I,C,M,A,E,K,S,C,C,C,E,I,E,E,E,E,E,E,E,G,C,E,A,I,C,M,C,E,A,I,C,M,A,C,I,C,O,I,C,E,I,G,E,I,E,C,E,E,I,C,E,S,G,E,I,C,E,I,C,E,G,C,E,K,C,E,I,C,E,M,C,E,G,E,E,I,E,E,E,W,C,G,K,C,E,E,O,C,G,E,S,C,G,E,C,E,G,E,C,G,E,M,C,E,Q,E,E,E,K,C,E,A,E,e,C,E,A,E,W,C,E,A,E,W,C,C,A,G,A,G,C,G,C,A,E,S,G,A,S,C,C,C,C,C,C,C,C,C,C,C,E,I,E,K,E,C,E,G,E,C,I,E,K,G,C,E,E,E,E,G,E,E,E,E,E,E,E,E,E,E,E,E,E,C,C,E,M,C,E,G,E,G,E,E,C,E,G,C,E,E,E,C,K,E,C,C,G,E,G,C,E,E,E,C,E,G,E,G,C,E,E,E,E,G,E,G,C,E,E,E,E,K,E,C,E,E,E,C,E,M,C,E,G,E,G,C,E,E,E,C,E,G,E,G,C,E,E,E,E,K,E,C,E,E,E,E,C,E,G,C,E,E,E,C,K,E,C,G,E,G,C,E,E,E,E,K,E,C,E,E,G,C,E,E,E,C,K,E,C,K,E,E,E,S,G,E,M,C,E,E,M,E,I,C,E,E,E,E,E,E,G,E,C,E,E,E,G,E,C,E,E,E,G,E,C,E,E,G,E,C,E,E,A,E,Y,E,A,E,S,G,G,C,A,E,S,C,E,A,E,I,E,E,G,G,C,A,E,W,C,E,A,E,S,C,E,A,E,Q,C,Q,A,E,M,E,C,E,A,S,C,C,C,C,C,C,C,E,I,E,E,E,E,E,E,E,E,S,C,E,E,K,C,E,C,C,E,E,E,I,C,E,E,M,C,E,E,e,C,E,E,e,C,E,G,E,G,C,C,C,G,C,G,C,C,E,I,A,E,E,E,A,E,U,C,E,E,C,C,E,E,C,C,E,E,C,C,E,E,A,W,E,G,E,E,A,C,A,Q,G,A,U,C,G,C,G,C,E,E,C,E,E,E,E,E,E,E,C,E,E,I,C,E,M,C,E,S,C,E,E,Y,C,S,E,U,C,E,c,C,E,W,C,E,e,C,G,C,E,S,C,C,E,G,C,E,Q,C,Q,E,S,C,E,E,W,C,C,E,E,E,E,E,M,C,E,E,E,G,A,S,C,C,C,C,C,E,I,E,E,U,C,E,E,O,C,E,G,E,C,E,E,G,E,C,E,E,G,E,C,C,C,G,E,U,C,E,E,E,G,E,M,E,C,G,G,C,E,U,C,C,E,E,Q,C,E,E,E,G,G,G,C,E,U,C,C,C,C,E,E,C,C,E,C,C,Q,E,O,E,E,E,C,C,E,E,C,C,E,E,C,C,E,C,C,C,E,E,E,E,K,C,E,I,C,G,E,O,E,C,C,G,I,G,O,gB,E,kB,G,O,gB,E,iB,S,G,C,C,C,C,C,E,I,E,K,G,C,G,E,K,G,C,G,E,E,C,C,E,E,C,C,M,C,E,E,E,C,E,C,C,C,E,E,C,E,C,C,C,E,E,E,E,C,E,C,C,C,E,E,C,E,C,C,C,C,C,C,S,G,C,C,C,E,I,E,E,E,E,E,E,G,E,G,E,E,M,C,I,E,E,E,E,M,C,E,E,A,E,A,C,E,C,C,E,A,E,C,C,E,C,C,E,E,C,C,E,C,C,E,K,G,C,E,E,E,E,C,E,E,E,C,G,E,K,G,C,E,G,M,C,I,E,I,C,C,C,S,G,C,C,C,E,I,E,E,C,C,E,C,C,E,E,C,C,E,C,C,E,K,I,C,E,E,E,G,M,C,G,A,C,E,C,C,E,C,A,E,E,G,A,C,E,C,C,E,C,A,E,E,O,E,G,C,C,C,I,G,W,I,C,S,C,E,I,C,K,C,C,E,E,E,E,E,E,E,C,C,E,S,G,C,C,C,C,C,E,I,E,E,U,C,E,G,E,E,E,C,E,E,E,C,G,C,G,C,E,M,C,E,E,C,C,E,E,C,A,E,I,E,E,C,C,E,E,C,C,E,E,Q,C,E,K,G,C,E,E,K,G,C,I,K,G,C,E,E,K,G,C,I,E,K,G,C,E,E,K,G,C,I,K,G,C,E,E,K,G,C,I,E,E,K,G,C,K,G,C,G,K,G,C,I,O,G,E,E,G,E,E,G,E,M,C,E,G,E,M,C,E,C,E,E,C,C,E,E,E,C,C,C,C,C,G,G,S,C,C,O,W,I,E,I,C,K,C,M,C,E,E,C,C,E,C,C,E,E,E,C,C,E,C,C,C,C,E,O,S,C,C,C,C,C,E,I,C,S,C,E,I,C,K,C,C,E,E,C,C,E,C,C,E,E,C,C,E,C,C,E,E,C,C,E,E,C,A,C,E,S,S,C,E,I,E,A,I,C,K,C,M,C,C,A,C,E,G,E,A,I,C,M,G,C,A,I,C,S,C,E,C,C,E,C,C,G,E,C,C,E,C,C,G,E,C,C,E,C,C,E,C,C,G,E,C,C,E,C,C,E,C,C,C,C,E,W,S,C,E,I,E,E,E,E,I,C,O,G,E,E,O,G,E,C,G,C,C,E,C,C,C,E,E,G,C,C,E,C,C,C,E,E,C,I,I,C,S,G,E,S,E,E,I,C,G,C,C,E,C,C,C,E,E,G,C,C,E,C,C,C,E,G,E,E,E,E,M,C,E,E,G,E,G,E,C,C,E,E,E,G,E,C,C,E,E,E,G,C,E,G,E,E,G,C,E,G,C,M,C,E,M,C,C,E,Q,W,I,E,A,I,C,K,C,E,A,I,C,S,C,E,A,I,C,M,G,M,C,G,C,E,E,C,C,E,E,C,A,E,E,G,G,C,E,E,C,C,E,C,C,E,E,C,A,E,E,G,G,C,E,E,C,C,E,C,C,E,E,C,C,E,C,A,E,E,G,G,C,E,E,C,C,E,E,C,C,E,C,A,E,E,G,A,C,G,I,G,C,Q,S,C,E,I,E,E,E,E,E,E,E,C,I,E,E,E,E,M,C,E,E,E,E,I,E,E,E,C,C,E,C,M,C,E,E,E,E,E,C,C,E,C,E,C,E,I,C,G,E,O,C,C,K,I,G,S,C,E,S,C,E,K,E,K,E,M,A,E,O,E,I,C,S,C,C,C,E,I,E,E,O,C,E,E,O,C,O,E,I,G,E,I,C,E,I,C,E,I,C,E,I,C,E,I,A,G,I,C,M,C,G,C,E,O,S,C,E,I,E,E,E,E,E,E,C,E,I,E,E,E,E,M,C,E,E,E,E,A,E,A,C,E,C,C,E,A,E,K,G,A,C,E,E,O,A,E,Q,C,G,A,S,E,O,C,E,Q,C,E,O,G,G,E,Q,A,C,G,A,S,C,E,I,E,E,E,E,E,E,E,I,E,E,E,E,M,C,E,E,E,E,A,C,E,A,C,E,C,C,E,A,E,O,A,E,Q,E,C,E,I,M,E,G,C,C,I,C,E,I,E,Q,C,C,E,C,C,E,C,E,A,G,E,E,Q,G,E,G,E,E,K,G,G,E,I,C,M,C,E,E,E,Q,G,G,A,S,C,C,C,E,I,E,E,E,E,I,E,E,M,C,E,G,E,E,E,I,E,C,C,E,C,O,C,E,E,E,G,G,E,Q,C,E,E,A,C,E,C,C,E,C,O,A,E,Q,E,E,I,C,U,C,E,I,G,E,E,E,E,E,S,C,C,C,E,I,E,E,Q,C,E,E,Q,A,C,G,G,E,E,Q,C,C,E,G,C,E,Q,C,C,C,C,E,E,E,E,O,S,C,C,C,E,I,E,E,I,E,E,M,C,E,G,E,E,E,G,A,C,E,C,C,E,C,O,A,G,E,Q,E,E,I,C,Q,C,G,O,C,C,E,C,O,I,E,K,S,C,C,C,E,I,E,E,E,E,E,E,I,E,E,E,E,M,C,E,E,E,E,A,C,E,A,C,E,C,C,E,A,E,O,A,E,Q,E,C,E,E,Q,G,E,G,E,G,C,E,K,G,G,E,I,C,M,C,E,E,E,Q,I,E,I,C,E,E,C,C,E,G,c,G,W,S,G,C,C,C,C,C,C,C,E,G,E,C,I,E,E,E,Q,C,E,E,O,A,C,C,C,E,I,C,E,C,E,C,C,E,I,C,C,E,I,C,A,G,A,C,I,G,E,C,E,E,G,C,C,C,G,C,M,C,C,E,E,M,C,E,C,C,C,I,G,O,M,C,O,c,C,C,U,K,Q,C,G,a,S,C,M,S,O,S,gB,K,Y,K,a,E,Y,E,M,C,E,K,C,E,M,K,E,Q,C,E,K,C,O,K,E,W,I,K,K,E,M,K,E,O,I,E,U,S,C,E,G,G,G,O,K,I,E,E,E,E,E,G,G,I,G,G,E,K,G,G,G,E,C,E,I,E,G,E,O,I,C,G,E,E,E,E,M,C,E,E,E,E,G,A,C,A,I,E,K,E,E,C,C,E,C,K,C,C,C,C,E,C,M,E,E,C,M,E,E,K,C,M,G,C,E,O,K,E,U,C,E,O,E,Q,E,Q,C,I,E,M,E,O,E,K,C,E,S,E,U,Q,gB,K,E,gB,E,e,E,gB,K,C,E,W,S,C,E,C,C,G,C,C,S,E,A,C,E,a,S,C,E,I,E,C,C,G,A,C,E,S,C,C,E,E,U,C,C,E,E,S,C,E,C,E,O,C,E,A,E,mB,S,C,C,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,K,C,E,C,C,G,C,E,E,S,C,E,C,E,C,E,E,gB,C,G,E,E,I,C,Q,C,E,C,G,E,E,E,A,E,U,C,E,C,E,E,E,C,A,C,I,E,K,C,A,C,I,G,C,E,C,C,E,E,O,I,C,E,A,C,E,G,C,E,C,E,E,C,E,M,E,C,G,O,E,M,C,E,M,C,E,O,C,S,C,E,C,C,E,E,E,I,C,G,C,E,C,E,C,C,E,C,C,K,C,E,E,G,E,I,C,G,E,E,M,C,S,C,C,C,E,O,G,E,S,E,C,E,S,C,C,C,E,C,C,E,C,C,C,E,E,C,E,C,C,E,C,E,I,E,G,C,C,G,O,E,S,C,C,E,C,G,C,O,E,U,C,C,G,E,E,I,C,I,E,E,C,E,E,G,C,I,E,I,G,E,E,E,E,M,C,E,E,E,E,G,A,C,E,C,C,E,A,C,C,G,C,E,C,G,G,E,iB,C,I,C,E,I,C,I,E,E,E,E,M,C,M,C,E,E,E,E,A,E,A,C,E,E,M,C,E,A,E,I,C,A,C,E,I,G,E,E,E,E,E,O,C,C,K,E,K,G,E,E,E,Q,C,C,O,C,E,M,E,U,E,Q,E,a,C,E,E,M,C,E,Q,E,C,C,G,C,I,C,G,E,I,C,E,C,E,O,G,G,E,U,C,E,S,C,C,O,S,C,C,C,C,C,E,C,C,E,C,C,C,E,E,C,E,C,C,E,C,E,K,C,C,C,C,E,C,E,S,C,C,C,C,E,E,Y,S,C,E,C,C,G,C,O,C,G,O,C,C,C,G,C,S,C,E,kB,S,C,E,G,I,C,E,C,C,G,C,O,C,E,Y,S,C,C,C,E,G,C,C,G,C,S,C,C,I,E,E,E,E,E,K,C,O,E,I,E,I,Y,I,Y,A,S,C,C,C,E,I,E,E,E,E,E,E,C,C,G,C,E,E,U,C,G,C,C,C,E,K,E,C,E,K,A,E,C,G,A,c,E,I,C,E,G,M,C,E,O,C,Q,G,A,a,E,I,C,M,C,E,E,Q,C,E,Q,C,E,E,E,C,A,G,C,G,C,A,E,E,A,I,G,C,E,E,C,C,E,E,C,E,E,C,E,G,G,E,A,E,K,C,E,G,G,G,E,A,E,K,C,E,E,C,C,E,E,G,K,K,Q,C,E,C,E,C,E,A,C,C,G,E,U,C,K,G,G,M,C,E,O,C,K,G,E,E,E,E,C,C,E,W,S,C,E,I,E,E,E,E,E,E,E,E,C,C,G,C,E,E,Q,C,E,E,Q,C,E,iB,G,E,G,S,C,E,G,I,E,E,E,E,M,C,E,E,E,E,G,A,C,E,C,C,E,A,C,C,E,C,I,E,C,C,E,C,O,C,G,E,E,C,E,E,E,E,M,C,E,E,E,E,A,C,E,C,C,E,A,E,Q,C,M,C,A,I,C,C,E,C,E,M,C,E,Q,C,C,C,E,M,E,E,M,A,G,C,G,M,C,E,O,E,E,M,E,E,O,E,M,A,C,C,E,O,W,C,C,M,Q,G,C,E,K,C,G,E,O,C,G,E,M,C,E,E,Q,C,G,E,K,C,G,E,I,C,G,E,U,C,G,E,Q,C,G,E,U,C,G,E,Q,C,G,E,K,C,G,E,K,C,G,E,S,C,G,E,O,C,G,E,M,C,G,E,S,C,G,E,M,C,G,E,O,C,G,E,O,C,G,E,G,C,G,E,U,C,G,E,K,C,G,E,O,C,G,E,M,C,G,O,c,C,E,O,W,C,C,M,Q,E","sources":["<anon>","node_modules/tw-elements/dist/js/tw-elements.umd.min.js","node_modules/tw-elements/src/js/dom/data.js","node_modules/tw-elements/src/js/util/index.js","node_modules/tw-elements/src/js/dom/event-handler.js","node_modules/tw-elements/src/js/base-component.js","node_modules/tw-elements/src/js/components/button.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/enums.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getWindow.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/applyStyles.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getBasePlacement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/math.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/userAgent.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/contains.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/within.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/expandToHashMap.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/arrow.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getVariation.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/computeStyles.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/eventListeners.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/rectToClientRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/computeOffsets.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/detectOverflow.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/flip.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/hide.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/offset.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/getAltAxis.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/orderModifiers.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/debounce.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/format.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/validateModifiers.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/uniqueBy.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/utils/mergeByName.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/createPopper.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/popper-lite.js","node_modules/tw-elements/node_modules/@popperjs/core/lib/popper.js","node_modules/tw-elements/src/js/dom/manipulator.js","node_modules/tw-elements/src/js/dom/selector-engine.js","node_modules/tw-elements/src/js/components/dropdown.js","node_modules/tw-elements/src/js/components/collapse.js","node_modules/tw-elements/src/js/util/scrollbar.js","node_modules/tw-elements/src/js/util/backdrop.js","node_modules/tw-elements/src/js/util/focusTrap.js","node_modules/tw-elements/src/js/util/component-functions.js","node_modules/tw-elements/src/js/components/offcanvas.js","node_modules/tw-elements/src/js/components/alert.js","node_modules/tw-elements/src/js/components/carousel.js","node_modules/tw-elements/src/js/components/modal.js","node_modules/tw-elements/src/js/util/sanitizer.js","node_modules/tw-elements/src/js/components/tooltip.js","node_modules/tw-elements/src/js/components/popover.js","node_modules/tw-elements/src/js/navigation/scrollspy.js","node_modules/tw-elements/src/js/navigation/tab.js","node_modules/tw-elements/src/js/components/toast.js","node_modules/tw-elements/node_modules/detect-autofill/dist/detect-autofill.js","node_modules/tw-elements/src/js/forms/input.js","node_modules/tw-elements/src/js/content-styles/animate.js","node_modules/tw-elements/src/js/methods/ripple.js","node_modules/tw-elements/src/js/forms/datepicker/date-utils.js","node_modules/tw-elements/src/js/forms/datepicker/templates.js","node_modules/tw-elements/src/js/util/keycodes.js","node_modules/tw-elements/src/js/forms/datepicker/index.js","node_modules/tw-elements/src/js/forms/timepicker/templates.js","node_modules/tw-elements/src/js/forms/timepicker/utils.js","node_modules/tw-elements/src/js/forms/timepicker/index.js","node_modules/tw-elements/node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js","node_modules/tw-elements/src/js/util/touch/swipe.js","node_modules/tw-elements/src/js/util/touch/index.js","node_modules/tw-elements/src/js/util/add-perfect-scrollbar-styles.js","node_modules/tw-elements/src/js/navigation/sidenav.js","node_modules/tw-elements/src/js/components/stepper.js","node_modules/tw-elements/src/js/forms/select/select-option.js","node_modules/tw-elements/src/js/forms/select/selection-model.js","node_modules/tw-elements/src/js/forms/select/util.js","node_modules/tw-elements/src/js/forms/select/templates.js","node_modules/tw-elements/src/js/forms/select/index.js","node_modules/tw-elements/src/js/autoinit/jqueryInit.js","node_modules/tw-elements/src/js/autoinit/autoinitCallbacks.js","node_modules/tw-elements/src/js/data/chart/chartDefaults.js","node_modules/tw-elements/src/js/autoinit/index.js","node_modules/tw-elements/src/js/autoinit/chartsInit.js","node_modules/tw-elements/src/js/components/chips/templates.js","node_modules/tw-elements/src/js/components/chips/chip.js","node_modules/tw-elements/src/js/components/chips/index.js","node_modules/tw-elements/node_modules/deepmerge/dist/cjs.js","node_modules/tw-elements/src/js/data/chart/charts.js","node_modules/tw-elements/src/js/index.umd.js","node_modules/tw-elements/node_modules/chart.js/dist/chunks/helpers.segment.mjs","node_modules/tw-elements/node_modules/chart.js/dist/chart.mjs","node_modules/tw-elements/node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js"],"sourcesContent":["/*!\n* Taliwind Elements 1.0.0-beta2\n* \n* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\n* Copyright  2023 MDBootstrap.com\n* \n* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\n* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\n* \n*/ (function(V, _t) {\n    typeof exports == \"object\" && typeof module < \"u\" ? _t(exports) : typeof define == \"function\" && define.amd ? define([\n        \"exports\"\n    ], _t) : (V = typeof globalThis < \"u\" ? globalThis : V || self, _t(V.te = {}));\n})(this, function(V) {\n    \"use strict\";\n    var Dk = Object.defineProperty;\n    var Mk = (V, _t, P)=>_t in V ? Dk(V, _t, {\n            enumerable: !0,\n            configurable: !0,\n            writable: !0,\n            value: P\n        }) : V[_t] = P;\n    var Ee = (V, _t, P)=>(Mk(V, typeof _t != \"symbol\" ? _t + \"\" : _t, P), P);\n    const _t = (()=>{\n        const i = {};\n        let t = 1;\n        return {\n            set (e, s, n) {\n                typeof e[s] > \"u\" && (e[s] = {\n                    key: s,\n                    id: t\n                }, t++), i[e[s].id] = n;\n            },\n            get (e, s) {\n                if (!e || typeof e[s] > \"u\") return null;\n                const n = e[s];\n                return n.key === s ? i[n.id] : null;\n            },\n            delete (e, s) {\n                if (typeof e[s] > \"u\") return;\n                const n = e[s];\n                n.key === s && (delete i[n.id], delete e[s]);\n            }\n        };\n    })(), P = {\n        setData (i, t, e) {\n            _t.set(i, t, e);\n        },\n        getData (i, t) {\n            return _t.get(i, t);\n        },\n        removeData (i, t) {\n            _t.delete(i, t);\n        }\n    }, Kp = 1e6, Up = 1e3, vr = \"transitionend\", Xp = (i)=>i == null ? `${i}` : ({}).toString.call(i).match(/\\s([a-z]+)/i)[1].toLowerCase(), se = (i)=>{\n        do i += Math.floor(Math.random() * Kp);\n        while (document.getElementById(i));\n        return i;\n    }, Il = (i)=>{\n        let t = i.getAttribute(\"data-te-target\");\n        if (!t || t === \"#\") {\n            let e = i.getAttribute(\"href\");\n            if (!e || !e.includes(\"#\") && !e.startsWith(\".\")) return null;\n            e.includes(\"#\") && !e.startsWith(\"#\") && (e = `#${e.split(\"#\")[1]}`), t = e && e !== \"#\" ? e.trim() : null;\n        }\n        return t;\n    }, yr = (i)=>{\n        const t = Il(i);\n        return t && document.querySelector(t) ? t : null;\n    }, Ie = (i)=>{\n        const t = Il(i);\n        return t ? document.querySelector(t) : null;\n    }, Gp = (i)=>{\n        if (!i) return 0;\n        let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(i);\n        const s = Number.parseFloat(t), n = Number.parseFloat(e);\n        return !s && !n ? 0 : (t = t.split(\",\")[0], e = e.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Up);\n    }, Ll = (i)=>{\n        i.dispatchEvent(new Event(vr));\n    }, Mi = (i)=>!i || typeof i != \"object\" ? !1 : (typeof i.jquery < \"u\" && (i = i[0]), typeof i.nodeType < \"u\"), Le = (i)=>Mi(i) ? i.jquery ? i[0] : i : typeof i == \"string\" && i.length > 0 ? document.querySelector(i) : null, W = (i, t, e)=>{\n        Object.keys(e).forEach((s)=>{\n            const n = e[s], o = t[s], r = o && Mi(o) ? \"element\" : Xp(o);\n            if (!new RegExp(n).test(r)) throw new Error(`${i.toUpperCase()}: Option \"${s}\" provided type \"${r}\" but expected type \"${n}\".`);\n        });\n    }, ne = (i)=>{\n        if (!i || i.getClientRects().length === 0) return !1;\n        if (i.style && i.parentNode && i.parentNode.style) {\n            const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);\n            return getComputedStyle(i).getPropertyValue(\"visibility\") === \"visible\" || t.display !== \"none\" && e.display !== \"none\" && t.visibility !== \"hidden\";\n        }\n        return !1;\n    }, ei = (i)=>!i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains(\"disabled\") ? !0 : typeof i.disabled < \"u\" ? i.disabled : i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\", Pl = (i)=>{\n        if (!document.documentElement.attachShadow) return null;\n        if (typeof i.getRootNode == \"function\") {\n            const t = i.getRootNode();\n            return t instanceof ShadowRoot ? t : null;\n        }\n        return i instanceof ShadowRoot ? i : i.parentNode ? Pl(i.parentNode) : null;\n    }, Sn = ()=>function() {}, Ii = (i)=>{\n        i.offsetHeight;\n    }, Rl = ()=>{\n        const { jQuery: i } = window;\n        return i && !document.body.hasAttribute(\"data-te-no-jquery\") ? i : null;\n    }, xr = [], Nl = (i)=>{\n        document.readyState === \"loading\" ? (xr.length || document.addEventListener(\"DOMContentLoaded\", ()=>{\n            xr.forEach((t)=>t());\n        }), xr.push(i)) : i();\n    }, st = ()=>document.documentElement.dir === \"rtl\", qp = (i)=>Array.from(i), z = (i)=>document.createElement(i), ii = (i)=>{\n        typeof i == \"function\" && i();\n    }, $l = (i, t, e = !0)=>{\n        if (!e) {\n            ii(i);\n            return;\n        }\n        const s = 5, n = Gp(t) + s;\n        let o = !1;\n        const r = ({ target: a })=>{\n            a === t && (o = !0, t.removeEventListener(vr, r), ii(i));\n        };\n        t.addEventListener(vr, r), setTimeout(()=>{\n            o || Ll(t);\n        }, n);\n    }, Bl = (i, t, e, s)=>{\n        let n = i.indexOf(t);\n        if (n === -1) return i[!e && s ? i.length - 1 : 0];\n        const o = i.length;\n        return n += e ? 1 : -1, s && (n = (n + o) % o), i[Math.max(0, Math.min(n, o - 1))];\n    }, Zp = /[^.]*(?=\\..*)\\.|.*/, Qp = /\\..*/, Jp = /::\\d+$/, Er = {};\n    let Hl = 1;\n    const t_ = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n    }, e_ = /^(mouseenter|mouseleave)/i, Fl = new Set([\n        \"click\",\n        \"dblclick\",\n        \"mouseup\",\n        \"mousedown\",\n        \"contextmenu\",\n        \"mousewheel\",\n        \"DOMMouseScroll\",\n        \"mouseover\",\n        \"mouseout\",\n        \"mousemove\",\n        \"selectstart\",\n        \"selectend\",\n        \"keydown\",\n        \"keypress\",\n        \"keyup\",\n        \"orientationchange\",\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\",\n        \"touchcancel\",\n        \"pointerdown\",\n        \"pointermove\",\n        \"pointerup\",\n        \"pointerleave\",\n        \"pointercancel\",\n        \"gesturestart\",\n        \"gesturechange\",\n        \"gestureend\",\n        \"focus\",\n        \"blur\",\n        \"change\",\n        \"reset\",\n        \"select\",\n        \"submit\",\n        \"focusin\",\n        \"focusout\",\n        \"load\",\n        \"unload\",\n        \"beforeunload\",\n        \"resize\",\n        \"move\",\n        \"DOMContentLoaded\",\n        \"readystatechange\",\n        \"error\",\n        \"abort\",\n        \"scroll\"\n    ]);\n    function Vl(i, t) {\n        return t && `${t}::${Hl++}` || i.uidEvent || Hl++;\n    }\n    function Wl(i) {\n        const t = Vl(i);\n        return i.uidEvent = t, Er[t] = Er[t] || {}, Er[t];\n    }\n    function i_(i, t) {\n        return function e(s) {\n            return s.delegateTarget = i, e.oneOff && b.off(i, s.type, t), t.apply(i, [\n                s\n            ]);\n        };\n    }\n    function s_(i, t, e) {\n        return function s(n) {\n            const o = i.querySelectorAll(t);\n            for(let { target: r } = n; r && r !== this; r = r.parentNode)for(let a = o.length; a--;)if (o[a] === r) return n.delegateTarget = r, s.oneOff && b.off(i, n.type, e), e.apply(r, [\n                n\n            ]);\n            return null;\n        };\n    }\n    function zl(i, t, e = null) {\n        const s = Object.keys(i);\n        for(let n = 0, o = s.length; n < o; n++){\n            const r = i[s[n]];\n            if (r.originalHandler === t && r.delegationSelector === e) return r;\n        }\n        return null;\n    }\n    function jl(i, t, e) {\n        const s = typeof t == \"string\", n = s ? e : t;\n        let o = Kl(i);\n        return Fl.has(o) || (o = i), [\n            s,\n            n,\n            o\n        ];\n    }\n    function Yl(i, t, e, s, n) {\n        if (typeof t != \"string\" || !i) return;\n        if (e || (e = s, s = null), e_.test(t)) {\n            const f = (p)=>function(_) {\n                    if (!_.relatedTarget || _.relatedTarget !== _.delegateTarget && !_.delegateTarget.contains(_.relatedTarget)) return p.call(this, _);\n                };\n            s ? s = f(s) : e = f(e);\n        }\n        const [o, r, a] = jl(t, e, s), l = Wl(i), c = l[a] || (l[a] = {}), h = zl(c, r, o ? e : null);\n        if (h) {\n            h.oneOff = h.oneOff && n;\n            return;\n        }\n        const d = Vl(r, t.replace(Zp, \"\")), u = o ? s_(i, e, s) : i_(i, e);\n        u.delegationSelector = o ? e : null, u.originalHandler = r, u.oneOff = n, u.uidEvent = d, c[d] = u, i.addEventListener(a, u, o);\n    }\n    function Cr(i, t, e, s, n) {\n        const o = zl(t[e], s, n);\n        o && (i.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);\n    }\n    function n_(i, t, e, s) {\n        const n = t[e] || {};\n        Object.keys(n).forEach((o)=>{\n            if (o.includes(s)) {\n                const r = n[o];\n                Cr(i, t, e, r.originalHandler, r.delegationSelector);\n            }\n        });\n    }\n    function Kl(i) {\n        return i = i.replace(Qp, \"\"), t_[i] || i;\n    }\n    const b = {\n        on (i, t, e, s) {\n            Yl(i, t, e, s, !1);\n        },\n        one (i, t, e, s) {\n            Yl(i, t, e, s, !0);\n        },\n        off (i, t, e, s) {\n            if (typeof t != \"string\" || !i) return;\n            const [n, o, r] = jl(t, e, s), a = r !== t, l = Wl(i), c = t.startsWith(\".\");\n            if (typeof o < \"u\") {\n                if (!l || !l[r]) return;\n                Cr(i, l, r, o, n ? e : null);\n                return;\n            }\n            c && Object.keys(l).forEach((d)=>{\n                n_(i, l, d, t.slice(1));\n            });\n            const h = l[r] || {};\n            Object.keys(h).forEach((d)=>{\n                const u = d.replace(Jp, \"\");\n                if (!a || t.includes(u)) {\n                    const f = h[d];\n                    Cr(i, l, r, f.originalHandler, f.delegationSelector);\n                }\n            });\n        },\n        trigger (i, t, e) {\n            if (typeof t != \"string\" || !i) return null;\n            const s = Rl(), n = Kl(t), o = t !== n, r = Fl.has(n);\n            let a, l = !0, c = !0, h = !1, d = null;\n            return o && s && (a = s.Event(t, e), s(i).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent(\"HTMLEvents\"), d.initEvent(n, l, !0)) : d = new CustomEvent(t, {\n                bubbles: l,\n                cancelable: !0\n            }), typeof e < \"u\" && Object.keys(e).forEach((u)=>{\n                Object.defineProperty(d, u, {\n                    get () {\n                        return e[u];\n                    }\n                });\n            }), h && d.preventDefault(), c && i.dispatchEvent(d), d.defaultPrevented && typeof a < \"u\" && a.preventDefault(), d;\n        }\n    }, si = {\n        on (i, t, e, s) {\n            const n = t.split(\" \");\n            for(let o = 0; o < n.length; o++)b.on(i, n[o], e, s);\n        },\n        off (i, t, e, s) {\n            const n = t.split(\" \");\n            for(let o = 0; o < n.length; o++)b.off(i, n[o], e, s);\n        }\n    }, o_ = \"5.1.3\";\n    class Xt {\n        constructor(t){\n            t = Le(t), t && (this._element = t, P.setData(this._element, this.constructor.DATA_KEY, this));\n        }\n        dispose() {\n            P.removeData(this._element, this.constructor.DATA_KEY), b.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t)=>{\n                this[t] = null;\n            });\n        }\n        _queueCallback(t, e, s = !0) {\n            $l(t, e, s);\n        }\n        static getInstance(t) {\n            return P.getData(Le(t), this.DATA_KEY);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n        static get VERSION() {\n            return o_;\n        }\n        static get NAME() {\n            throw new Error('You have to implement the static method \"NAME\", for each component!');\n        }\n        static get DATA_KEY() {\n            return `te.${this.NAME}`;\n        }\n        static get EVENT_KEY() {\n            return `.${this.DATA_KEY}`;\n        }\n    }\n    const r_ = \"button\", a_ = \"active\";\n    class On extends Xt {\n        static get NAME() {\n            return r_;\n        }\n        toggle() {\n            this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(a_));\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = On.getOrCreateInstance(this);\n                t === \"toggle\" && e[t]();\n            });\n        }\n    }\n    var gt = \"top\", Ot = \"bottom\", Dt = \"right\", mt = \"left\", bs = \"auto\", Li = [\n        gt,\n        Ot,\n        Dt,\n        mt\n    ], ni = \"start\", Pi = \"end\", Ul = \"clippingParents\", Tr = \"viewport\", Ri = \"popper\", Xl = \"reference\", Ar = Li.reduce(function(i, t) {\n        return i.concat([\n            t + \"-\" + ni,\n            t + \"-\" + Pi\n        ]);\n    }, []), wr = [].concat(Li, [\n        bs\n    ]).reduce(function(i, t) {\n        return i.concat([\n            t,\n            t + \"-\" + ni,\n            t + \"-\" + Pi\n        ]);\n    }, []), Gl = \"beforeRead\", ql = \"read\", Zl = \"afterRead\", Ql = \"beforeMain\", Jl = \"main\", tc = \"afterMain\", ec = \"beforeWrite\", ic = \"write\", sc = \"afterWrite\", Dn = [\n        Gl,\n        ql,\n        Zl,\n        Ql,\n        Jl,\n        tc,\n        ec,\n        ic,\n        sc\n    ];\n    function oe(i) {\n        return i ? (i.nodeName || \"\").toLowerCase() : null;\n    }\n    function Mt(i) {\n        if (i == null) return window;\n        if (i.toString() !== \"[object Window]\") {\n            var t = i.ownerDocument;\n            return t && t.defaultView || window;\n        }\n        return i;\n    }\n    function oi(i) {\n        var t = Mt(i).Element;\n        return i instanceof t || i instanceof Element;\n    }\n    function It(i) {\n        var t = Mt(i).HTMLElement;\n        return i instanceof t || i instanceof HTMLElement;\n    }\n    function kr(i) {\n        if (typeof ShadowRoot > \"u\") return !1;\n        var t = Mt(i).ShadowRoot;\n        return i instanceof t || i instanceof ShadowRoot;\n    }\n    function l_(i) {\n        var t = i.state;\n        Object.keys(t.elements).forEach(function(e) {\n            var s = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];\n            !It(o) || !oe(o) || (Object.assign(o.style, s), Object.keys(n).forEach(function(r) {\n                var a = n[r];\n                a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? \"\" : a);\n            }));\n        });\n    }\n    function c_(i) {\n        var t = i.state, e = {\n            popper: {\n                position: t.options.strategy,\n                left: \"0\",\n                top: \"0\",\n                margin: \"0\"\n            },\n            arrow: {\n                position: \"absolute\"\n            },\n            reference: {}\n        };\n        return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n            Object.keys(t.elements).forEach(function(s) {\n                var n = t.elements[s], o = t.attributes[s] || {}, r = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = r.reduce(function(l, c) {\n                    return l[c] = \"\", l;\n                }, {});\n                !It(n) || !oe(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {\n                    n.removeAttribute(l);\n                }));\n            });\n        };\n    }\n    const Sr = {\n        name: \"applyStyles\",\n        enabled: !0,\n        phase: \"write\",\n        fn: l_,\n        effect: c_,\n        requires: [\n            \"computeStyles\"\n        ]\n    };\n    function Gt(i) {\n        return i.split(\"-\")[0];\n    }\n    var ri = Math.max, Mn = Math.min, Ni = Math.round;\n    function Or() {\n        var i = navigator.userAgentData;\n        return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {\n            return t.brand + \"/\" + t.version;\n        }).join(\" \") : navigator.userAgent;\n    }\n    function nc() {\n        return !/^((?!chrome|android).)*safari/i.test(Or());\n    }\n    function $i(i, t, e) {\n        t === void 0 && (t = !1), e === void 0 && (e = !1);\n        var s = i.getBoundingClientRect(), n = 1, o = 1;\n        t && It(i) && (n = i.offsetWidth > 0 && Ni(s.width) / i.offsetWidth || 1, o = i.offsetHeight > 0 && Ni(s.height) / i.offsetHeight || 1);\n        var r = oi(i) ? Mt(i) : window, a = r.visualViewport, l = !nc() && e, c = (s.left + (l && a ? a.offsetLeft : 0)) / n, h = (s.top + (l && a ? a.offsetTop : 0)) / o, d = s.width / n, u = s.height / o;\n        return {\n            width: d,\n            height: u,\n            top: h,\n            right: c + d,\n            bottom: h + u,\n            left: c,\n            x: c,\n            y: h\n        };\n    }\n    function Dr(i) {\n        var t = $i(i), e = i.offsetWidth, s = i.offsetHeight;\n        return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {\n            x: i.offsetLeft,\n            y: i.offsetTop,\n            width: e,\n            height: s\n        };\n    }\n    function oc(i, t) {\n        var e = t.getRootNode && t.getRootNode();\n        if (i.contains(t)) return !0;\n        if (e && kr(e)) {\n            var s = t;\n            do {\n                if (s && i.isSameNode(s)) return !0;\n                s = s.parentNode || s.host;\n            }while (s);\n        }\n        return !1;\n    }\n    function qt(i) {\n        return Mt(i).getComputedStyle(i);\n    }\n    function h_(i) {\n        return [\n            \"table\",\n            \"td\",\n            \"th\"\n        ].indexOf(oe(i)) >= 0;\n    }\n    function Pe(i) {\n        return ((oi(i) ? i.ownerDocument : i.document) || window.document).documentElement;\n    }\n    function In(i) {\n        return oe(i) === \"html\" ? i : i.assignedSlot || i.parentNode || (kr(i) ? i.host : null) || Pe(i);\n    }\n    function rc(i) {\n        return !It(i) || qt(i).position === \"fixed\" ? null : i.offsetParent;\n    }\n    function d_(i) {\n        var t = /firefox/i.test(Or()), e = /Trident/i.test(Or());\n        if (e && It(i)) {\n            var s = qt(i);\n            if (s.position === \"fixed\") return null;\n        }\n        var n = In(i);\n        for(kr(n) && (n = n.host); It(n) && [\n            \"html\",\n            \"body\"\n        ].indexOf(oe(n)) < 0;){\n            var o = qt(n);\n            if (o.transform !== \"none\" || o.perspective !== \"none\" || o.contain === \"paint\" || [\n                \"transform\",\n                \"perspective\"\n            ].indexOf(o.willChange) !== -1 || t && o.willChange === \"filter\" || t && o.filter && o.filter !== \"none\") return n;\n            n = n.parentNode;\n        }\n        return null;\n    }\n    function vs(i) {\n        for(var t = Mt(i), e = rc(i); e && h_(e) && qt(e).position === \"static\";)e = rc(e);\n        return e && (oe(e) === \"html\" || oe(e) === \"body\" && qt(e).position === \"static\") ? t : e || d_(i) || t;\n    }\n    function Mr(i) {\n        return [\n            \"top\",\n            \"bottom\"\n        ].indexOf(i) >= 0 ? \"x\" : \"y\";\n    }\n    function ys(i, t, e) {\n        return ri(i, Mn(t, e));\n    }\n    function u_(i, t, e) {\n        var s = ys(i, t, e);\n        return s > e ? e : s;\n    }\n    function ac() {\n        return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        };\n    }\n    function lc(i) {\n        return Object.assign({}, ac(), i);\n    }\n    function cc(i, t) {\n        return t.reduce(function(e, s) {\n            return e[s] = i, e;\n        }, {});\n    }\n    var f_ = function(t, e) {\n        return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n            placement: e.placement\n        })) : t, lc(typeof t != \"number\" ? t : cc(t, Li));\n    };\n    function p_(i) {\n        var t, e = i.state, s = i.name, n = i.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Gt(e.placement), l = Mr(a), c = [\n            mt,\n            Dt\n        ].indexOf(a) >= 0, h = c ? \"height\" : \"width\";\n        if (!(!o || !r)) {\n            var d = f_(n.padding, e), u = Dr(o), f = l === \"y\" ? gt : mt, p = l === \"y\" ? Ot : Dt, _ = e.rects.reference[h] + e.rects.reference[l] - r[l] - e.rects.popper[h], m = r[l] - e.rects.reference[l], y = vs(o), x = y ? l === \"y\" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, E = _ / 2 - m / 2, C = d[f], T = x - u[h] - d[p], A = x / 2 - u[h] / 2 + E, w = ys(C, A, T), S = l;\n            e.modifiersData[s] = (t = {}, t[S] = w, t.centerOffset = w - A, t);\n        }\n    }\n    function __(i) {\n        var t = i.state, e = i.options, s = e.element, n = s === void 0 ? \"[data-popper-arrow]\" : s;\n        if (n != null && !(typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n))) {\n            if (({}).NODE_ENV !== \"production\" && (It(n) || console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\",\n                \"the arrow.\"\n            ].join(\" \"))), !oc(t.elements.popper, n)) {\n                ({}).NODE_ENV !== \"production\" && console.error([\n                    'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n                    \"element.\"\n                ].join(\" \"));\n                return;\n            }\n            t.elements.arrow = n;\n        }\n    }\n    const hc = {\n        name: \"arrow\",\n        enabled: !0,\n        phase: \"main\",\n        fn: p_,\n        effect: __,\n        requires: [\n            \"popperOffsets\"\n        ],\n        requiresIfExists: [\n            \"preventOverflow\"\n        ]\n    };\n    function Bi(i) {\n        return i.split(\"-\")[1];\n    }\n    var g_ = {\n        top: \"auto\",\n        right: \"auto\",\n        bottom: \"auto\",\n        left: \"auto\"\n    };\n    function m_(i, t) {\n        var e = i.x, s = i.y, n = t.devicePixelRatio || 1;\n        return {\n            x: Ni(e * n) / n || 0,\n            y: Ni(s * n) / n || 0\n        };\n    }\n    function dc(i) {\n        var t, e = i.popper, s = i.popperRect, n = i.placement, o = i.variation, r = i.offsets, a = i.position, l = i.gpuAcceleration, c = i.adaptive, h = i.roundOffsets, d = i.isFixed, u = r.x, f = u === void 0 ? 0 : u, p = r.y, _ = p === void 0 ? 0 : p, m = typeof h == \"function\" ? h({\n            x: f,\n            y: _\n        }) : {\n            x: f,\n            y: _\n        };\n        f = m.x, _ = m.y;\n        var y = r.hasOwnProperty(\"x\"), x = r.hasOwnProperty(\"y\"), E = mt, C = gt, T = window;\n        if (c) {\n            var A = vs(e), w = \"clientHeight\", S = \"clientWidth\";\n            if (A === Mt(e) && (A = Pe(e), qt(A).position !== \"static\" && a === \"absolute\" && (w = \"scrollHeight\", S = \"scrollWidth\")), A, n === gt || (n === mt || n === Dt) && o === Pi) {\n                C = Ot;\n                var k = d && A === T && T.visualViewport ? T.visualViewport.height : A[w];\n                _ -= k - s.height, _ *= l ? 1 : -1;\n            }\n            if (n === mt || (n === gt || n === Ot) && o === Pi) {\n                E = Dt;\n                var D = d && A === T && T.visualViewport ? T.visualViewport.width : A[S];\n                f -= D - s.width, f *= l ? 1 : -1;\n            }\n        }\n        var O = Object.assign({\n            position: a\n        }, c && g_), M = h === !0 ? m_({\n            x: f,\n            y: _\n        }, Mt(e)) : {\n            x: f,\n            y: _\n        };\n        if (f = M.x, _ = M.y, l) {\n            var L;\n            return Object.assign({}, O, (L = {}, L[C] = x ? \"0\" : \"\", L[E] = y ? \"0\" : \"\", L.transform = (T.devicePixelRatio || 1) <= 1 ? \"translate(\" + f + \"px, \" + _ + \"px)\" : \"translate3d(\" + f + \"px, \" + _ + \"px, 0)\", L));\n        }\n        return Object.assign({}, O, (t = {}, t[C] = x ? _ + \"px\" : \"\", t[E] = y ? f + \"px\" : \"\", t.transform = \"\", t));\n    }\n    function b_(i) {\n        var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;\n        if (({}).NODE_ENV !== \"production\") {\n            var c = qt(t.elements.popper).transitionProperty || \"\";\n            r && [\n                \"transform\",\n                \"top\",\n                \"right\",\n                \"bottom\",\n                \"left\"\n            ].some(function(d) {\n                return c.indexOf(d) >= 0;\n            }) && console.warn([\n                \"Popper: Detected CSS transitions on at least one of the following\",\n                'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n                `\n\n`,\n                'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n                \"for smooth transitions, or remove these properties from the CSS\",\n                \"transition declaration on the popper element if only transitioning\",\n                \"opacity or background-color for example.\",\n                `\n\n`,\n                \"We recommend using the popper element as a wrapper around an inner\",\n                \"element that can have any CSS property transitioned for animations.\"\n            ].join(\" \"));\n        }\n        var h = {\n            placement: Gt(t.placement),\n            variation: Bi(t.placement),\n            popper: t.elements.popper,\n            popperRect: t.rects.popper,\n            gpuAcceleration: n,\n            isFixed: t.options.strategy === \"fixed\"\n        };\n        t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, dc(Object.assign({}, h, {\n            offsets: t.modifiersData.popperOffsets,\n            position: t.options.strategy,\n            adaptive: r,\n            roundOffsets: l\n        })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, dc(Object.assign({}, h, {\n            offsets: t.modifiersData.arrow,\n            position: \"absolute\",\n            adaptive: !1,\n            roundOffsets: l\n        })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n            \"data-popper-placement\": t.placement\n        });\n    }\n    const Ir = {\n        name: \"computeStyles\",\n        enabled: !0,\n        phase: \"beforeWrite\",\n        fn: b_,\n        data: {}\n    };\n    var Ln = {\n        passive: !0\n    };\n    function v_(i) {\n        var t = i.state, e = i.instance, s = i.options, n = s.scroll, o = n === void 0 ? !0 : n, r = s.resize, a = r === void 0 ? !0 : r, l = Mt(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n        return o && c.forEach(function(h) {\n            h.addEventListener(\"scroll\", e.update, Ln);\n        }), a && l.addEventListener(\"resize\", e.update, Ln), function() {\n            o && c.forEach(function(h) {\n                h.removeEventListener(\"scroll\", e.update, Ln);\n            }), a && l.removeEventListener(\"resize\", e.update, Ln);\n        };\n    }\n    const Lr = {\n        name: \"eventListeners\",\n        enabled: !0,\n        phase: \"write\",\n        fn: function() {},\n        effect: v_,\n        data: {}\n    };\n    var y_ = {\n        left: \"right\",\n        right: \"left\",\n        bottom: \"top\",\n        top: \"bottom\"\n    };\n    function Pn(i) {\n        return i.replace(/left|right|bottom|top/g, function(t) {\n            return y_[t];\n        });\n    }\n    var x_ = {\n        start: \"end\",\n        end: \"start\"\n    };\n    function uc(i) {\n        return i.replace(/start|end/g, function(t) {\n            return x_[t];\n        });\n    }\n    function Pr(i) {\n        var t = Mt(i), e = t.pageXOffset, s = t.pageYOffset;\n        return {\n            scrollLeft: e,\n            scrollTop: s\n        };\n    }\n    function Rr(i) {\n        return $i(Pe(i)).left + Pr(i).scrollLeft;\n    }\n    function E_(i, t) {\n        var e = Mt(i), s = Pe(i), n = e.visualViewport, o = s.clientWidth, r = s.clientHeight, a = 0, l = 0;\n        if (n) {\n            o = n.width, r = n.height;\n            var c = nc();\n            (c || !c && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\n        }\n        return {\n            width: o,\n            height: r,\n            x: a + Rr(i),\n            y: l\n        };\n    }\n    function C_(i) {\n        var t, e = Pe(i), s = Pr(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, o = ri(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = ri(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + Rr(i), l = -s.scrollTop;\n        return qt(n || e).direction === \"rtl\" && (a += ri(e.clientWidth, n ? n.clientWidth : 0) - o), {\n            width: o,\n            height: r,\n            x: a,\n            y: l\n        };\n    }\n    function Nr(i) {\n        var t = qt(i), e = t.overflow, s = t.overflowX, n = t.overflowY;\n        return /auto|scroll|overlay|hidden/.test(e + n + s);\n    }\n    function fc(i) {\n        return [\n            \"html\",\n            \"body\",\n            \"#document\"\n        ].indexOf(oe(i)) >= 0 ? i.ownerDocument.body : It(i) && Nr(i) ? i : fc(In(i));\n    }\n    function xs(i, t) {\n        var e;\n        t === void 0 && (t = []);\n        var s = fc(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), o = Mt(s), r = n ? [\n            o\n        ].concat(o.visualViewport || [], Nr(s) ? s : []) : s, a = t.concat(r);\n        return n ? a : a.concat(xs(In(r)));\n    }\n    function $r(i) {\n        return Object.assign({}, i, {\n            left: i.x,\n            top: i.y,\n            right: i.x + i.width,\n            bottom: i.y + i.height\n        });\n    }\n    function T_(i, t) {\n        var e = $i(i, !1, t === \"fixed\");\n        return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;\n    }\n    function pc(i, t, e) {\n        return t === Tr ? $r(E_(i, e)) : oi(t) ? T_(t, e) : $r(C_(Pe(i)));\n    }\n    function A_(i) {\n        var t = xs(In(i)), e = [\n            \"absolute\",\n            \"fixed\"\n        ].indexOf(qt(i).position) >= 0, s = e && It(i) ? vs(i) : i;\n        return oi(s) ? t.filter(function(n) {\n            return oi(n) && oc(n, s) && oe(n) !== \"body\";\n        }) : [];\n    }\n    function w_(i, t, e, s) {\n        var n = t === \"clippingParents\" ? A_(i) : [].concat(t), o = [].concat(n, [\n            e\n        ]), r = o[0], a = o.reduce(function(l, c) {\n            var h = pc(i, c, s);\n            return l.top = ri(h.top, l.top), l.right = Mn(h.right, l.right), l.bottom = Mn(h.bottom, l.bottom), l.left = ri(h.left, l.left), l;\n        }, pc(i, r, s));\n        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;\n    }\n    function _c(i) {\n        var t = i.reference, e = i.element, s = i.placement, n = s ? Gt(s) : null, o = s ? Bi(s) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;\n        switch(n){\n            case gt:\n                l = {\n                    x: r,\n                    y: t.y - e.height\n                };\n                break;\n            case Ot:\n                l = {\n                    x: r,\n                    y: t.y + t.height\n                };\n                break;\n            case Dt:\n                l = {\n                    x: t.x + t.width,\n                    y: a\n                };\n                break;\n            case mt:\n                l = {\n                    x: t.x - e.width,\n                    y: a\n                };\n                break;\n            default:\n                l = {\n                    x: t.x,\n                    y: t.y\n                };\n        }\n        var c = n ? Mr(n) : null;\n        if (c != null) {\n            var h = c === \"y\" ? \"height\" : \"width\";\n            switch(o){\n                case ni:\n                    l[c] = l[c] - (t[h] / 2 - e[h] / 2);\n                    break;\n                case Pi:\n                    l[c] = l[c] + (t[h] / 2 - e[h] / 2);\n                    break;\n            }\n        }\n        return l;\n    }\n    function Hi(i, t) {\n        t === void 0 && (t = {});\n        var e = t, s = e.placement, n = s === void 0 ? i.placement : s, o = e.strategy, r = o === void 0 ? i.strategy : o, a = e.boundary, l = a === void 0 ? Ul : a, c = e.rootBoundary, h = c === void 0 ? Tr : c, d = e.elementContext, u = d === void 0 ? Ri : d, f = e.altBoundary, p = f === void 0 ? !1 : f, _ = e.padding, m = _ === void 0 ? 0 : _, y = lc(typeof m != \"number\" ? m : cc(m, Li)), x = u === Ri ? Xl : Ri, E = i.rects.popper, C = i.elements[p ? x : u], T = w_(oi(C) ? C : C.contextElement || Pe(i.elements.popper), l, h, r), A = $i(i.elements.reference), w = _c({\n            reference: A,\n            element: E,\n            strategy: \"absolute\",\n            placement: n\n        }), S = $r(Object.assign({}, E, w)), k = u === Ri ? S : A, D = {\n            top: T.top - k.top + y.top,\n            bottom: k.bottom - T.bottom + y.bottom,\n            left: T.left - k.left + y.left,\n            right: k.right - T.right + y.right\n        }, O = i.modifiersData.offset;\n        if (u === Ri && O) {\n            var M = O[n];\n            Object.keys(D).forEach(function(L) {\n                var X = [\n                    Dt,\n                    Ot\n                ].indexOf(L) >= 0 ? 1 : -1, I = [\n                    gt,\n                    Ot\n                ].indexOf(L) >= 0 ? \"y\" : \"x\";\n                D[L] += M[I] * X;\n            });\n        }\n        return D;\n    }\n    function k_(i, t) {\n        t === void 0 && (t = {});\n        var e = t, s = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, c = l === void 0 ? wr : l, h = Bi(s), d = h ? a ? Ar : Ar.filter(function(p) {\n            return Bi(p) === h;\n        }) : Li, u = d.filter(function(p) {\n            return c.indexOf(p) >= 0;\n        });\n        u.length === 0 && (u = d, ({}).NODE_ENV !== \"production\" && console.error([\n            \"Popper: The `allowedAutoPlacements` option did not allow any\",\n            \"placements. Ensure the `placement` option matches the variation\",\n            \"of the allowed placements.\",\n            'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n            'Use \"auto-start\" instead.'\n        ].join(\" \")));\n        var f = u.reduce(function(p, _) {\n            return p[_] = Hi(i, {\n                placement: _,\n                boundary: n,\n                rootBoundary: o,\n                padding: r\n            })[Gt(_)], p;\n        }, {});\n        return Object.keys(f).sort(function(p, _) {\n            return f[p] - f[_];\n        });\n    }\n    function S_(i) {\n        if (Gt(i) === bs) return [];\n        var t = Pn(i);\n        return [\n            uc(i),\n            t,\n            uc(t)\n        ];\n    }\n    function O_(i) {\n        var t = i.state, e = i.options, s = i.name;\n        if (!t.modifiersData[s]._skip) {\n            for(var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, c = e.padding, h = e.boundary, d = e.rootBoundary, u = e.altBoundary, f = e.flipVariations, p = f === void 0 ? !0 : f, _ = e.allowedAutoPlacements, m = t.options.placement, y = Gt(m), x = y === m, E = l || (x || !p ? [\n                Pn(m)\n            ] : S_(m)), C = [\n                m\n            ].concat(E).reduce(function(xe, Ut) {\n                return xe.concat(Gt(Ut) === bs ? k_(t, {\n                    placement: Ut,\n                    boundary: h,\n                    rootBoundary: d,\n                    padding: c,\n                    flipVariations: p,\n                    allowedAutoPlacements: _\n                }) : Ut);\n            }, []), T = t.rects.reference, A = t.rects.popper, w = new Map, S = !0, k = C[0], D = 0; D < C.length; D++){\n                var O = C[D], M = Gt(O), L = Bi(O) === ni, X = [\n                    gt,\n                    Ot\n                ].indexOf(M) >= 0, I = X ? \"width\" : \"height\", F = Hi(t, {\n                    placement: O,\n                    boundary: h,\n                    rootBoundary: d,\n                    altBoundary: u,\n                    padding: c\n                }), Y = X ? L ? Dt : mt : L ? Ot : gt;\n                T[I] > A[I] && (Y = Pn(Y));\n                var Yt = Pn(Y), ee = [];\n                if (o && ee.push(F[M] <= 0), a && ee.push(F[Y] <= 0, F[Yt] <= 0), ee.every(function(xe) {\n                    return xe;\n                })) {\n                    k = O, S = !1;\n                    break;\n                }\n                w.set(O, ee);\n            }\n            if (S) for(var ie = p ? 3 : 1, ti = function(Ut) {\n                var Me = C.find(function(mr) {\n                    var Oi = w.get(mr);\n                    if (Oi) return Oi.slice(0, Ut).every(function(Ol) {\n                        return Ol;\n                    });\n                });\n                if (Me) return k = Me, \"break\";\n            }, Kt = ie; Kt > 0; Kt--){\n                var ye = ti(Kt);\n                if (ye === \"break\") break;\n            }\n            t.placement !== k && (t.modifiersData[s]._skip = !0, t.placement = k, t.reset = !0);\n        }\n    }\n    const gc = {\n        name: \"flip\",\n        enabled: !0,\n        phase: \"main\",\n        fn: O_,\n        requiresIfExists: [\n            \"offset\"\n        ],\n        data: {\n            _skip: !1\n        }\n    };\n    function mc(i, t, e) {\n        return e === void 0 && (e = {\n            x: 0,\n            y: 0\n        }), {\n            top: i.top - t.height - e.y,\n            right: i.right - t.width + e.x,\n            bottom: i.bottom - t.height + e.y,\n            left: i.left - t.width - e.x\n        };\n    }\n    function bc(i) {\n        return [\n            gt,\n            Dt,\n            Ot,\n            mt\n        ].some(function(t) {\n            return i[t] >= 0;\n        });\n    }\n    function D_(i) {\n        var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Hi(t, {\n            elementContext: \"reference\"\n        }), a = Hi(t, {\n            altBoundary: !0\n        }), l = mc(r, s), c = mc(a, n, o), h = bc(l), d = bc(c);\n        t.modifiersData[e] = {\n            referenceClippingOffsets: l,\n            popperEscapeOffsets: c,\n            isReferenceHidden: h,\n            hasPopperEscaped: d\n        }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n            \"data-popper-reference-hidden\": h,\n            \"data-popper-escaped\": d\n        });\n    }\n    const vc = {\n        name: \"hide\",\n        enabled: !0,\n        phase: \"main\",\n        requiresIfExists: [\n            \"preventOverflow\"\n        ],\n        fn: D_\n    };\n    function M_(i, t, e) {\n        var s = Gt(i), n = [\n            mt,\n            gt\n        ].indexOf(s) >= 0 ? -1 : 1, o = typeof e == \"function\" ? e(Object.assign({}, t, {\n            placement: i\n        })) : e, r = o[0], a = o[1];\n        return r = r || 0, a = (a || 0) * n, [\n            mt,\n            Dt\n        ].indexOf(s) >= 0 ? {\n            x: a,\n            y: r\n        } : {\n            x: r,\n            y: a\n        };\n    }\n    function I_(i) {\n        var t = i.state, e = i.options, s = i.name, n = e.offset, o = n === void 0 ? [\n            0,\n            0\n        ] : n, r = wr.reduce(function(h, d) {\n            return h[d] = M_(d, t.rects, o), h;\n        }, {}), a = r[t.placement], l = a.x, c = a.y;\n        t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[s] = r;\n    }\n    const yc = {\n        name: \"offset\",\n        enabled: !0,\n        phase: \"main\",\n        requires: [\n            \"popperOffsets\"\n        ],\n        fn: I_\n    };\n    function L_(i) {\n        var t = i.state, e = i.name;\n        t.modifiersData[e] = _c({\n            reference: t.rects.reference,\n            element: t.rects.popper,\n            strategy: \"absolute\",\n            placement: t.placement\n        });\n    }\n    const Br = {\n        name: \"popperOffsets\",\n        enabled: !0,\n        phase: \"read\",\n        fn: L_,\n        data: {}\n    };\n    function P_(i) {\n        return i === \"x\" ? \"y\" : \"x\";\n    }\n    function R_(i) {\n        var t = i.state, e = i.options, s = i.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, c = e.rootBoundary, h = e.altBoundary, d = e.padding, u = e.tether, f = u === void 0 ? !0 : u, p = e.tetherOffset, _ = p === void 0 ? 0 : p, m = Hi(t, {\n            boundary: l,\n            rootBoundary: c,\n            padding: d,\n            altBoundary: h\n        }), y = Gt(t.placement), x = Bi(t.placement), E = !x, C = Mr(y), T = P_(C), A = t.modifiersData.popperOffsets, w = t.rects.reference, S = t.rects.popper, k = typeof _ == \"function\" ? _(Object.assign({}, t.rects, {\n            placement: t.placement\n        })) : _, D = typeof k == \"number\" ? {\n            mainAxis: k,\n            altAxis: k\n        } : Object.assign({\n            mainAxis: 0,\n            altAxis: 0\n        }, k), O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, M = {\n            x: 0,\n            y: 0\n        };\n        if (A) {\n            if (o) {\n                var L, X = C === \"y\" ? gt : mt, I = C === \"y\" ? Ot : Dt, F = C === \"y\" ? \"height\" : \"width\", Y = A[C], Yt = Y + m[X], ee = Y - m[I], ie = f ? -S[F] / 2 : 0, ti = x === ni ? w[F] : S[F], Kt = x === ni ? -S[F] : -w[F], ye = t.elements.arrow, xe = f && ye ? Dr(ye) : {\n                    width: 0,\n                    height: 0\n                }, Ut = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : ac(), Me = Ut[X], mr = Ut[I], Oi = ys(0, w[F], xe[F]), Ol = E ? w[F] / 2 - ie - Oi - Me - D.mainAxis : ti - Oi - Me - D.mainAxis, Tk = E ? -w[F] / 2 + ie + Oi + mr + D.mainAxis : Kt + Oi + mr + D.mainAxis, Dl = t.elements.arrow && vs(t.elements.arrow), Ak = Dl ? C === \"y\" ? Dl.clientTop || 0 : Dl.clientLeft || 0 : 0, Rp = (L = O == null ? void 0 : O[C]) != null ? L : 0, wk = Y + Ol - Rp - Ak, kk = Y + Tk - Rp, Np = ys(f ? Mn(Yt, wk) : Yt, Y, f ? ri(ee, kk) : ee);\n                A[C] = Np, M[C] = Np - Y;\n            }\n            if (a) {\n                var $p, Sk = C === \"x\" ? gt : mt, Ok = C === \"x\" ? Ot : Dt, Di = A[T], br = T === \"y\" ? \"height\" : \"width\", Bp = Di + m[Sk], Hp = Di - m[Ok], Ml = [\n                    gt,\n                    mt\n                ].indexOf(y) !== -1, Fp = ($p = O == null ? void 0 : O[T]) != null ? $p : 0, Vp = Ml ? Bp : Di - w[br] - S[br] - Fp + D.altAxis, Wp = Ml ? Di + w[br] + S[br] - Fp - D.altAxis : Hp, zp = f && Ml ? u_(Vp, Di, Wp) : ys(f ? Vp : Bp, Di, f ? Wp : Hp);\n                A[T] = zp, M[T] = zp - Di;\n            }\n            t.modifiersData[s] = M;\n        }\n    }\n    const xc = {\n        name: \"preventOverflow\",\n        enabled: !0,\n        phase: \"main\",\n        fn: R_,\n        requiresIfExists: [\n            \"offset\"\n        ]\n    };\n    function N_(i) {\n        return {\n            scrollLeft: i.scrollLeft,\n            scrollTop: i.scrollTop\n        };\n    }\n    function $_(i) {\n        return i === Mt(i) || !It(i) ? Pr(i) : N_(i);\n    }\n    function B_(i) {\n        var t = i.getBoundingClientRect(), e = Ni(t.width) / i.offsetWidth || 1, s = Ni(t.height) / i.offsetHeight || 1;\n        return e !== 1 || s !== 1;\n    }\n    function H_(i, t, e) {\n        e === void 0 && (e = !1);\n        var s = It(t), n = It(t) && B_(t), o = Pe(t), r = $i(i, n, e), a = {\n            scrollLeft: 0,\n            scrollTop: 0\n        }, l = {\n            x: 0,\n            y: 0\n        };\n        return (s || !s && !e) && ((oe(t) !== \"body\" || Nr(o)) && (a = $_(t)), It(t) ? (l = $i(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Rr(o))), {\n            x: r.left + a.scrollLeft - l.x,\n            y: r.top + a.scrollTop - l.y,\n            width: r.width,\n            height: r.height\n        };\n    }\n    function F_(i) {\n        var t = new Map, e = new Set, s = [];\n        i.forEach(function(o) {\n            t.set(o.name, o);\n        });\n        function n(o) {\n            e.add(o.name);\n            var r = [].concat(o.requires || [], o.requiresIfExists || []);\n            r.forEach(function(a) {\n                if (!e.has(a)) {\n                    var l = t.get(a);\n                    l && n(l);\n                }\n            }), s.push(o);\n        }\n        return i.forEach(function(o) {\n            e.has(o.name) || n(o);\n        }), s;\n    }\n    function V_(i) {\n        var t = F_(i);\n        return Dn.reduce(function(e, s) {\n            return e.concat(t.filter(function(n) {\n                return n.phase === s;\n            }));\n        }, []);\n    }\n    function W_(i) {\n        var t;\n        return function() {\n            return t || (t = new Promise(function(e) {\n                Promise.resolve().then(function() {\n                    t = void 0, e(i());\n                });\n            })), t;\n        };\n    }\n    function Re(i) {\n        for(var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)e[s - 1] = arguments[s];\n        return [].concat(e).reduce(function(n, o) {\n            return n.replace(/%s/, o);\n        }, i);\n    }\n    var ai = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', z_ = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', Ec = [\n        \"name\",\n        \"enabled\",\n        \"phase\",\n        \"fn\",\n        \"effect\",\n        \"requires\",\n        \"options\"\n    ];\n    function j_(i) {\n        i.forEach(function(t) {\n            [].concat(Object.keys(t), Ec).filter(function(e, s, n) {\n                return n.indexOf(e) === s;\n            }).forEach(function(e) {\n                switch(e){\n                    case \"name\":\n                        typeof t.name != \"string\" && console.error(Re(ai, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n                        break;\n                    case \"enabled\":\n                        typeof t.enabled != \"boolean\" && console.error(Re(ai, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n                        break;\n                    case \"phase\":\n                        Dn.indexOf(t.phase) < 0 && console.error(Re(ai, t.name, '\"phase\"', \"either \" + Dn.join(\", \"), '\"' + String(t.phase) + '\"'));\n                        break;\n                    case \"fn\":\n                        typeof t.fn != \"function\" && console.error(Re(ai, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n                        break;\n                    case \"effect\":\n                        t.effect != null && typeof t.effect != \"function\" && console.error(Re(ai, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n                        break;\n                    case \"requires\":\n                        t.requires != null && !Array.isArray(t.requires) && console.error(Re(ai, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n                        break;\n                    case \"requiresIfExists\":\n                        Array.isArray(t.requiresIfExists) || console.error(Re(ai, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n                        break;\n                    case \"options\":\n                    case \"data\":\n                        break;\n                    default:\n                        console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + Ec.map(function(s) {\n                            return '\"' + s + '\"';\n                        }).join(\", \") + '; but \"' + e + '\" was provided.');\n                }\n                t.requires && t.requires.forEach(function(s) {\n                    i.find(function(n) {\n                        return n.name === s;\n                    }) == null && console.error(Re(z_, String(t.name), s, s));\n                });\n            });\n        });\n    }\n    function Y_(i, t) {\n        var e = new Set;\n        return i.filter(function(s) {\n            var n = t(s);\n            if (!e.has(n)) return e.add(n), !0;\n        });\n    }\n    function K_(i) {\n        var t = i.reduce(function(e, s) {\n            var n = e[s.name];\n            return e[s.name] = n ? Object.assign({}, n, s, {\n                options: Object.assign({}, n.options, s.options),\n                data: Object.assign({}, n.data, s.data)\n            }) : s, e;\n        }, {});\n        return Object.keys(t).map(function(e) {\n            return t[e];\n        });\n    }\n    var Cc = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", U_ = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", Tc = {\n        placement: \"bottom\",\n        modifiers: [],\n        strategy: \"absolute\"\n    };\n    function Ac() {\n        for(var i = arguments.length, t = new Array(i), e = 0; e < i; e++)t[e] = arguments[e];\n        return !t.some(function(s) {\n            return !(s && typeof s.getBoundingClientRect == \"function\");\n        });\n    }\n    function Rn(i) {\n        i === void 0 && (i = {});\n        var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Tc : n;\n        return function(a, l, c) {\n            c === void 0 && (c = o);\n            var h = {\n                placement: \"bottom\",\n                orderedModifiers: [],\n                options: Object.assign({}, Tc, o),\n                modifiersData: {},\n                elements: {\n                    reference: a,\n                    popper: l\n                },\n                attributes: {},\n                styles: {}\n            }, d = [], u = !1, f = {\n                state: h,\n                setOptions: function(y) {\n                    var x = typeof y == \"function\" ? y(h.options) : y;\n                    _(), h.options = Object.assign({}, o, h.options, x), h.scrollParents = {\n                        reference: oi(a) ? xs(a) : a.contextElement ? xs(a.contextElement) : [],\n                        popper: xs(l)\n                    };\n                    var E = V_(K_([].concat(s, h.options.modifiers)));\n                    if (h.orderedModifiers = E.filter(function(O) {\n                        return O.enabled;\n                    }), ({}).NODE_ENV !== \"production\") {\n                        var C = Y_([].concat(E, h.options.modifiers), function(O) {\n                            var M = O.name;\n                            return M;\n                        });\n                        if (j_(C), Gt(h.options.placement) === bs) {\n                            var T = h.orderedModifiers.find(function(O) {\n                                var M = O.name;\n                                return M === \"flip\";\n                            });\n                            T || console.error([\n                                'Popper: \"auto\" placements require the \"flip\" modifier be',\n                                \"present and enabled to work.\"\n                            ].join(\" \"));\n                        }\n                        var A = qt(l), w = A.marginTop, S = A.marginRight, k = A.marginBottom, D = A.marginLeft;\n                        [\n                            w,\n                            S,\n                            k,\n                            D\n                        ].some(function(O) {\n                            return parseFloat(O);\n                        }) && console.warn([\n                            'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                            \"between the popper and its reference element or boundary.\",\n                            \"To replicate margin, use the `offset` modifier, as well as\",\n                            \"the `padding` option in the `preventOverflow` and `flip`\",\n                            \"modifiers.\"\n                        ].join(\" \"));\n                    }\n                    return p(), f.update();\n                },\n                forceUpdate: function() {\n                    if (!u) {\n                        var y = h.elements, x = y.reference, E = y.popper;\n                        if (!Ac(x, E)) {\n                            ({}).NODE_ENV !== \"production\" && console.error(Cc);\n                            return;\n                        }\n                        h.rects = {\n                            reference: H_(x, vs(E), h.options.strategy === \"fixed\"),\n                            popper: Dr(E)\n                        }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(O) {\n                            return h.modifiersData[O.name] = Object.assign({}, O.data);\n                        });\n                        for(var C = 0, T = 0; T < h.orderedModifiers.length; T++){\n                            if (({}).NODE_ENV !== \"production\" && (C += 1, C > 100)) {\n                                console.error(U_);\n                                break;\n                            }\n                            if (h.reset === !0) {\n                                h.reset = !1, T = -1;\n                                continue;\n                            }\n                            var A = h.orderedModifiers[T], w = A.fn, S = A.options, k = S === void 0 ? {} : S, D = A.name;\n                            typeof w == \"function\" && (h = w({\n                                state: h,\n                                options: k,\n                                name: D,\n                                instance: f\n                            }) || h);\n                        }\n                    }\n                },\n                update: W_(function() {\n                    return new Promise(function(m) {\n                        f.forceUpdate(), m(h);\n                    });\n                }),\n                destroy: function() {\n                    _(), u = !0;\n                }\n            };\n            if (!Ac(a, l)) return ({}).NODE_ENV !== \"production\" && console.error(Cc), f;\n            f.setOptions(c).then(function(m) {\n                !u && c.onFirstUpdate && c.onFirstUpdate(m);\n            });\n            function p() {\n                h.orderedModifiers.forEach(function(m) {\n                    var y = m.name, x = m.options, E = x === void 0 ? {} : x, C = m.effect;\n                    if (typeof C == \"function\") {\n                        var T = C({\n                            state: h,\n                            name: y,\n                            instance: f,\n                            options: E\n                        }), A = function() {};\n                        d.push(T || A);\n                    }\n                });\n            }\n            function _() {\n                d.forEach(function(m) {\n                    return m();\n                }), d = [];\n            }\n            return f;\n        };\n    }\n    var X_ = Rn(), G_ = [\n        Lr,\n        Br,\n        Ir,\n        Sr\n    ], q_ = Rn({\n        defaultModifiers: G_\n    }), Z_ = [\n        Lr,\n        Br,\n        Ir,\n        Sr,\n        yc,\n        gc,\n        xc,\n        hc,\n        vc\n    ], Fi = Rn({\n        defaultModifiers: Z_\n    });\n    const wc = Object.freeze(Object.defineProperty({\n        __proto__: null,\n        afterMain: tc,\n        afterRead: Zl,\n        afterWrite: sc,\n        applyStyles: Sr,\n        arrow: hc,\n        auto: bs,\n        basePlacements: Li,\n        beforeMain: Ql,\n        beforeRead: Gl,\n        beforeWrite: ec,\n        bottom: Ot,\n        clippingParents: Ul,\n        computeStyles: Ir,\n        createPopper: Fi,\n        createPopperBase: X_,\n        createPopperLite: q_,\n        detectOverflow: Hi,\n        end: Pi,\n        eventListeners: Lr,\n        flip: gc,\n        hide: vc,\n        left: mt,\n        main: Jl,\n        modifierPhases: Dn,\n        offset: yc,\n        placements: wr,\n        popper: Ri,\n        popperGenerator: Rn,\n        popperOffsets: Br,\n        preventOverflow: xc,\n        read: ql,\n        reference: Xl,\n        right: Dt,\n        start: ni,\n        top: gt,\n        variationPlacements: Ar,\n        viewport: Tr,\n        write: ic\n    }, Symbol.toStringTag, {\n        value: \"Module\"\n    }));\n    function Hr(i) {\n        return i === \"true\" ? !0 : i === \"false\" ? !1 : i === Number(i).toString() ? Number(i) : i === \"\" || i === \"null\" ? null : i;\n    }\n    function Fr(i) {\n        return i.replace(/[A-Z]/g, (t)=>`-${t.toLowerCase()}`);\n    }\n    const v = {\n        setDataAttribute (i, t, e) {\n            i.setAttribute(`data-te-${Fr(t)}`, e);\n        },\n        removeDataAttribute (i, t) {\n            i.removeAttribute(`data-te-${Fr(t)}`);\n        },\n        getDataAttributes (i) {\n            if (!i) return {};\n            const t = {};\n            return Object.keys(i.dataset).filter((e)=>e.startsWith(\"te\")).forEach((e)=>{\n                if (e.startsWith(\"teClass\")) return;\n                let s = e.replace(/^te/, \"\");\n                s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Hr(i.dataset[e]);\n            }), t;\n        },\n        getDataClassAttributes (i) {\n            if (!i) return {};\n            const t = {\n                ...i.dataset\n            };\n            return Object.keys(t).filter((e)=>e.startsWith(\"teClass\")).forEach((e)=>{\n                let s = e.replace(/^teClass/, \"\");\n                s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Hr(t[e]);\n            }), t;\n        },\n        getDataAttribute (i, t) {\n            return Hr(i.getAttribute(`data-te-${Fr(t)}`));\n        },\n        offset (i) {\n            const t = i.getBoundingClientRect();\n            return {\n                top: t.top + document.body.scrollTop,\n                left: t.left + document.body.scrollLeft\n            };\n        },\n        position (i) {\n            return {\n                top: i.offsetTop,\n                left: i.offsetLeft\n            };\n        },\n        style (i, t) {\n            Object.assign(i.style, t);\n        },\n        toggleClass (i, t) {\n            i && Vr(t).forEach((e)=>{\n                i.classList.contains(e) ? i.classList.remove(e) : i.classList.add(e);\n            });\n        },\n        addClass (i, t) {\n            Vr(t).forEach((e)=>!i.classList.contains(e) && i.classList.add(e));\n        },\n        addStyle (i, t) {\n            Object.keys(t).forEach((e)=>{\n                i.style[e] = t[e];\n            });\n        },\n        removeClass (i, t) {\n            Vr(t).forEach((e)=>i.classList.contains(e) && i.classList.remove(e));\n        },\n        hasClass (i, t) {\n            return i.classList.contains(t);\n        }\n    };\n    function Vr(i) {\n        return typeof i == \"string\" ? i.split(\" \") : Array.isArray(i) ? i : !1;\n    }\n    const Q_ = 3, g = {\n        closest (i, t) {\n            return i.closest(t);\n        },\n        matches (i, t) {\n            return i.matches(t);\n        },\n        find (i, t = document.documentElement) {\n            return [].concat(...Element.prototype.querySelectorAll.call(t, i));\n        },\n        findOne (i, t = document.documentElement) {\n            return Element.prototype.querySelector.call(t, i);\n        },\n        children (i, t) {\n            return [].concat(...i.children).filter((s)=>s.matches(t));\n        },\n        parents (i, t) {\n            const e = [];\n            let s = i.parentNode;\n            for(; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== Q_;)this.matches(s, t) && e.push(s), s = s.parentNode;\n            return e;\n        },\n        prev (i, t) {\n            let e = i.previousElementSibling;\n            for(; e;){\n                if (e.matches(t)) return [\n                    e\n                ];\n                e = e.previousElementSibling;\n            }\n            return [];\n        },\n        next (i, t) {\n            let e = i.nextElementSibling;\n            for(; e;){\n                if (this.matches(e, t)) return [\n                    e\n                ];\n                e = e.nextElementSibling;\n            }\n            return [];\n        },\n        focusableChildren (i) {\n            const t = [\n                \"a\",\n                \"button\",\n                \"input\",\n                \"textarea\",\n                \"select\",\n                \"details\",\n                \"[tabindex]\",\n                '[contenteditable=\"true\"]'\n            ].map((e)=>`${e}:not([tabindex^=\"-\"])`).join(\", \");\n            return this.find(t, i).filter((e)=>!ei(e) && ne(e));\n        }\n    }, Wr = \"dropdown\", li = \".te.dropdown\", zr = \".data-api\", Nn = \"Escape\", kc = \"Space\", Sc = \"Tab\", jr = \"ArrowUp\", $n = \"ArrowDown\", J_ = 2, tg = new RegExp(`${jr}|${$n}|${Nn}`), eg = `hide${li}`, ig = `hidden${li}`, sg = `show${li}`, ng = `shown${li}`, og = `click${li}${zr}`, Oc = `keydown${li}${zr}`, rg = `keyup${li}${zr}`, Ne = \"show\", ag = \"dropup\", lg = \"dropend\", cg = \"dropstart\", hg = \"[data-te-navbar-ref]\", Bn = \"[data-te-dropdown-toggle-ref]\", Yr = \"[data-te-dropdown-menu-ref]\", dg = \"[data-te-navbar-nav-ref]\", ug = \"[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)\", fg = st() ? \"top-end\" : \"top-start\", pg = st() ? \"top-start\" : \"top-end\", _g = st() ? \"bottom-end\" : \"bottom-start\", gg = st() ? \"bottom-start\" : \"bottom-end\", mg = st() ? \"left-start\" : \"right-start\", bg = st() ? \"right-start\" : \"left-start\", vg = [\n        {\n            opacity: \"0\"\n        },\n        {\n            opacity: \"1\"\n        }\n    ], yg = [\n        {\n            opacity: \"1\"\n        },\n        {\n            opacity: \"0\"\n        }\n    ], Hn = {\n        duration: 550,\n        iterations: 1,\n        easing: \"ease\",\n        fill: \"both\"\n    }, xg = {\n        offset: [\n            0,\n            2\n        ],\n        boundary: \"clippingParents\",\n        reference: \"toggle\",\n        display: \"dynamic\",\n        popperConfig: null,\n        autoClose: !0,\n        dropdownAnimation: \"on\"\n    }, Eg = {\n        offset: \"(array|string|function)\",\n        boundary: \"(string|element)\",\n        reference: \"(string|element|object)\",\n        display: \"string\",\n        popperConfig: \"(null|object|function)\",\n        autoClose: \"(boolean|string)\",\n        dropdownAnimation: \"string\"\n    };\n    class $t extends Xt {\n        constructor(t, e){\n            super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;\n            const s = window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n            this._animationCanPlay = this._config.dropdownAnimation === \"on\" && !s, this._didInit = !1, this._init();\n        }\n        static get Default() {\n            return xg;\n        }\n        static get DefaultType() {\n            return Eg;\n        }\n        static get NAME() {\n            return Wr;\n        }\n        toggle() {\n            return this._isShown() ? this.hide() : this.show();\n        }\n        show() {\n            if (ei(this._element) || this._isShown(this._menu)) return;\n            const t = {\n                relatedTarget: this._element\n            };\n            if (b.trigger(this._element, sg, t).defaultPrevented) return;\n            const s = $t.getParentFromElement(this._element);\n            this._inNavbar ? v.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(s), \"ontouchstart\" in document.documentElement && !s.closest(dg) && [].concat(...document.body.children).forEach((n)=>b.on(n, \"mouseover\", Sn)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.setAttribute(`data-te-dropdown-${Ne}`, \"\"), this._animationCanPlay && this._menu.animate(vg, Hn), this._element.setAttribute(`data-te-dropdown-${Ne}`, \"\"), setTimeout(()=>{\n                b.trigger(this._element, ng, t);\n            }, this._animationCanPlay ? Hn.duration : 0);\n        }\n        hide() {\n            if (ei(this._element) || !this._isShown(this._menu)) return;\n            const t = {\n                relatedTarget: this._element\n            };\n            this._completeHide(t);\n        }\n        dispose() {\n            this._popper && this._popper.destroy(), super.dispose();\n        }\n        update() {\n            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n        }\n        _init() {\n            this._didInit || (b.on(document, Oc, Bn, $t.dataApiKeydownHandler), b.on(document, Oc, Yr, $t.dataApiKeydownHandler), b.on(document, og, $t.clearMenus), b.on(document, rg, $t.clearMenus), this._didInit = !0);\n        }\n        _completeHide(t) {\n            this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\" || b.trigger(this._element, eg, t).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((s)=>b.off(s, \"mouseover\", Sn)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(yg, Hn)), setTimeout(()=>{\n                this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Ne}`), this._element.removeAttribute(`data-te-dropdown-${Ne}`), this._element.setAttribute(\"aria-expanded\", \"false\"), v.removeDataAttribute(this._menu, \"popper\"), b.trigger(this._element, ig, t);\n            }, this._animationCanPlay ? Hn.duration : 0));\n        }\n        _getConfig(t) {\n            if (t = {\n                ...this.constructor.Default,\n                ...v.getDataAttributes(this._element),\n                ...t\n            }, W(Wr, t, this.constructor.DefaultType), typeof t.reference == \"object\" && !Mi(t.reference) && typeof t.reference.getBoundingClientRect != \"function\") throw new TypeError(`${Wr.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n            return t;\n        }\n        _createPopper(t) {\n            if (typeof wc > \"u\") throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n            let e = this._element;\n            this._config.reference === \"parent\" ? e = t : Mi(this._config.reference) ? e = Le(this._config.reference) : typeof this._config.reference == \"object\" && (e = this._config.reference);\n            const s = this._getPopperConfig(), n = s.modifiers.find((o)=>o.name === \"applyStyles\" && o.enabled === !1);\n            this._popper = Fi(e, this._menu, s), n && v.setDataAttribute(this._menu, \"popper\", \"static\");\n        }\n        _isShown(t = this._element) {\n            return t.dataset[`teDropdown${Ne.charAt(0).toUpperCase() + Ne.slice(1)}`] === \"\";\n        }\n        _getMenuElement() {\n            return g.next(this._element, Yr)[0];\n        }\n        _getPlacement() {\n            const t = this._element.parentNode;\n            if (t.dataset.teDropdownPosition === lg) return mg;\n            if (t.dataset.teDropdownPosition === cg) return bg;\n            const e = getComputedStyle(this._menu).getPropertyValue(\"--te-position\").trim() === \"end\";\n            return t.dataset.teDropdownPosition === ag ? e ? pg : fg : e ? gg : _g;\n        }\n        _detectNavbar() {\n            return this._element.closest(hg) !== null;\n        }\n        _getOffset() {\n            const { offset: t } = this._config;\n            return typeof t == \"string\" ? t.split(\",\").map((e)=>Number.parseInt(e, 10)) : typeof t == \"function\" ? (e)=>t(e, this._element) : t;\n        }\n        _getPopperConfig() {\n            const t = {\n                placement: this._getPlacement(),\n                modifiers: [\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    }\n                ]\n            };\n            return this._config.display === \"static\" && (t.modifiers = [\n                {\n                    name: \"applyStyles\",\n                    enabled: !1\n                }\n            ]), {\n                ...t,\n                ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(t) : this._config.popperConfig\n            };\n        }\n        _selectMenuItem({ key: t, target: e }) {\n            const s = g.find(ug, this._menu).filter(ne);\n            s.length && Bl(s, e, t === $n, !s.includes(e)).focus();\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = $t.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t]();\n                }\n            });\n        }\n        static clearMenus(t) {\n            if (t && (t.button === J_ || t.type === \"keyup\" && t.key !== Sc)) return;\n            const e = g.find(Bn);\n            for(let s = 0, n = e.length; s < n; s++){\n                const o = $t.getInstance(e[s]);\n                if (!o || o._config.autoClose === !1 || !o._isShown()) continue;\n                const r = {\n                    relatedTarget: o._element\n                };\n                if (t) {\n                    const a = t.composedPath(), l = a.includes(o._menu);\n                    if (a.includes(o._element) || o._config.autoClose === \"inside\" && !l || o._config.autoClose === \"outside\" && l || o._menu.contains(t.target) && (t.type === \"keyup\" && t.key === Sc || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;\n                    t.type === \"click\" && (r.clickEvent = t);\n                }\n                o._completeHide(r);\n            }\n        }\n        static getParentFromElement(t) {\n            return Ie(t) || t.parentNode;\n        }\n        static dataApiKeydownHandler(t) {\n            if (/input|textarea/i.test(t.target.tagName) ? t.key === kc || t.key !== Nn && (t.key !== $n && t.key !== jr || t.target.closest(Yr)) : !tg.test(t.key)) return;\n            const e = this.dataset[`teDropdown${Ne.charAt(0).toUpperCase() + Ne.slice(1)}`] === \"\";\n            if (!e && t.key === Nn || (t.preventDefault(), t.stopPropagation(), ei(this))) return;\n            const s = this.matches(Bn) ? this : g.prev(this, Bn)[0], n = $t.getOrCreateInstance(s);\n            if (t.key === Nn) {\n                n.hide();\n                return;\n            }\n            if (t.key === jr || t.key === $n) {\n                e || n.show(), n._selectMenuItem(t);\n                return;\n            }\n            (!e || t.key === kc) && $t.clearMenus();\n        }\n    }\n    const Kr = \"collapse\", Dc = \"te.collapse\", Fn = `.${Dc}`, Mc = {\n        toggle: !0,\n        parent: null\n    }, Cg = {\n        toggle: \"boolean\",\n        parent: \"(null|element)\"\n    }, Tg = `show${Fn}`, Ag = `shown${Fn}`, wg = `hide${Fn}`, kg = `hidden${Fn}`, Ur = \"data-te-collapse-show\", Ic = \"data-te-collapse-collapsed\", Vn = \"data-te-collapse-collapsing\", Sg = \"data-te-collapse-horizontal\", Vi = \"data-te-collapse-item\", Lc = `:scope [${Vi}] [${Vi}]`, Og = \"width\", Dg = \"height\", Mg = \"[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]\", Pc = \"[data-te-collapse-init]\", Ig = {\n        visible: \"!visible\",\n        hidden: \"hidden\",\n        baseTransition: \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n        collapsing: \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n        collapsingHorizontal: \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"\n    }, Lg = {\n        visible: \"string\",\n        hidden: \"string\",\n        baseTransition: \"string\",\n        collapsing: \"string\",\n        collapsingHorizontal: \"string\"\n    };\n    class re extends Xt {\n        constructor(t, e, s){\n            super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._triggerArray = [];\n            const n = g.find(Pc);\n            for(let o = 0, r = n.length; o < r; o++){\n                const a = n[o], l = yr(a), c = g.find(l).filter((h)=>h === this._element);\n                l !== null && c.length && (this._selector = l, this._triggerArray.push(a));\n            }\n            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n        }\n        static get Default() {\n            return Mc;\n        }\n        static get NAME() {\n            return Kr;\n        }\n        toggle() {\n            this._isShown() ? this.hide() : this.show();\n        }\n        show() {\n            if (this._isTransitioning || this._isShown()) return;\n            let t = [], e;\n            if (this._config.parent) {\n                const h = g.find(Lc, this._config.parent);\n                t = g.find(Mg, this._config.parent).filter((d)=>!h.includes(d));\n            }\n            const s = g.findOne(this._selector);\n            if (t.length) {\n                const h = t.find((d)=>s !== d);\n                if (e = h ? re.getInstance(h) : null, e && e._isTransitioning) return;\n            }\n            if (b.trigger(this._element, Tg).defaultPrevented) return;\n            t.forEach((h)=>{\n                s !== h && re.getOrCreateInstance(h, {\n                    toggle: !1\n                }).hide(), e || P.setData(h, Dc, null);\n            });\n            const o = this._getDimension(), r = o === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n            v.removeClass(this._element, this._classes.visible), v.removeClass(this._element, this._classes.hidden), v.addClass(this._element, r), this._element.removeAttribute(Vi), this._element.setAttribute(Vn, \"\"), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n            const a = ()=>{\n                this._isTransitioning = !1, v.removeClass(this._element, this._classes.hidden), v.removeClass(this._element, r), v.addClass(this._element, this._classes.visible), this._element.removeAttribute(Vn), this._element.setAttribute(Vi, \"\"), this._element.setAttribute(Ur, \"\"), this._element.style[o] = \"\", b.trigger(this._element, Ag);\n            }, c = `scroll${o[0].toUpperCase() + o.slice(1)}`;\n            this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[c]}px`;\n        }\n        hide() {\n            if (this._isTransitioning || !this._isShown() || b.trigger(this._element, wg).defaultPrevented) return;\n            const e = this._getDimension(), s = e === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n            this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Ii(this._element), v.addClass(this._element, s), v.removeClass(this._element, this._classes.visible), v.removeClass(this._element, this._classes.hidden), this._element.setAttribute(Vn, \"\"), this._element.removeAttribute(Vi), this._element.removeAttribute(Ur);\n            const n = this._triggerArray.length;\n            for(let r = 0; r < n; r++){\n                const a = this._triggerArray[r], l = Ie(a);\n                l && !this._isShown(l) && this._addAriaAndCollapsedClass([\n                    a\n                ], !1);\n            }\n            this._isTransitioning = !0;\n            const o = ()=>{\n                this._isTransitioning = !1, v.removeClass(this._element, s), v.addClass(this._element, this._classes.visible), v.addClass(this._element, this._classes.hidden), this._element.removeAttribute(Vn), this._element.setAttribute(Vi, \"\"), b.trigger(this._element, kg);\n            };\n            this._element.style[e] = \"\", this._queueCallback(o, this._element, !0);\n        }\n        _isShown(t = this._element) {\n            return t.hasAttribute(Ur);\n        }\n        _getConfig(t) {\n            return t = {\n                ...Mc,\n                ...v.getDataAttributes(this._element),\n                ...t\n            }, t.toggle = !!t.toggle, t.parent = Le(t.parent), W(Kr, t, Cg), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Ig,\n                ...e,\n                ...t\n            }, W(Kr, t, Lg), t;\n        }\n        _getDimension() {\n            return this._element.hasAttribute(Sg) ? Og : Dg;\n        }\n        _initializeChildren() {\n            if (!this._config.parent) return;\n            const t = g.find(Lc, this._config.parent);\n            g.find(Pc, this._config.parent).filter((e)=>!t.includes(e)).forEach((e)=>{\n                const s = Ie(e);\n                s && this._addAriaAndCollapsedClass([\n                    e\n                ], this._isShown(s));\n            });\n        }\n        _addAriaAndCollapsedClass(t, e) {\n            t.length && t.forEach((s)=>{\n                e ? s.removeAttribute(Ic) : s.setAttribute(`${Ic}`, \"\"), s.setAttribute(\"aria-expanded\", e);\n            });\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = {};\n                typeof t == \"string\" && /show|hide/.test(t) && (e.toggle = !1);\n                const s = re.getOrCreateInstance(this, e);\n                if (typeof t == \"string\") {\n                    if (typeof s[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    s[t]();\n                }\n            });\n        }\n    }\n    const Rc = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", Nc = \".sticky-top\";\n    class Es {\n        constructor(){\n            this._element = document.body;\n        }\n        getWidth() {\n            const t = document.documentElement.clientWidth;\n            return Math.abs(window.innerWidth - t);\n        }\n        hide() {\n            const t = this.getWidth();\n            this._disableOverFlow(), this._setElementAttributes(this._element, \"paddingRight\", (e)=>e + t), this._setElementAttributes(Rc, \"paddingRight\", (e)=>e + t), this._setElementAttributes(Nc, \"marginRight\", (e)=>e - t);\n        }\n        _disableOverFlow() {\n            this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\n        }\n        _setElementAttributes(t, e, s) {\n            const n = this.getWidth(), o = (r)=>{\n                if (r !== this._element && window.innerWidth > r.clientWidth + n) return;\n                this._saveInitialAttribute(r, e);\n                const a = window.getComputedStyle(r)[e];\n                r.style[e] = `${s(Number.parseFloat(a))}px`;\n            };\n            this._applyManipulationCallback(t, o);\n        }\n        reset() {\n            this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(Rc, \"paddingRight\"), this._resetElementAttributes(Nc, \"marginRight\");\n        }\n        _saveInitialAttribute(t, e) {\n            const s = t.style[e];\n            s && v.setDataAttribute(t, e, s);\n        }\n        _resetElementAttributes(t, e) {\n            const s = (n)=>{\n                const o = v.getDataAttribute(n, e);\n                typeof o > \"u\" ? n.style.removeProperty(e) : (v.removeDataAttribute(n, e), n.style[e] = o);\n            };\n            this._applyManipulationCallback(t, s);\n        }\n        _applyManipulationCallback(t, e) {\n            Mi(t) ? e(t) : g.find(t, this._element).forEach(e);\n        }\n        isOverflowing() {\n            return this.getWidth() > 0;\n        }\n    }\n    const Pg = {\n        isVisible: !0,\n        isAnimated: !1,\n        rootElement: \"body\",\n        clickCallback: null,\n        backdropClasses: null\n    }, Rg = {\n        isVisible: \"boolean\",\n        isAnimated: \"boolean\",\n        rootElement: \"(element|string)\",\n        clickCallback: \"(function|null)\",\n        backdropClasses: \"(array|null)\"\n    }, $c = \"backdrop\", Bc = `mousedown.te.${$c}`;\n    class Xr {\n        constructor(t){\n            this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n        }\n        show(t) {\n            if (!this._config.isVisible) {\n                ii(t);\n                return;\n            }\n            this._append(), this._config.isAnimated && Ii(this._getElement());\n            const e = this._config.backdropClasses || [\n                \"opacity-50\",\n                \"transition-all\",\n                \"duration-300\",\n                \"ease-in-out\",\n                \"fixed\",\n                \"top-0\",\n                \"left-0\",\n                \"z-[1040]\",\n                \"bg-black\",\n                \"w-screen\",\n                \"h-screen\"\n            ];\n            v.removeClass(this._getElement(), \"opacity-0\"), v.addClass(this._getElement(), e), this._element.setAttribute(\"data-te-backdrop-show\", \"\"), this._emulateAnimation(()=>{\n                ii(t);\n            });\n        }\n        hide(t) {\n            if (!this._config.isVisible) {\n                ii(t);\n                return;\n            }\n            this._element.removeAttribute(\"data-te-backdrop-show\"), this._getElement().classList.add(\"opacity-0\"), this._getElement().classList.remove(\"opacity-50\"), this._emulateAnimation(()=>{\n                this.dispose(), ii(t);\n            });\n        }\n        _getElement() {\n            if (!this._element) {\n                const t = document.createElement(\"div\");\n                t.className = this._config.className, this._config.isAnimated && t.classList.add(\"opacity-50\"), this._element = t;\n            }\n            return this._element;\n        }\n        _getConfig(t) {\n            return t = {\n                ...Pg,\n                ...typeof t == \"object\" ? t : {}\n            }, t.rootElement = Le(t.rootElement), W($c, t, Rg), t;\n        }\n        _append() {\n            this._isAppended || (this._config.rootElement.append(this._getElement()), b.on(this._getElement(), Bc, ()=>{\n                ii(this._config.clickCallback);\n            }), this._isAppended = !0);\n        }\n        dispose() {\n            this._isAppended && (b.off(this._element, Bc), this._element.remove(), this._isAppended = !1);\n        }\n        _emulateAnimation(t) {\n            $l(t, this._getElement(), this._config.isAnimated);\n        }\n    }\n    class Cs {\n        constructor(t, e = {}, s){\n            this._element = t, this._toggler = s, this._event = e.event || \"blur\", this._condition = e.condition || (()=>!0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n)=>{\n                this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());\n            };\n        }\n        trap() {\n            this._setElements(), this._init(), this._setFocusTrap();\n        }\n        disable() {\n            this._focusableElements.forEach((t)=>{\n                t.removeEventListener(this._event, this.handler);\n            }), this._toggler && this._toggler.focus();\n        }\n        update() {\n            this._setElements(), this._setFocusTrap();\n        }\n        _init() {\n            const t = (e)=>{\n                !this._firstElement || e.key !== \"Tab\" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener(\"keydown\", t));\n            };\n            window.addEventListener(\"keydown\", t);\n        }\n        _filterVisible(t) {\n            return t.filter((e)=>{\n                if (!ne(e)) return !1;\n                const s = g.parents(e, \"*\");\n                for(let n = 0; n < s.length; n++){\n                    const o = window.getComputedStyle(s[n]);\n                    if (o && (o.display === \"none\" || o.visibility === \"hidden\")) return !1;\n                }\n                return !0;\n            });\n        }\n        _setElements() {\n            this._focusableElements = g.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];\n        }\n        _setFocusTrap() {\n            this._focusableElements.forEach((t, e)=>{\n                e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);\n            });\n        }\n    }\n    const Wn = (i, t = \"hide\")=>{\n        const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME;\n        b.on(document, e, `[data-te-${s}-dismiss]`, function(n) {\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName) && n.preventDefault(), ei(this)) return;\n            const o = Ie(this) || this.closest(`.${s}`) || this.closest(`[data-te-${s}-init]`);\n            if (!o) return;\n            i.getOrCreateInstance(o)[t]();\n        });\n    }, Hc = \"offcanvas\", Wi = \".te.offcanvas\", Ng = `load${Wi}.data-api`, $g = \"Escape\", Fc = {\n        backdrop: !0,\n        keyboard: !0,\n        scroll: !1\n    }, Bg = {\n        backdrop: \"boolean\",\n        keyboard: \"boolean\",\n        scroll: \"boolean\"\n    }, Vc = \"show\", Hg = \"[data-te-offcanvas-init][data-te-offcanvas-show]\", Fg = `show${Wi}`, Vg = `shown${Wi}`, Wg = `hide${Wi}`, zg = `hidden${Wi}`, jg = `keydown.dismiss${Wi}`;\n    class zi extends Xt {\n        constructor(t, e){\n            super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();\n        }\n        static get NAME() {\n            return Hc;\n        }\n        static get Default() {\n            return Fc;\n        }\n        toggle(t) {\n            return this._isShown ? this.hide() : this.show(t);\n        }\n        show(t) {\n            if (this._isShown || b.trigger(this._element, Fg, {\n                relatedTarget: t\n            }).defaultPrevented) return;\n            this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new Es().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`data-te-offcanvas-${Vc}`, \"\");\n            const s = ()=>{\n                this._config.scroll || this._focustrap.trap(), b.trigger(this._element, Vg, {\n                    relatedTarget: t\n                });\n            };\n            this._queueCallback(s, this._element, !0);\n        }\n        hide() {\n            if (!this._isShown || b.trigger(this._element, Wg).defaultPrevented) return;\n            this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${Vc}`), this._backdrop.hide();\n            const e = ()=>{\n                this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new Es().reset(), b.trigger(this._element, zg);\n            };\n            this._queueCallback(e, this._element, !0);\n        }\n        dispose() {\n            this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n        }\n        _init() {\n            this._didInit || (b.on(window, Ng, ()=>g.find(Hg).forEach((t)=>zi.getOrCreateInstance(t).show())), Wn(zi), this._didInit = !0);\n        }\n        _getConfig(t) {\n            return t = {\n                ...Fc,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" ? t : {}\n            }, W(Hc, t, Bg), t;\n        }\n        _initializeBackDrop() {\n            return new Xr({\n                isVisible: this._config.backdrop,\n                isAnimated: !0,\n                rootElement: this._element.parentNode,\n                clickCallback: ()=>this.hide()\n            });\n        }\n        _initializeFocusTrap() {\n            return new Cs(this._element, {\n                event: \"keydown\",\n                condition: (t)=>t.key === \"Tab\"\n            });\n        }\n        _addEventListeners() {\n            b.on(this._element, jg, (t)=>{\n                this._config.keyboard && t.key === $g && this.hide();\n            });\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = zi.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t](this);\n                }\n            });\n        }\n    }\n    const Gr = \"alert\", Wc = \".te.alert\", Yg = `close${Wc}`, Kg = `closed${Wc}`, Ts = \"data-te-alert-show\", Ug = {\n        animation: \"boolean\",\n        autohide: \"boolean\",\n        delay: \"number\"\n    }, zc = {\n        animation: !0,\n        autohide: !0,\n        delay: 1e3\n    }, Xg = {\n        fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n        fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n    }, Gg = {\n        fadeIn: \"string\",\n        fadeOut: \"string\"\n    };\n    class As extends Xt {\n        constructor(t, e, s){\n            super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._didInit = !1, this._init();\n        }\n        static get DefaultType() {\n            return Ug;\n        }\n        static get Default() {\n            return zc;\n        }\n        static get NAME() {\n            return Gr;\n        }\n        close() {\n            if (b.trigger(this._element, Yg).defaultPrevented) return;\n            let e = 0;\n            this._config.animation && (e = 300, v.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(Ts), setTimeout(()=>{\n                this._queueCallback(()=>this._destroyElement(), this._element, this._config.animation);\n            }, e);\n        }\n        show() {\n            if (this._element) {\n                if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(Ts) && (v.removeClass(this._element, \"hidden\"), v.addClass(this._element, \"block\"), ne(this._element))) {\n                    const t = (e)=>{\n                        v.removeClass(this._element, \"hidden\"), v.addClass(this._element, \"block\"), b.off(e.target, \"animationend\", t);\n                    };\n                    this._element.setAttribute(Ts, \"\"), b.on(this._element, \"animationend\", t);\n                }\n                this._config.animation && (v.removeClass(this._element, this._classes.fadeOut), v.addClass(this._element, this._classes.fadeIn));\n            }\n        }\n        hide() {\n            if (this._element && this._element.hasAttribute(Ts)) {\n                this._element.removeAttribute(Ts);\n                const t = (e)=>{\n                    v.addClass(this._element, \"hidden\"), v.removeClass(this._element, \"block\"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), b.off(e.target, \"animationend\", t);\n                };\n                b.on(this._element, \"animationend\", t), v.removeClass(this._element, this._classes.fadeIn), v.addClass(this._element, this._classes.fadeOut);\n            }\n        }\n        _init() {\n            this._didInit || (Wn(As, \"close\"), this._didInit = !0);\n        }\n        _getConfig(t) {\n            return t = {\n                ...zc,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" && t ? t : {}\n            }, W(Gr, t, this.constructor.DefaultType), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Xg,\n                ...e,\n                ...t\n            }, W(Gr, t, Gg), t;\n        }\n        _setupAutohide() {\n            this._timeout = setTimeout(()=>{\n                this.hide();\n            }, this._config.delay);\n        }\n        _destroyElement() {\n            this._element.remove(), b.trigger(this._element, Kg), this.dispose();\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = As.getOrCreateInstance(this);\n                if (typeof t == \"string\") {\n                    if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t](this);\n                }\n            });\n        }\n    }\n    const qr = \"carousel\", Lt = \".te.carousel\", jc = \".data-api\", qg = \"ArrowLeft\", Zg = \"ArrowRight\", Qg = 500, Jg = 40, Yc = {\n        interval: 5e3,\n        keyboard: !0,\n        slide: !1,\n        pause: \"hover\",\n        wrap: !0,\n        touch: !0\n    }, tm = {\n        interval: \"(number|boolean)\",\n        keyboard: \"boolean\",\n        slide: \"(boolean|string)\",\n        pause: \"(string|boolean)\",\n        wrap: \"boolean\",\n        touch: \"boolean\"\n    }, em = {\n        pointer: \"touch-pan-y\",\n        block: \"!block\",\n        visible: \"data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]\",\n        invisible: \"data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600\",\n        slideRight: \"translate-x-full\",\n        slideLeft: \"-translate-x-full\"\n    }, im = {\n        pointer: \"string\",\n        block: \"string\",\n        visible: \"string\",\n        invisible: \"string\",\n        slideRight: \"string\",\n        slideLeft: \"string\"\n    }, ci = \"next\", hi = \"prev\", di = \"left\", ws = \"right\", sm = {\n        [qg]: ws,\n        [Zg]: di\n    }, nm = `slide${Lt}`, Kc = `slid${Lt}`, om = `keydown${Lt}`, rm = `mouseenter${Lt}`, am = `mouseleave${Lt}`, lm = `touchstart${Lt}`, cm = `touchmove${Lt}`, hm = `touchend${Lt}`, dm = `pointerdown${Lt}`, um = `pointerup${Lt}`, fm = `dragstart${Lt}`, pm = `load${Lt}${jc}`, _m = `click${Lt}${jc}`, gm = \"data-te-carousel-init\", ui = \"data-te-carousel-active\", mm = \"data-te-carousel-slide\", bm = \"data-te-carousel-item-end\", Zr = \"data-te-carousel-item-start\", vm = \"data-te-carousel-item-next\", ym = \"data-te-carousel-item-prev\", xm = \"data-te-carousel-pointer-event\", Em = \"[data-te-carousel-init]\", Uc = \"[data-te-carousel-active]\", Qr = \"[data-te-carousel-item]\", ji = `${Uc}${Qr}`, Cm = `${Qr} img`, Tm = \"[data-te-carousel-item-next], [data-te-carousel-item-prev]\", Am = \"[data-te-carousel-indicators]\", wm = \"[data-te-target]\", km = \"[data-te-slide], [data-te-slide-to]\", Sm = \"touch\", Om = \"pen\";\n    class ae extends Xt {\n        constructor(t, e, s){\n            super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._indicatorsElement = g.findOne(Am, this._element), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init();\n        }\n        static get Default() {\n            return Yc;\n        }\n        static get NAME() {\n            return qr;\n        }\n        next() {\n            this._slide(ci);\n        }\n        nextWhenVisible() {\n            !document.hidden && ne(this._element) && this.next();\n        }\n        prev() {\n            this._slide(hi);\n        }\n        pause(t) {\n            t || (this._isPaused = !0), g.findOne(Tm, this._element) && (Ll(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n        }\n        cycle(t) {\n            t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));\n        }\n        to(t) {\n            this._activeElement = g.findOne(ji, this._element);\n            const e = this._getItemIndex(this._activeElement);\n            if (t > this._items.length - 1 || t < 0) return;\n            if (this._isSliding) {\n                b.one(this._element, Kc, ()=>this.to(t));\n                return;\n            }\n            if (e === t) {\n                this.pause(), this.cycle();\n                return;\n            }\n            const s = t > e ? ci : hi;\n            this._slide(s, this._items[t]);\n        }\n        _init() {\n            this._didInit || (b.on(document, _m, km, ae.dataApiClickHandler), b.on(window, pm, ()=>{\n                const t = g.find(Em);\n                for(let e = 0, s = t.length; e < s; e++)ae.carouselInterface(t[e], ae.getInstance(t[e]));\n            }), this._didInit = !0);\n        }\n        _getConfig(t) {\n            return t = {\n                ...Yc,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" ? t : {}\n            }, W(qr, t, tm), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...em,\n                ...e,\n                ...t\n            }, W(qr, t, im), t;\n        }\n        _applyInitialClasses() {\n            const t = g.findOne(ji, this._element);\n            t.classList.add(this._classes.block, ...this._classes.visible.split(\" \")), this._setActiveIndicatorElement(t);\n        }\n        _handleSwipe() {\n            const t = Math.abs(this.touchDeltaX);\n            if (t <= Jg) return;\n            const e = t / this.touchDeltaX;\n            this.touchDeltaX = 0, e && this._slide(e > 0 ? ws : di);\n        }\n        _setActiveElementClass() {\n            this._activeElement = g.findOne(ji, this._element), v.addClass(this._activeElement, \"hidden\");\n        }\n        _addEventListeners() {\n            this._config.keyboard && b.on(this._element, om, (t)=>this._keydown(t)), this._config.pause === \"hover\" && (b.on(this._element, rm, (t)=>this.pause(t)), b.on(this._element, am, (t)=>this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();\n        }\n        _addTouchEventListeners() {\n            const t = (o)=>this._pointerEvent && (o.pointerType === Om || o.pointerType === Sm), e = (o)=>{\n                t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);\n            }, s = (o)=>{\n                this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;\n            }, n = (o)=>{\n                t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === \"hover\" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((r)=>this.cycle(r), Qg + this._config.interval));\n            };\n            g.find(Cm, this._element).forEach((o)=>{\n                b.on(o, fm, (r)=>r.preventDefault());\n            }), this._pointerEvent ? (b.on(this._element, dm, (o)=>e(o)), b.on(this._element, um, (o)=>n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${xm}`, \"\")) : (b.on(this._element, lm, (o)=>e(o)), b.on(this._element, cm, (o)=>s(o)), b.on(this._element, hm, (o)=>n(o)));\n        }\n        _keydown(t) {\n            if (/input|textarea/i.test(t.target.tagName)) return;\n            const e = sm[t.key];\n            e && (t.preventDefault(), this._slide(e));\n        }\n        _getItemIndex(t) {\n            return this._items = t && t.parentNode ? g.find(Qr, t.parentNode) : [], this._items.indexOf(t);\n        }\n        _getItemByOrder(t, e) {\n            const s = t === ci;\n            return Bl(this._items, e, s, this._config.wrap);\n        }\n        _triggerSlideEvent(t, e) {\n            const s = this._getItemIndex(t), n = this._getItemIndex(g.findOne(ji, this._element));\n            return b.trigger(this._element, nm, {\n                relatedTarget: t,\n                direction: e,\n                from: n,\n                to: s\n            });\n        }\n        _setActiveIndicatorElement(t) {\n            if (this._indicatorsElement) {\n                const e = g.findOne(Uc, this._indicatorsElement);\n                e.removeAttribute(ui), e.removeAttribute(\"aria-current\"), e.classList.remove(\"!opacity-100\");\n                const s = g.find(wm, this._indicatorsElement);\n                for(let n = 0; n < s.length; n++)if (Number.parseInt(s[n].getAttribute(\"data-te-slide-to\"), 10) === this._getItemIndex(t)) {\n                    s[n].setAttribute(`${ui}`, \"\"), s[n].setAttribute(\"aria-current\", \"true\"), s[n].classList.add(\"!opacity-100\");\n                    break;\n                }\n            }\n        }\n        _updateInterval() {\n            const t = this._activeElement || g.findOne(ji, this._element);\n            if (!t) return;\n            const e = Number.parseInt(t.getAttribute(\"data-te-interval\"), 10);\n            e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n        }\n        _slide(t, e) {\n            const s = this._directionToOrder(t), n = g.findOne(ji, this._element), o = this._getItemIndex(n), r = e || this._getItemByOrder(s, n), a = this._getItemIndex(r), l = !!this._interval, c = s === ci, h = c ? Zr : bm, d = c ? vm : ym, u = this._orderToDirection(s), f = h === Zr ? this._classes.slideLeft : this._classes.slideRight, p = h !== Zr ? this._classes.slideLeft : this._classes.slideRight;\n            if (r && r.hasAttribute(ui)) {\n                this._isSliding = !1;\n                return;\n            }\n            if (this._isSliding || this._triggerSlideEvent(r, u).defaultPrevented || !n || !r) return;\n            this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;\n            const m = ()=>{\n                b.trigger(this._element, Kc, {\n                    relatedTarget: r,\n                    direction: u,\n                    from: o,\n                    to: a\n                });\n            };\n            if (this._element.hasAttribute(mm)) {\n                r.setAttribute(`${d}`, \"\"), r.classList.add(this._classes.block, p), Ii(r), n.setAttribute(`${h}`, \"\"), n.classList.add(f, ...this._classes.invisible.split(\" \")), n.classList.remove(...this._classes.visible.split(\" \")), r.setAttribute(`${h}`, \"\"), r.classList.add(...this._classes.visible.split(\" \")), r.classList.remove(this._classes.slideRight, this._classes.slideLeft);\n                const y = ()=>{\n                    r.removeAttribute(h), r.removeAttribute(d), r.setAttribute(`${ui}`, \"\"), n.removeAttribute(ui), n.classList.remove(f, ...this._classes.invisible.split(\" \"), this._classes.block), n.removeAttribute(d), n.removeAttribute(h), this._isSliding = !1, setTimeout(m, 0);\n                };\n                this._queueCallback(y, n, !0);\n            } else n.removeAttribute(ui), n.classList.remove(this._classes.block), r.setAttribute(`${ui}`, \"\"), r.classList.add(this._classes.block), this._isSliding = !1, m();\n            l && this.cycle();\n        }\n        _directionToOrder(t) {\n            return [\n                ws,\n                di\n            ].includes(t) ? st() ? t === di ? hi : ci : t === di ? ci : hi : t;\n        }\n        _orderToDirection(t) {\n            return [\n                ci,\n                hi\n            ].includes(t) ? st() ? t === hi ? di : ws : t === hi ? ws : di : t;\n        }\n        static carouselInterface(t, e) {\n            const s = ae.getOrCreateInstance(t, e);\n            let { _config: n } = s;\n            typeof e == \"object\" && (n = {\n                ...n,\n                ...e\n            });\n            const o = typeof e == \"string\" ? e : n.slide;\n            if (typeof e == \"number\") s.to(e);\n            else if (typeof o == \"string\") {\n                if (typeof s[o] > \"u\") throw new TypeError(`No method named \"${o}\"`);\n                s[o]();\n            } else n.interval && n.carouselInit === null && (s.pause(), s.cycle());\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                ae.carouselInterface(this, t);\n            });\n        }\n        static dataApiClickHandler(t) {\n            const e = Ie(this);\n            if (!e || !e.hasAttribute(gm)) return;\n            const s = {\n                ...v.getDataAttributes(e),\n                ...v.getDataAttributes(this)\n            }, n = this.getAttribute(\"data-te-slide-to\");\n            n && (s.interval = !1), ae.carouselInterface(e, s), n && ae.getInstance(e).to(n), t.preventDefault();\n        }\n    }\n    const Jr = \"modal\", Zt = \".te.modal\", Xc = \"Escape\", Gc = {\n        backdrop: !0,\n        keyboard: !0,\n        focus: !0\n    }, Dm = {\n        backdrop: \"(boolean|string)\",\n        keyboard: \"boolean\",\n        focus: \"boolean\"\n    }, Mm = {\n        show: \"transform-none\",\n        static: \"scale-[1.02]\",\n        staticProperties: \"transition-scale duration-300 ease-in-out\"\n    }, Im = {\n        show: \"string\",\n        static: \"string\",\n        staticProperties: \"string\"\n    }, Lm = `hide${Zt}`, Pm = `hidePrevented${Zt}`, Rm = `hidden${Zt}`, Nm = `show${Zt}`, $m = `shown${Zt}`, qc = `resize${Zt}`, Zc = `click.dismiss${Zt}`, Qc = `keydown.dismiss${Zt}`, Bm = `mouseup.dismiss${Zt}`, Jc = `mousedown.dismiss${Zt}`, th = \"data-te-modal-open\", eh = \"data-te-open\", ks = \"[data-te-modal-dialog-ref]\", Hm = \"[data-te-modal-body-ref]\";\n    class Ss extends Xt {\n        constructor(t, e, s){\n            super(t), this._config = this._getConfig(e), this._classes = this._getClasses(s), this._dialog = g.findOne(ks, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new Es, this._didInit = !1, this._init();\n        }\n        static get Default() {\n            return Gc;\n        }\n        static get NAME() {\n            return Jr;\n        }\n        toggle(t) {\n            return this._isShown ? this.hide() : this.show(t);\n        }\n        show(t) {\n            this._isShown || this._isTransitioning || b.trigger(this._element, Nm, {\n                relatedTarget: t\n            }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(th, \"true\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), b.on(this._dialog, Jc, ()=>{\n                b.one(this._element, Bm, (s)=>{\n                    s.target === this._element && (this._ignoreBackdropClick = !0);\n                });\n            }), this._showElement(t), this._showBackdrop());\n        }\n        hide() {\n            if (!this._isShown || this._isTransitioning || b.trigger(this._element, Lm).defaultPrevented) return;\n            this._isShown = !1;\n            const e = this._isAnimated();\n            e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), g.findOne(ks, this._element).classList.remove(this._classes.show), b.off(this._element, Zc), b.off(this._dialog, Jc), this._queueCallback(()=>this._hideModal(), this._element, e), this._element.removeAttribute(eh);\n        }\n        dispose() {\n            [\n                window,\n                this._dialog\n            ].forEach((t)=>b.off(t, Zt)), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n        }\n        handleUpdate() {\n            this._adjustDialog();\n        }\n        _init() {\n            this._didInit || (Wn(Ss), this._didInit = !0);\n        }\n        _initializeBackDrop() {\n            return new Xr({\n                isVisible: !!this._config.backdrop,\n                isAnimated: this._isAnimated()\n            });\n        }\n        _initializeFocusTrap() {\n            return new Cs(this._element, {\n                event: \"keydown\",\n                condition: (t)=>t.key === \"Tab\"\n            });\n        }\n        _getConfig(t) {\n            return t = {\n                ...Gc,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" ? t : {}\n            }, W(Jr, t, Dm), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Mm,\n                ...e,\n                ...t\n            }, W(Jr, t, Im), t;\n        }\n        _showElement(t) {\n            const e = this._isAnimated(), s = g.findOne(Hm, this._dialog);\n            (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = \"block\", this._element.classList.remove(\"hidden\"), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`${eh}`, \"true\"), this._element.scrollTop = 0;\n            const n = g.findOne(ks, this._element);\n            n.classList.add(this._classes.show), n.classList.remove(\"opacity-0\"), n.classList.add(\"opacity-100\"), s && (s.scrollTop = 0), e && Ii(this._element);\n            const o = ()=>{\n                this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, b.trigger(this._element, $m, {\n                    relatedTarget: t\n                });\n            };\n            this._queueCallback(o, this._dialog, e);\n        }\n        _setEscapeEvent() {\n            this._isShown ? b.on(document, Qc, (t)=>{\n                this._config.keyboard && t.key === Xc ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Xc && this._triggerBackdropTransition();\n            }) : b.off(this._element, Qc);\n        }\n        _setResizeEvent() {\n            this._isShown ? b.on(window, qc, ()=>this._adjustDialog()) : b.off(window, qc);\n        }\n        _hideModal() {\n            const t = g.findOne(ks, this._element);\n            t.classList.remove(this._classes.show), t.classList.remove(\"opacity-100\"), t.classList.add(\"opacity-0\"), setTimeout(()=>{\n                this._element.style.display = \"none\";\n            }, 300), this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop.hide(()=>{\n                document.body.removeAttribute(th), this._resetAdjustments(), this._scrollBar.reset(), b.trigger(this._element, Rm);\n            });\n        }\n        _showBackdrop(t) {\n            b.on(this._element, Zc, (e)=>{\n                if (this._ignoreBackdropClick) {\n                    this._ignoreBackdropClick = !1;\n                    return;\n                }\n                e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === \"static\" && this._triggerBackdropTransition());\n            }), this._backdrop.show(t);\n        }\n        _isAnimated() {\n            return !!g.findOne(ks, this._element);\n        }\n        _triggerBackdropTransition() {\n            if (b.trigger(this._element, Pm).defaultPrevented) return;\n            const { classList: e, scrollHeight: s, style: n } = this._element, o = s > document.documentElement.clientHeight;\n            !o && n.overflowY === \"hidden\" || e.contains(this._classes.static) || (o || (n.overflowY = \"hidden\"), e.add(...this._classes.static.split(\" \")), e.add(...this._classes.staticProperties.split(\" \")), this._queueCallback(()=>{\n                e.remove(this._classes.static), setTimeout(()=>{\n                    e.remove(...this._classes.staticProperties.split(\" \"));\n                }, 300), o || this._queueCallback(()=>{\n                    n.overflowY = \"\";\n                }, this._dialog);\n            }, this._dialog), this._element.focus());\n        }\n        _adjustDialog() {\n            const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0;\n            (!s && t && !st() || s && !t && st()) && (this._element.style.paddingLeft = `${e}px`), (s && !t && !st() || !s && t && st()) && (this._element.style.paddingRight = `${e}px`);\n        }\n        _resetAdjustments() {\n            this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n        }\n        static jQueryInterface(t, e) {\n            return this.each(function() {\n                const s = Ss.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof s[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    s[t](e);\n                }\n            });\n        }\n    }\n    const Fm = new Set([\n        \"background\",\n        \"cite\",\n        \"href\",\n        \"itemtype\",\n        \"longdesc\",\n        \"poster\",\n        \"src\",\n        \"xlink:href\"\n    ]), Vm = /^aria-[\\w-]*$/i, Wm = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, zm = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, jm = (i, t)=>{\n        const e = i.nodeName.toLowerCase();\n        if (t.includes(e)) return Fm.has(e) ? !!(Wm.test(i.nodeValue) || zm.test(i.nodeValue)) : !0;\n        const s = t.filter((n)=>n instanceof RegExp);\n        for(let n = 0, o = s.length; n < o; n++)if (s[n].test(e)) return !0;\n        return !1;\n    }, Ym = {\n        \"*\": [\n            \"class\",\n            \"dir\",\n            \"id\",\n            \"lang\",\n            \"role\",\n            Vm\n        ],\n        a: [\n            \"target\",\n            \"href\",\n            \"title\",\n            \"rel\"\n        ],\n        area: [],\n        b: [],\n        br: [],\n        col: [],\n        code: [],\n        div: [],\n        em: [],\n        hr: [],\n        h1: [],\n        h2: [],\n        h3: [],\n        h4: [],\n        h5: [],\n        h6: [],\n        i: [],\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\"\n        ],\n        li: [],\n        ol: [],\n        p: [],\n        pre: [],\n        s: [],\n        small: [],\n        span: [],\n        sub: [],\n        sup: [],\n        strong: [],\n        u: [],\n        ul: []\n    };\n    function ih(i, t, e) {\n        if (!i.length) return i;\n        if (e && typeof e == \"function\") return e(i);\n        const n = new window.DOMParser().parseFromString(i, \"text/html\"), o = [].concat(...n.body.querySelectorAll(\"*\"));\n        for(let r = 0, a = o.length; r < a; r++){\n            const l = o[r], c = l.nodeName.toLowerCase();\n            if (!Object.keys(t).includes(c)) {\n                l.remove();\n                continue;\n            }\n            const h = [].concat(...l.attributes), d = [].concat(t[\"*\"] || [], t[c] || []);\n            h.forEach((u)=>{\n                jm(u, d) || l.removeAttribute(u.nodeName);\n            });\n        }\n        return n.body.innerHTML;\n    }\n    const sh = \"tooltip\", le = \".te.tooltip\", Km = \"te-tooltip\", Um = new Set([\n        \"sanitize\",\n        \"allowList\",\n        \"sanitizeFn\"\n    ]), Xm = {\n        animation: \"boolean\",\n        template: \"string\",\n        title: \"(string|element|function)\",\n        trigger: \"string\",\n        delay: \"(number|object)\",\n        html: \"boolean\",\n        selector: \"(string|boolean)\",\n        placement: \"(string|function)\",\n        offset: \"(array|string|function)\",\n        container: \"(string|element|boolean)\",\n        fallbackPlacements: \"array\",\n        boundary: \"(string|element)\",\n        customClass: \"(string|function)\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        allowList: \"object\",\n        popperConfig: \"(null|object|function)\"\n    }, Gm = {\n        AUTO: \"auto\",\n        TOP: \"top\",\n        RIGHT: st() ? \"left\" : \"right\",\n        BOTTOM: \"bottom\",\n        LEFT: st() ? \"right\" : \"left\"\n    }, qm = {\n        animation: !0,\n        template: '<div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\"><div data-te-tooltip-inner-ref class=\"tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div></div>',\n        trigger: \"hover focus\",\n        title: \"\",\n        delay: 0,\n        html: !1,\n        selector: !1,\n        placement: \"top\",\n        offset: [\n            0,\n            0\n        ],\n        container: !1,\n        fallbackPlacements: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        boundary: \"clippingParents\",\n        customClass: \"\",\n        sanitize: !0,\n        sanitizeFn: null,\n        allowList: Ym,\n        popperConfig: {\n            hide: !0\n        }\n    }, Zm = {\n        HIDE: `hide${le}`,\n        HIDDEN: `hidden${le}`,\n        SHOW: `show${le}`,\n        SHOWN: `shown${le}`,\n        INSERTED: `inserted${le}`,\n        CLICK: `click${le}`,\n        FOCUSIN: `focusin${le}`,\n        FOCUSOUT: `focusout${le}`,\n        MOUSEENTER: `mouseenter${le}`,\n        MOUSELEAVE: `mouseleave${le}`\n    }, Qm = \"fade\", Jm = \"modal\", ta = \"show\", Os = \"show\", ea = \"out\", nh = \".tooltip-inner\", oh = `.${Jm}`, rh = \"hide.te.modal\", Ds = \"hover\", ia = \"focus\", tb = \"click\", eb = \"manual\";\n    let Ms = class jp extends Xt {\n        constructor(t, e){\n            if (typeof wc > \"u\") throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n            super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n        }\n        static get Default() {\n            return qm;\n        }\n        static get NAME() {\n            return sh;\n        }\n        static get Event() {\n            return Zm;\n        }\n        static get DefaultType() {\n            return Xm;\n        }\n        enable() {\n            this._isEnabled = !0;\n        }\n        disable() {\n            this._isEnabled = !1;\n        }\n        toggleEnabled() {\n            this._isEnabled = !this._isEnabled;\n        }\n        toggle(t) {\n            if (this._isEnabled) {\n                if (t) {\n                    const e = this._initializeOnDelegatedTarget(t);\n                    e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n                } else {\n                    if (this.getTipElement().classList.contains(ta)) {\n                        this._leave(null, this);\n                        return;\n                    }\n                    this._enter(null, this);\n                }\n            }\n        }\n        dispose() {\n            clearTimeout(this._timeout), b.off(this._element.closest(oh), rh, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\n        }\n        show() {\n            if (this._element.style.display === \"none\") throw new Error(\"Please use show on visible elements\");\n            if (!(this.isWithContent() && this._isEnabled)) return;\n            const t = b.trigger(this._element, this.constructor.Event.SHOW), e = Pl(this._element), s = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n            if (t.defaultPrevented || !s) return;\n            this.constructor.NAME === \"tooltip\" && this.tip && this.getTitle() !== this.tip.querySelector(nh).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\n            const n = this.getTipElement(), o = se(this.constructor.NAME);\n            n.setAttribute(\"id\", o), this._element.setAttribute(\"aria-describedby\", o), this._config.animation && setTimeout(()=>{\n                this.tip.classList.add(\"opacity-100\"), this.tip.classList.remove(\"opacity-0\");\n            }, 100);\n            const r = typeof this._config.placement == \"function\" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);\n            this._addAttachmentClass(a);\n            const { container: l } = this._config;\n            if (P.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), b.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Fi(this._element, n, this._getPopperConfig(a)), n.getAttribute(\"id\").includes(\"tooltip\")) switch(r){\n                case \"bottom\":\n                    n.classList.add(\"py-[0.4rem]\");\n                    break;\n                case \"left\":\n                    n.classList.add(\"px-[0.4rem]\");\n                    break;\n                case \"right\":\n                    n.classList.add(\"px-[0.4rem]\");\n                    break;\n                default:\n                    n.classList.add(\"py-[0.4rem]\");\n                    break;\n            }\n            const h = this._resolvePossibleFunction(this._config.customClass);\n            h && n.classList.add(...h.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((f)=>{\n                b.on(f, \"mouseover\", Sn);\n            });\n            const d = ()=>{\n                const f = this._hoverState;\n                this._hoverState = null, b.trigger(this._element, this.constructor.Event.SHOWN), f === ea && this._leave(null, this);\n            }, u = this.tip.classList.contains(\"transition-opacity\");\n            this._queueCallback(d, this.tip, u);\n        }\n        hide() {\n            if (!this._popper) return;\n            const t = this.getTipElement(), e = ()=>{\n                this._isWithActiveTrigger() || (this._hoverState !== Os && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), b.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\n            };\n            if (b.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;\n            t.classList.add(\"opacity-0\"), t.classList.remove(\"opacity-100\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((o)=>b.off(o, \"mouseover\", Sn)), this._activeTrigger[tb] = !1, this._activeTrigger[ia] = !1, this._activeTrigger[Ds] = !1;\n            const n = this.tip.classList.contains(\"opacity-0\");\n            this._queueCallback(e, this.tip, n), this._hoverState = \"\";\n        }\n        update() {\n            this._popper !== null && this._popper.update();\n        }\n        isWithContent() {\n            return !!this.getTitle();\n        }\n        getTipElement() {\n            if (this.tip) return this.tip;\n            const t = document.createElement(\"div\");\n            t.innerHTML = this._config.template;\n            const e = t.children[0];\n            return this.setContent(e), e.classList.remove(Qm, ta), this.tip = e, this.tip;\n        }\n        setContent(t) {\n            this._sanitizeAndSetContent(t, this.getTitle(), nh);\n        }\n        _sanitizeAndSetContent(t, e, s) {\n            const n = g.findOne(s, t);\n            if (!e && n) {\n                n.remove();\n                return;\n            }\n            this.setElementContent(n, e);\n        }\n        setElementContent(t, e) {\n            if (t !== null) {\n                if (Mi(e)) {\n                    e = Le(e), this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent;\n                    return;\n                }\n                this._config.html ? (this._config.sanitize && (e = ih(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e;\n            }\n        }\n        getTitle() {\n            const t = this._element.getAttribute(\"data-te-original-title\") || this._config.title;\n            return this._resolvePossibleFunction(t);\n        }\n        updateAttachment(t) {\n            return t === \"right\" ? \"end\" : t === \"left\" ? \"start\" : t;\n        }\n        _initializeOnDelegatedTarget(t, e) {\n            return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());\n        }\n        _getOffset() {\n            const { offset: t } = this._config;\n            return typeof t == \"string\" ? t.split(\",\").map((e)=>Number.parseInt(e, 10)) : typeof t == \"function\" ? (e)=>t(e, this._element) : t;\n        }\n        _resolvePossibleFunction(t) {\n            return typeof t == \"function\" ? t.call(this._element) : t;\n        }\n        _getPopperConfig(t) {\n            const e = {\n                placement: t,\n                modifiers: [\n                    {\n                        name: \"flip\",\n                        options: {\n                            fallbackPlacements: this._config.fallbackPlacements\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    },\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"arrow\",\n                        options: {\n                            element: `.${this.constructor.NAME}-arrow`\n                        }\n                    },\n                    {\n                        name: \"onChange\",\n                        enabled: !0,\n                        phase: \"afterWrite\",\n                        fn: (s)=>this._handlePopperPlacementChange(s)\n                    }\n                ],\n                onFirstUpdate: (s)=>{\n                    s.options.placement !== s.placement && this._handlePopperPlacementChange(s);\n                }\n            };\n            return {\n                ...e,\n                ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(e) : this._config.popperConfig\n            };\n        }\n        _addAttachmentClass(t) {\n            this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);\n        }\n        _getAttachment(t) {\n            return Gm[t.toUpperCase()];\n        }\n        _setListeners() {\n            this._config.trigger.split(\" \").forEach((e)=>{\n                if (e === \"click\") b.on(this._element, this.constructor.Event.CLICK, this._config.selector, (s)=>this.toggle(s));\n                else if (e !== eb) {\n                    const s = e === Ds ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === Ds ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n                    b.on(this._element, s, this._config.selector, (o)=>this._enter(o)), b.on(this._element, n, this._config.selector, (o)=>this._leave(o));\n                }\n            }), this._hideModalHandler = ()=>{\n                this._element && this.hide();\n            }, b.on(this._element.closest(oh), rh, this._hideModalHandler), this._config.selector ? this._config = {\n                ...this._config,\n                trigger: \"manual\",\n                selector: \"\"\n            } : this._fixTitle();\n        }\n        _fixTitle() {\n            const t = this._element.getAttribute(\"title\"), e = typeof this._element.getAttribute(\"data-te-original-title\");\n            (t || e !== \"string\") && (this._element.setAttribute(\"data-te-original-title\", t || \"\"), t && !this._element.getAttribute(\"aria-label\") && !this._element.textContent && this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n        }\n        _enter(t, e) {\n            if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusin\" ? ia : Ds] = !0), e.getTipElement().classList.contains(ta) || e._hoverState === Os) {\n                e._hoverState = Os;\n                return;\n            }\n            if (clearTimeout(e._timeout), e._hoverState = Os, !e._config.delay || !e._config.delay.show) {\n                e.show();\n                return;\n            }\n            e._timeout = setTimeout(()=>{\n                e._hoverState === Os && e.show();\n            }, e._config.delay.show);\n        }\n        _leave(t, e) {\n            if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusout\" ? ia : Ds] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {\n                if (clearTimeout(e._timeout), e._hoverState = ea, !e._config.delay || !e._config.delay.hide) {\n                    e.hide();\n                    return;\n                }\n                e._timeout = setTimeout(()=>{\n                    e._hoverState === ea && e.hide();\n                }, e._config.delay.hide);\n            }\n        }\n        _isWithActiveTrigger() {\n            for(const t in this._activeTrigger)if (this._activeTrigger[t]) return !0;\n            return !1;\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._element);\n            return Object.keys(e).forEach((s)=>{\n                Um.has(s) && delete e[s];\n            }), t = {\n                ...this.constructor.Default,\n                ...e,\n                ...typeof t == \"object\" && t ? t : {}\n            }, t.container = t.container === !1 ? document.body : Le(t.container), typeof t.delay == \"number\" && (t.delay = {\n                show: t.delay,\n                hide: t.delay\n            }), typeof t.title == \"number\" && (t.title = t.title.toString()), typeof t.content == \"number\" && (t.content = t.content.toString()), W(sh, t, this.constructor.DefaultType), t.sanitize && (t.template = ih(t.template, t.allowList, t.sanitizeFn)), t;\n        }\n        _getDelegateConfig() {\n            const t = {};\n            for(const e in this._config)this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n            return t;\n        }\n        _cleanTipClass() {\n            const t = this.getTipElement(), e = new RegExp(`(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`, \"g\"), s = t.getAttribute(\"class\").match(e);\n            s !== null && s.length > 0 && s.map((n)=>n.trim()).forEach((n)=>t.classList.remove(n));\n        }\n        _getBasicClassPrefix() {\n            return Km;\n        }\n        _handlePopperPlacementChange(t) {\n            const { state: e } = t;\n            e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n        }\n        _disposePopper() {\n            this._popper && (this._popper.destroy(), this._popper = null);\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = jp.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t]();\n                }\n            });\n        }\n    };\n    const ib = \"popover\", ce = \".te.popover\", sb = \"te-popover\", nb = {\n        ...Ms.Default,\n        placement: \"right\",\n        offset: [\n            0,\n            8\n        ],\n        trigger: \"click\",\n        content: \"\",\n        template: '<div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\"><h3 class=\"popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500\"></h3><div class=\"popover-body p-4 text-[#212529] dark:text-white\"></div></div>'\n    }, ob = {\n        ...Ms.DefaultType,\n        content: \"(string|element|function)\"\n    }, rb = {\n        HIDE: `hide${ce}`,\n        HIDDEN: `hidden${ce}`,\n        SHOW: `show${ce}`,\n        SHOWN: `shown${ce}`,\n        INSERTED: `inserted${ce}`,\n        CLICK: `click${ce}`,\n        FOCUSIN: `focusin${ce}`,\n        FOCUSOUT: `focusout${ce}`,\n        MOUSEENTER: `mouseenter${ce}`,\n        MOUSELEAVE: `mouseleave${ce}`\n    }, ab = \".popover-header\", lb = \".popover-body\";\n    class zn extends Ms {\n        static get Default() {\n            return nb;\n        }\n        static get NAME() {\n            return ib;\n        }\n        static get Event() {\n            return rb;\n        }\n        static get DefaultType() {\n            return ob;\n        }\n        isWithContent() {\n            return this.getTitle() || this._getContent();\n        }\n        setContent(t) {\n            this._sanitizeAndSetContent(t, this.getTitle(), ab), this._sanitizeAndSetContent(t, this._getContent(), lb);\n        }\n        _getContent() {\n            return this._resolvePossibleFunction(this._config.content);\n        }\n        _getBasicClassPrefix() {\n            return sb;\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = zn.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t]();\n                }\n            });\n        }\n    }\n    const sa = \"scrollspy\", jn = \".te.scrollspy\", cb = \".data-api\", ah = {\n        offset: 10,\n        method: \"auto\",\n        target: \"\"\n    }, hb = {\n        offset: \"number\",\n        method: \"string\",\n        target: \"(string|element)\"\n    }, db = {\n        active: \"!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400\"\n    }, ub = {\n        active: \"string\"\n    }, fb = `activate${jn}`, pb = `scroll${jn}`, _b = `load${jn}${cb}`, na = \"data-te-nav-link-active\", lh = \"[data-te-dropdown-item-ref]\", gb = '[data-te-spy=\"scroll\"]', mb = \"[data-te-nav-list-ref]\", oa = \"[data-te-nav-link-ref]\", bb = \"[data-te-nav-item-ref]\", ch = \"[data-te-list-group-item-ref]\", ra = `${oa}, ${ch}, ${lh}`, vb = \"[data-te-dropdown-ref]\", yb = \"[data-te-dropdown-toggle-ref]\", xb = \"offset\", hh = \"position\";\n    class Is extends Xt {\n        constructor(t, e, s){\n            super(t), this._scrollElement = this._element.tagName === \"BODY\" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, b.on(this._scrollElement, pb, ()=>this._process()), this.refresh(), this._process(), this._didInit = !1, this._init();\n        }\n        static get Default() {\n            return ah;\n        }\n        static get NAME() {\n            return sa;\n        }\n        refresh() {\n            const t = this._scrollElement === this._scrollElement.window ? xb : hh, e = this._config.method === \"auto\" ? t : this._config.method, s = e === hh ? this._getScrollTop() : 0;\n            this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), g.find(ra, this._config.target).map((o)=>{\n                const r = yr(o), a = r ? g.findOne(r) : null;\n                if (a) {\n                    const l = a.getBoundingClientRect();\n                    if (l.width || l.height) return [\n                        v[e](a).top + s,\n                        r\n                    ];\n                }\n                return null;\n            }).filter((o)=>o).sort((o, r)=>o[0] - r[0]).forEach((o)=>{\n                this._offsets.push(o[0]), this._targets.push(o[1]);\n            });\n        }\n        dispose() {\n            b.off(this._scrollElement, jn), super.dispose();\n        }\n        _init() {\n            this._didInit || (b.on(window, _b, ()=>{\n                g.find(gb).forEach((t)=>new Is(t));\n            }), this._didInit = !0);\n        }\n        _getConfig(t) {\n            return t = {\n                ...ah,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" && t ? t : {}\n            }, t.target = Le(t.target) || document.documentElement, W(sa, t, hb), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...db,\n                ...e,\n                ...t\n            }, W(sa, t, ub), t;\n        }\n        _getScrollTop() {\n            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n        }\n        _getScrollHeight() {\n            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n        }\n        _getOffsetHeight() {\n            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n        }\n        _process() {\n            const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), s = this._config.offset + e - this._getOffsetHeight();\n            if (this._scrollHeight !== e && this.refresh(), t >= s) {\n                const n = this._targets[this._targets.length - 1];\n                this._activeTarget !== n && this._activate(n);\n                return;\n            }\n            if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {\n                this._activeTarget = null, this._clear();\n                return;\n            }\n            for(let n = this._offsets.length; n--;)this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > \"u\" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);\n        }\n        _activate(t) {\n            this._activeTarget = t, this._clear();\n            const e = ra.split(\",\").map((n)=>`${n}[data-te-target=\"${t}\"],${n}[href=\"${t}\"]`), s = g.findOne(e.join(\",\"), this._config.target);\n            s.classList.add(...this._classes.active.split(\" \")), s.setAttribute(na, \"\"), s.getAttribute(lh) ? g.findOne(yb, s.closest(vb)).classList.add(...this._classes.active.split(\" \")) : g.parents(s, mb).forEach((n)=>{\n                g.prev(n, `${oa}, ${ch}`).forEach((o)=>{\n                    o.classList.add(...this._classes.active.split(\" \")), o.setAttribute(na, \"\");\n                }), g.prev(n, bb).forEach((o)=>{\n                    g.children(o, oa).forEach((r)=>r.classList.add(...this._classes.active.split(\" \")));\n                });\n            }), b.trigger(this._scrollElement, fb, {\n                relatedTarget: t\n            });\n        }\n        _clear() {\n            g.find(ra, this._config.target).filter((t)=>t.classList.contains(...this._classes.active.split(\" \"))).forEach((t)=>{\n                t.classList.remove(...this._classes.active.split(\" \")), t.removeAttribute(na);\n            });\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = Is.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t]();\n                }\n            });\n        }\n    }\n    const dh = \"tab\", Yn = \".te.tab\", Eb = `hide${Yn}`, Cb = `hidden${Yn}`, Tb = `show${Yn}`, Ab = `shown${Yn}`, wb = \"data-te-dropdown-menu-ref\", Yi = \"data-te-tab-active\", Kn = \"data-te-nav-active\", kb = \"[data-te-dropdown-ref]\", Sb = \"[data-te-nav-ref]\", uh = `[${Yi}]`, Ob = `[${Kn}]`, fh = \":scope > li > .active\", Db = \"[data-te-dropdown-toggle-ref]\", Mb = \":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]\", Ib = {\n        show: \"opacity-100\",\n        hide: \"opacity-0\"\n    }, Lb = {\n        show: \"string\",\n        hide: \"string\"\n    };\n    class Un extends Xt {\n        constructor(t, e){\n            super(t), this._classes = this._getClasses(e);\n        }\n        static get NAME() {\n            return dh;\n        }\n        show() {\n            if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Kn) === \"\") return;\n            let t;\n            const e = Ie(this._element), s = this._element.closest(Sb), n = g.findOne(Ob, s);\n            if (s) {\n                const l = s.nodeName === \"UL\" || s.nodeName === \"OL\" ? fh : uh;\n                t = g.find(l, s), t = t[t.length - 1];\n            }\n            const o = t ? b.trigger(t, Eb, {\n                relatedTarget: this._element\n            }) : null;\n            if (b.trigger(this._element, Tb, {\n                relatedTarget: t\n            }).defaultPrevented || o !== null && o.defaultPrevented) return;\n            this._activate(this._element, s, null, n, this._element);\n            const a = ()=>{\n                b.trigger(t, Cb, {\n                    relatedTarget: this._element\n                }), b.trigger(this._element, Ab, {\n                    relatedTarget: t\n                });\n            };\n            e ? this._activate(e, e.parentNode, a, n, this._element) : a();\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Ib,\n                ...e,\n                ...t\n            }, W(dh, t, Lb), t;\n        }\n        _activate(t, e, s, n, o) {\n            const a = (e && (e.nodeName === \"UL\" || e.nodeName === \"OL\") ? g.find(fh, e) : g.children(e, uh))[0], l = s && a && a.hasAttribute(Yi), c = ()=>this._transitionComplete(t, a, s, n, o);\n            a && l ? (v.removeClass(a, this._classes.show), v.addClass(a, this._classes.hide), this._queueCallback(c, t, !0)) : c();\n        }\n        _transitionComplete(t, e, s, n, o) {\n            if (e && n) {\n                e.removeAttribute(Yi), n.removeAttribute(Kn);\n                const a = g.findOne(Mb, e.parentNode);\n                a && a.removeAttribute(Yi), e.getAttribute(\"role\") === \"tab\" && e.setAttribute(\"aria-selected\", !1);\n            }\n            t.setAttribute(Yi, \"\"), o.setAttribute(Kn, \"\"), t.getAttribute(\"role\") === \"tab\" && t.setAttribute(\"aria-selected\", !0), Ii(t), t.classList.contains(this._classes.hide) && (v.removeClass(t, this._classes.hide), v.addClass(t, this._classes.show));\n            let r = t.parentNode;\n            if (r && r.nodeName === \"LI\" && (r = r.parentNode), r && r.hasAttribute(wb)) {\n                const a = t.closest(kb);\n                a && g.find(Db, a).forEach((l)=>l.setAttribute(Yi, \"\")), t.setAttribute(\"aria-expanded\", !0);\n            }\n            s && s();\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = Un.getOrCreateInstance(this);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t]();\n                }\n            });\n        }\n    }\n    const aa = \"toast\", $e = \".te.toast\", Pb = `mouseover${$e}`, Rb = `mouseout${$e}`, Nb = `focusin${$e}`, $b = `focusout${$e}`, Bb = `hide${$e}`, Hb = `hidden${$e}`, Fb = `show${$e}`, Vb = `shown${$e}`, ph = \"data-te-toast-hide\", la = \"data-te-toast-show\", Xn = \"data-te-toast-showing\", Wb = {\n        animation: \"boolean\",\n        autohide: \"boolean\",\n        delay: \"number\"\n    }, _h = {\n        animation: !0,\n        autohide: !0,\n        delay: 5e3\n    }, zb = {\n        fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n        fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n    }, jb = {\n        fadeIn: \"string\",\n        fadeOut: \"string\"\n    };\n    class Ls extends Xt {\n        constructor(t, e, s){\n            super(t), this._config = this._getConfig(e), this._classes = this._getClasses(s), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();\n        }\n        static get DefaultType() {\n            return Wb;\n        }\n        static get Default() {\n            return _h;\n        }\n        static get NAME() {\n            return aa;\n        }\n        show() {\n            if (b.trigger(this._element, Fb).defaultPrevented) return;\n            this._clearTimeout(), this._config.animation && (v.removeClass(this._element, this._classes.fadeOut), v.addClass(this._element, this._classes.fadeIn));\n            const e = ()=>{\n                this._element.removeAttribute(Xn), b.trigger(this._element, Vb), this._maybeScheduleHide();\n            };\n            this._element.removeAttribute(ph), Ii(this._element), this._element.setAttribute(la, \"\"), this._element.setAttribute(Xn, \"\"), this._queueCallback(e, this._element, this._config.animation);\n        }\n        hide() {\n            if (!this._element || this._element.dataset.teToastShow === void 0 || b.trigger(this._element, Bb).defaultPrevented) return;\n            const e = ()=>{\n                let s = 0;\n                this._config.animation && (s = 300, v.removeClass(this._element, this._classes.fadeIn), v.addClass(this._element, this._classes.fadeOut)), setTimeout(()=>{\n                    this._element.setAttribute(ph, \"\"), this._element.removeAttribute(Xn), this._element.removeAttribute(la), b.trigger(this._element, Hb);\n                }, s);\n            };\n            this._element.setAttribute(Xn, \"\"), this._queueCallback(e, this._element, this._config.animation);\n        }\n        dispose() {\n            this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(la), super.dispose();\n        }\n        _init() {\n            this._didInit || (Wn(Ls), this._didInit = !0);\n        }\n        _getConfig(t) {\n            return t = {\n                ..._h,\n                ...v.getDataAttributes(this._element),\n                ...typeof t == \"object\" && t ? t : {}\n            }, W(aa, t, this.constructor.DefaultType), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...zb,\n                ...e,\n                ...t\n            }, W(aa, t, jb), t;\n        }\n        _maybeScheduleHide() {\n            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{\n                this.hide();\n            }, this._config.delay)));\n        }\n        _onInteraction(t, e) {\n            switch(t.type){\n                case \"mouseover\":\n                case \"mouseout\":\n                    this._hasMouseInteraction = e;\n                    break;\n                case \"focusin\":\n                case \"focusout\":\n                    this._hasKeyboardInteraction = e;\n                    break;\n            }\n            if (e) {\n                this._clearTimeout();\n                return;\n            }\n            const s = t.relatedTarget;\n            this._element === s || this._element.contains(s) || this._maybeScheduleHide();\n        }\n        _setListeners() {\n            b.on(this._element, Pb, (t)=>this._onInteraction(t, !0)), b.on(this._element, Rb, (t)=>this._onInteraction(t, !1)), b.on(this._element, Nb, (t)=>this._onInteraction(t, !0)), b.on(this._element, $b, (t)=>this._onInteraction(t, !1));\n        }\n        _clearTimeout() {\n            clearTimeout(this._timeout), this._timeout = null;\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                const e = Ls.getOrCreateInstance(this, t);\n                if (typeof t == \"string\") {\n                    if (typeof e[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    e[t](this);\n                }\n            });\n        }\n    }\n    (()=>{\n        var i = {\n            454: (s, n, o)=>{\n                o.d(n, {\n                    Z: ()=>l\n                });\n                var r = o(645), a = o.n(r)()(function(c) {\n                    return c[1];\n                });\n                a.push([\n                    s.id,\n                    \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\",\n                    \"\"\n                ]);\n                const l = a;\n            },\n            645: (s)=>{\n                s.exports = function(n) {\n                    var o = [];\n                    return o.toString = function() {\n                        return this.map(function(r) {\n                            var a = n(r);\n                            return r[2] ? \"@media \".concat(r[2], \" {\").concat(a, \"}\") : a;\n                        }).join(\"\");\n                    }, o.i = function(r, a, l) {\n                        typeof r == \"string\" && (r = [\n                            [\n                                null,\n                                r,\n                                \"\"\n                            ]\n                        ]);\n                        var c = {};\n                        if (l) for(var h = 0; h < this.length; h++){\n                            var d = this[h][0];\n                            d != null && (c[d] = !0);\n                        }\n                        for(var u = 0; u < r.length; u++){\n                            var f = [].concat(r[u]);\n                            l && c[f[0]] || (a && (f[2] ? f[2] = \"\".concat(a, \" and \").concat(f[2]) : f[2] = a), o.push(f));\n                        }\n                    }, o;\n                };\n            },\n            810: ()=>{\n                (function() {\n                    if (typeof window < \"u\") try {\n                        var s = new window.CustomEvent(\"test\", {\n                            cancelable: !0\n                        });\n                        if (s.preventDefault(), s.defaultPrevented !== !0) throw new Error(\"Could not prevent default\");\n                    } catch  {\n                        var n = function(r, a) {\n                            var l, c;\n                            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent(\"CustomEvent\")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), c = l.preventDefault, l.preventDefault = function() {\n                                c.call(this);\n                                try {\n                                    Object.defineProperty(this, \"defaultPrevented\", {\n                                        get: function() {\n                                            return !0;\n                                        }\n                                    });\n                                } catch  {\n                                    this.defaultPrevented = !0;\n                                }\n                            }, l;\n                        };\n                        n.prototype = window.Event.prototype, window.CustomEvent = n;\n                    }\n                })();\n            },\n            379: (s, n, o)=>{\n                var r, a = function() {\n                    var E = {};\n                    return function(C) {\n                        if (E[C] === void 0) {\n                            var T = document.querySelector(C);\n                            if (window.HTMLIFrameElement && T instanceof window.HTMLIFrameElement) try {\n                                T = T.contentDocument.head;\n                            } catch  {\n                                T = null;\n                            }\n                            E[C] = T;\n                        }\n                        return E[C];\n                    };\n                }(), l = [];\n                function c(E) {\n                    for(var C = -1, T = 0; T < l.length; T++)if (l[T].identifier === E) {\n                        C = T;\n                        break;\n                    }\n                    return C;\n                }\n                function h(E, C) {\n                    for(var T = {}, A = [], w = 0; w < E.length; w++){\n                        var S = E[w], k = C.base ? S[0] + C.base : S[0], D = T[k] || 0, O = \"\".concat(k, \" \").concat(D);\n                        T[k] = D + 1;\n                        var M = c(O), L = {\n                            css: S[1],\n                            media: S[2],\n                            sourceMap: S[3]\n                        };\n                        M !== -1 ? (l[M].references++, l[M].updater(L)) : l.push({\n                            identifier: O,\n                            updater: x(L, C),\n                            references: 1\n                        }), A.push(O);\n                    }\n                    return A;\n                }\n                function d(E) {\n                    var C = document.createElement(\"style\"), T = E.attributes || {};\n                    if (T.nonce === void 0) {\n                        var A = o.nc;\n                        A && (T.nonce = A);\n                    }\n                    if (Object.keys(T).forEach(function(S) {\n                        C.setAttribute(S, T[S]);\n                    }), typeof E.insert == \"function\") E.insert(C);\n                    else {\n                        var w = a(E.insert || \"head\");\n                        if (!w) throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n                        w.appendChild(C);\n                    }\n                    return C;\n                }\n                var u, f = (u = [], function(E, C) {\n                    return u[E] = C, u.filter(Boolean).join(`\n`);\n                });\n                function p(E, C, T, A) {\n                    var w = T ? \"\" : A.media ? \"@media \".concat(A.media, \" {\").concat(A.css, \"}\") : A.css;\n                    if (E.styleSheet) E.styleSheet.cssText = f(C, w);\n                    else {\n                        var S = document.createTextNode(w), k = E.childNodes;\n                        k[C] && E.removeChild(k[C]), k.length ? E.insertBefore(S, k[C]) : E.appendChild(S);\n                    }\n                }\n                function _(E, C, T) {\n                    var A = T.css, w = T.media, S = T.sourceMap;\n                    if (w ? E.setAttribute(\"media\", w) : E.removeAttribute(\"media\"), S && typeof btoa < \"u\" && (A += `\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(S)))), \" */\")), E.styleSheet) E.styleSheet.cssText = A;\n                    else {\n                        for(; E.firstChild;)E.removeChild(E.firstChild);\n                        E.appendChild(document.createTextNode(A));\n                    }\n                }\n                var m = null, y = 0;\n                function x(E, C) {\n                    var T, A, w;\n                    if (C.singleton) {\n                        var S = y++;\n                        T = m || (m = d(C)), A = p.bind(null, T, S, !1), w = p.bind(null, T, S, !0);\n                    } else T = d(C), A = _.bind(null, T, C), w = function() {\n                        (function(k) {\n                            if (k.parentNode === null) return !1;\n                            k.parentNode.removeChild(k);\n                        })(T);\n                    };\n                    return A(E), function(k) {\n                        if (k) {\n                            if (k.css === E.css && k.media === E.media && k.sourceMap === E.sourceMap) return;\n                            A(E = k);\n                        } else w();\n                    };\n                }\n                s.exports = function(E, C) {\n                    (C = C || {}).singleton || typeof C.singleton == \"boolean\" || (C.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));\n                    var T = h(E = E || [], C);\n                    return function(A) {\n                        if (A = A || [], Object.prototype.toString.call(A) === \"[object Array]\") {\n                            for(var w = 0; w < T.length; w++){\n                                var S = c(T[w]);\n                                l[S].references--;\n                            }\n                            for(var k = h(A, C), D = 0; D < T.length; D++){\n                                var O = c(T[D]);\n                                l[O].references === 0 && (l[O].updater(), l.splice(O, 1));\n                            }\n                            T = k;\n                        }\n                    };\n                };\n            }\n        }, t = {};\n        function e(s) {\n            var n = t[s];\n            if (n !== void 0) return n.exports;\n            var o = t[s] = {\n                id: s,\n                exports: {}\n            };\n            return i[s](o, o.exports, e), o.exports;\n        }\n        e.n = (s)=>{\n            var n = s && s.__esModule ? ()=>s.default : ()=>s;\n            return e.d(n, {\n                a: n\n            }), n;\n        }, e.d = (s, n)=>{\n            for(var o in n)e.o(n, o) && !e.o(s, o) && Object.defineProperty(s, o, {\n                enumerable: !0,\n                get: n[o]\n            });\n        }, e.o = (s, n)=>Object.prototype.hasOwnProperty.call(s, n), (()=>{\n            var s = e(379), n = e.n(s), o = e(454);\n            function r(l) {\n                if (!l.hasAttribute(\"autocompleted\")) {\n                    l.setAttribute(\"autocompleted\", \"\");\n                    var c = new window.CustomEvent(\"onautocomplete\", {\n                        bubbles: !0,\n                        cancelable: !0,\n                        detail: null\n                    });\n                    l.dispatchEvent(c) || (l.value = \"\");\n                }\n            }\n            function a(l) {\n                l.hasAttribute(\"autocompleted\") && (l.removeAttribute(\"autocompleted\"), l.dispatchEvent(new window.CustomEvent(\"onautocomplete\", {\n                    bubbles: !0,\n                    cancelable: !1,\n                    detail: null\n                })));\n            }\n            n()(o.Z, {\n                insert: \"head\",\n                singleton: !1\n            }), o.Z.locals, e(810), document.addEventListener(\"animationstart\", function(l) {\n                l.animationName === \"onautofillstart\" ? r(l.target) : a(l.target);\n            }, !0), document.addEventListener(\"input\", function(l) {\n                l.inputType !== \"insertReplacementText\" && \"data\" in l ? a(l.target) : r(l.target);\n            }, !0);\n        })();\n    })();\n    const ca = \"input\", Gn = \"te.input\", gh = \"data-te-input-wrapper-init\", mh = \"data-te-input-notch-ref\", bh = \"data-te-input-notch-leading-ref\", vh = \"data-te-input-notch-middle-ref\", Yb = \"data-te-input-notch-trailing-ref\", Kb = \"data-te-input-helper-ref\", Ub = \"data-te-input-placeholder-active\", Be = \"data-te-input-state-active\", yh = \"data-te-input-focused\", xh = \"data-te-input-form-counter\", fi = `[${gh}] input`, pi = `[${gh}] textarea`, Ki = `[${mh}]`, Eh = `[${bh}]`, Ch = `[${vh}]`, Xb = `[${Kb}]`, Gb = {\n        inputFormWhite: !1\n    }, qb = {\n        inputFormWhite: \"(boolean)\"\n    }, Zb = {\n        notch: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\n        notchLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0\",\n        notchLeadingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n        notchLeadingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n        notchMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent\",\n        notchMiddleNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n        notchMiddleWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n        notchTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0\",\n        notchTrailingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n        notchTrailingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n        counter: \"text-right leading-[1.6]\"\n    }, Qb = {\n        notch: \"string\",\n        notchLeading: \"string\",\n        notchLeadingNormal: \"string\",\n        notchLeadingWhite: \"string\",\n        notchMiddle: \"string\",\n        notchMiddleNormal: \"string\",\n        notchMiddleWhite: \"string\",\n        notchTrailing: \"string\",\n        notchTrailingNormal: \"string\",\n        notchTrailingWhite: \"string\",\n        counter: \"string\"\n    };\n    class Z {\n        constructor(t, e, s){\n            this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(s), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (P.setData(t, Gn, this), this.init());\n        }\n        static get NAME() {\n            return ca;\n        }\n        get input() {\n            return g.findOne(\"input\", this._element) || g.findOne(\"textarea\", this._element);\n        }\n        init() {\n            this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);\n        }\n        update() {\n            this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();\n        }\n        forceActive() {\n            this.input.setAttribute(Be, \"\"), g.findOne(Ki, this.input.parentNode).setAttribute(Be, \"\");\n        }\n        forceInactive() {\n            this.input.removeAttribute(Be), g.findOne(Ki, this.input.parentNode).removeAttribute(Be);\n        }\n        dispose() {\n            this._removeBorder(), P.removeData(this._element, Gn), this._element = null;\n        }\n        _getConfig(t, e) {\n            return t = {\n                ...Gb,\n                ...v.getDataAttributes(e),\n                ...typeof t == \"object\" ? t : {}\n            }, W(ca, t, qb), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Zb,\n                ...e,\n                ...t\n            }, W(ca, t, Qb), t;\n        }\n        _getLabelData() {\n            this._label = g.findOne(\"label\", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());\n        }\n        _getHelper() {\n            this._helper = g.findOne(Xb, this._element);\n        }\n        _getCounter() {\n            this._counter = v.getDataAttribute(this.input, \"inputShowcounter\"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());\n        }\n        _getEvents() {\n            b.on(document, \"focus\", fi, Z.activate(new Z)), b.on(document, \"input\", fi, Z.activate(new Z)), b.on(document, \"blur\", fi, Z.deactivate(new Z)), b.on(document, \"focus\", pi, Z.activate(new Z)), b.on(document, \"input\", pi, Z.activate(new Z)), b.on(document, \"blur\", pi, Z.deactivate(new Z)), b.on(window, \"shown.te.modal\", (t)=>{\n                g.find(fi, t.target).forEach((e)=>{\n                    const s = Z.getInstance(e.parentNode);\n                    s && s.update();\n                }), g.find(pi, t.target).forEach((e)=>{\n                    const s = Z.getInstance(e.parentNode);\n                    s && s.update();\n                });\n            }), b.on(window, \"shown.te.dropdown\", (t)=>{\n                const e = t.target.parentNode.querySelector(\"[data-te-dropdown-menu-ref]\");\n                e && (g.find(fi, e).forEach((s)=>{\n                    const n = Z.getInstance(s.parentNode);\n                    n && n.update();\n                }), g.find(pi, e).forEach((s)=>{\n                    const n = Z.getInstance(s.parentNode);\n                    n && n.update();\n                }));\n            }), b.on(window, \"shown.te.tab\", (t)=>{\n                let e;\n                t.target.href ? e = t.target.href.split(\"#\")[1] : e = v.getDataAttribute(t.target, \"target\").split(\"#\")[1];\n                const s = g.findOne(`#${e}`);\n                g.find(fi, s).forEach((n)=>{\n                    const o = Z.getInstance(n.parentNode);\n                    o && o.update();\n                }), g.find(pi, s).forEach((n)=>{\n                    const o = Z.getInstance(n.parentNode);\n                    o && o.update();\n                });\n            }), b.on(window, \"reset\", (t)=>{\n                g.find(fi, t.target).forEach((e)=>{\n                    const s = Z.getInstance(e.parentNode);\n                    s && s.forceInactive();\n                }), g.find(pi, t.target).forEach((e)=>{\n                    const s = Z.getInstance(e.parentNode);\n                    s && s.forceInactive();\n                });\n            }), b.on(window, \"onautocomplete\", (t)=>{\n                const e = Z.getInstance(t.target.parentNode);\n                !e || !t.cancelable || e.forceActive();\n            });\n        }\n        _showCounter() {\n            if (g.find(`[${xh}]`, this._element).length > 0) return;\n            this._counterElement = document.createElement(\"div\"), v.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(xh, \"\");\n            const e = this.input.value.length;\n            this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();\n        }\n        _bindCounter() {\n            b.on(this.input, \"input\", ()=>{\n                const t = this.input.value.length;\n                this._counterElement.innerHTML = `${t} / ${this._maxLength}`;\n            });\n        }\n        _toggleDefaultDatePlaceholder(t = this.input) {\n            if (!(t.getAttribute(\"type\") === \"date\")) return;\n            !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;\n        }\n        _showPlaceholder() {\n            this.input.setAttribute(Ub, \"\");\n        }\n        _getNotchData() {\n            this._notchMiddle = g.findOne(Ch, this._element), this._notchLeading = g.findOne(Eh, this._element);\n        }\n        _getLabelWidth() {\n            this._labelWidth = this._label.clientWidth * .8 + 8;\n        }\n        _getLabelPositionInInputGroup() {\n            if (this._labelMarginLeft = 0, !this._element.hasAttribute(\"data-te-input-group-ref\")) return;\n            const t = this.input, e = g.prev(t, \"[data-te-input-group-text-ref]\")[0];\n            e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;\n        }\n        _applyDivs() {\n            const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, s = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = g.find(Ki, this._element), o = z(\"div\");\n            v.addClass(o, this._classes.notch), o.setAttribute(mh, \"\"), this._notchLeading = z(\"div\"), v.addClass(this._notchLeading, `${this._classes.notchLeading} ${t}`), this._notchLeading.setAttribute(bh, \"\"), this._notchMiddle = z(\"div\"), v.addClass(this._notchMiddle, `${this._classes.notchMiddle} ${e}`), this._notchMiddle.setAttribute(vh, \"\"), this._notchTrailing = z(\"div\"), v.addClass(this._notchTrailing, `${this._classes.notchTrailing} ${s}`), this._notchTrailing.setAttribute(Yb, \"\"), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));\n        }\n        _applyNotch() {\n            this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\n        }\n        _removeBorder() {\n            const t = g.findOne(Ki, this._element);\n            t && t.remove();\n        }\n        _activate(t) {\n            Nl(()=>{\n                this._getElements(t);\n                const e = t ? t.target : this.input, s = g.findOne(Ki, this._element);\n                t && t.type === \"focus\" && s.setAttribute(yh, \"\"), e.value !== \"\" && (e.setAttribute(Be, \"\"), s.setAttribute(Be, \"\")), this._toggleDefaultDatePlaceholder(e);\n            });\n        }\n        _getElements(t) {\n            if (t && (this._element = t.target.parentNode, this._label = g.findOne(\"label\", this._element)), t && this._label) {\n                const e = this._labelWidth;\n                this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = g.findOne(Ch, t.target.parentNode), this._notchLeading = g.findOne(Eh, t.target.parentNode), this._applyNotch());\n            }\n        }\n        _deactivate(t) {\n            const e = t ? t.target : this.input, s = g.findOne(Ki, e.parentNode);\n            s.removeAttribute(yh), e.value === \"\" && (e.removeAttribute(Be), s.removeAttribute(Be)), this._toggleDefaultDatePlaceholder(e);\n        }\n        static activate(t) {\n            return function(e) {\n                t._activate(e);\n            };\n        }\n        static deactivate(t) {\n            return function(e) {\n                t._deactivate(e);\n            };\n        }\n        static jQueryInterface(t, e) {\n            return this.each(function() {\n                let s = P.getData(this, Gn);\n                const n = typeof t == \"object\" && t;\n                if (!(!s && /dispose/.test(t)) && (s || (s = new Z(this, n)), typeof t == \"string\")) {\n                    if (typeof s[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    s[t](e);\n                }\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, Gn);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const Th = \"animation\", ha = \"te.animation\", Jb = {\n        animation: \"string\",\n        animationStart: \"string\",\n        animationShowOnLoad: \"boolean\",\n        onStart: \"(null|function)\",\n        onEnd: \"(null|function)\",\n        onHide: \"(null|function)\",\n        onShow: \"(null|function)\",\n        animationOnScroll: \"(string)\",\n        animationWindowHeight: \"number\",\n        animationOffset: \"(number|string)\",\n        animationDelay: \"(number|string)\",\n        animationReverse: \"boolean\",\n        animationInterval: \"(number|string)\",\n        animationRepeat: \"(number|boolean)\",\n        animationReset: \"boolean\"\n    }, tv = {\n        animation: \"fade\",\n        animationStart: \"onClick\",\n        animationShowOnLoad: !0,\n        onStart: null,\n        onEnd: null,\n        onHide: null,\n        onShow: null,\n        animationOnScroll: \"once\",\n        animationWindowHeight: 0,\n        animationOffset: 0,\n        animationDelay: 0,\n        animationReverse: !1,\n        animationInterval: 0,\n        animationRepeat: !1,\n        animationReset: !1\n    };\n    class qn {\n        constructor(t, e){\n            this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (P.setData(t, ha, this), this._init());\n        }\n        static get NAME() {\n            return Th;\n        }\n        init() {\n            this._init();\n        }\n        startAnimation() {\n            this._startAnimation();\n        }\n        stopAnimation() {\n            this._clearAnimationClass();\n        }\n        changeAnimationType(t) {\n            this._options.animation = t;\n        }\n        dispose() {\n            b.off(this._element, \"mousedown\"), b.off(this._animateElement, \"animationend\"), b.off(window, \"scroll\"), b.off(this._element, \"mouseover\"), P.removeData(this._element, ha), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;\n        }\n        _init() {\n            switch(this._options.animationStart){\n                case \"onHover\":\n                    this._bindHoverEvents();\n                    break;\n                case \"onLoad\":\n                    this._startAnimation();\n                    break;\n                case \"onScroll\":\n                    this._bindScrollEvents();\n                    break;\n                case \"onClick\":\n                    this._bindClickEvents();\n                    break;\n            }\n            this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();\n        }\n        _getAnimateElement() {\n            const t = v.getDataAttribute(this._element, \"animation-target\");\n            return t ? g.find(t)[0] : this._element;\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._animateElement);\n            return t = {\n                ...tv,\n                ...e,\n                ...t\n            }, W(Th, t, Jb), t;\n        }\n        _animateOnScroll() {\n            const t = v.offset(this._animateElement).top, e = this._animateElement.offsetHeight, s = window.innerHeight, n = t + this._options.animationOffset <= s && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === \"visible\";\n            switch(!0){\n                case n && this._isFirstScroll:\n                    this._isFirstScroll = !1, this._startAnimation();\n                    break;\n                case !n && this._isFirstScroll:\n                    this._isFirstScroll = !1, this._hideAnimateElement();\n                    break;\n                case n && !o && this._repeatAnimateOnScroll:\n                    this._options.animationOnScroll !== \"repeat\" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();\n                    break;\n                case !n && o && this._repeatAnimateOnScroll:\n                    this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);\n                    break;\n            }\n        }\n        _addAnimatedClass() {\n            v.addClass(this._animateElement, `animate-${this._options.animation}`);\n        }\n        _clearAnimationClass() {\n            this._animateElement.classList.remove(`animate-${this._options.animation}`);\n        }\n        _startAnimation() {\n            this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();\n        }\n        _setAnimationReverse() {\n            v.style(this._animateElement, {\n                animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : \"2\",\n                animationDirection: \"alternate\"\n            });\n        }\n        _setAnimationDuration() {\n            v.style(this._animateElement, {\n                animationDuration: `${this._options.animationDuration}ms`\n            });\n        }\n        _setAnimationDelay() {\n            v.style(this._animateElement, {\n                animationDelay: `${this._options.animationDelay}ms`\n            });\n        }\n        _setAnimationRepeat() {\n            v.style(this._animateElement, {\n                animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : this._options.animationRepeat\n            });\n        }\n        _setAnimationInterval() {\n            b.on(this._animateElement, \"click\", ()=>{\n                this._clearAnimationClass(), setTimeout(()=>{\n                    this._addAnimatedClass();\n                }, this._options.animationInterval);\n            });\n        }\n        _hideAnimateElement() {\n            v.style(this._animateElement, {\n                visibility: \"hidden\"\n            });\n        }\n        _showAnimateElement() {\n            v.style(this._animateElement, {\n                visibility: \"visible\"\n            });\n        }\n        _bindResetAnimationAfterFinish() {\n            b.on(this._animateElement, \"animationend\", ()=>{\n                this._clearAnimationClass();\n            });\n        }\n        _bindTriggerOnEndCallback() {\n            b.on(this._animateElement, \"animationend\", ()=>{\n                this._callback(this._options.onEnd);\n            });\n        }\n        _bindScrollEvents() {\n            this._options.animationShowOnLoad || this._animateOnScroll(), b.on(window, \"scroll\", ()=>{\n                this._animateOnScroll();\n            });\n        }\n        _bindClickEvents() {\n            b.on(this._element, \"mousedown\", ()=>{\n                this._startAnimation();\n            });\n        }\n        _bindHoverEvents() {\n            b.one(this._element, \"mouseover\", ()=>{\n                this._startAnimation();\n            }), b.one(this._animateElement, \"animationend\", ()=>{\n                setTimeout(()=>{\n                    this._bindHoverEvents();\n                }, 100);\n            });\n        }\n        _callback(t) {\n            t instanceof Function && t();\n        }\n        static autoInit(t) {\n            t._init();\n        }\n        static jQueryInterface(t) {\n            new qn(this[0], t).init();\n        }\n        static getInstance(t) {\n            return P.getData(t, ha);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const da = \"ripple\", Zn = \"te.ripple\", ev = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", iv = [\n        \"[data-te-ripple-init]\"\n    ], Qn = [\n        0,\n        0,\n        0\n    ], sv = [\n        {\n            name: \"primary\",\n            gradientColor: \"#3B71CA\"\n        },\n        {\n            name: \"secondary\",\n            gradientColor: \"#9FA6B2\"\n        },\n        {\n            name: \"success\",\n            gradientColor: \"#14A44D\"\n        },\n        {\n            name: \"danger\",\n            gradientColor: \"#DC4C64\"\n        },\n        {\n            name: \"warning\",\n            gradientColor: \"#E4A11B\"\n        },\n        {\n            name: \"info\",\n            gradientColor: \"#54B4D3\"\n        },\n        {\n            name: \"light\",\n            gradientColor: \"#fbfbfb\"\n        },\n        {\n            name: \"dark\",\n            gradientColor: \"#262626\"\n        }\n    ], Ah = .5, nv = {\n        rippleCentered: !1,\n        rippleColor: \"\",\n        rippleColorDark: \"\",\n        rippleDuration: \"500ms\",\n        rippleRadius: 0,\n        rippleUnbound: !1\n    }, ov = {\n        rippleCentered: \"boolean\",\n        rippleColor: \"string\",\n        rippleColorDark: \"string\",\n        rippleDuration: \"string\",\n        rippleRadius: \"number\",\n        rippleUnbound: \"boolean\"\n    }, rv = {\n        ripple: \"relative overflow-hidden inline-block align-bottom\",\n        rippleWave: \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\n        unbound: \"overflow-visible\"\n    }, av = {\n        ripple: \"string\",\n        rippleWave: \"string\",\n        unbound: \"string\"\n    };\n    class Ui {\n        constructor(t, e, s){\n            this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(s), this._element && (P.setData(t, Zn, this), v.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();\n        }\n        static get NAME() {\n            return da;\n        }\n        init() {\n            this._addClickEvent(this._element);\n        }\n        dispose() {\n            P.removeData(this._element, Zn), b.off(this._element, \"click\", this._clickHandler), this._element = null, this._options = null;\n        }\n        _autoInit(t) {\n            iv.forEach((e)=>{\n                g.closest(t.target, e) && (this._element = g.closest(t.target, e));\n            }), this._element.style.minWidth || (v.style(this._element, {\n                \"min-width\": getComputedStyle(this._element).width\n            }), this._isMinWidthSet = !0), this._initialClasses = [\n                ...this._element.classList\n            ], v.addClass(this._element, this._classes.ripple), this._options = this._getConfig(), this._createRipple(t);\n        }\n        _addClickEvent(t) {\n            b.on(t, \"mousedown\", this._clickHandler);\n        }\n        _createRipple(t) {\n            this._element.className.indexOf(this._classes.ripple) < 0 && v.addClass(this._element, this._classes.ripple);\n            const { layerX: e, layerY: s } = t, n = e, o = s, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), c = {\n                offsetX: this._options.rippleCentered ? r / 2 : n,\n                offsetY: this._options.rippleCentered ? a / 2 : o,\n                height: r,\n                width: a\n            }, h = this._getDiameter(c), d = this._options.rippleRadius || h / 2, u = {\n                delay: l * Ah,\n                duration: l - l * Ah\n            }, f = {\n                left: this._options.rippleCentered ? `${a / 2 - d}px` : `${n - d}px`,\n                top: this._options.rippleCentered ? `${r / 2 - d}px` : `${o - d}px`,\n                height: `${this._options.rippleRadius * 2 || h}px`,\n                width: `${this._options.rippleRadius * 2 || h}px`,\n                transitionDelay: `0s, ${u.delay}ms`,\n                transitionDuration: `${l}ms, ${u.duration}ms`\n            }, p = z(\"div\");\n            this._createHTMLRipple({\n                wrapper: this._element,\n                ripple: p,\n                styles: f\n            }), this._removeHTMLRipple({\n                ripple: p,\n                duration: l\n            });\n        }\n        _createHTMLRipple({ wrapper: t, ripple: e, styles: s }) {\n            Object.keys(s).forEach((n)=>e.style[n] = s[n]), v.addClass(e, this._classes.rippleWave), e.setAttribute(\"data-te-ripple-ref\", \"\"), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);\n        }\n        _removeHTMLRipple({ ripple: t, duration: e }) {\n            this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(()=>{\n                t.classList.add(\"!opacity-0\");\n            }, 10), this._rippleTimer = setTimeout(()=>{\n                if (t && (t.remove(), this._element)) {\n                    g.find(\"[data-te-ripple-ref]\", this._element).forEach((n)=>{\n                        n.remove();\n                    }), this._isMinWidthSet && (v.style(this._element, {\n                        \"min-width\": \"\"\n                    }), this._isMinWidthSet = !1);\n                    const s = this._initialClasses ? this._addedNewRippleClasses(this._classes.ripple, this._initialClasses) : this._classes.ripple.split(\" \");\n                    v.removeClass(this._element, s);\n                }\n            }, e);\n        }\n        _addedNewRippleClasses(t, e) {\n            return t.split(\" \").filter((s)=>e.findIndex((n)=>s === n) === -1);\n        }\n        _durationToMsNumber(t) {\n            return Number(t.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n        }\n        _getConfig(t = {}) {\n            const e = v.getDataAttributes(this._element);\n            return t = {\n                ...nv,\n                ...e,\n                ...t\n            }, W(da, t, ov), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...rv,\n                ...e,\n                ...t\n            }, W(da, t, av), t;\n        }\n        _getDiameter({ offsetX: t, offsetY: e, height: s, width: n }) {\n            const o = e <= s / 2, r = t <= n / 2, a = (u, f)=>Math.sqrt(u ** 2 + f ** 2), l = e === s / 2 && t === n / 2, c = {\n                first: o === !0 && r === !1,\n                second: o === !0 && r === !0,\n                third: o === !1 && r === !0,\n                fourth: o === !1 && r === !1\n            }, h = {\n                topLeft: a(t, e),\n                topRight: a(n - t, e),\n                bottomLeft: a(t, s - e),\n                bottomRight: a(n - t, s - e)\n            };\n            let d = 0;\n            return l || c.fourth ? d = h.topLeft : c.third ? d = h.topRight : c.second ? d = h.bottomRight : c.first && (d = h.bottomLeft), d * 2;\n        }\n        _appendRipple(t, e) {\n            e.appendChild(t), setTimeout(()=>{\n                v.addClass(t, \"opacity-0 scale-100\");\n            }, 50);\n        }\n        _toggleUnbound(t) {\n            this._options.rippleUnbound === !0 ? v.addClass(t, this._classes.unbound) : v.removeClass(t, this._classes.unbound);\n        }\n        _addColor(t) {\n            let e = this._options.rippleColor || \"rgb(0,0,0)\";\n            (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);\n            const s = sv.find((r)=>r.name === e.toLowerCase()), n = s ? this._colorToRGB(s.gradientColor).join(\",\") : this._colorToRGB(e).join(\",\"), o = ev.split(\"{{color}}\").join(`${n}`);\n            t.style.backgroundImage = `radial-gradient(circle, ${o})`;\n        }\n        _colorToRGB(t) {\n            function e(o) {\n                return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [\n                    parseInt(o.substr(1, 2), 16),\n                    parseInt(o.substr(3, 2), 16),\n                    parseInt(o.substr(5, 2), 16)\n                ];\n            }\n            function s(o) {\n                const r = document.body.appendChild(document.createElement(\"fictum\")), a = \"rgb(1, 2, 3)\";\n                return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === \"\") ? Qn : (o = getComputedStyle(r).color, document.body.removeChild(r), o);\n            }\n            function n(o) {\n                return o = o.match(/[.\\d]+/g).map((r)=>+Number(r)), o.length = 3, o;\n            }\n            return t.toLowerCase() === \"transparent\" ? Qn : t[0] === \"#\" ? e(t) : (t.indexOf(\"rgb\") === -1 && (t = s(t)), t.indexOf(\"rgb\") === 0 ? n(t) : Qn);\n        }\n        static autoInitial(t) {\n            return function(e) {\n                t._autoInit(e);\n            };\n        }\n        static jQueryInterface(t) {\n            return this.each(function() {\n                return P.getData(this, Zn) ? null : new Ui(this, t);\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, Zn);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    function bt(i) {\n        return i.getDate();\n    }\n    function Jn(i) {\n        return i.getDay();\n    }\n    function ot(i) {\n        return i.getMonth();\n    }\n    function K(i) {\n        return i.getFullYear();\n    }\n    function lv(i, t, e) {\n        const s = e.startDay, n = s > 0 ? 7 - s : 0, r = new Date(i, t).getDay() + n;\n        return r >= 7 ? r - 7 : r;\n    }\n    function ua(i) {\n        return cv(i).getDate();\n    }\n    function cv(i) {\n        return he(i.getFullYear(), i.getMonth() + 1, 0);\n    }\n    function Xi() {\n        return new Date;\n    }\n    function Et(i, t) {\n        return Ct(i, t * 12);\n    }\n    function Ct(i, t) {\n        const e = he(i.getFullYear(), i.getMonth() + t, i.getDate()), s = bt(i), n = bt(e);\n        return s !== n && e.setDate(0), e;\n    }\n    function Gi(i, t) {\n        return he(i.getFullYear(), i.getMonth(), i.getDate() + t);\n    }\n    function he(i, t, e) {\n        const s = new Date(i, t, e);\n        return i >= 0 && i < 100 && s.setFullYear(s.getFullYear() - 1900), s;\n    }\n    function wh(i) {\n        const t = i.split(\"-\"), e = t[0], s = t[1], n = t[2];\n        return he(e, s, n);\n    }\n    function hv(i) {\n        return !Number.isNaN(i.getTime());\n    }\n    function qi(i, t) {\n        return K(i) - K(t) || ot(i) - ot(t) || bt(i) - bt(t);\n    }\n    function _i(i, t) {\n        return i.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), i.getTime() === t.getTime();\n    }\n    function to(i, t) {\n        const s = K(i) - uv();\n        return dv(s, t);\n    }\n    function dv(i, t) {\n        return (i % t + t) % t;\n    }\n    function uv(i, t, e) {\n        let s = 0;\n        return e ? s = K(e) - i + 1 : t && (s = K(t)), s;\n    }\n    function eo(i, t, e, s, n, o) {\n        const r = new Date;\n        r.setHours(0, 0, 0, 0);\n        const a = t && qi(i, t) <= -1, l = e && qi(i, e) >= 1, c = n && qi(i, r) <= -1, h = o && qi(i, r) >= 1, d = s && s(i) === !1;\n        return a || l || d || c || h;\n    }\n    function kh(i, t, e, s, n, o) {\n        const r = new Date, a = s && K(s), l = s && ot(s), c = e && K(e), h = e && ot(e), d = K(r), u = ot(r), f = l && a && (t > a || t === a && i > l), p = h && c && (t < c || t === c && i < h), _ = n && (t < d || t === d && i < u), m = o && (t > d || t === d && i > u);\n        return f || p || _ || m;\n    }\n    function fa(i, t, e, s, n) {\n        const o = t && K(t), r = e && K(e), a = K(new Date), l = r && i > r, c = o && i < o, h = s && i < a, d = n && i > a;\n        return l || c || h || d;\n    }\n    function fv(i, t, e, s, n, o, r, a) {\n        const l = new Date;\n        return l.setHours(0, 0, 0, 0), (i && o && qi(o, l) < 0 || i) && (o = l), o && Ps(t, o, e, s, n, o, r, a);\n    }\n    function pv(i, t, e, s, n, o, r, a) {\n        const l = new Date;\n        return l.setHours(0, 0, 0, 0), (i && n && qi(n, l) < 0 || i) && (n = l), n && Ps(t, n, e, s, n, o, r, a);\n    }\n    function Ps(i, t, e, s, n, o, r, a) {\n        return e === \"days\" ? K(i) === K(t) && ot(i) === ot(t) : e === \"months\" ? K(i) === K(t) : e === \"years\" ? K(t) >= a && K(t) <= r : !1;\n    }\n    const _v = \"data-te-datepicker-modal-container-ref\", gv = \"data-te-datepicker-dropdown-container-ref\", mv = \"data-te-dropdown-backdrop-ref\", bv = \"data-te-datepicker-date-text-ref\", Sh = \"data-te-datepicker-view-ref\", vv = \"data-te-datepicker-previous-button-ref\", yv = \"data-te-datepicker-next-button-ref\", xv = \"data-te-datepicker-ok-button-ref\", Ev = \"data-te-datepicker-cancel-button-ref\", Cv = \"data-te-datepicker-clear-button-ref\", Tv = \"data-te-datepicker-view-change-button-ref\";\n    function Av(i, t, e, s, n, o, r, a, l, c) {\n        const h = ot(i), d = K(i), u = bt(i), f = Jn(i), p = z(\"div\"), _ = `\n        ${Oh(i, h, d, t, e, s, n, o, r, a, c)}\n    `, m = `\n      ${kv(u, f, h, n, c)}\n      ${Oh(i, h, d, t, e, s, n, o, r, a, c)}\n    `;\n        return n.inline ? (v.addClass(p, c.datepickerDropdownContainer), p.setAttribute(gv, l), p.innerHTML = _) : (v.addClass(p, c.modalContainer), p.setAttribute(_v, l), p.innerHTML = m), p;\n    }\n    function wv(i) {\n        const t = z(\"div\");\n        return v.addClass(t, i), t.setAttribute(mv, \"\"), t;\n    }\n    function kv(i, t, e, s, n) {\n        return `\n      <div class=\"${n.datepickerHeader}\">\n        <div class=\"${n.datepickerTitle}\">\n          <span class=\"${n.datepickerTitleText}\">${s.title}</span>\n        </div>\n        <div class=\"${n.datepickerDate}\">\n          <span class=\"${n.datepickerDateText}\" ${bv} >${s.weekdaysShort[t]}, ${s.monthsShort[e]} ${i}</span>\n        </div>\n      </div>\n    `;\n    }\n    function Oh(i, t, e, s, n, o, r, a, l, c, h) {\n        let d;\n        return r.inline ? d = `\n    <div class=\"${h.datepickerMain}\">\n      ${Mh(t, e, r, h)}\n      <div class=\"${h.datepickerView}\" ${Sh} tabindex=\"0\">\n        ${Dh(i, e, s, n, o, r, a, l, c, h)}\n      </div>\n    </div>\n  ` : d = `\n    <div class=\"${h.datepickerMain}\">\n      ${Mh(t, e, r, h)}\n      <div class=\"${h.datepickerView}\" ${Sh} tabindex=\"0\">\n        ${Dh(i, e, s, n, o, r, a, l, c, h)}\n      </div>\n      ${Sv(r, h)}\n    </div>\n  `, d;\n    }\n    function Dh(i, t, e, s, n, o, r, a, l, c) {\n        let h;\n        return o.view === \"days\" ? h = io(i, e, o, c) : o.view === \"months\" ? h = so(t, s, n, o, r, c) : h = no(i, s, o, a, l, c), h;\n    }\n    function Mh(i, t, e, s) {\n        return `\n    <div class=\"${s.datepickerDateControls}\">\n      <button class=\"${s.datepickerViewChangeButton}\" aria-label=\"${e.switchToMultiYearViewLabel}\" ${Tv}>\n        ${e.monthsFull[i]} ${t} ${de(e, s)}\n      </button>\n      <div class=\"${s.datepickerArrowControls}\">\n        <button class=\"${s.datepickerPreviousButton}\" aria-label=\"${e.prevMonthLabel}\" ${vv}>${e.changeMonthIconTemplate}</button>\n        <button class=\"${s.datepickerNextButton}\" aria-label=\"${e.nextMonthLabel}\" ${yv}>${e.changeMonthIconTemplate}</button>\n      </div>\n    </div>\n    `;\n    }\n    function de(i, t) {\n        return `\n  <span class=\"${t.datepickerViewChangeIcon}\">\n  ${i.viewChangeIconTemplate}\n  </span>\n  `;\n    }\n    function Sv(i, t) {\n        const e = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${i.okBtnLabel}\" ${xv}>${i.okBtnText}</button>`, s = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${i.cancelBtnLabel}\" ${Ev}>${i.cancelBtnText}</button>`, n = `<button class=\"${t.datepickerFooterBtn} ${t.datepickerClearBtn}\" aria-label=\"${i.clearBtnLabel}\" ${Cv}>${i.clearBtnText}</button>`;\n        return `\n        <div class=\"${t.datepickerFooter}\">\n          \n        ${i.removeClearBtn ? \"\" : n}\n        ${i.removeCancelBtn ? \"\" : s}\n        ${i.removeOkBtn ? \"\" : e}\n        </div>\n      `;\n    }\n    function io(i, t, e, s) {\n        const n = Ov(i, t, e), r = `\n      <tr>\n        ${e.weekdaysNarrow.map((l, c)=>`<th class=\"${s.datepickerDayHeading}\" scope=\"col\" aria-label=\"${e.weekdaysFull[c]}\">${l}</th>`).join(\"\")}\n      </tr>\n    `, a = n.map((l)=>`\n        <tr>\n          ${l.map((c)=>`\n              <td\n              class=\"${s.datepickerCell} ${s.datepickerCellSmall}\"\n              data-te-date=\"${K(c.date)}-${ot(c.date)}-${bt(c.date)}\"\n              aria-label=\"${c.date}\"\n              aria-selected=\"${c.isSelected}\"\n              ${c.isSelected ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${!c.currentMonth || c.disabled ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${c.isToday ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div\n                  class=\"${s.datepickerCellContent} ${s.datepickerCellContentSmall}\"\n                  style=\"${c.currentMonth ? \"display: block\" : \"display: none\"}\"\n                  >\n                  ${c.dayNumber}\n                  </div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\");\n        return `\n      <table class=\"${s.datepickerTable}\">\n        <thead>\n          ${r}\n        </thead>\n        <tbody>\n         ${a}\n        </tbody>\n      </table>\n    `;\n    }\n    function Ov(i, t, e) {\n        const s = [], n = ot(i), o = ot(Ct(i, -1)), r = ot(Ct(i, 1)), a = K(i), l = lv(a, n, e), c = ua(i), h = ua(Ct(i, -1)), d = 7;\n        let u = 1, f = !1;\n        for(let p = 1; p < d; p++){\n            const _ = [];\n            if (p === 1) {\n                const m = h - l + 1;\n                for(let x = m; x <= h; x++){\n                    const E = he(a, o, x);\n                    _.push({\n                        date: E,\n                        currentMonth: f,\n                        isSelected: t && _i(E, t),\n                        isToday: _i(E, Xi()),\n                        dayNumber: bt(E)\n                    });\n                }\n                f = !0;\n                const y = d - _.length;\n                for(let x = 0; x < y; x++){\n                    const E = he(a, n, u);\n                    _.push({\n                        date: E,\n                        currentMonth: f,\n                        isSelected: t && _i(E, t),\n                        isToday: _i(E, Xi()),\n                        dayNumber: bt(E),\n                        disabled: eo(E, e.min, e.max, e.filter, e.disablePast, e.disableFuture)\n                    }), u++;\n                }\n            } else for(let m = 1; m < 8; m++){\n                u > c && (u = 1, f = !1);\n                const y = he(a, f ? n : r, u);\n                _.push({\n                    date: y,\n                    currentMonth: f,\n                    isSelected: t && _i(y, t),\n                    isToday: _i(y, Xi()),\n                    dayNumber: bt(y),\n                    disabled: eo(y, e.min, e.max, e.filter, e.disablePast, e.disableFuture)\n                }), u++;\n            }\n            s.push(_);\n        }\n        return s;\n    }\n    function so(i, t, e, s, n, o) {\n        const r = Dv(s, n), a = ot(Xi()), l = K(Xi()), c = `\n      ${r.map((h)=>`\n          <tr>\n            ${h.map((d)=>{\n                const u = s.monthsShort.indexOf(d);\n                return `\n                <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"\n                ${kh(u, i, s.min, s.max, s.disablePast, s.disableFuture) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n                \n                data-te-month=\"${u}\" data-te-year=\"${i}\" aria-label=\"${d}, ${i}\"\n                ${u === e && i === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n                ${u === a && i === l ? \"data-te-datepicker-cell-current\" : \"\"}\" data-te-month=\"${u}\" data-te-year=\"${i}\" aria-label=\"${d}, ${i}\">\n                  <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${d}</div>\n                </td>\n              `;\n            }).join(\"\")}\n          </tr>\n        `).join(\"\")}\n    `;\n        return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n         ${c}\n        </tbody>\n      </table>\n    `;\n    }\n    function Dv(i, t) {\n        const e = [];\n        let s = [];\n        for(let n = 0; n < i.monthsShort.length; n++)if (s.push(i.monthsShort[n]), s.length === t) {\n            const o = s;\n            e.push(o), s = [];\n        }\n        return e;\n    }\n    function no(i, t, e, s, n, o) {\n        const r = Mv(i, s, n), a = K(Xi()), l = `\n    ${r.map((c)=>`\n        <tr>\n          ${c.map((h)=>`\n              <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"  aria-label=\"${h}\" data-te-year=\"${h}\"\n              ${fa(h, e.min, e.max, e.disablePast, e.disableFuture) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${h === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${h === a ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${h}</div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\")}\n  `;\n        return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n        ${l}\n        </tbody>\n      </table>\n    `;\n    }\n    function Mv(i, t, e) {\n        const s = [], n = K(i), o = to(i, t), r = n - o;\n        let a = [];\n        for(let l = 0; l < t; l++)if (a.push(r + l), a.length === e) {\n            const c = a;\n            s.push(c), a = [];\n        }\n        return s;\n    }\n    function Iv(i, t) {\n        return `\n    <button id=\"${i}\" type=\"button\" class=\"${t}\" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n      </svg>  \n    </button>\n  `;\n    }\n    const Zi = 37, Tt = 38, Qi = 39, ut = 40, Ji = 36, ts = 35, pa = 33, _a = 34, Pt = 13, oo = 32, ro = 27, Rs = 9, Lv = 8, Pv = 46, Qt = 24, ao = 4, lo = 4, ga = \"datepicker\", co = \"te.datepicker\", ho = `.${co}`, Rv = \".data-api\", Nv = `close${ho}`, $v = `open${ho}`, Bv = `dateChange${ho}`, uo = `click${ho}${Rv}`, Ih = \"data-te-datepicker-modal-container-ref\", Lh = \"data-te-datepicker-dropdown-container-ref\", fo = \"[data-te-datepicker-toggle-ref]\", Hv = `[${Ih}]`, Fv = `[${Lh}]`, Vv = \"[data-te-datepicker-view-change-button-ref]\", Wv = \"[data-te-datepicker-previous-button-ref]\", zv = \"[data-te-datepicker-next-button-ref]\", jv = \"[data-te-datepicker-ok-button-ref]\", Yv = \"[data-te-datepicker-cancel-button-ref]\", Kv = \"[data-te-datepicker-clear-button-ref]\", Uv = \"[data-te-datepicker-view-ref]\", Xv = \"[data-te-datepicker-toggle-button-ref]\", Gv = \"[data-te-datepicker-date-text-ref]\", qv = \"[data-te-dropdown-backdrop-ref]\", Zv = \"animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", Qv = \"animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", Jv = \"animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", t0 = \"animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", e0 = \"flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700\", i0 = \"w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]\", s0 = \"relative h-full\", n0 = \"xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800\", o0 = \"h-8 flex flex-col justify-end\", r0 = \"text-[10px] font-normal uppercase tracking-[1.7px] text-white\", a0 = \"xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end\", l0 = \"text-[34px] font-normal text-white\", c0 = \"outline-none px-3\", h0 = \"px-3 pt-2.5 pb-0 flex justify-between text-black/[64]\", d0 = \"flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", u0 = \"mt-2.5\", f0 = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto\", p0 = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto\", _0 = \"h-14 flex absolute w-full bottom-0 justify-end items-center px-3\", g0 = \"outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", m0 = \"mr-auto\", b0 = \"w-10 h-10 text-center text-[12px] font-normal dark:text-white\", v0 = \"text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group\", y0 = \"w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8\", x0 = \"w-[76px] h-[42px]\", E0 = \"mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500\", C0 = \"w-9 h-9 leading-9 rounded-[50%] text-[13px]\", T0 = \"w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]\", A0 = \"mx-auto w-[304px]\", w0 = \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\", k0 = \"inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white\", S0 = \"w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700\", O0 = {\n        title: \"Select date\",\n        container: \"body\",\n        disablePast: !1,\n        disableFuture: !1,\n        monthsFull: [\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\"\n        ],\n        monthsShort: [\n            \"Jan\",\n            \"Feb\",\n            \"Mar\",\n            \"Apr\",\n            \"May\",\n            \"Jun\",\n            \"Jul\",\n            \"Aug\",\n            \"Sep\",\n            \"Oct\",\n            \"Nov\",\n            \"Dec\"\n        ],\n        weekdaysFull: [\n            \"Sunday\",\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\"\n        ],\n        weekdaysShort: [\n            \"Sun\",\n            \"Mon\",\n            \"Tue\",\n            \"Wed\",\n            \"Thu\",\n            \"Fri\",\n            \"Sat\"\n        ],\n        weekdaysNarrow: [\n            \"S\",\n            \"M\",\n            \"T\",\n            \"W\",\n            \"T\",\n            \"F\",\n            \"S\"\n        ],\n        okBtnText: \"Ok\",\n        clearBtnText: \"Clear\",\n        cancelBtnText: \"Cancel\",\n        okBtnLabel: \"Confirm selection\",\n        clearBtnLabel: \"Clear selection\",\n        cancelBtnLabel: \"Cancel selection\",\n        nextMonthLabel: \"Next month\",\n        prevMonthLabel: \"Previous month\",\n        nextYearLabel: \"Next year\",\n        prevYearLabel: \"Previous year\",\n        changeMonthIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n  </svg>\n  `,\n        nextMultiYearLabel: \"Next 24 years\",\n        prevMultiYearLabel: \"Previous 24 years\",\n        switchToMultiYearViewLabel: \"Choose year and month\",\n        switchToMonthViewLabel: \"Choose date\",\n        switchToDayViewLabel: \"Choose date\",\n        startDate: null,\n        startDay: 0,\n        format: \"dd/mm/yyyy\",\n        view: \"days\",\n        viewChangeIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"0\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n  </svg>\n  `,\n        min: null,\n        max: null,\n        filter: null,\n        inline: !1,\n        toggleButton: !0,\n        disableToggleButton: !1,\n        disableInput: !1,\n        animations: !0,\n        confirmDateOnSelect: !1,\n        removeOkBtn: !1,\n        removeCancelBtn: !1,\n        removeClearBtn: !1\n    }, D0 = {\n        title: \"string\",\n        container: \"string\",\n        disablePast: \"boolean\",\n        disableFuture: \"boolean\",\n        monthsFull: \"array\",\n        monthsShort: \"array\",\n        weekdaysFull: \"array\",\n        weekdaysShort: \"array\",\n        weekdaysNarrow: \"array\",\n        okBtnText: \"string\",\n        clearBtnText: \"string\",\n        cancelBtnText: \"string\",\n        okBtnLabel: \"string\",\n        clearBtnLabel: \"string\",\n        cancelBtnLabel: \"string\",\n        nextMonthLabel: \"string\",\n        prevMonthLabel: \"string\",\n        nextYearLabel: \"string\",\n        prevYearLabel: \"string\",\n        nextMultiYearLabel: \"string\",\n        prevMultiYearLabel: \"string\",\n        changeMonthIconTemplate: \"string\",\n        switchToMultiYearViewLabel: \"string\",\n        switchToMonthViewLabel: \"string\",\n        switchToDayViewLabel: \"string\",\n        startDate: \"(null|string|date)\",\n        startDay: \"number\",\n        format: \"string\",\n        view: \"string\",\n        viewChangeIconTemplate: \"string\",\n        min: \"(null|string|date)\",\n        max: \"(null|string|date)\",\n        filter: \"(null|function)\",\n        inline: \"boolean\",\n        toggleButton: \"boolean\",\n        disableToggleButton: \"boolean\",\n        disableInput: \"boolean\",\n        animations: \"boolean\",\n        confirmDateOnSelect: \"boolean\",\n        removeOkBtn: \"boolean\",\n        removeCancelBtn: \"boolean\",\n        removeClearBtn: \"boolean\"\n    }, M0 = {\n        fadeIn: Zv,\n        fadeOut: Qv,\n        fadeInShort: Jv,\n        fadeOutShort: t0,\n        modalContainer: e0,\n        datepickerBackdrop: i0,\n        datepickerMain: s0,\n        datepickerHeader: n0,\n        datepickerTitle: o0,\n        datepickerTitleText: r0,\n        datepickerDate: a0,\n        datepickerDateText: l0,\n        datepickerView: c0,\n        datepickerDateControls: h0,\n        datepickerViewChangeButton: d0,\n        datepickerViewChangeIcon: k0,\n        datepickerArrowControls: u0,\n        datepickerPreviousButton: f0,\n        datepickerNextButton: p0,\n        datepickerFooter: _0,\n        datepickerFooterBtn: g0,\n        datepickerClearBtn: m0,\n        datepickerDayHeading: b0,\n        datepickerCell: v0,\n        datepickerCellSmall: y0,\n        datepickerCellLarge: x0,\n        datepickerCellContent: E0,\n        datepickerCellContentSmall: C0,\n        datepickerCellContentLarge: T0,\n        datepickerTable: A0,\n        datepickerToggleButton: w0,\n        datepickerDropdownContainer: S0\n    }, I0 = {\n        fadeIn: \"string\",\n        fadeOut: \"string\",\n        fadeInShort: \"string\",\n        fadeOutShort: \"string\",\n        modalContainer: \"string\",\n        datepickerBackdrop: \"string\",\n        datepickerMain: \"string\",\n        datepickerHeader: \"string\",\n        datepickerTitle: \"string\",\n        datepickerTitleText: \"string\",\n        datepickerDate: \"string\",\n        datepickerDateText: \"string\",\n        datepickerView: \"string\",\n        datepickerDateControls: \"string\",\n        datepickerViewChangeButton: \"string\",\n        datepickerArrowControls: \"string\",\n        datepickerPreviousButton: \"string\",\n        datepickerNextButton: \"string\",\n        datepickerFooter: \"string\",\n        datepickerFooterBtn: \"string\",\n        datepickerClearBtn: \"string\",\n        datepickerDayHeading: \"string\",\n        datepickerCell: \"string\",\n        datepickerCellSmall: \"string\",\n        datepickerCellLarge: \"string\",\n        datepickerCellContent: \"string\",\n        datepickerCellContentSmall: \"string\",\n        datepickerCellContentLarge: \"string\",\n        datepickerTable: \"string\",\n        datepickerToggleButton: \"string\",\n        datepickerDropdownContainer: \"string\"\n    };\n    class Ph {\n        constructor(t, e, s){\n            this._element = t, this._input = g.findOne(\"input\", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(s), this._activeDate = new Date, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = se(\"datepicker-toggle-\"), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this._scrollBar = new Es, this._element && P.setData(t, co, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = \"true\"), this._options.disableInput && (this._input.disabled = \"true\");\n        }\n        static get NAME() {\n            return ga;\n        }\n        get container() {\n            return g.findOne(`[${Ih}='${this._toggleButtonId}']`) || g.findOne(`[${Lh}='${this._toggleButtonId}']`);\n        }\n        get options() {\n            return this._options;\n        }\n        get activeCell() {\n            let t;\n            return this._view === \"days\" && (t = this._getActiveDayCell()), this._view === \"months\" && (t = this._getActiveMonthCell()), this._view === \"years\" && (t = this._getActiveYearCell()), t;\n        }\n        get activeDay() {\n            return bt(this._activeDate);\n        }\n        get activeMonth() {\n            return ot(this._activeDate);\n        }\n        get activeYear() {\n            return K(this._activeDate);\n        }\n        get firstYearInView() {\n            return this.activeYear - to(this._activeDate, Qt);\n        }\n        get lastYearInView() {\n            return this.firstYearInView + Qt - 1;\n        }\n        get viewChangeButton() {\n            return g.findOne(Vv, this.container);\n        }\n        get previousButton() {\n            return g.findOne(Wv, this.container);\n        }\n        get nextButton() {\n            return g.findOne(zv, this.container);\n        }\n        get okButton() {\n            return g.findOne(jv, this.container);\n        }\n        get cancelButton() {\n            return g.findOne(Yv, this.container);\n        }\n        get clearButton() {\n            return g.findOne(Kv, this.container);\n        }\n        get datesContainer() {\n            return g.findOne(Uv, this.container);\n        }\n        get toggleButton() {\n            return g.findOne(Xv, this._element);\n        }\n        update(t = {}) {\n            this._options = this._getConfig({\n                ...this._options,\n                ...t\n            });\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._element);\n            if (t = {\n                ...O0,\n                ...e,\n                ...t\n            }, W(ga, t, D0), t.max && typeof t.max == \"string\" && (t.max = new Date(t.max)), t.min && typeof t.min == \"string\" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {\n                const s = this._getNewDaysOrderArray(t);\n                t.weekdaysNarrow = s;\n            }\n            return t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...M0,\n                ...e,\n                ...t\n            }, W(ga, t, I0), t;\n        }\n        _getContainer() {\n            return g.findOne(this._options.container);\n        }\n        _getNewDaysOrderArray(t) {\n            const e = t.startDay, s = t.weekdaysNarrow;\n            return s.slice(e).concat(s.slice(0, e));\n        }\n        _init() {\n            !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = \"none\")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();\n        }\n        _appendToggleButton() {\n            const t = Iv(this._toggleButtonId, this._classes.datepickerToggleButton);\n            this._element.insertAdjacentHTML(\"beforeend\", t);\n        }\n        open() {\n            if (this._input.readOnly || this._input.disabled) return;\n            const t = b.trigger(this._element, $v);\n            if (this._isOpen || t.defaultPrevented) return;\n            this._setInitialDate();\n            const e = wv(this._classes.datepickerBackdrop), s = Av(this._activeDate, this._selectedDate, this._selectedYear, this._selectedMonth, this._options, lo, Qt, ao, this._toggleButtonId, this._classes);\n            this._options.inline ? this._openDropdown(s) : (this._openModal(e, s), this._scrollBar.hide()), this._animations && (v.addClass(this.container, this._classes.fadeIn), v.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(()=>{\n                this._listenToOutsideClick();\n            }, 0);\n        }\n        _openDropdown(t) {\n            this._popper = Fi(this._input, t, {\n                placement: \"bottom-start\"\n            }), this._getContainer().appendChild(t);\n        }\n        _openModal(t, e) {\n            const s = this._getContainer();\n            s.appendChild(t), s.appendChild(e);\n        }\n        _setFocusTrap(t) {\n            this._focusTrap = new Cs(t, {\n                event: \"keydown\",\n                condition: (e)=>e.key === \"Tab\"\n            }), this._focusTrap.trap();\n        }\n        _listenToUserInput() {\n            b.on(this._input, \"input\", (t)=>{\n                this._handleUserInput(t.target.value);\n            });\n        }\n        _listenToToggleClick() {\n            b.on(this._element, uo, fo, (t)=>{\n                t.preventDefault(), this.open();\n            });\n        }\n        _listenToToggleKeydown() {\n            b.on(this._element, \"keydown\", fo, (t)=>{\n                t.keyCode === Pt && !this._isOpen && this.open();\n            });\n        }\n        _listenToDateSelection() {\n            b.on(this.datesContainer, \"click\", (t)=>{\n                this._handleDateSelection(t);\n            });\n        }\n        _handleDateSelection(t) {\n            const e = t.target.nodeName === \"DIV\" ? t.target.parentNode.dataset : t.target.dataset, s = t.target.nodeName === \"DIV\" ? t.target.parentNode : t.target;\n            if (e.teDate && this._pickDay(e.teDate, s), e.teMonth && e.teYear) {\n                const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);\n                this._pickMonth(n, o);\n            }\n            if (e.teYear && !e.teMonth) {\n                const n = parseInt(e.teYear, 10);\n                this._pickYear(n);\n            }\n            this._options.inline || this._updateHeaderDate(this._activeDate, this._options.monthsShort, this._options.weekdaysShort);\n        }\n        _updateHeaderDate(t, e, s) {\n            const n = g.findOne(Gv, this.container), o = ot(t), r = bt(t), a = Jn(t);\n            n.innerHTML = `${s[a]}, ${e[o]} ${r}`;\n        }\n        _addControlsListeners() {\n            b.on(this.nextButton, \"click\", ()=>{\n                this._view === \"days\" ? this.nextMonth() : this._view === \"years\" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();\n            }), b.on(this.previousButton, \"click\", ()=>{\n                this._view === \"days\" ? this.previousMonth() : this._view === \"years\" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();\n            }), b.on(this.viewChangeButton, \"click\", ()=>{\n                this._view === \"days\" ? this._changeView(\"years\") : (this._view === \"years\" || this._view === \"months\") && this._changeView(\"days\");\n            }), this._options.inline || this._listenToFooterButtonsClick();\n        }\n        _listenToFooterButtonsClick() {\n            b.on(this.okButton, \"click\", ()=>this.handleOk()), b.on(this.cancelButton, \"click\", ()=>this.handleCancel()), b.on(this.clearButton, \"click\", ()=>this.handleClear());\n        }\n        _listenToOutsideClick() {\n            b.on(document, uo, (t)=>{\n                const e = t.target === this.container, s = this.container && this.container.contains(t.target);\n                !e && !s && this.close();\n            });\n        }\n        _listenToEscapeClick() {\n            b.on(document, \"keydown\", (t)=>{\n                t.keyCode === ro && this._isOpen && this.close();\n            });\n        }\n        _listenToKeyboardNavigation() {\n            b.on(this.datesContainer, \"keydown\", (t)=>{\n                this._handleKeydown(t);\n            });\n        }\n        _listenToDatesContainerFocus() {\n            b.on(this.datesContainer, \"focus\", ()=>{\n                this._focusActiveCell(this.activeCell);\n            });\n        }\n        _listenToDatesContainerBlur() {\n            b.on(this.datesContainer, \"blur\", ()=>{\n                this._removeCurrentFocusStyles();\n            });\n        }\n        _handleKeydown(t) {\n            this._view === \"days\" && this._handleDaysViewKeydown(t), this._view === \"months\" && this._handleMonthsViewKeydown(t), this._view === \"years\" && this._handleYearsViewKeydown(t);\n        }\n        _handleDaysViewKeydown(t) {\n            const e = this._activeDate, s = this.activeCell;\n            switch(t.keyCode){\n                case Zi:\n                    this._activeDate = Gi(this._activeDate, st() ? 1 : -1);\n                    break;\n                case Qi:\n                    this._activeDate = Gi(this._activeDate, st() ? -1 : 1);\n                    break;\n                case Tt:\n                    this._activeDate = Gi(this._activeDate, -7);\n                    break;\n                case ut:\n                    this._activeDate = Gi(this._activeDate, 7);\n                    break;\n                case Ji:\n                    this._activeDate = Gi(this._activeDate, 1 - bt(this._activeDate));\n                    break;\n                case ts:\n                    this._activeDate = Gi(this._activeDate, ua(this._activeDate) - bt(this._activeDate));\n                    break;\n                case pa:\n                    this._activeDate = Ct(this._activeDate, -1);\n                    break;\n                case _a:\n                    this._activeDate = Ct(this._activeDate, 1);\n                    break;\n                case Pt:\n                case oo:\n                    this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();\n                    return;\n                default:\n                    return;\n            }\n            Ps(e, this._activeDate, this._view, Qt, this._options.min, this._options.max) || this._changeView(\"days\"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();\n        }\n        _asyncFocusDatesContainer() {\n            setTimeout(()=>{\n                this.datesContainer.focus();\n            }, 0);\n        }\n        _focusActiveCell(t) {\n            t && t.setAttribute(\"data-te-datepicker-cell-focused\", \"\");\n        }\n        _removeHighlightFromCell(t) {\n            t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n        }\n        _getActiveDayCell() {\n            const t = g.find(\"td\", this.datesContainer);\n            return Array.from(t).find((s)=>{\n                const n = wh(s.dataset.teDate);\n                return _i(n, this._activeDate);\n            });\n        }\n        _handleMonthsViewKeydown(t) {\n            const e = this._activeDate, s = this.activeCell;\n            switch(t.keyCode){\n                case Zi:\n                    this._activeDate = Ct(this._activeDate, st() ? 1 : -1);\n                    break;\n                case Qi:\n                    this._activeDate = Ct(this._activeDate, st() ? -1 : 1);\n                    break;\n                case Tt:\n                    this._activeDate = Ct(this._activeDate, -4);\n                    break;\n                case ut:\n                    this._activeDate = Ct(this._activeDate, 4);\n                    break;\n                case Ji:\n                    this._activeDate = Ct(this._activeDate, -this.activeMonth);\n                    break;\n                case ts:\n                    this._activeDate = Ct(this._activeDate, 11 - this.activeMonth);\n                    break;\n                case pa:\n                    this._activeDate = Et(this._activeDate, -1);\n                    break;\n                case _a:\n                    this._activeDate = Et(this._activeDate, 1);\n                    break;\n                case Pt:\n                case oo:\n                    this._selectMonth(this.activeMonth);\n                    return;\n                default:\n                    return;\n            }\n            Ps(e, this._activeDate, this._view, Qt, this._options.min, this._options.max) || this._changeView(\"months\"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();\n        }\n        _getActiveMonthCell() {\n            const t = g.find(\"td\", this.datesContainer);\n            return Array.from(t).find((s)=>{\n                const n = parseInt(s.dataset.teYear, 10), o = parseInt(s.dataset.teMonth, 10);\n                return n === this.activeYear && o === this.activeMonth;\n            });\n        }\n        _handleYearsViewKeydown(t) {\n            const e = this._activeDate, s = this.activeCell, n = 4, o = 24;\n            switch(t.keyCode){\n                case Zi:\n                    this._activeDate = Et(this._activeDate, st() ? 1 : -1);\n                    break;\n                case Qi:\n                    this._activeDate = Et(this._activeDate, st() ? -1 : 1);\n                    break;\n                case Tt:\n                    this._activeDate = Et(this._activeDate, -n);\n                    break;\n                case ut:\n                    this._activeDate = Et(this._activeDate, n);\n                    break;\n                case Ji:\n                    this._activeDate = Et(this._activeDate, -to(this._activeDate, o));\n                    break;\n                case ts:\n                    this._activeDate = Et(this._activeDate, o - to(this._activeDate, o) - 1);\n                    break;\n                case pa:\n                    this._activeDate = Et(this._activeDate, -o);\n                    break;\n                case _a:\n                    this._activeDate = Et(this._activeDate, o);\n                    break;\n                case Pt:\n                case oo:\n                    this._selectYear(this.activeYear);\n                    return;\n                default:\n                    return;\n            }\n            Ps(e, this._activeDate, this._view, Qt, this._options.min, this._options.max) || this._changeView(\"years\"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();\n        }\n        _getActiveYearCell() {\n            const t = g.find(\"td\", this.datesContainer);\n            return Array.from(t).find((s)=>parseInt(s.dataset.teYear, 10) === this.activeYear);\n        }\n        _setInitialDate() {\n            this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = new Date;\n        }\n        close() {\n            const t = b.trigger(this._element, Nv);\n            !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && v.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());\n        }\n        _closeDropdown() {\n            const t = g.findOne(Fv);\n            window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && (t && document.body.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener(\"animationend\", ()=>{\n                t && document.body.removeChild(t), this._popper && this._popper.destroy();\n            }), this._removeFocusTrap();\n        }\n        _closeModal() {\n            const t = g.findOne(qv), e = g.findOne(Hv);\n            !e || !t || (this._animations ? (v.addClass(t, this._classes.fadeOutShort), t.addEventListener(\"animationend\", ()=>{\n                this._removePicker(t, e), this._scrollBar.reset();\n            })) : (this._removePicker(t, e), this._scrollBar.reset()));\n        }\n        _removePicker(t, e) {\n            const s = this._getContainer();\n            s.removeChild(t), s.removeChild(e);\n        }\n        _removeFocusTrap() {\n            this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);\n        }\n        _removeDatepickerListeners() {\n            b.off(this.nextButton, \"click\"), b.off(this.previousButton, \"click\"), b.off(this.viewChangeButton, \"click\"), b.off(this.okButton, \"click\"), b.off(this.cancelButton, \"click\"), b.off(this.clearButton, \"click\"), b.off(this.datesContainer, \"click\"), b.off(this.datesContainer, \"keydown\"), b.off(this.datesContainer, \"focus\"), b.off(this.datesContainer, \"blur\"), b.off(document, uo);\n        }\n        dispose() {\n            this._isOpen && this.close(), this._removeInputAndToggleListeners();\n            const t = g.findOne(`#${this._toggleButtonId}`);\n            t && this._element.removeChild(t), P.removeData(this._element, co), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;\n        }\n        _removeInputAndToggleListeners() {\n            b.off(this._input, \"input\"), b.off(this._element, uo, fo), b.off(this._element, \"keydown\", fo);\n        }\n        handleOk() {\n            this._confirmSelection(this._headerDate), this.close();\n        }\n        _selectDate(t, e = this.activeCell) {\n            const { min: s, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;\n            eo(t, s, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = K(t), this._selectedMonth = ot(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));\n        }\n        _selectYear(t, e = this.activeCell) {\n            this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView(\"months\");\n        }\n        _selectMonth(t, e = this.activeCell) {\n            this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView(\"days\");\n        }\n        _removeSelectedStyles(t) {\n            t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n        }\n        _addSelectedStyles(t) {\n            t && t.setAttribute(\"data-te-datepicker-cell-selected\", \"\");\n        }\n        _confirmSelection(t) {\n            if (t) {\n                const e = this.formatDate(t);\n                this._input.value = e, b.trigger(this._element, Bv, {\n                    date: t\n                }), b.trigger(this._input, \"input\");\n            }\n        }\n        handleCancel() {\n            this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();\n        }\n        handleClear() {\n            this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = \"\", this._setInitialDate(), this._changeView(\"days\"), this._updateHeaderDate(this._activeDate, this._options.monthsShort, this._options.weekdaysShort);\n        }\n        _removeCurrentSelectionStyles() {\n            const t = g.findOne(\"[data-te-datepicker-cell-selected]\", this.container);\n            t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n        }\n        _removeCurrentFocusStyles() {\n            const t = g.findOne(\"[data-te-datepicker-cell-focused]\", this.container);\n            t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n        }\n        formatDate(t) {\n            const e = bt(t), s = this._addLeadingZero(bt(t)), n = this._options.weekdaysShort[Jn(t)], o = this._options.weekdaysFull[Jn(t)], r = ot(t) + 1, a = this._addLeadingZero(ot(t) + 1), l = this._options.monthsShort[ot(t)], c = this._options.monthsFull[ot(t)], h = K(t).toString().length === 2 ? K(t) : K(t).toString().slice(2, 4), d = K(t), u = this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);\n            let f = \"\";\n            return u.forEach((p)=>{\n                switch(p){\n                    case \"dddd\":\n                        p = p.replace(p, o);\n                        break;\n                    case \"ddd\":\n                        p = p.replace(p, n);\n                        break;\n                    case \"dd\":\n                        p = p.replace(p, s);\n                        break;\n                    case \"d\":\n                        p = p.replace(p, e);\n                        break;\n                    case \"mmmm\":\n                        p = p.replace(p, c);\n                        break;\n                    case \"mmm\":\n                        p = p.replace(p, l);\n                        break;\n                    case \"mm\":\n                        p = p.replace(p, a);\n                        break;\n                    case \"m\":\n                        p = p.replace(p, r);\n                        break;\n                    case \"yyyy\":\n                        p = p.replace(p, d);\n                        break;\n                    case \"yy\":\n                        p = p.replace(p, h);\n                        break;\n                }\n                f += p;\n            }), f;\n        }\n        _addLeadingZero(t) {\n            return parseInt(t, 10) < 10 ? `0${t}` : t;\n        }\n        _pickDay(t, e) {\n            const s = wh(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;\n            eo(s, n, o, r, a, l) || (this._activeDate = s, this._selectDate(s, e));\n        }\n        _pickYear(t) {\n            const { min: e, max: s, disablePast: n, disableFuture: o } = this._options;\n            if (fa(t, e, s, n, o)) return;\n            const r = he(t, this.activeMonth, this.activeDay);\n            this._activeDate = r, this._selectedDate = r, this._selectYear(t);\n        }\n        _pickMonth(t, e) {\n            const { min: s, max: n, disablePast: o, disableFuture: r } = this._options;\n            if (kh(t, e, s, n, o, r) || fa(e, s, n, o, r)) return;\n            const a = he(e, t, this.activeDay);\n            this._activeDate = a, this._selectMonth(t);\n        }\n        nextMonth() {\n            const t = Ct(this._activeDate, 1), e = io(t, this._headerDate, this._options, this._classes);\n            this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.datesContainer.innerHTML = e;\n        }\n        previousMonth() {\n            const t = Ct(this._activeDate, -1);\n            this._activeDate = t;\n            const e = io(t, this._headerDate, this._options, this._classes);\n            this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.datesContainer.innerHTML = e;\n        }\n        nextYear() {\n            const t = Et(this._activeDate, 1);\n            this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes);\n            const e = so(this.activeYear, this._selectedYear, this._selectedMonth, this._options, lo, this._classes);\n            this.datesContainer.innerHTML = e;\n        }\n        previousYear() {\n            const t = Et(this._activeDate, -1);\n            this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes);\n            const e = so(this.activeYear, this._selectedYear, this._selectedMonth, this._options, lo, this._classes);\n            this.datesContainer.innerHTML = e;\n        }\n        nextYears() {\n            const t = Et(this._activeDate, 24);\n            this._activeDate = t;\n            const e = no(t, this._selectedYear, this._options, Qt, ao, this._classes);\n            this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.datesContainer.innerHTML = e;\n        }\n        previousYears() {\n            const t = Et(this._activeDate, -24);\n            this._activeDate = t;\n            const e = no(t, this._selectedYear, this._options, Qt, ao, this._classes);\n            this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.datesContainer.innerHTML = e;\n        }\n        _asyncChangeView(t) {\n            setTimeout(()=>{\n                this._changeView(t);\n            }, 0);\n        }\n        _changeView(t) {\n            this._view = t, this.datesContainer.blur(), t === \"days\" && (this.datesContainer.innerHTML = io(this._activeDate, this._headerDate, this._options, this._classes)), t === \"months\" && (this.datesContainer.innerHTML = so(this.activeYear, this._selectedYear, this._selectedMonth, this._options, lo, this._classes)), t === \"years\" && (this.datesContainer.innerHTML = no(this._activeDate, this._selectedYear, this._options, Qt, ao, this._classes)), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();\n        }\n        _updateViewControlsAndAttributes(t) {\n            t === \"days\" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.viewChangeButton.setAttribute(\"aria-label\", this._options.switchToMultiYearViewLabel), this.previousButton.setAttribute(\"aria-label\", this._options.prevMonthLabel), this.nextButton.setAttribute(\"aria-label\", this._options.nextMonthLabel)), t === \"months\" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.viewChangeButton.setAttribute(\"aria-label\", this._options.switchToDayViewLabel), this.previousButton.setAttribute(\"aria-label\", this._options.prevYearLabel), this.nextButton.setAttribute(\"aria-label\", this._options.nextYearLabel)), t === \"years\" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += de(this._options, this._classes), this.viewChangeButton.setAttribute(\"aria-label\", this._options.switchToMonthViewLabel), this.previousButton.setAttribute(\"aria-label\", this._options.prevMultiYearLabel), this.nextButton.setAttribute(\"aria-label\", this._options.nextMultiYearLabel));\n        }\n        _updateControlsDisabledState() {\n            fv(this._options.disableFuture, this._activeDate, this._view, Qt, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, pv(this._options.disablePast, this._activeDate, this._view, Qt, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;\n        }\n        _handleUserInput(t) {\n            const e = this._getDelimeters(this._options.format), s = this._parseDate(t, this._options.format, e);\n            hv(s) ? (this._activeDate = s, this._selectedDate = s, this._selectedYear = K(s), this._selectedMonth = ot(s), this._headerDate = s) : (this._activeDate = new Date, this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);\n        }\n        _getDelimeters(t) {\n            return t.match(/[^(dmy)]{1,}/g);\n        }\n        _parseDate(t, e, s) {\n            let n;\n            s[0] !== s[1] ? n = s[0] + s[1] : n = s[0];\n            const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf(\"mmm\") !== -1, c = [];\n            for(let _ = 0; _ < a.length; _++)a[_].indexOf(\"yy\") !== -1 && (c[0] = {\n                value: r[_],\n                format: a[_]\n            }), a[_].indexOf(\"m\") !== -1 && (c[1] = {\n                value: r[_],\n                format: a[_]\n            }), a[_].indexOf(\"d\") !== -1 && a[_].length <= 2 && (c[2] = {\n                value: r[_],\n                format: a[_]\n            });\n            let h;\n            e.indexOf(\"mmmm\") !== -1 ? h = this._options.monthsFull : h = this._options.monthsShort;\n            const d = Number(c[0].value), u = l ? this.getMonthNumberByMonthName(c[1].value, h) : Number(c[1].value) - 1, f = Number(c[2].value);\n            return he(d, u, f);\n        }\n        getMonthNumberByMonthName(t, e) {\n            return e.findIndex((s)=>s === t);\n        }\n        static getInstance(t) {\n            return P.getData(t, co);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const L0 = ({ format24: i, okLabel: t, cancelLabel: e, headID: s, footerID: n, bodyID: o, pickerID: r, clearLabel: a, inline: l, showClearBtn: c, amLabel: h, pmLabel: d }, u)=>{\n        const f = `<div id='${r}' class='${u.timepickerWrapper}' data-te-timepicker-wrapper>\n      <div class=\"${u.timepickerContainer}\">\n        <div class=\"${u.timepickerElements}\">\n        <div id='${s}' class='${u.timepickerHead}' style='padding-right:${i ? 50 : 10}px'>\n        <div class='${u.timepickerHeadContent}'>\n            <div class=\"${u.timepickerCurrentWrapper}\">\n              <span class=\"${u.timepickerCurrentButtonWrapper}\">\n                <button type='button' class='${u.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>\n              </span>\n              <button type='button' class='${u.timepickerDot}' disabled>:</button>\n            <span class=\"${u.timepickerCurrentButtonWrapper}\">\n              <button type='button' class='${u.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>\n            </span>\n            </div>\n            ${i ? \"\" : `<div class=\"${u.timepickerModeWrapper}\">\n                  <button type='button' class=\"${u.timepickerModeAm}\" tabindex=\"0\" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${h}</button>\n                  <button class=\"${u.timepickerModePm}\" tabindex=\"0\" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${d}</button>\n                </div>`}\n        </div>\n      </div>\n      ${l ? \"\" : `<div id='${o}' class='${u.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>\n            <div class='${u.timepickerClock}' data-te-timepicker-clock>\n              <span class='${u.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>\n              <div class='${u.timepickerHandPointer}' data-te-timepicker-hand-pointer>\n                <div class='${u.timepickerPointerCircle}' data-te-timepicker-circle></div>\n              </div>\n              ${i ? '<div class=\"' + u.timepickerClockInner + '\" data-te-timepicker-clock-inner></div>' : \"\"}\n            </div>\n          </div>`}\n    </div>\n    <div id='${n}' class='${u.timepickerFooterWrapper}'>\n      <div class=\"${u.timepickerFooter}\">\n        ${c ? `<button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-clear tabindex=\"0\" data-te-ripple-init>${a}</button>` : \"\"}\n        <button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-cancel tabindex=\"0\" data-te-ripple-init>${e}</button>\n        <button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n      </div>\n    </div>\n  </div>\n</div>`, p = `<div id='${r}' class='${u.timepickerInlineWrapper}' data-te-timepicker-wrapper>\n        <div class=\"${u.timepickerInlineContainer}\">\n          <div class=\"${u.timepickerInlineElements}\">\n          <div id='${s}' class='${u.timepickerInlineHead}'\n          style='padding-right:10px'>\n          <div class='${u.timepickerInlineHeadContent}'>\n              <div class=\"${u.timepickerCurrentWrapper}\">\n                <span class=\"${u.timepickerInlineHourWrapper}\" data-te-timepicker-inline-hour-icons>\n                  <span class=\"${u.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>\n                    <span class=\"${u.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                      </svg>   \n                    </span>\n                  </span>\n                  <button type='button' class='${u.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                  <span class=\"${u.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>\n                    <span class=\"${u.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                      </svg>  \n                    </span>\n                  </span>\n                </span>\n                <button type='button' class='${u.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>\n              <span class=\"${u.timepickerCurrentMinuteWrapper}\">\n                <span class=\"${u.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>\n                  <span class=\"${u.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                    </svg>\n                  </span>\n                </span>\n                <button type='button' class='${u.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                <span class=\"${u.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>\n                  <span class=\"${u.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                    </svg> \n                  </span>\n                </span>\n              </span>\n              </div>\n              ${i ? \"\" : `<div class=\"${u.timepickerInlineModeWrapper}\">\n                      <button type='button' class=\"${u.timepickerInlineModeAm}\" data-te-timepicker-am data-te-timepicker-hour-mode tabindex=\"0\" data-te-ripple-init>${h}</button>\n                      <button class=\"${u.timepickerInlineModePm}\" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex=\"0\" data-te-ripple-init>${d}</button>\n                      <button type='button' class='${u.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n                    </div>`}\n              ${i ? `<button class='${u.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>` : \"\"}\n          </div>\n        </div>\n      </div>\n    </div>\n</div>`;\n        return l ? p : f;\n    }, P0 = (i, t, e)=>{\n        const { iconSVG: s } = i;\n        return `\n  <button id=\"${t}\" tabindex=\"0\" type=\"button\" class=\"${e.timepickerToggleButton}\" data-te-toggle=\"timepicker\" data-te-timepicker-toggle-button data-te-timepicker-icon>\n    ${s}\n  </button>\n`;\n    }, po = \"data-te-timepicker-disabled\", _o = \"data-te-timepicker-active\", gi = (i)=>{\n        if (i === \"\") return;\n        let t, e, s, n;\n        return Rh(i) ? (t = i.getHours(), n = t, e = i.getMinutes(), t %= 12, n === 0 && t === 0 && (s = \"AM\"), t = t || 12, s === void 0 && (s = Number(n) >= 12 ? \"PM\" : \"AM\"), e = e < 10 ? `0${e}` : e) : ([t, e, s] = j(i, !1), n = t, t %= 12, n === 0 && t === 0 && (s = \"AM\"), t = t || 12, s === void 0 && (s = Number(n) >= 12 ? \"PM\" : \"AM\")), {\n            hours: t,\n            minutes: e,\n            amOrPm: s\n        };\n    }, Rh = (i)=>i && Object.prototype.toString.call(i) === \"[object Date]\" && !Number.isNaN(i), Nh = (i)=>{\n        if (i === \"\") return;\n        let t, e;\n        return Rh(i) ? (t = i.getHours(), e = i.getMinutes()) : [t, e] = j(i, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {\n            hours: t,\n            minutes: e\n        };\n    }, R0 = (i, t, e)=>b.on(document, i, t, ({ target: s })=>{\n            if (s.hasAttribute(_o)) return;\n            document.querySelectorAll(t).forEach((o)=>{\n                o.hasAttribute(_o) && (v.removeClass(o, e.opacity), o.removeAttribute(_o));\n            }), v.addClass(s, e.opacity), s.setAttribute(_o, \"\");\n        }), $h = ({ clientX: i, clientY: t, touches: e }, s, n = !1)=>{\n        const { left: o, top: r } = s.getBoundingClientRect();\n        let a = {};\n        return !n || !e ? a = {\n            x: i - o,\n            y: t - r\n        } : n && Object.keys(e).length > 0 && (a = {\n            x: e[0].clientX - o,\n            y: e[0].clientY - r\n        }), a;\n    }, go = ()=>navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), j = (i, t = !0)=>t ? i.value.replace(/:/gi, \" \").split(\" \") : i.replace(/:/gi, \" \").split(\" \"), Bh = (i, t)=>{\n        const [e, s, n] = j(i, !1), [o, r, a] = j(t, !1);\n        return n === \"PM\" && a === \"AM\" || n === a && e > o || s > r;\n    }, Hh = ()=>{\n        const i = new Date, t = i.getHours(), e = i.getMinutes();\n        return `${t}:${e < 10 ? `0${e}` : e}`;\n    }, He = (i, t, e)=>{\n        if (!t) return i;\n        let s = Hh();\n        return e && (s = `${gi(s).hours}:${gi(s).minutes} ${gi(s).amOrPm}`), (i !== \"\" && Bh(s, i) || i === \"\") && (i = s), i;\n    }, Fe = (i, t, e)=>{\n        if (!t) return i;\n        let s = Hh();\n        return e && (s = `${gi(s).hours}:${gi(s).minutes} ${gi(s).amOrPm}`), (i !== \"\" && !Bh(s, i) || i === \"\") && (i = s), i;\n    }, N0 = ({ format12: i, maxTime: t, minTime: e, disablePast: s, disableFuture: n }, o, r)=>{\n        const a = j(o)[1];\n        e = He(e, s, i), t = Fe(t, n, i);\n        const [l, c, h] = j(t, !1), [d, u, f] = j(e, !1);\n        if (h !== void 0 || f !== void 0) return [\n            r,\n            a\n        ];\n        if (!(l !== \"\" && d === \"\" && Number(r) > Number(l)) && !(l === \"\" && d !== \"\" && c === void 0 && u !== \"\" && Number(r) < Number(d))) return [\n            r,\n            a\n        ];\n    }, Fh = (i, t, e, s)=>{\n        i.forEach((n)=>{\n            t = t === \"12\" && s ? \"0\" : t, (n.textContent === \"00\" || Number(n.textContent === \"12\" && s ? \"0\" : n.textContent) > t) && (v.addClass(n, e.tipsDisabled), n.setAttribute(po, \"\"));\n        });\n    }, Vh = (i, t, e, s)=>{\n        i.forEach((n)=>{\n            t = t === \"12\" && s ? \"0\" : t, n.textContent !== \"00\" && Number(n.textContent === \"12\" && s ? \"0\" : n.textContent) < Number(t) && (v.addClass(n, e.tipsDisabled), n.setAttribute(po, \"\"));\n        });\n    }, Wh = (i, t, e, s)=>{\n        if (t === \"12\" || t === \"24\") return;\n        const n = e ? 12 : 24;\n        return s === \"max\" ? (Number(i) === n ? 0 : Number(i)) > Number(t) : (Number(i) === n ? 0 : Number(i)) < Number(t);\n    }, $0 = (i, t, e, s, n, o)=>{\n        i.forEach((r)=>{\n            (Wh(s, e, o, \"max\") || Number(r.textContent) > t && Number(s) === Number(e)) && (v.addClass(r, n.tipsDisabled), r.setAttribute(po, \"\"));\n        });\n    }, B0 = (i, t, e, s, n, o)=>{\n        i.forEach((r)=>{\n            (Wh(s, e, o, \"min\") || Number(r.textContent) < t && Number(s) === Number(e)) && (v.addClass(r, n.tipsDisabled), r.setAttribute(po, \"\"));\n        });\n    }, H0 = (i)=>i.startsWith(\"0\") ? Number(i.slice(1)) : Number(i), Ns = \"timepicker\", H = `data-te-${Ns}`, zh = \"[data-te-toggle]\", mo = `te.${Ns}`, ue = `.${mo}`, fe = \".data-api\", jh = `click${ue}${fe}`, bo = `keydown${ue}${fe}`, Yh = `mousedown${ue}${fe}`, Kh = `mouseup${ue}${fe}`, Uh = `mousemove${ue}${fe}`, Xh = `mouseleave${ue}${fe}`, Gh = `mouseover${ue}${fe}`, qh = `touchmove${ue}${fe}`, Zh = `touchend${ue}${fe}`, Qh = `touchstart${ue}${fe}`, F0 = `[${H}-am]`, V0 = `[${H}-pm]`, W0 = `[${H}-format24]`, vo = `[${H}-current]`, yo = `[${H}-hour-mode]`, z0 = `[${H}-toggle-button]`, ma = `${H}-cancel`, Jh = `${H}-clear`, ba = `${H}-submit`, j0 = `${H}-icon`, va = `${H}-icon-up`, ya = `${H}-icon-down`, Y0 = `${H}-icon-inline-hour`, K0 = `${H}-icon-inline-minute`, td = `${H}-inline-hour-icons`, U0 = `${H}-current-inline`, X0 = \"readonly\", ed = `${H}-invalid-feedback`, xa = `${H}-is-invalid`, Ve = `${H}-disabled`, J = `${H}-active`, G0 = `${H}-input`, mi = `${H}-clock`, $s = `${H}-clock-inner`, Ea = `${H}-wrapper`, id = `${H}-clock-wrapper`, xo = `${H}-hour`, Ca = `${H}-minute`, Eo = `${H}-tips-element`, ft = `${H}-tips-hours`, vt = `${H}-tips-minutes`, Rt = `${H}-tips-inner`, Co = `${H}-tips-inner-element`, sd = `${H}-middle-dot`, Ta = `${H}-hand-pointer`, Aa = `${H}-circle`, nd = `${H}-modal`, q0 = {\n        appendValidationInfo: !0,\n        bodyID: \"\",\n        cancelLabel: \"Cancel\",\n        clearLabel: \"Clear\",\n        closeModalOnBackdropClick: !0,\n        closeModalOnMinutesClick: !1,\n        container: \"body\",\n        defaultTime: \"\",\n        disabled: !1,\n        disablePast: !1,\n        disableFuture: !1,\n        enableValidation: !0,\n        focusInputAfterApprove: !1,\n        footerID: \"\",\n        format12: !0,\n        format24: !1,\n        headID: \"\",\n        increment: !1,\n        inline: !1,\n        invalidLabel: \"Invalid Time Format\",\n        maxTime: \"\",\n        minTime: \"\",\n        modalID: \"\",\n        okLabel: \"Ok\",\n        overflowHidden: !0,\n        pickerID: \"\",\n        readOnly: !1,\n        showClearBtn: !0,\n        switchHoursToMinutesOnClick: !0,\n        iconSVG: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n</svg>`,\n        withIcon: !0,\n        pmLabel: \"PM\",\n        amLabel: \"AM\",\n        animations: !0\n    }, Z0 = {\n        appendValidationInfo: \"boolean\",\n        bodyID: \"string\",\n        cancelLabel: \"string\",\n        clearLabel: \"string\",\n        closeModalOnBackdropClick: \"boolean\",\n        closeModalOnMinutesClick: \"boolean\",\n        container: \"string\",\n        disabled: \"boolean\",\n        disablePast: \"boolean\",\n        disableFuture: \"boolean\",\n        enableValidation: \"boolean\",\n        footerID: \"string\",\n        format12: \"boolean\",\n        format24: \"boolean\",\n        headID: \"string\",\n        increment: \"boolean\",\n        inline: \"boolean\",\n        invalidLabel: \"string\",\n        modalID: \"string\",\n        okLabel: \"string\",\n        overflowHidden: \"boolean\",\n        pickerID: \"string\",\n        readOnly: \"boolean\",\n        showClearBtn: \"boolean\",\n        switchHoursToMinutesOnClick: \"boolean\",\n        defaultTime: \"(string|date|number)\",\n        iconSVG: \"string\",\n        withIcon: \"boolean\",\n        pmLabel: \"string\",\n        amLabel: \"string\",\n        animations: \"boolean\"\n    }, Q0 = {\n        tips: \"absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent\",\n        tipsActive: \"text-white bg-[#3b71ca] font-normal\",\n        tipsDisabled: \"text-[#b3afaf] pointer-events-none bg-transparent\",\n        transform: \"transition-[transform,height] ease-in-out duration-[400ms]\",\n        modal: \"z-[1065]\",\n        clockAnimation: \"animate-[show-up-clock_350ms_linear]\",\n        opacity: \"!opacity-100\",\n        timepickerWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed\",\n        timepickerContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg\",\n        timepickerElements: \"flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n        timepickerHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center\",\n        timepickerHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly\",\n        timepickerCurrentWrapper: \"[direction:ltr] rtl:[direction:rtl]\",\n        timepickerCurrentButtonWrapper: \"relative h-full\",\n        timepickerCurrentButton: \"text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none \",\n        timepickerDot: \"font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal\",\n        timepickerModeWrapper: \"flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n        timepickerModeAm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n        timepickerModePm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n        timepickerClockWrapper: \"min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500\",\n        timepickerClock: \"relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50\",\n        timepickerMiddleDot: \"top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute\",\n        timepickerHandPointer: \"bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute\",\n        timepickerPointerCircle: \"-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute\",\n        timepickerClockInner: \"absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]\",\n        timepickerFooterWrapper: \"rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500\",\n        timepickerFooter: \"w-full flex justify-between\",\n        timepickerFooterButton: \"text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none\",\n        timepickerInlineWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg\",\n        timepickerInlineContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]\",\n        timepickerInlineElements: \"flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n        timepickerInlineHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg\",\n        timepickerInlineHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center\",\n        timepickerInlineHourWrapper: \"relative h-full !opacity-100\",\n        timepickerCurrentMinuteWrapper: \"relative h-full\",\n        timepickerInlineIconUp: \"absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n        timepickerInlineIconSvg: \"h-4 w-4\",\n        timepickerInlineCurrentButton: \"font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]\",\n        timepickerInlineIconDown: \"absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n        timepickerInlineDot: \"font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]\",\n        timepickerInlineModeWrapper: \"flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n        timepickerInlineModeAm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6\",\n        timepickerInlineModePm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer\",\n        timepickerInlineSubmitButton: \"hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0\",\n        timepickerToggleButton: \"h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white\"\n    }, J0 = {\n        tips: \"string\",\n        tipsActive: \"string\",\n        tipsDisabled: \"string\",\n        transform: \"string\",\n        modal: \"string\",\n        clockAnimation: \"string\",\n        opacity: \"string\",\n        timepickerWrapper: \"string\",\n        timepickerContainer: \"string\",\n        timepickerElements: \"string\",\n        timepickerHead: \"string\",\n        timepickerHeadContent: \"string\",\n        timepickerCurrentWrapper: \"string\",\n        timepickerCurrentButtonWrapper: \"string\",\n        timepickerCurrentButton: \"string\",\n        timepickerDot: \"string\",\n        timepickerModeWrapper: \"string\",\n        timepickerModeAm: \"string\",\n        timepickerModePm: \"string\",\n        timepickerClockWrapper: \"string\",\n        timepickerClock: \"string\",\n        timepickerMiddleDot: \"string\",\n        timepickerHandPointer: \"string\",\n        timepickerPointerCircle: \"string\",\n        timepickerClockInner: \"string\",\n        timepickerFooterWrapper: \"string\",\n        timepickerFooterButton: \"string\",\n        timepickerInlineWrapper: \"string\",\n        timepickerInlineContainer: \"string\",\n        timepickerInlineElements: \"string\",\n        timepickerInlineHead: \"string\",\n        timepickerInlineHeadContent: \"string\",\n        timepickerInlineHourWrapper: \"string\",\n        timepickerCurrentMinuteWrapper: \"string\",\n        timepickerInlineIconUp: \"string\",\n        timepickerInlineIconSvg: \"string\",\n        timepickerInlineCurrentButton: \"string\",\n        timepickerInlineIconDown: \"string\",\n        timepickerInlineDot: \"string\",\n        timepickerInlineModeWrapper: \"string\",\n        timepickerInlineModeAm: \"string\",\n        timepickerInlineModePm: \"string\",\n        timepickerInlineSubmitButton: \"string\",\n        timepickerToggleButton: \"string\"\n    };\n    class od {\n        constructor(t, e = {}, s){\n            Ee(this, \"_toggleAmPm\", (t)=>{\n                t === \"PM\" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === \"AM\" && (this._isPmEnabled = !1, this._isAmEnabled = !0);\n            });\n            Ee(this, \"_toggleBackgroundColorCircle\", (t)=>{\n                if (this._modal.querySelector(`${t}[${J}]`) !== null) {\n                    v.addStyle(this._circle, {\n                        backgroundColor: \"#1976d2\"\n                    });\n                    return;\n                }\n                v.addStyle(this._circle, {\n                    backgroundColor: \"transparent\"\n                });\n            });\n            Ee(this, \"_toggleClassActive\", (t, { textContent: e }, s)=>{\n                const n = [\n                    ...t\n                ].find((o)=>Number(o) === Number(e));\n                return s.forEach((o)=>{\n                    if (!o.hasAttribute(Ve)) {\n                        if (o.textContent === n) {\n                            v.addClass(o, this._classes.tipsActive), o.setAttribute(J, \"\");\n                            return;\n                        }\n                        v.removeClass(o, this._classes.tipsActive), o.removeAttribute(J);\n                    }\n                });\n            });\n            Ee(this, \"_makeMinutesDegrees\", (t, e)=>{\n                const { increment: s } = this._options;\n                return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), s && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = \"00\")), t >= 360 && (t = 0), {\n                    degrees: t,\n                    minute: e,\n                    addDegrees: s ? 30 : 6\n                };\n            });\n            Ee(this, \"_makeHourDegrees\", (t, e, s)=>{\n                if (t) return this._hasTargetInnerClass(t) ? e < 0 ? (s = Math.round(360 + e / 30) % 24, e = 360 + e) : (s = Math.round(e / 30) + 12, s === 12 && (s = \"00\")) : e < 0 ? (s = Math.round(360 + e / 30) % 12, e = 360 + e) : (s = Math.round(e / 30) % 12, (s === 0 || s > 12) && (s = 12)), e >= 360 && (e = 0), {\n                    degrees: e,\n                    hour: s,\n                    addDegrees: 30\n                };\n            });\n            Ee(this, \"_makeInnerHoursDegrees\", (t, e)=>(t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = \"00\")), {\n                    degrees: t,\n                    hour: e,\n                    addDegrees: 30\n                }));\n            Ee(this, \"_getAppendClock\", (t = [], e = `[${mi}]`, s)=>{\n                let { minTime: n, maxTime: o } = this._options;\n                const { inline: r, format12: a, disablePast: l, disableFuture: c } = this._options;\n                n = He(n, l, a), o = Fe(o, c, a);\n                const [h, d, u] = j(o, !1), [f, p, _] = j(n, !1);\n                !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(J) && (v.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(J, \"\"));\n                const m = g.findOne(e), y = 360 / t.length;\n                function x(A) {\n                    return A * (Math.PI / 180);\n                }\n                if (m === null) return;\n                const E = (m.offsetWidth - 32) / 2, C = (m.offsetHeight - 32) / 2, T = E - 4;\n                setTimeout(()=>{\n                    let A;\n                    a && (A = g.findOne(`${yo}[${J}]`).textContent), this._handleDisablingTipsMinTime(A, _, p, f), this._handleDisablingTipsMaxTime(A, u, d, h);\n                }, 0), [\n                    ...t\n                ].forEach((A, w)=>{\n                    const S = x(w * y), k = z(\"span\"), D = z(\"span\");\n                    D.innerHTML = A, v.addClass(k, this._classes.tips), k.setAttribute(s, \"\");\n                    const O = k.offsetWidth, M = k.offsetHeight;\n                    return v.addStyle(k, {\n                        left: `${E + Math.sin(S) * T - O}px`,\n                        bottom: `${C + Math.cos(S) * T - M}px`\n                    }), t.includes(\"05\") && k.setAttribute(vt, \"\"), t.includes(\"13\") ? D.setAttribute(Co, \"\") : D.setAttribute(Eo, \"\"), k.appendChild(D), m.appendChild(k);\n                });\n            });\n            this._element = t, this._element && P.setData(t, mo, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(s), this._currentTime = null, this._toggleButtonId = se(\"timepicker-toggle-\"), this.hoursArray = [\n                \"12\",\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\",\n                \"8\",\n                \"9\",\n                \"10\",\n                \"11\"\n            ], this.innerHours = [\n                \"00\",\n                \"13\",\n                \"14\",\n                \"15\",\n                \"16\",\n                \"17\",\n                \"18\",\n                \"19\",\n                \"20\",\n                \"21\",\n                \"22\",\n                \"23\"\n            ], this.minutesArray = [\n                \"00\",\n                \"05\",\n                \"10\",\n                \"15\",\n                \"20\",\n                \"25\",\n                \"30\",\n                \"35\",\n                \"40\",\n                \"45\",\n                \"50\",\n                \"55\"\n            ], this.input = g.findOne(\"input\", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = g.findOne(z0, this._element), this._checkToggleButton(), this.inputFormatShow = g.findOne(W0, this._element), this.inputFormat = this.inputFormatShow === null ? \"\" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = g.findOne(zh, this._element), this.toggleElement = Object.values(t.querySelector(zh).dataset)[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = this._options.defaultTime !== \"\" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = Nh(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = gi(this._inputValue)), this._options.readOnly && this.input.setAttribute(X0, !0), this.inputFormat === \"true\" && this.inputFormat !== \"\" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = Nh(this._inputValue)), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = {\n                degrees: null\n            }, this._scrollBar = new Es;\n        }\n        static get NAME() {\n            return Ns;\n        }\n        init() {\n            const { format12: t, format24: e, enableValidation: s } = this._options;\n            let n, o, r;\n            if (this.input.setAttribute(G0, \"\"), this._currentTime !== void 0) {\n                const { hours: a, minutes: l, amOrPm: c } = this._currentTime;\n                n = Number(a) < 10 ? 0 : \"\", o = `${n}${Number(a)}:${l}`, r = c, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);\n            } else n = \"\", o = \"\", r = \"\", this.input.value = \"\";\n            this.input.value.length > 0 && this.input.value !== \"\" && (this.input.setAttribute(J, \"\"), b.trigger(this.input, \"input\")), !(this._options === null && this._element === null) && (s && this._getValidate(\"keydown change blur focus\"), this._handleOpen(), this._listenToToggleKeydown());\n        }\n        dispose() {\n            this._removeModal(), this._element !== null && P.removeData(this._element, mo), setTimeout(()=>{\n                this._element = null, this._options = null, this.input = null, this._focusTrap = null;\n            }, 350), b.off(this._document, \"click\", `[data-te-toggle='${this.toggleElement}']`), b.off(this._element, \"keydown\", `[data-te-toggle='${this.toggleElement}']`);\n        }\n        update(t = {}) {\n            this._options = this._getConfig({\n                ...this._options,\n                ...t\n            });\n        }\n        _checkToggleButton() {\n            this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === \"true\" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));\n        }\n        _appendToggleButton() {\n            const t = P0(this._options, this._toggleButtonId, this._classes);\n            this.input.insertAdjacentHTML(\"afterend\", t);\n        }\n        _getDomElements() {\n            this._hour = g.findOne(`[${xo}]`), this._minutes = g.findOne(`[${Ca}]`), this._AM = g.findOne(F0), this._PM = g.findOne(V0), this._wrapper = g.findOne(`[${Ea}]`), this._modal = g.findOne(`[${nd}]`), this._hand = g.findOne(`[${Ta}]`), this._circle = g.findOne(`[${Aa}]`), this._clock = g.findOne(`[${mi}]`), this._clockInner = g.findOne(`[${$s}]`);\n        }\n        _handlerMaxMinHoursOptions(t, e, s, n, o, r) {\n            if (!e && !s) return !0;\n            const { format24: a, format12: l, disablePast: c, disableFuture: h } = this._options, { _isAmEnabled: d, _isPmEnabled: u } = this, f = r.keyCode, p = r.target.hasAttribute($s) || r.target.hasAttribute(Rt) || r.target.hasAttribute(Co);\n            s = He(s, c, l), e = Fe(e, h, l), typeof e != \"number\" && (e = j(e, !1)[0]);\n            const _ = e !== \"\" ? e * 30 : \"\", m = s !== \"\" ? s * 30 : \"\";\n            t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;\n            const y = ()=>{\n                const w = document.querySelectorAll(`[${Eo}]`), S = document.querySelectorAll(`[${Co}]`), k = H0(this._hour.innerText);\n                let D, O, M;\n                return f === Tt ? O = 1 : f === ut && (O = -1), k === 12 && f === Tt ? M = 1 : k === 0 && f === Tt ? M = 13 : k === 0 && f === ut ? M = 23 : k === 13 && f === ut ? M = 0 : k === 1 && f === ut ? M = 12 : M = k + O, w.forEach((L)=>{\n                    Number(L.textContent) === M && (D = L);\n                }), S.forEach((L)=>{\n                    Number(L.textContent) === M && (D = L);\n                }), !D.parentElement.hasAttribute(Ve);\n            }, x = ()=>{\n                const w = s !== \"\" && s > 12 ? (s - 12) * 30 : \"\", S = e !== \"\" && e > 12 ? (e - 12) * 30 : \"\";\n                if (!(w && t < w || S && t > S || e && e < 12)) return !0;\n            };\n            if (a && r.type !== \"keydown\" && p) return x();\n            if (r.type === \"keydown\") return y();\n            const E = !o || o === \"PM\" && u || s !== \"\" && o === \"AM\" && d, C = !n || n === \"PM\" && u || e !== \"\" && n === \"AM\" && d, T = ()=>{\n                const w = m === 360 && l ? 0 : m;\n                if (s) {\n                    if (o === \"PM\" && d || E && t < w) return;\n                } else return !0;\n                return !0;\n            }, A = ()=>{\n                const w = _ === 360 && l ? 0 : _;\n                if (e) {\n                    if (n === \"AM\" && u || C && t > w) return;\n                } else return !0;\n                return !0;\n            };\n            return T() && A();\n        }\n        _handleKeyboard() {\n            b.on(this._document, bo, \"\", (t)=>{\n                let e, s, n;\n                const { increment: o, maxTime: r, minTime: a, format12: l, disablePast: c, disableFuture: h } = this._options;\n                let d = j(a, !1)[0], u = j(r, !1)[0];\n                const f = j(a, !1)[2], p = j(r, !1)[2];\n                d = He(d, c, l), u = Fe(u, h, l), typeof u != \"number\" && (u = j(u, !1)[0]);\n                const _ = g.findOne(`[${vt}]`) === null, m = g.findOne(`[${Rt}]`) !== null, y = Number(this._hand.style.transform.replace(/[^\\d-]/g, \"\")), x = g.find(`[${vt}]`, this._modal), E = g.find(`[${ft}]`, this._modal), C = g.find(`[${Rt}]`, this._modal);\n                let T = this._makeHourDegrees(t.target, y, e).hour;\n                const { degrees: A, addDegrees: w } = this._makeHourDegrees(t.target, y, e);\n                let { minute: S, degrees: k } = this._makeMinutesDegrees(y, s);\n                const D = this._makeMinutesDegrees(y, s).addDegrees;\n                let { hour: O } = this._makeInnerHoursDegrees(y, n);\n                if (t.keyCode === ro) {\n                    const M = g.findOne(`[${ma}]`, this._modal);\n                    b.trigger(M, \"click\");\n                } else if (_) {\n                    if (m && (t.keyCode === Qi && (this._isInner = !1, v.addStyle(this._hand, {\n                        height: \"calc(40% + 1px)\"\n                    }), this._hour.textContent = this._setHourOrMinute(T > 12 ? 1 : T), this._toggleClassActive(this.hoursArray, this._hour, E), this._toggleClassActive(this.innerHours, this._hour, C)), t.keyCode === Zi && (this._isInner = !0, v.addStyle(this._hand, {\n                        height: \"21.5%\"\n                    }), this._hour.textContent = this._setHourOrMinute(O >= 24 || O === \"00\" ? 0 : O), this._toggleClassActive(this.innerHours, this._hour, C), this._toggleClassActive(this.hoursArray, this._hour - 1, E))), t.keyCode === Tt) {\n                        if (!this._handlerMaxMinHoursOptions(A + 30, u, d, p, f, t)) return;\n                        v.addStyle(this._hand, {\n                            transform: `rotateZ(${A + w}deg)`\n                        }), this._isInner ? (O += 1, O === 24 ? O = 0 : (O === 25 || O === \"001\") && (O = 13), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, C)) : (T += 1, this._hour.textContent = this._setHourOrMinute(T > 12 ? 1 : T), this._toggleClassActive(this.hoursArray, this._hour, E));\n                    }\n                    if (t.keyCode === ut) {\n                        if (!this._handlerMaxMinHoursOptions(A - 30, u, d, p, f, t)) return;\n                        v.addStyle(this._hand, {\n                            transform: `rotateZ(${A - w}deg)`\n                        }), this._isInner ? (O -= 1, O === 12 ? O = 0 : O === -1 && (O = 23), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, C)) : (T -= 1, this._hour.textContent = this._setHourOrMinute(T === 0 ? 12 : T), this._toggleClassActive(this.hoursArray, this._hour, E));\n                    }\n                } else t.keyCode === Tt && (k += D, v.addStyle(this._hand, {\n                    transform: `rotateZ(${k}deg)`\n                }), S += 1, o && (S += 4, S === \"0014\" && (S = 5)), this._minutes.textContent = this._setHourOrMinute(S > 59 ? 0 : S), this._toggleClassActive(this.minutesArray, this._minutes, x), this._toggleBackgroundColorCircle(`[${vt}]`)), t.keyCode === ut && (k -= D, v.addStyle(this._hand, {\n                    transform: `rotateZ(${k}deg)`\n                }), o ? S -= 5 : S -= 1, S === -1 ? S = 59 : S === -5 && (S = 55), this._minutes.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.minutesArray, this._minutes, x), this._toggleBackgroundColorCircle(`[${vt}]`));\n            });\n        }\n        _setActiveClassToTipsOnOpen(t, ...e) {\n            if (!this._isInvalidTimeFormat) {\n                if (this._options.format24) {\n                    const s = g.find(`[${ft}]`, this._modal), n = g.find(`[${Rt}]`, this._modal);\n                    this._addActiveClassToTip(s, t), this._addActiveClassToTip(n, t);\n                } else {\n                    [\n                        ...e\n                    ].filter((n)=>(n === \"PM\" ? (v.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(J, \"\")) : n === \"AM\" ? (v.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(J, \"\")) : (v.removeClass(this._AM, this._classes.opacity), v.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(J), this._PM.removeAttribute(J)), n));\n                    const s = g.find(`[${ft}]`, this._modal);\n                    this._addActiveClassToTip(s, t);\n                }\n            }\n        }\n        _setTipsAndTimesDependOnInputValue(t, e) {\n            const { inline: s, format12: n } = this._options;\n            if (this._isInvalidTimeFormat) this._hour.textContent = \"12\", this._minutes.textContent = \"00\", s || v.addStyle(this._hand, {\n                transform: \"rotateZ(0deg)\"\n            }), n && (v.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(J, \"\"));\n            else {\n                const o = t > 12 ? t * 30 - 360 : t * 30;\n                this._hour.textContent = t, this._minutes.textContent = e, s || (v.addStyle(this._hand, {\n                    transform: `rotateZ(${o}deg)`\n                }), v.addStyle(this._circle, {\n                    backgroundColor: \"#1976d2\"\n                }), (Number(t) > 12 || t === \"00\") && v.addStyle(this._hand, {\n                    height: \"21.5%\"\n                }));\n            }\n        }\n        _listenToToggleKeydown() {\n            b.on(this._element, \"keydown\", `[data-te-toggle='${this.toggleElement}']`, (t)=>{\n                t.keyCode === Pt && (t.preventDefault(), b.trigger(this.elementToggle, \"click\"));\n            });\n        }\n        _handleOpen() {\n            const t = this._getContainer();\n            si.on(this._element, \"click\", `[data-te-toggle='${this.toggleElement}']`, (e)=>{\n                if (this._options === null) return;\n                const s = v.getDataAttribute(this.input, \"toggle\") !== null ? 200 : 0;\n                setTimeout(()=>{\n                    v.addStyle(this.elementToggle, {\n                        pointerEvents: \"none\"\n                    }), this.elementToggle.blur();\n                    let n;\n                    j(this.input)[0] === \"\" ? n = [\n                        \"12\",\n                        \"00\",\n                        \"PM\"\n                    ] : n = j(this.input);\n                    const { modalID: o, inline: r, format12: a } = this._options, [l, c, h] = n, d = z(\"div\");\n                    if ((Number(l) > 12 || l === \"00\") && (this._isInner = !0), this.input.blur(), e.target.blur(), d.innerHTML = L0(this._options, this._classes), v.addClass(d, this._classes.modal), d.setAttribute(nd, \"\"), d.setAttribute(\"role\", \"dialog\"), d.setAttribute(\"tabIndex\", \"-1\"), d.setAttribute(\"id\", o), r ? (this._popper = Fi(this.input, d, {\n                        placement: \"bottom-start\"\n                    }), t.appendChild(d)) : (t.appendChild(d), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : v.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, c, h), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, c, h), this._setTipsAndTimesDependOnInputValue(l, c), this.input.value === \"\") {\n                        const u = g.find(`[${ft}]`, this._modal);\n                        a && (v.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(J, \"\")), this._hour.textContent = \"12\", this._minutes.textContent = \"00\", this._addActiveClassToTip(u, Number(this._hour.textContent));\n                    }\n                    if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r) this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();\n                    else {\n                        this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();\n                        const u = document.querySelector(`${vo}[${J}]`);\n                        v.addClass(u, this._classes.opacity), v.addStyle(this._hour, {\n                            pointerEvents: \"none\"\n                        }), v.addStyle(this._minutes, {\n                            pointerEvents: \"\"\n                        });\n                    }\n                    this._focusTrap = new Cs(this._wrapper, {\n                        event: \"keydown\",\n                        condition: ({ key: u })=>u === \"Tab\"\n                    }), this._focusTrap.trap();\n                }, s);\n            });\n        }\n        _handleInlineClicks() {\n            let t, e;\n            const s = (u)=>{\n                let f = u;\n                return f > 59 ? f = 0 : f < 0 && (f = 59), f;\n            }, n = (u)=>{\n                let f = u;\n                return this._options.format24 ? (f > 24 ? f = 1 : f < 0 && (f = 23), f > 23 && (f = 0)) : (f > 12 ? f = 1 : f < 1 && (f = 12), f > 12 && (f = 1)), f;\n            }, o = (u)=>{\n                const f = n(u);\n                this._hour.textContent = this._setHourOrMinute(f);\n            }, r = (u)=>{\n                const f = s(u);\n                this._minutes.textContent = this._setHourOrMinute(f);\n            }, a = ()=>{\n                t += 1, o(t);\n            }, l = ()=>{\n                e += 1, r(e);\n            }, c = ()=>{\n                t -= 1, o(t);\n            }, h = ()=>{\n                e -= 1, r(e);\n            }, d = (u)=>{\n                clearInterval(this._interval), this._interval = setInterval(u, 100);\n            };\n            si.on(this._modal, \"click mousedown mouseup touchstart touchend contextmenu\", `[${va}], [${ya}]`, (u)=>{\n                t = Number(this._hour.textContent), e = Number(this._minutes.textContent);\n                const { target: f, type: p } = u, _ = p === \"mousedown\" || p === \"touchstart\";\n                f.closest(`[${va}]`) ? f.closest(`[${va}]`).parentNode.hasAttribute(td) ? _ ? d(a) : p === \"mouseup\" || p === \"touchend\" || p === \"contextmenu\" ? clearInterval(this._interval) : a() : _ ? d(l) : p === \"mouseup\" || p === \"touchend\" || p === \"contextmenu\" ? clearInterval(this._interval) : l() : f.closest(`[${ya}]`) && (f.closest(`[${ya}]`).parentNode.hasAttribute(td) ? _ ? d(c) : p === \"mouseup\" || p === \"touchend\" ? clearInterval(this._interval) : c() : _ ? d(h) : p === \"mouseup\" || p === \"touchend\" ? clearInterval(this._interval) : h());\n            }), b.on(window, bo, (u)=>{\n                const f = u.code, p = document.activeElement.hasAttribute(xo), _ = document.activeElement.hasAttribute(Ca), m = document.activeElement === document.body;\n                switch(t = Number(this._hour.textContent), e = Number(this._minutes.textContent), f){\n                    case \"ArrowUp\":\n                        u.preventDefault(), m || p ? (this._hour.focus(), a()) : _ && l();\n                        break;\n                    case \"ArrowDown\":\n                        u.preventDefault(), m || p ? (this._hour.focus(), c()) : _ && h();\n                        break;\n                }\n            });\n        }\n        _handleClose() {\n            b.on(this._modal, \"click\", `[${Ea}], [${ma}], [${Jh}]`, ({ target: t })=>{\n                const { closeModalOnBackdropClick: e } = this._options, s = ()=>{\n                    var n;\n                    v.addStyle(this.elementToggle, {\n                        pointerEvents: \"auto\"\n                    }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();\n                };\n                if (t.hasAttribute(Jh)) {\n                    this._toggleAmPm(\"PM\"), this.input.value = \"\", this.input.removeAttribute(J);\n                    let n;\n                    j(this.input)[0] === \"\" ? n = [\n                        \"12\",\n                        \"00\",\n                        \"PM\"\n                    ] : n = j(this.input);\n                    const [o, r, a] = n;\n                    this._setTipsAndTimesDependOnInputValue(\"12\", \"00\"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();\n                } else (t.hasAttribute(ma) || t.hasAttribute(ba) || t.hasAttribute(Ea) && e) && s();\n            });\n        }\n        showValueInput() {\n            return this.input.value;\n        }\n        _handleOkButton() {\n            si.on(this._modal, \"click\", `[${ba}]`, ()=>{\n                let { maxTime: t, minTime: e } = this._options;\n                const { format12: s, format24: n, readOnly: o, focusInputAfterApprove: r, disablePast: a, disableFuture: l } = this._options, c = this._document.querySelector(`${yo}[${J}]`), h = `${this._hour.textContent}:${this._minutes.textContent}`, d = Number(this._hour.textContent), u = d === 12 && s ? 0 : d, f = Number(this._minutes.textContent);\n                e = He(e, a, s), t = Fe(t, l, s);\n                let [p, _, m] = j(t, !1), [y, x, E] = j(e, !1);\n                y = y === \"12\" && s ? \"00\" : y, p = p === \"12\" && s ? \"00\" : p;\n                const C = u < Number(y), T = u > Number(p);\n                let A = !0;\n                c && (A = m === c.textContent);\n                let w = !0;\n                c && (w = E === c.textContent);\n                const S = f > _ && u === Number(p), k = f < x && u === Number(y);\n                if (this.input.setAttribute(J, \"\"), v.addStyle(this.elementToggle, {\n                    pointerEvents: \"auto\"\n                }), t !== \"\") {\n                    if (A && (T || S)) return;\n                    if (m === \"AM\" && c.textContent === \"PM\") return;\n                }\n                e !== \"\" && (w && (C || k) || E === \"PM\" && c.textContent === \"AM\") || N0(this._options, this.input, this._hour.textContent) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(xa), !o && r && this.input.focus(), v.addStyle(this.elementToggle, {\n                    pointerEvents: \"auto\"\n                }), n ? this.input.value = h : c === null ? this.input.value = `${h} PM` : this.input.value = `${h} ${c.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), b.trigger(this.input, \"input.te.timepicker\"), b.trigger(this.input, \"input\"));\n            });\n        }\n        _handleHoverInlineBtn() {\n            si.on(this._modal, \"mouseover mouseleave\", `[${U0}]`, ({ type: t, target: e })=>{\n                const s = g.find(`[${Y0}]`, this._modal), n = g.find(`[${K0}]`, this._modal), o = (l, c)=>l.forEach((h)=>{\n                        if (c) {\n                            v.addClass(h, this._classes.opacity), h.setAttribute(J, \"\");\n                            return;\n                        }\n                        v.removeClass(h, this._classes.opacity), h.removeAttribute(J);\n                    }), a = e.hasAttribute(xo) ? s : n;\n                o(a, t === \"mouseover\");\n            });\n        }\n        _handleDocumentClickInline() {\n            b.on(document, jh, ({ target: t })=>{\n                if (this._modal && !this._modal.contains(t) && !t.hasAttribute(j0)) {\n                    if (clearInterval(this._interval), v.addStyle(this.elementToggle, {\n                        pointerEvents: \"auto\"\n                    }), this._removeModal(), !this._animations) return;\n                    this._toggleBackdropAnimation(!0);\n                }\n            });\n        }\n        _handleSwitchHourMinute() {\n            R0(\"click\", vo, this._classes), b.on(this._modal, \"click\", vo, ()=>{\n                const { format24: t } = this._options, e = g.find(vo, this._modal), s = g.find(`[${vt}]`, this._modal), n = g.find(`[${ft}]`, this._modal), o = g.find(`[${Rt}]`, this._modal), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (c, h)=>{\n                    n.forEach((u)=>u.remove()), s.forEach((u)=>u.remove()), v.addClass(this._hand, this._classes.transform), setTimeout(()=>{\n                        v.removeClass(this._hand, this._classes.transform);\n                    }, 401), this._getAppendClock(c, `[${mi}]`, h);\n                    const d = ()=>{\n                        const u = g.find(`[${ft}]`, this._modal), f = g.find(`[${vt}]`, this._modal);\n                        this._addActiveClassToTip(u, r), this._addActiveClassToTip(f, a);\n                    };\n                    if (!t) setTimeout(()=>{\n                        d();\n                    }, 401);\n                    else {\n                        const u = g.find(`[${Rt}]`, this._modal);\n                        setTimeout(()=>{\n                            this._addActiveClassToTip(u, r), d();\n                        }, 401);\n                    }\n                };\n                e.forEach((c)=>{\n                    c.hasAttribute(J) && (c.hasAttribute(Ca) ? (v.addClass(this._hand, this._classes.transform), v.addStyle(this._hand, {\n                        transform: `rotateZ(${this._minutes.textContent * 6}deg)`,\n                        height: \"calc(40% + 1px)\"\n                    }), t && o.length > 0 && o.forEach((h)=>h.remove()), l(this.minutesArray, vt), this._hour.style.pointerEvents = \"\", this._minutes.style.pointerEvents = \"none\") : c.hasAttribute(xo) && (v.addStyle(this._hand, {\n                        transform: `rotateZ(${this._hour.textContent * 30}deg)`\n                    }), Number(this._hour.textContent) > 12 ? (v.addStyle(this._hand, {\n                        transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,\n                        height: \"21.5%\"\n                    }), Number(this._hour.textContent) > 12 && v.addStyle(this._hand, {\n                        height: \"21.5%\"\n                    })) : v.addStyle(this._hand, {\n                        height: \"calc(40% + 1px)\"\n                    }), t && this._getAppendClock(this.innerHours, `[${$s}]`, Rt), o.length > 0 && o.forEach((h)=>h.remove()), l(this.hoursArray, ft), v.addStyle(this._hour, {\n                        pointerEvents: \"none\"\n                    }), v.addStyle(this._minutes, {\n                        pointerEvents: \"\"\n                    })));\n                });\n            });\n        }\n        _handleDisablingTipsMaxTime(t, e, s, n) {\n            if (!this._options.maxTime && !this._options.disableFuture) return;\n            const o = g.find(`[${ft}]`), r = g.find(`[${Rt}]`), a = g.find(`[${vt}]`);\n            if (!e || e === t) {\n                Fh(r, n, this._classes, this._options.format12), Fh(o, n, this._classes, this._options.format12), $0(a, s, n, this._hour.textContent, this._classes, this._options.format12);\n                return;\n            }\n            e === \"AM\" && t === \"PM\" && (o.forEach((l)=>{\n                v.addClass(l, this._classes.tipsDisabled), l.setAttribute(Ve, \"\");\n            }), a.forEach((l)=>{\n                v.addClass(l, this._classes.tipsDisabled), l.setAttribute(Ve, \"\");\n            }));\n        }\n        _handleDisablingTipsMinTime(t, e, s, n) {\n            if (!this._options.minTime && !this._options.disablePast) return;\n            const o = g.find(`[${ft}]`), r = g.find(`[${Rt}]`), a = g.find(`[${vt}]`);\n            !e || e === t ? (Vh(o, n, this._classes, this._options.format12), Vh(r, n, this._classes, this._options.format12), B0(a, s, n, this._hour.textContent, this._classes, this._options.format12)) : e === \"PM\" && t === \"AM\" && (o.forEach((l)=>{\n                v.addClass(l, this._classes.tipsDisabled), l.setAttribute(Ve, \"\");\n            }), a.forEach((l)=>{\n                v.addClass(l, this._classes.tipsDisabled), l.setAttribute(Ve, \"\");\n            }));\n        }\n        _handleSwitchTimeMode() {\n            b.on(document, \"click\", yo, ({ target: t })=>{\n                let { maxTime: e, minTime: s } = this._options;\n                const { disablePast: n, disableFuture: o, format12: r } = this._options;\n                s = He(s, n, r), e = Fe(e, o, r);\n                const [a, l, c] = j(e, !1), [h, d, u] = j(s, !1), f = g.find(`[${ft}]`), p = g.find(`[${vt}]`);\n                (()=>{\n                    f.forEach((m)=>{\n                        v.removeClass(m, this._classes.tipsDisabled), m.removeAttribute(Ve);\n                    }), p.forEach((m)=>{\n                        v.removeClass(m, this._classes.tipsDisabled), m.removeAttribute(Ve);\n                    });\n                })(), this._handleDisablingTipsMinTime(t.textContent, u, d, h), this._handleDisablingTipsMaxTime(t.textContent, c, l, a), this._toggleAmPm(t.textContent), t.hasAttribute(J) || (g.find(yo).forEach((y)=>{\n                    y.hasAttribute(J) && (v.removeClass(y, this._classes.opacity), y.removeAttribute(J));\n                }), v.addClass(t, this._classes.opacity), t.setAttribute(J, \"\"));\n            });\n        }\n        _handleClockClick() {\n            let { maxTime: t, minTime: e } = this._options;\n            const { disablePast: s, disableFuture: n, format12: o } = this._options;\n            e = He(e, s, o), t = Fe(t, n, o);\n            const r = j(t, !1)[2], a = j(e, !1)[2], l = j(t, !1)[0], c = j(e, !1)[0], h = g.findOne(`[${id}]`);\n            si.on(document, `${Yh} ${Kh} ${Uh} ${Xh} ${Gh} ${Qh} ${qh} ${Zh}`, \"\", (d)=>{\n                go() || d.preventDefault();\n                const { type: u, target: f } = d, { closeModalOnMinutesClick: p, switchHoursToMinutesOnClick: _ } = this._options, m = g.findOne(`[${vt}]`, this._modal) !== null, y = g.findOne(`[${ft}]`, this._modal) !== null, x = g.findOne(`[${Rt}]`, this._modal) !== null, E = g.find(`[${vt}]`, this._modal), C = $h(d, h), T = h.offsetWidth / 2;\n                let A = Math.atan2(C.y - T, C.x - T);\n                if (go()) {\n                    const D = $h(d, h, !0);\n                    A = Math.atan2(D.y - T, D.x - T);\n                }\n                let w = null, S = null, k = null;\n                if (u === \"mousedown\" || u === \"mousemove\" || u === \"touchmove\" || u === \"touchstart\") (u === \"mousedown\" || u === \"touchstart\" || u === \"touchmove\") && (this._hasTargetInnerClass(f) || f.hasAttribute(id) || f.hasAttribute(mi) || f.hasAttribute(vt) || f.hasAttribute(ft) || f.hasAttribute(Aa) || f.hasAttribute(Ta) || f.hasAttribute(sd) || f.hasAttribute(Eo)) && (this._isMouseMove = !0, go() && d.touches && (w = d.touches[0].clientX, S = d.touches[0].clientY, k = document.elementFromPoint(w, S)));\n                else if (u === \"mouseup\" || u === \"touchend\") {\n                    if (this._isMouseMove = !1, this._hasTargetInnerClass(f) || f.hasAttribute(mi) || f.hasAttribute(ft) || f.hasAttribute(Aa) || f.hasAttribute(Ta) || f.hasAttribute(sd) || f.hasAttribute(Eo)) {\n                        if ((y || x) && _) {\n                            const D = Number(this._hour.textContent) > l || Number(this._hour.textContent) < c;\n                            if (this._options.format24 && l !== \"\" && c !== \"\" && D) return;\n                            if (this._options.format24 && c !== \"\" && Number(this._hour.textContent) < c) return;\n                        }\n                        b.trigger(this._minutes, \"click\");\n                    }\n                    if (m && p) {\n                        const D = g.findOne(`[${ba}]`, this._modal);\n                        b.trigger(D, \"click\");\n                    }\n                }\n                if (m) {\n                    let D;\n                    const O = Math.trunc(A * 180 / Math.PI) + 90, { degrees: M, minute: L } = this._makeMinutesDegrees(O, D);\n                    if (this._handlerMaxMinMinutesOptions(M, L) === void 0) return;\n                    const { degrees: X, minute: I } = this._handlerMaxMinMinutesOptions(M, L);\n                    if (this._isMouseMove) {\n                        if (v.addStyle(this._hand, {\n                            transform: `rotateZ(${X}deg)`\n                        }), I === void 0) return;\n                        const F = ()=>I >= 10 || I === \"00\" ? I : `0${I}`;\n                        this._minutes.textContent = F(), this._toggleClassActive(this.minutesArray, this._minutes, E), this._toggleBackgroundColorCircle(`[${vt}]`), this._objWithDataOnChange.degreesMinutes = X, this._objWithDataOnChange.minutes = I;\n                    }\n                }\n                if (y || x) {\n                    let D, O = Math.trunc(A * 180 / Math.PI) + 90;\n                    if (O = Math.round(O / 30) * 30, v.addStyle(this._circle, {\n                        backgroundColor: \"#1976d2\"\n                    }), this._makeHourDegrees(f, O, D) === void 0) return;\n                    const M = ()=>{\n                        if (go() && O && k) {\n                            const { degrees: L, hour: X } = this._makeHourDegrees(k, O, D);\n                            return this._handleMoveHand(k, X, L);\n                        } else {\n                            const { degrees: L, hour: X } = this._makeHourDegrees(f, O, D);\n                            return this._handleMoveHand(f, X, L);\n                        }\n                    };\n                    this._objWithDataOnChange.degreesHours = O, this._handlerMaxMinHoursOptions(O, l, c, r, a, d) && M();\n                }\n                d.stopPropagation();\n            });\n        }\n        _hasTargetInnerClass(t) {\n            return t.hasAttribute($s) || t.hasAttribute(Rt) || t.hasAttribute(Co);\n        }\n        _handleMoveHand(t, e, s) {\n            const n = g.find(`[${ft}]`, this._modal), o = g.find(`[${Rt}]`, this._modal);\n            this._isMouseMove && (this._hasTargetInnerClass(t) ? v.addStyle(this._hand, {\n                height: \"21.5%\"\n            }) : v.addStyle(this._hand, {\n                height: \"calc(40% + 1px)\"\n            }), v.addStyle(this._hand, {\n                transform: `rotateZ(${s}deg)`\n            }), this._hour.textContent = e >= 10 || e === \"00\" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === \"00\" ? e : `0${e}`);\n        }\n        _handlerMaxMinMinutesOptions(t, e) {\n            let { maxTime: s, minTime: n } = this._options;\n            const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;\n            n = He(n, a, o), s = Fe(s, l, o);\n            const c = j(s, !1)[1], h = j(n, !1)[1], d = j(s, !1)[0], u = j(n, !1)[0], f = u === \"12\" && o ? \"0\" : u, p = d === \"12\" && o ? \"0\" : d, _ = j(s, !1)[2], m = j(n, !1)[2], y = c !== \"\" ? c * 6 : \"\", x = h !== \"\" ? h * 6 : \"\", E = Number(this._hour.textContent), C = E === 12 && o ? 0 : E;\n            if (!_ && !m) {\n                if (s !== \"\" && n !== \"\") {\n                    if (Number(p) === C && t > y || Number(f) === C && t < x) return t;\n                } else if (n !== \"\" && C <= Number(f)) {\n                    if (t <= x - 6) return t;\n                } else if (s !== \"\" && C >= Number(p) && t >= y + 6) return t;\n            } else {\n                if (n !== \"\") {\n                    if (m === \"PM\" && this._isAmEnabled) return;\n                    if (m === \"PM\" && this._isPmEnabled) {\n                        if (C < Number(f)) return;\n                        if (C <= Number(f) && t <= x - 6) return t;\n                    } else if (m === \"AM\" && this._isAmEnabled) {\n                        if (C < Number(f)) return;\n                        if (C <= Number(f) && t <= x - 6) return t;\n                    }\n                }\n                if (s !== \"\") {\n                    if (_ === \"AM\" && this._isPmEnabled) return;\n                    if (_ === \"PM\" && this._isPmEnabled) {\n                        if (C >= Number(p) && t >= y + 6) return t;\n                    } else if (_ === \"AM\" && this._isAmEnabled && C >= Number(p) && t >= y + 6) return t;\n                }\n            }\n            return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {\n                degrees: t,\n                minute: e\n            };\n        }\n        _removeModal() {\n            this._animations ? setTimeout(()=>{\n                this._removeModalElements(), this._scrollBar.reset();\n            }, 300) : (this._removeModalElements(), this._scrollBar.reset()), si.off(this._document, `${jh} ${bo} ${Yh} ${Kh} ${Uh} ${Xh} ${Gh} ${Qh} ${qh} ${Zh}`), b.off(window, bo);\n        }\n        _removeModalElements() {\n            this._modal && this._modal.remove();\n        }\n        _toggleBackdropAnimation(t = !1) {\n            t ? this._wrapper.classList.add(\"animate-[fade-out_350ms_ease-in-out]\") : (this._wrapper.classList.add(\"animate-[fade-in_350ms_ease-in-out]\"), this._options.inline || v.addClass(this._clock, this._classes.clockAnimation)), setTimeout(()=>{\n                this._wrapper.classList.remove(\"animate-[fade-out_350ms_ease-in-out]\", \"animate-[fade-in_350ms_ease-in-out]\");\n            }, 351);\n        }\n        _addActiveClassToTip(t, e) {\n            t.forEach((s)=>{\n                Number(s.textContent) === Number(e) && (v.addClass(s, this._classes.tipsActive), s.setAttribute(J, \"\"));\n            });\n        }\n        _setHourOrMinute(t) {\n            return t < 10 ? `0${t}` : t;\n        }\n        _appendTimes() {\n            const { format24: t } = this._options;\n            if (t) {\n                this._getAppendClock(this.hoursArray, `[${mi}]`, ft), this._getAppendClock(this.innerHours, `[${$s}]`, Rt);\n                return;\n            }\n            this._getAppendClock(this.hoursArray, `[${mi}]`, ft);\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._element);\n            return t = {\n                ...q0,\n                ...e,\n                ...t\n            }, W(Ns, t, Z0), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Q0,\n                ...e,\n                ...t\n            }, W(Ns, t, J0), t;\n        }\n        _getContainer() {\n            return g.findOne(this._options.container);\n        }\n        _getValidate(t) {\n            const { invalidLabel: e, format24: s, format12: n, appendValidationInfo: o } = this._options;\n            let r;\n            o && (r = z(\"div\"), r.setAttribute(ed, \"\"), r.innerHTML = e), si.on(this.input, t, ({ target: a })=>{\n                if (this._options === null || this.input.value === \"\") return;\n                const l = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/, c = /^([01]\\d|2[0-3])(:[0-5]\\d)$/, h = l.test(a.value);\n                if (c.test(a.value) !== !0 && s || h !== !0 && n) {\n                    o && (this.input.setAttribute(xa, \"\"), this.input.parentNode.insertBefore(r, this.input.nextSibling)), v.addStyle(a, {\n                        marginBottom: 0\n                    }), v.addStyle(r, {\n                        bottom: \"-23px\"\n                    }), this._isInvalidTimeFormat = !0;\n                    return;\n                }\n                this.input.removeAttribute(xa), this._isInvalidTimeFormat = !1;\n                const u = g.findOne(`[${ed}]`);\n                u !== null && u.remove();\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, mo);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    } /*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */ \n    function pe(i) {\n        return getComputedStyle(i);\n    }\n    function At(i, t) {\n        for(var e in t){\n            var s = t[e];\n            typeof s == \"number\" && (s = s + \"px\"), i.style[e] = s;\n        }\n        return i;\n    }\n    function To(i) {\n        var t = document.createElement(\"div\");\n        return t.className = i, t;\n    }\n    var rd = typeof Element < \"u\" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);\n    function We(i, t) {\n        if (!rd) throw new Error(\"No element matching method supported\");\n        return rd.call(i, t);\n    }\n    function es(i) {\n        i.remove ? i.remove() : i.parentNode && i.parentNode.removeChild(i);\n    }\n    function ad(i, t) {\n        return Array.prototype.filter.call(i.children, function(e) {\n            return We(e, t);\n        });\n    }\n    var at = {\n        main: \"ps\",\n        rtl: \"ps__rtl\",\n        element: {\n            thumb: function(i) {\n                return \"ps__thumb-\" + i;\n            },\n            rail: function(i) {\n                return \"ps__rail-\" + i;\n            },\n            consuming: \"ps__child--consume\"\n        },\n        state: {\n            focus: \"ps--focus\",\n            clicking: \"ps--clicking\",\n            active: function(i) {\n                return \"ps--active-\" + i;\n            },\n            scrolling: function(i) {\n                return \"ps--scrolling-\" + i;\n            }\n        }\n    }, ld = {\n        x: null,\n        y: null\n    };\n    function cd(i, t) {\n        var e = i.element.classList, s = at.state.scrolling(t);\n        e.contains(s) ? clearTimeout(ld[t]) : e.add(s);\n    }\n    function hd(i, t) {\n        ld[t] = setTimeout(function() {\n            return i.isAlive && i.element.classList.remove(at.state.scrolling(t));\n        }, i.settings.scrollingThreshold);\n    }\n    function ty(i, t) {\n        cd(i, t), hd(i, t);\n    }\n    var Bs = function(t) {\n        this.element = t, this.handlers = {};\n    }, dd = {\n        isEmpty: {\n            configurable: !0\n        }\n    };\n    Bs.prototype.bind = function(t, e) {\n        typeof this.handlers[t] > \"u\" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);\n    }, Bs.prototype.unbind = function(t, e) {\n        var s = this;\n        this.handlers[t] = this.handlers[t].filter(function(n) {\n            return e && n !== e ? !0 : (s.element.removeEventListener(t, n, !1), !1);\n        });\n    }, Bs.prototype.unbindAll = function() {\n        for(var t in this.handlers)this.unbind(t);\n    }, dd.isEmpty.get = function() {\n        var i = this;\n        return Object.keys(this.handlers).every(function(t) {\n            return i.handlers[t].length === 0;\n        });\n    }, Object.defineProperties(Bs.prototype, dd);\n    var is = function() {\n        this.eventElements = [];\n    };\n    is.prototype.eventElement = function(t) {\n        var e = this.eventElements.filter(function(s) {\n            return s.element === t;\n        })[0];\n        return e || (e = new Bs(t), this.eventElements.push(e)), e;\n    }, is.prototype.bind = function(t, e, s) {\n        this.eventElement(t).bind(e, s);\n    }, is.prototype.unbind = function(t, e, s) {\n        var n = this.eventElement(t);\n        n.unbind(e, s), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);\n    }, is.prototype.unbindAll = function() {\n        this.eventElements.forEach(function(t) {\n            return t.unbindAll();\n        }), this.eventElements = [];\n    }, is.prototype.once = function(t, e, s) {\n        var n = this.eventElement(t), o = function(r) {\n            n.unbind(e, o), s(r);\n        };\n        n.bind(e, o);\n    };\n    function Ao(i) {\n        if (typeof window.CustomEvent == \"function\") return new CustomEvent(i);\n        var t = document.createEvent(\"CustomEvent\");\n        return t.initCustomEvent(i, !1, !1, void 0), t;\n    }\n    function wo(i, t, e, s, n) {\n        s === void 0 && (s = !0), n === void 0 && (n = !1);\n        var o;\n        if (t === \"top\") o = [\n            \"contentHeight\",\n            \"containerHeight\",\n            \"scrollTop\",\n            \"y\",\n            \"up\",\n            \"down\"\n        ];\n        else if (t === \"left\") o = [\n            \"contentWidth\",\n            \"containerWidth\",\n            \"scrollLeft\",\n            \"x\",\n            \"left\",\n            \"right\"\n        ];\n        else throw new Error(\"A proper axis should be provided\");\n        ey(i, e, o, s, n);\n    }\n    function ey(i, t, e, s, n) {\n        var o = e[0], r = e[1], a = e[2], l = e[3], c = e[4], h = e[5];\n        s === void 0 && (s = !0), n === void 0 && (n = !1);\n        var d = i.element;\n        i.reach[l] = null, d[a] < 1 && (i.reach[l] = \"start\"), d[a] > i[o] - i[r] - 1 && (i.reach[l] = \"end\"), t && (d.dispatchEvent(Ao(\"ps-scroll-\" + l)), t < 0 ? d.dispatchEvent(Ao(\"ps-scroll-\" + c)) : t > 0 && d.dispatchEvent(Ao(\"ps-scroll-\" + h)), s && ty(i, l)), i.reach[l] && (t || n) && d.dispatchEvent(Ao(\"ps-\" + l + \"-reach-\" + i.reach[l]));\n    }\n    function it(i) {\n        return parseInt(i, 10) || 0;\n    }\n    function iy(i) {\n        return We(i, \"input,[contenteditable]\") || We(i, \"select,[contenteditable]\") || We(i, \"textarea,[contenteditable]\") || We(i, \"button,[contenteditable]\");\n    }\n    function sy(i) {\n        var t = pe(i);\n        return it(t.width) + it(t.paddingLeft) + it(t.paddingRight) + it(t.borderLeftWidth) + it(t.borderRightWidth);\n    }\n    var ss = {\n        isWebKit: typeof document < \"u\" && \"WebkitAppearance\" in document.documentElement.style,\n        supportsTouch: typeof window < \"u\" && (\"ontouchstart\" in window || \"maxTouchPoints\" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),\n        supportsIePointer: typeof navigator < \"u\" && navigator.msMaxTouchPoints,\n        isChrome: typeof navigator < \"u\" && /Chrome/i.test(navigator && navigator.userAgent)\n    };\n    function Ce(i) {\n        var t = i.element, e = Math.floor(t.scrollTop), s = t.getBoundingClientRect();\n        i.containerWidth = Math.round(s.width), i.containerHeight = Math.round(s.height), i.contentWidth = t.scrollWidth, i.contentHeight = t.scrollHeight, t.contains(i.scrollbarXRail) || (ad(t, at.element.rail(\"x\")).forEach(function(n) {\n            return es(n);\n        }), t.appendChild(i.scrollbarXRail)), t.contains(i.scrollbarYRail) || (ad(t, at.element.rail(\"y\")).forEach(function(n) {\n            return es(n);\n        }), t.appendChild(i.scrollbarYRail)), !i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth ? (i.scrollbarXActive = !0, i.railXWidth = i.containerWidth - i.railXMarginWidth, i.railXRatio = i.containerWidth / i.railXWidth, i.scrollbarXWidth = ud(i, it(i.railXWidth * i.containerWidth / i.contentWidth)), i.scrollbarXLeft = it((i.negativeScrollAdjustment + t.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth))) : i.scrollbarXActive = !1, !i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight ? (i.scrollbarYActive = !0, i.railYHeight = i.containerHeight - i.railYMarginHeight, i.railYRatio = i.containerHeight / i.railYHeight, i.scrollbarYHeight = ud(i, it(i.railYHeight * i.containerHeight / i.contentHeight)), i.scrollbarYTop = it(e * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight))) : i.scrollbarYActive = !1, i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth && (i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth), i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight && (i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight), ny(t, i), i.scrollbarXActive ? t.classList.add(at.state.active(\"x\")) : (t.classList.remove(at.state.active(\"x\")), i.scrollbarXWidth = 0, i.scrollbarXLeft = 0, t.scrollLeft = i.isRtl === !0 ? i.contentWidth : 0), i.scrollbarYActive ? t.classList.add(at.state.active(\"y\")) : (t.classList.remove(at.state.active(\"y\")), i.scrollbarYHeight = 0, i.scrollbarYTop = 0, t.scrollTop = 0);\n    }\n    function ud(i, t) {\n        return i.settings.minScrollbarLength && (t = Math.max(t, i.settings.minScrollbarLength)), i.settings.maxScrollbarLength && (t = Math.min(t, i.settings.maxScrollbarLength)), t;\n    }\n    function ny(i, t) {\n        var e = {\n            width: t.railXWidth\n        }, s = Math.floor(i.scrollTop);\n        t.isRtl ? e.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth - t.contentWidth : e.left = i.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - s : e.top = t.scrollbarXTop + s, At(t.scrollbarXRail, e);\n        var n = {\n            top: s,\n            height: t.railYHeight\n        };\n        t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + i.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - i.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + i.scrollLeft, At(t.scrollbarYRail, n), At(t.scrollbarX, {\n            left: t.scrollbarXLeft,\n            width: t.scrollbarXWidth - t.railBorderXWidth\n        }), At(t.scrollbarY, {\n            top: t.scrollbarYTop,\n            height: t.scrollbarYHeight - t.railBorderYWidth\n        });\n    }\n    function oy(i) {\n        i.element, i.event.bind(i.scrollbarY, \"mousedown\", function(t) {\n            return t.stopPropagation();\n        }), i.event.bind(i.scrollbarYRail, \"mousedown\", function(t) {\n            var e = t.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top, s = e > i.scrollbarYTop ? 1 : -1;\n            i.element.scrollTop += s * i.containerHeight, Ce(i), t.stopPropagation();\n        }), i.event.bind(i.scrollbarX, \"mousedown\", function(t) {\n            return t.stopPropagation();\n        }), i.event.bind(i.scrollbarXRail, \"mousedown\", function(t) {\n            var e = t.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left, s = e > i.scrollbarXLeft ? 1 : -1;\n            i.element.scrollLeft += s * i.containerWidth, Ce(i), t.stopPropagation();\n        });\n    }\n    function ry(i) {\n        fd(i, [\n            \"containerWidth\",\n            \"contentWidth\",\n            \"pageX\",\n            \"railXWidth\",\n            \"scrollbarX\",\n            \"scrollbarXWidth\",\n            \"scrollLeft\",\n            \"x\",\n            \"scrollbarXRail\"\n        ]), fd(i, [\n            \"containerHeight\",\n            \"contentHeight\",\n            \"pageY\",\n            \"railYHeight\",\n            \"scrollbarY\",\n            \"scrollbarYHeight\",\n            \"scrollTop\",\n            \"y\",\n            \"scrollbarYRail\"\n        ]);\n    }\n    function fd(i, t) {\n        var e = t[0], s = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], h = t[8], d = i.element, u = null, f = null, p = null;\n        function _(x) {\n            x.touches && x.touches[0] && (x[n] = x.touches[0].pageY), d[l] = u + p * (x[n] - f), cd(i, c), Ce(i), x.stopPropagation(), x.type.startsWith(\"touch\") && x.changedTouches.length > 1 && x.preventDefault();\n        }\n        function m() {\n            hd(i, c), i[h].classList.remove(at.state.clicking), i.event.unbind(i.ownerDocument, \"mousemove\", _);\n        }\n        function y(x, E) {\n            u = d[l], E && x.touches && (x[n] = x.touches[0].pageY), f = x[n], p = (i[s] - i[e]) / (i[o] - i[a]), E ? i.event.bind(i.ownerDocument, \"touchmove\", _) : (i.event.bind(i.ownerDocument, \"mousemove\", _), i.event.once(i.ownerDocument, \"mouseup\", m), x.preventDefault()), i[h].classList.add(at.state.clicking), x.stopPropagation();\n        }\n        i.event.bind(i[r], \"mousedown\", function(x) {\n            y(x);\n        }), i.event.bind(i[r], \"touchstart\", function(x) {\n            y(x, !0);\n        });\n    }\n    function ay(i) {\n        var t = i.element, e = function() {\n            return We(t, \":hover\");\n        }, s = function() {\n            return We(i.scrollbarX, \":focus\") || We(i.scrollbarY, \":focus\");\n        };\n        function n(o, r) {\n            var a = Math.floor(t.scrollTop);\n            if (o === 0) {\n                if (!i.scrollbarYActive) return !1;\n                if (a === 0 && r > 0 || a >= i.contentHeight - i.containerHeight && r < 0) return !i.settings.wheelPropagation;\n            }\n            var l = t.scrollLeft;\n            if (r === 0) {\n                if (!i.scrollbarXActive) return !1;\n                if (l === 0 && o < 0 || l >= i.contentWidth - i.containerWidth && o > 0) return !i.settings.wheelPropagation;\n            }\n            return !0;\n        }\n        i.event.bind(i.ownerDocument, \"keydown\", function(o) {\n            if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !s())) {\n                var r = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;\n                if (r) {\n                    if (r.tagName === \"IFRAME\") r = r.contentDocument.activeElement;\n                    else for(; r.shadowRoot;)r = r.shadowRoot.activeElement;\n                    if (iy(r)) return;\n                }\n                var a = 0, l = 0;\n                switch(o.which){\n                    case 37:\n                        o.metaKey ? a = -i.contentWidth : o.altKey ? a = -i.containerWidth : a = -30;\n                        break;\n                    case 38:\n                        o.metaKey ? l = i.contentHeight : o.altKey ? l = i.containerHeight : l = 30;\n                        break;\n                    case 39:\n                        o.metaKey ? a = i.contentWidth : o.altKey ? a = i.containerWidth : a = 30;\n                        break;\n                    case 40:\n                        o.metaKey ? l = -i.contentHeight : o.altKey ? l = -i.containerHeight : l = -30;\n                        break;\n                    case 32:\n                        o.shiftKey ? l = i.containerHeight : l = -i.containerHeight;\n                        break;\n                    case 33:\n                        l = i.containerHeight;\n                        break;\n                    case 34:\n                        l = -i.containerHeight;\n                        break;\n                    case 36:\n                        l = i.contentHeight;\n                        break;\n                    case 35:\n                        l = -i.contentHeight;\n                        break;\n                    default:\n                        return;\n                }\n                i.settings.suppressScrollX && a !== 0 || i.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Ce(i), n(a, l) && o.preventDefault());\n            }\n        });\n    }\n    function ly(i) {\n        var t = i.element;\n        function e(r, a) {\n            var l = Math.floor(t.scrollTop), c = t.scrollTop === 0, h = l + t.offsetHeight === t.scrollHeight, d = t.scrollLeft === 0, u = t.scrollLeft + t.offsetWidth === t.scrollWidth, f;\n            return Math.abs(a) > Math.abs(r) ? f = c || h : f = d || u, f ? !i.settings.wheelPropagation : !0;\n        }\n        function s(r) {\n            var a = r.deltaX, l = -1 * r.deltaY;\n            return (typeof a > \"u\" || typeof l > \"u\") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [\n                -l,\n                -a\n            ] : [\n                a,\n                l\n            ];\n        }\n        function n(r, a, l) {\n            if (!ss.isWebKit && t.querySelector(\"select:focus\")) return !0;\n            if (!t.contains(r)) return !1;\n            for(var c = r; c && c !== t;){\n                if (c.classList.contains(at.element.consuming)) return !0;\n                var h = pe(c);\n                if (l && h.overflowY.match(/(scroll|auto)/)) {\n                    var d = c.scrollHeight - c.clientHeight;\n                    if (d > 0 && (c.scrollTop > 0 && l < 0 || c.scrollTop < d && l > 0)) return !0;\n                }\n                if (a && h.overflowX.match(/(scroll|auto)/)) {\n                    var u = c.scrollWidth - c.clientWidth;\n                    if (u > 0 && (c.scrollLeft > 0 && a < 0 || c.scrollLeft < u && a > 0)) return !0;\n                }\n                c = c.parentNode;\n            }\n            return !1;\n        }\n        function o(r) {\n            var a = s(r), l = a[0], c = a[1];\n            if (!n(r.target, l, c)) {\n                var h = !1;\n                i.settings.useBothWheelAxes ? i.scrollbarYActive && !i.scrollbarXActive ? (c ? t.scrollTop -= c * i.settings.wheelSpeed : t.scrollTop += l * i.settings.wheelSpeed, h = !0) : i.scrollbarXActive && !i.scrollbarYActive && (l ? t.scrollLeft += l * i.settings.wheelSpeed : t.scrollLeft -= c * i.settings.wheelSpeed, h = !0) : (t.scrollTop -= c * i.settings.wheelSpeed, t.scrollLeft += l * i.settings.wheelSpeed), Ce(i), h = h || e(l, c), h && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());\n            }\n        }\n        typeof window.onwheel < \"u\" ? i.event.bind(t, \"wheel\", o) : typeof window.onmousewheel < \"u\" && i.event.bind(t, \"mousewheel\", o);\n    }\n    function cy(i) {\n        if (!ss.supportsTouch && !ss.supportsIePointer) return;\n        var t = i.element;\n        function e(p, _) {\n            var m = Math.floor(t.scrollTop), y = t.scrollLeft, x = Math.abs(p), E = Math.abs(_);\n            if (E > x) {\n                if (_ < 0 && m === i.contentHeight - i.containerHeight || _ > 0 && m === 0) return window.scrollY === 0 && _ > 0 && ss.isChrome;\n            } else if (x > E && (p < 0 && y === i.contentWidth - i.containerWidth || p > 0 && y === 0)) return !0;\n            return !0;\n        }\n        function s(p, _) {\n            t.scrollTop -= _, t.scrollLeft -= p, Ce(i);\n        }\n        var n = {}, o = 0, r = {}, a = null;\n        function l(p) {\n            return p.targetTouches ? p.targetTouches[0] : p;\n        }\n        function c(p) {\n            return p.pointerType && p.pointerType === \"pen\" && p.buttons === 0 ? !1 : !!(p.targetTouches && p.targetTouches.length === 1 || p.pointerType && p.pointerType !== \"mouse\" && p.pointerType !== p.MSPOINTER_TYPE_MOUSE);\n        }\n        function h(p) {\n            if (c(p)) {\n                var _ = l(p);\n                n.pageX = _.pageX, n.pageY = _.pageY, o = new Date().getTime(), a !== null && clearInterval(a);\n            }\n        }\n        function d(p, _, m) {\n            if (!t.contains(p)) return !1;\n            for(var y = p; y && y !== t;){\n                if (y.classList.contains(at.element.consuming)) return !0;\n                var x = pe(y);\n                if (m && x.overflowY.match(/(scroll|auto)/)) {\n                    var E = y.scrollHeight - y.clientHeight;\n                    if (E > 0 && (y.scrollTop > 0 && m < 0 || y.scrollTop < E && m > 0)) return !0;\n                }\n                if (_ && x.overflowX.match(/(scroll|auto)/)) {\n                    var C = y.scrollWidth - y.clientWidth;\n                    if (C > 0 && (y.scrollLeft > 0 && _ < 0 || y.scrollLeft < C && _ > 0)) return !0;\n                }\n                y = y.parentNode;\n            }\n            return !1;\n        }\n        function u(p) {\n            if (c(p)) {\n                var _ = l(p), m = {\n                    pageX: _.pageX,\n                    pageY: _.pageY\n                }, y = m.pageX - n.pageX, x = m.pageY - n.pageY;\n                if (d(p.target, y, x)) return;\n                s(y, x), n = m;\n                var E = new Date().getTime(), C = E - o;\n                C > 0 && (r.x = y / C, r.y = x / C, o = E), e(y, x) && p.preventDefault();\n            }\n        }\n        function f() {\n            i.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {\n                if (i.isInitialized) {\n                    clearInterval(a);\n                    return;\n                }\n                if (!r.x && !r.y) {\n                    clearInterval(a);\n                    return;\n                }\n                if (Math.abs(r.x) < .01 && Math.abs(r.y) < .01) {\n                    clearInterval(a);\n                    return;\n                }\n                if (!i.element) {\n                    clearInterval(a);\n                    return;\n                }\n                s(r.x * 30, r.y * 30), r.x *= .8, r.y *= .8;\n            }, 10));\n        }\n        ss.supportsTouch ? (i.event.bind(t, \"touchstart\", h), i.event.bind(t, \"touchmove\", u), i.event.bind(t, \"touchend\", f)) : ss.supportsIePointer && (window.PointerEvent ? (i.event.bind(t, \"pointerdown\", h), i.event.bind(t, \"pointermove\", u), i.event.bind(t, \"pointerup\", f)) : window.MSPointerEvent && (i.event.bind(t, \"MSPointerDown\", h), i.event.bind(t, \"MSPointerMove\", u), i.event.bind(t, \"MSPointerUp\", f)));\n    }\n    var hy = function() {\n        return {\n            handlers: [\n                \"click-rail\",\n                \"drag-thumb\",\n                \"keyboard\",\n                \"wheel\",\n                \"touch\"\n            ],\n            maxScrollbarLength: null,\n            minScrollbarLength: null,\n            scrollingThreshold: 1e3,\n            scrollXMarginOffset: 0,\n            scrollYMarginOffset: 0,\n            suppressScrollX: !1,\n            suppressScrollY: !1,\n            swipeEasing: !0,\n            useBothWheelAxes: !1,\n            wheelPropagation: !0,\n            wheelSpeed: 1\n        };\n    }, dy = {\n        \"click-rail\": oy,\n        \"drag-thumb\": ry,\n        keyboard: ay,\n        wheel: ly,\n        touch: cy\n    }, Hs = function(t, e) {\n        var s = this;\n        if (e === void 0 && (e = {}), typeof t == \"string\" && (t = document.querySelector(t)), !t || !t.nodeName) throw new Error(\"no element is specified to initialize PerfectScrollbar\");\n        this.element = t, t.classList.add(at.main), this.settings = hy();\n        for(var n in e)this.settings[n] = e[n];\n        this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;\n        var o = function() {\n            return t.classList.add(at.state.focus);\n        }, r = function() {\n            return t.classList.remove(at.state.focus);\n        };\n        this.isRtl = pe(t).direction === \"rtl\", this.isRtl === !0 && t.classList.add(at.rtl), this.isNegativeScroll = function() {\n            var c = t.scrollLeft, h = null;\n            return t.scrollLeft = -1, h = t.scrollLeft < 0, t.scrollLeft = c, h;\n        }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new is, this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = To(at.element.rail(\"x\")), t.appendChild(this.scrollbarXRail), this.scrollbarX = To(at.element.thumb(\"x\")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarX, \"focus\", o), this.event.bind(this.scrollbarX, \"blur\", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;\n        var a = pe(this.scrollbarXRail);\n        this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = it(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = it(a.borderLeftWidth) + it(a.borderRightWidth), At(this.scrollbarXRail, {\n            display: \"block\"\n        }), this.railXMarginWidth = it(a.marginLeft) + it(a.marginRight), At(this.scrollbarXRail, {\n            display: \"\"\n        }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = To(at.element.rail(\"y\")), t.appendChild(this.scrollbarYRail), this.scrollbarY = To(at.element.thumb(\"y\")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarY, \"focus\", o), this.event.bind(this.scrollbarY, \"blur\", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;\n        var l = pe(this.scrollbarYRail);\n        this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = it(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? sy(this.scrollbarY) : null, this.railBorderYWidth = it(l.borderTopWidth) + it(l.borderBottomWidth), At(this.scrollbarYRail, {\n            display: \"block\"\n        }), this.railYMarginHeight = it(l.marginTop) + it(l.marginBottom), At(this.scrollbarYRail, {\n            display: \"\"\n        }), this.railYHeight = null, this.railYRatio = null, this.reach = {\n            x: t.scrollLeft <= 0 ? \"start\" : t.scrollLeft >= this.contentWidth - this.containerWidth ? \"end\" : null,\n            y: t.scrollTop <= 0 ? \"start\" : t.scrollTop >= this.contentHeight - this.containerHeight ? \"end\" : null\n        }, this.isAlive = !0, this.settings.handlers.forEach(function(c) {\n            return dy[c](s);\n        }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, \"scroll\", function(c) {\n            return s.onScroll(c);\n        }), Ce(this);\n    };\n    Hs.prototype.update = function() {\n        this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, At(this.scrollbarXRail, {\n            display: \"block\"\n        }), At(this.scrollbarYRail, {\n            display: \"block\"\n        }), this.railXMarginWidth = it(pe(this.scrollbarXRail).marginLeft) + it(pe(this.scrollbarXRail).marginRight), this.railYMarginHeight = it(pe(this.scrollbarYRail).marginTop) + it(pe(this.scrollbarYRail).marginBottom), At(this.scrollbarXRail, {\n            display: \"none\"\n        }), At(this.scrollbarYRail, {\n            display: \"none\"\n        }), Ce(this), wo(this, \"top\", 0, !1, !0), wo(this, \"left\", 0, !1, !0), At(this.scrollbarXRail, {\n            display: \"\"\n        }), At(this.scrollbarYRail, {\n            display: \"\"\n        }));\n    }, Hs.prototype.onScroll = function(t) {\n        this.isAlive && (Ce(this), wo(this, \"top\", this.element.scrollTop - this.lastScrollTop), wo(this, \"left\", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);\n    }, Hs.prototype.destroy = function() {\n        this.isAlive && (this.event.unbindAll(), es(this.scrollbarX), es(this.scrollbarY), es(this.scrollbarXRail), es(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);\n    }, Hs.prototype.removePsClasses = function() {\n        this.element.className = this.element.className.split(\" \").filter(function(t) {\n            return !t.match(/^ps([-_].+|)$/);\n        }).join(\" \");\n    };\n    const uy = {\n        threshold: 10,\n        direction: \"all\"\n    };\n    class fy {\n        constructor(t, e){\n            this._element = t, this._startPosition = null, this._options = {\n                ...uy,\n                ...e\n            };\n        }\n        handleTouchStart(t) {\n            this._startPosition = this._getCoordinates(t);\n        }\n        handleTouchMove(t) {\n            if (!this._startPosition) return;\n            const e = this._getCoordinates(t), s = {\n                x: e.x - this._startPosition.x,\n                y: e.y - this._startPosition.y\n            }, n = this._getDirection(s);\n            if (this._options.direction === \"all\") {\n                if (n.y.value < this._options.threshold && n.x.value < this._options.threshold) return;\n                const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;\n                b.trigger(this._element, `swipe${r}`), b.trigger(this._element, \"swipe\", {\n                    direction: r\n                }), this._startPosition = null;\n                return;\n            }\n            const o = this._options.direction === \"left\" || this._options === \"right\" ? \"x\" : \"y\";\n            n[o].direction === this._options.direction && n[o].value > this._options.threshold && (b.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);\n        }\n        handleTouchEnd() {\n            this._startPosition = null;\n        }\n        _getCoordinates(t) {\n            const [e] = t.touches;\n            return {\n                x: e.clientX,\n                y: e.clientY\n            };\n        }\n        _getDirection(t) {\n            return {\n                x: {\n                    direction: t.x < 0 ? \"left\" : \"right\",\n                    value: Math.abs(t.x)\n                },\n                y: {\n                    direction: t.y < 0 ? \"up\" : \"down\",\n                    value: Math.abs(t.y)\n                }\n            };\n        }\n    }\n    class py {\n        constructor(t, e = \"swipe\", s = {}){\n            this._element = t, this._event = e, this.swipe = new fy(t, s), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);\n        }\n        dispose() {\n            this._element.removeEventListener(\"touchstart\", this._touchStartHandler), this._element.removeEventListener(\"touchmove\", this._touchMoveHandler), window.removeEventListener(\"touchend\", this._touchEndHandler);\n        }\n        init() {\n            this._element.addEventListener(\"touchstart\", (t)=>this._handleTouchStart(t)), this._element.addEventListener(\"touchmove\", (t)=>this._handleTouchMove(t)), window.addEventListener(\"touchend\", (t)=>this._handleTouchEnd(t));\n        }\n        _handleTouchStart(t) {\n            this[this._event].handleTouchStart(t);\n        }\n        _handleTouchMove(t) {\n            this[this._event].handleTouchMove(t);\n        }\n        _handleTouchEnd(t) {\n            this[this._event].handleTouchEnd(t);\n        }\n    }\n    const _y = \"group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none\", gy = \"group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\", my = \"absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none\", by = \"group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\", vy = \"absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none\", yy = (i = document)=>{\n        [\n            {\n                ps: \"ps__rail-x\",\n                te: gy\n            },\n            {\n                ps: \"ps__rail-y\",\n                te: by\n            },\n            {\n                ps: \"ps__thumb-x\",\n                te: my\n            },\n            {\n                ps: \"ps__thumb-y\",\n                te: vy\n            }\n        ].forEach((e)=>{\n            v.addClass(g.findOne(`.${e.ps}`, i), e.te), v.removeClass(g.findOne(`.${e.ps}`, i), e.ps);\n        }), v.addClass(i, _y), v.removeClass(i, \"ps\");\n    }, pd = \"sidenav\", ko = \"te.sidenav\", xy = \"data-te-sidenav-rotate-icon-ref\", wa = \"[data-te-sidenav-toggle-ref]\", Ey = \"[data-te-collapse-init]\", Cy = '[data-te-sidenav-slim=\"true\"]', Ty = '[data-te-sidenav-slim=\"false\"]', Ay = \"[data-te-sidenav-menu-ref]\", ns = \"[data-te-sidenav-collapse-ref]\", Fs = \"[data-te-sidenav-link-ref]\", wy = st() ? 100 : -100, ky = st() ? -100 : 100, Sy = {\n        sidenavAccordion: \"(boolean)\",\n        sidenavBackdrop: \"(boolean)\",\n        sidenavBackdropClass: \"(null|string)\",\n        sidenavCloseOnEsc: \"(boolean)\",\n        sidenavColor: \"(string)\",\n        sidenavContent: \"(null|string)\",\n        sidenavExpandable: \"(boolean)\",\n        sidenavExpandOnHover: \"(boolean)\",\n        sidenavFocusTrap: \"(boolean)\",\n        sidenavHidden: \"(boolean)\",\n        sidenavMode: \"(string)\",\n        sidenavModeBreakpointOver: \"(null|string|number)\",\n        sidenavModeBreakpointSide: \"(null|string|number)\",\n        sidenavModeBreakpointPush: \"(null|string|number)\",\n        sidenavBreakpointSm: \"(number)\",\n        sidenavBreakpointMd: \"(number)\",\n        sidenavBreakpointLg: \"(number)\",\n        sidenavBreakpointXl: \"(number)\",\n        sidenavBreakpoint2xl: \"(number)\",\n        sidenavScrollContainer: \"(null|string)\",\n        sidenavSlim: \"(boolean)\",\n        sidenavSlimCollapsed: \"(boolean)\",\n        sidenavSlimWidth: \"(number)\",\n        sidenavPosition: \"(string)\",\n        sidenavRight: \"(boolean)\",\n        sidenavTransitionDuration: \"(number)\",\n        sidenavWidth: \"(number)\"\n    }, Oy = {\n        sidenavAccordion: !1,\n        sidenavBackdrop: !0,\n        sidenavBackdropClass: null,\n        sidenavCloseOnEsc: !0,\n        sidenavColor: \"primary\",\n        sidenavContent: null,\n        sidenavExpandable: !0,\n        sidenavExpandOnHover: !1,\n        sidenavFocusTrap: !0,\n        sidenavHidden: !0,\n        sidenavMode: \"over\",\n        sidenavModeBreakpointOver: null,\n        sidenavModeBreakpointSide: null,\n        sidenavModeBreakpointPush: null,\n        sidenavBreakpointSm: 640,\n        sidenavBreakpointMd: 768,\n        sidenavBreakpointLg: 1024,\n        sidenavBreakpointXl: 1280,\n        sidenavBreakpoint2xl: 1536,\n        sidenavScrollContainer: null,\n        sidenavSlim: !1,\n        sidenavSlimCollapsed: !1,\n        sidenavSlimWidth: 77,\n        sidenavPosition: \"fixed\",\n        sidenavRight: !1,\n        sidenavTransitionDuration: 300,\n        sidenavWidth: 240\n    };\n    class bi {\n        constructor(t, e = {}){\n            Ee(this, \"_addBackdropOnInit\", ()=>{\n                this._options.sidenavHidden || (this._backdrop.show(), b.off(this._element, \"transitionend\", this._addBackdropOnInit));\n            });\n            this._element = t, this._options = e, this._ID = se(\"\"), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (s)=>{\n                s.keyCode === ro && this.toggler && ne(this.toggler) && (this._update(!1), b.off(window, \"keydown\", this.escHandler));\n            }, this.hashHandler = ()=>{\n                this._setActiveElements();\n            }, t && (P.setData(t, ko, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === \"over\" && b.on(this._element, \"transitionend\", this._addBackdropOnInit), this._didInit = !1, this._init();\n        }\n        static get NAME() {\n            return pd;\n        }\n        get container() {\n            if (this.options.sidenavPosition === \"fixed\") return g.findOne(\"body\");\n            const t = (e)=>!e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === \"relative\" || e.parentNode.classList.contains(\"relative\") ? e.parentNode : t(e.parentNode);\n            return t(this._element);\n        }\n        get isVisible() {\n            let t = 0, e = window.innerWidth;\n            if (this.options.sidenavPosition !== \"fixed\") {\n                const n = this.container.getBoundingClientRect();\n                t = n.x, e = n.x + n.width;\n            }\n            const { x: s } = this._element.getBoundingClientRect();\n            return this.options.sidenavRight ? Math.abs(s - e) > 10 : Math.abs(s - t) < 10;\n        }\n        get links() {\n            return g.find(Fs, this._element);\n        }\n        get navigation() {\n            return g.find(Ay, this._element);\n        }\n        get options() {\n            const t = {\n                ...Oy,\n                ...v.getDataAttributes(this._element),\n                ...this._options\n            };\n            return W(pd, t, Sy), t;\n        }\n        get sidenavStyle() {\n            return {\n                width: `${this.width}px`,\n                height: this.options.sidenavPosition === \"fixed\" ? \"100vh\" : \"100%\",\n                position: this.options.sidenavPosition,\n                transition: `all ${this.transitionDuration} linear`\n            };\n        }\n        get toggler() {\n            return g.find(wa).find((e)=>{\n                const s = v.getDataAttribute(e, \"target\");\n                return g.findOne(s) === this._element;\n            });\n        }\n        get transitionDuration() {\n            return `${this.options.sidenavTransitionDuration / 1e3}s`;\n        }\n        get translation() {\n            return this.options.sidenavRight ? ky : wy;\n        }\n        get width() {\n            return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;\n        }\n        get isBackdropVisible() {\n            return !!this._backdrop._element;\n        }\n        changeMode(t) {\n            this._setMode(t);\n        }\n        dispose() {\n            b.off(window, \"keydown\", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), b.off(window, \"hashchange\", this.hashHandler), this._touch.dispose(), P.removeData(this._element, ko), this._element = null;\n        }\n        hide() {\n            this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();\n        }\n        show() {\n            this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === \"over\" && this._backdrop.show();\n        }\n        toggle() {\n            this._emitEvents(!this.isVisible), this._update(!this.isVisible);\n        }\n        toggleSlim() {\n            this._setSlim(!this._slimCollapsed);\n        }\n        update(t) {\n            this._options = t, this._setup();\n        }\n        getBreakpoint(t) {\n            return this._transformBreakpointValuesToObject()[t];\n        }\n        _init() {\n            this._didInit || (b.on(document, \"click\", wa, bi.toggleSidenav()), this._didInit = !0);\n        }\n        _transformBreakpointValuesToObject() {\n            return {\n                sm: this.options.sidenavBreakpointSm,\n                md: this.options.sidenavBreakpointMd,\n                lg: this.options.sidenavBreakpointLg,\n                xl: this.options.sidenavBreakpointXl,\n                \"2xl\": this.options.sidenavBreakpoint2xl\n            };\n        }\n        _setModeFromBreakpoints() {\n            const t = window.innerWidth, e = this._transformBreakpointValuesToObject();\n            if (t === void 0 || !e) return;\n            const s = typeof this.options.sidenavModeBreakpointOver == \"number\" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == \"number\" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == \"number\" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, c)=>l - c < 0 ? -1 : c - l < 0 ? 1 : 0, a = [\n                s,\n                n,\n                o\n            ].filter((l)=>l != null && l >= 0).sort(r)[0];\n            s > 0 && s === a ? (this._options.sidenavMode = \"over\", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = \"side\" : o > 0 && o === a && (this._options.sidenavMode = \"push\");\n        }\n        _collapseItems() {\n            this.navigation.forEach((t)=>{\n                g.find(ns, t).forEach((s)=>{\n                    re.getInstance(s).hide();\n                });\n            });\n        }\n        _getOffsetValue(t, { index: e, property: s, offsets: n }) {\n            const o = this._getPxValue(this._initialContentStyle[e][n[s].property]), r = t ? n[s].value : 0;\n            return o + r;\n        }\n        _getProperty(...t) {\n            return t.map((e, s)=>s === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join(\"\");\n        }\n        _getPxValue(t) {\n            return t ? parseFloat(t) : 0;\n        }\n        _handleSwipe(t, e) {\n            e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && ne(this.toggler) && this.toggle() : this.toggleSlim());\n        }\n        _isActive(t, e) {\n            return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;\n        }\n        _isAllToBeCollapsed() {\n            return g.find(Ey, this._element).filter((s)=>s.getAttribute(\"aria-expanded\") === \"true\").length === 0;\n        }\n        _isAllCollapsed() {\n            return g.find(ns, this._element).filter((t)=>ne(t)).length === 0;\n        }\n        _initializeBackDrop() {\n            if (!this.options.sidenavBackdrop) return;\n            const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(\" \") : this.options.sidenavPosition ? [\n                \"opacity-50\",\n                \"transition-all\",\n                \"duration-300\",\n                \"ease-in-out\",\n                this.options.sidenavPosition,\n                \"top-0\",\n                \"left-0\",\n                \"z-50\",\n                \"bg-black/10\",\n                \"dark:bg-black-60\",\n                \"w-full\",\n                \"h-full\",\n                this._element.id\n            ] : null;\n            return new Xr({\n                isVisible: this.options.sidenavBackdrop,\n                isAnimated: !0,\n                rootElement: this._element.parentNode,\n                backdropClasses: t,\n                clickCallback: ()=>this.hide()\n            });\n        }\n        _updateBackdrop(t) {\n            if (this.options.sidenavMode === \"over\") {\n                t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();\n                return;\n            }\n            this.isBackdropVisible && this._backdrop.hide();\n        }\n        _setup() {\n            this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === \"over\" && this._setTabindex(!0);\n        }\n        _setupActiveState() {\n            this._setActiveElements(), this.links.forEach((t)=>{\n                b.on(t, \"click\", ()=>this._setActiveElements(t)), b.on(t, \"keydown\", (e)=>{\n                    e.keyCode === Pt && this._setActiveElements(t);\n                });\n            }), b.on(window, \"hashchange\", this.hashHandler);\n        }\n        _setupCollapse() {\n            this.navigation.forEach((t, e)=>{\n                g.find(ns, t).forEach((n, o)=>this._setupCollapseList({\n                        list: n,\n                        index: o,\n                        menu: t,\n                        menuIndex: e\n                    }));\n            });\n        }\n        _generateCollpaseID(t, e) {\n            return `sidenav-collapse-${this._ID}-${e}-${t}`;\n        }\n        _setupCollapseList({ list: t, index: e, menu: s, menuIndex: n }) {\n            const o = this._generateCollpaseID(e, n);\n            t.setAttribute(\"id\", o), t.setAttribute(\"data-te-collapse-item\", \"\");\n            const [r] = g.prev(t, Fs);\n            v.setDataAttribute(r, \"collapse-init\", \"\"), r.setAttribute(\"href\", `#${o}`), r.setAttribute(\"role\", \"button\");\n            const a = re.getInstance(t) || new re(t, {\n                toggle: !1,\n                parent: this.options.sidenavAccordion ? s : t\n            });\n            (t.dataset.teSidenavStateShow === \"\" || t.dataset.teCollapseShow === \"\") && this._rotateArrow(r, !1), b.on(r, \"click\", (l)=>{\n                this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n            }), b.on(t, \"show.te.collapse\", ()=>this._rotateArrow(r, !1)), b.on(t, \"hide.te.collapse\", ()=>this._rotateArrow(r, !0)), b.on(t, \"shown.te.collapse\", ()=>{\n                this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n            }), b.on(t, \"hidden.te.collapse\", ()=>{\n                this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n            });\n        }\n        _setupContent() {\n            this._content = g.find(this.options.sidenavContent), this._content.forEach((t)=>{\n                const e = [\n                    \"!p\",\n                    \"!m\",\n                    \"!px\",\n                    \"!pl\",\n                    \"!pr\",\n                    \"!mx\",\n                    \"!ml\",\n                    \"!mr\",\n                    \"!-p\",\n                    \"!-m\",\n                    \"!-px\",\n                    \"!-pl\",\n                    \"!-pr\",\n                    \"!-mx\",\n                    \"!-ml\",\n                    \"!-mr\"\n                ];\n                [\n                    ...t.classList\n                ].filter((n)=>e.findIndex((o)=>n.includes(o)) >= 0).forEach((n)=>t.classList.remove(n));\n            }), this._initialContentStyle = this._content.map((t)=>{\n                const { paddingLeft: e, paddingRight: s, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);\n                return {\n                    paddingLeft: e,\n                    paddingRight: s,\n                    marginLeft: n,\n                    marginRight: o,\n                    transition: r\n                };\n            });\n        }\n        _setupFocusTrap() {\n            this._focusTrap = new Cs(this._element, {\n                event: \"keydown\",\n                condition: (t)=>t.keyCode === Rs,\n                onlyVisible: !0\n            }, this.toggler);\n        }\n        _setupInitialStyling() {\n            this._setColor(), v.style(this._element, this.sidenavStyle);\n        }\n        _setupScrolling() {\n            let t = this._element;\n            if (this.options.sidenavScrollContainer) {\n                t = g.findOne(this.options.sidenavScrollContainer, this._element);\n                const s = qp(t.parentNode.children).filter((n)=>n !== t).reduce((n, o)=>n + o.clientHeight, 0);\n                v.style(t, {\n                    maxHeight: `calc(100% - ${s}px)`,\n                    position: \"relative\"\n                });\n            }\n            this._perfectScrollbar = new Hs(t, {\n                suppressScrollX: !0,\n                handlers: [\n                    \"click-rail\",\n                    \"drag-thumb\",\n                    \"wheel\",\n                    \"touch\"\n                ]\n            }), yy(t);\n        }\n        _setupSlim() {\n            this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener(\"mouseenter\", ()=>{\n                this._slimCollapsed && this._setSlim(!1);\n            }), this._element.addEventListener(\"mouseleave\", ()=>{\n                this._slimCollapsed || this._setSlim(!0);\n            }));\n        }\n        _setupRippleEffect() {\n            this.links.forEach((t)=>{\n                let e = Ui.getInstance(t), s = this.options.sidenavColor;\n                if (e && e._options.sidenavColor !== this.options.sidenavColor) e.dispose();\n                else if (e) return;\n                (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (s = \"white\"), e = new Ui(t, {\n                    rippleColor: s\n                });\n            });\n        }\n        _setupTouch() {\n            this._touch = new py(this._element, \"swipe\", {\n                threshold: 20\n            }), this._touch.init(), b.on(this._element, \"swipeleft\", (t)=>this._handleSwipe(t, this.options.sidenavRight)), b.on(this._element, \"swiperight\", (t)=>this._handleSwipe(t, !this.options.sidenavRight));\n        }\n        _setActive(t, e) {\n            t.setAttribute(\"data-te-sidebar-state-active\", \"\"), this._activeNode && t.removeAttribute(\"data-te-sidebar-state-active\"), this._activeNode = t;\n            const [s] = g.parents(this._activeNode, ns);\n            if (!s) {\n                this._setActiveCategory();\n                return;\n            }\n            const [n] = g.prev(s, Fs);\n            this._setActiveCategory(n), !e && !this._slimCollapsed && re.getInstance(s).show();\n        }\n        _setActiveCategory(t) {\n            this.navigation.forEach((e)=>{\n                g.find(ns, e).forEach((n)=>{\n                    const [o] = g.prev(n, Fs);\n                    o !== t ? o.removeAttribute(\"data-te-sidenav-state-active\") : o.setAttribute(\"data-te-sidenav-state-active\", \"\");\n                });\n            });\n        }\n        _setActiveElements(t) {\n            this.navigation.forEach((e)=>{\n                g.find(Fs, e).filter((n)=>g.next(n, ns).length === 0).forEach((n)=>{\n                    this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);\n                });\n            }), t && this._updateFocus(this.isVisible);\n        }\n        _setColor() {\n            const t = [\n                \"primary\",\n                \"secondary\",\n                \"success\",\n                \"info\",\n                \"warning\",\n                \"danger\",\n                \"light\",\n                \"dark\"\n            ], { sidenavColor: e } = this.options, s = t.includes(e) ? e : \"primary\";\n            t.forEach((n)=>{\n                this._element.classList.remove(`sidenav-${n}`);\n            }), v.addClass(this._element, `sidenav-${s}`);\n        }\n        _setContentOffsets(t, e, s) {\n            this._content.forEach((n, o)=>{\n                const r = this._getOffsetValue(t, {\n                    index: o,\n                    property: \"padding\",\n                    offsets: e\n                }), a = this._getOffsetValue(t, {\n                    index: o,\n                    property: \"margin\",\n                    offsets: e\n                }), l = {};\n                if (s || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, v.style(n, l), !!t) {\n                    if (s) {\n                        v.style(n, {\n                            transition: this._initialContentStyle[o].transition\n                        });\n                        return;\n                    }\n                    b.on(n, \"transitionend\", ()=>{\n                        v.style(n, {\n                            transition: this._initialContentStyle[o].transition\n                        });\n                    });\n                }\n            });\n        }\n        _setMode(t) {\n            this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));\n        }\n        _setSlim(t) {\n            const e = t ? [\n                \"collapse\",\n                \"collapsed\"\n            ] : [\n                \"expand\",\n                \"expanded\"\n            ];\n            this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), v.style(this._element, {\n                width: `${this.width}px`\n            }), this._updateOffsets(this.isVisible);\n        }\n        _setTabindex(t) {\n            this.links.forEach((e)=>{\n                e.tabIndex = t ? 0 : -1;\n            });\n        }\n        _emitEvents(t) {\n            const e = t ? [\n                \"show\",\n                \"shown\"\n            ] : [\n                \"hide\",\n                \"hidden\"\n            ];\n            this._triggerEvents(...e);\n        }\n        _rotateArrow(t, e) {\n            const [s] = g.children(t, `[${xy}]`);\n            s && (e ? v.removeClass(s, \"rotate-180\") : v.addClass(s, \"rotate-180\"));\n        }\n        _toggleCategory(t, e) {\n            t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));\n        }\n        _toggleSlimDisplay(t) {\n            const e = g.find(Cy, this._element), s = g.find(Ty, this._element), n = ()=>{\n                e.forEach((o)=>{\n                    v.style(o, {\n                        display: this._slimCollapsed ? \"unset\" : \"none\"\n                    });\n                }), s.forEach((o)=>{\n                    v.style(o, {\n                        display: this._slimCollapsed ? \"none\" : \"unset\"\n                    });\n                });\n            };\n            t ? setTimeout(()=>n(), this.options.sidenavTransitionDuration) : n();\n        }\n        async _triggerEvents(t, e) {\n            b.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(()=>{\n                b.trigger(this._element, `${e}.te.sidenav`);\n            }, this.options.sidenavTransitionDuration + 5);\n        }\n        _update(t) {\n            this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== \"side\" && b.on(window, \"keydown\", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);\n        }\n        _updateDisplay(t) {\n            const e = t ? 0 : this.translation;\n            v.style(this._element, {\n                transform: `translateX(${e}%)`\n            });\n        }\n        _updateFocus(t) {\n            if (this._setTabindex(t), this.options.sidenavMode === \"over\" && this.options.sidenavFocusTrap) {\n                if (t) {\n                    this._focusTrap.trap();\n                    return;\n                }\n                this._focusTrap.disable();\n            }\n            this._focusTrap.disable();\n        }\n        _updateOffsets(t, e = !1) {\n            const [s, n] = this.options.sidenavRight ? [\n                \"right\",\n                \"left\"\n            ] : [\n                \"left\",\n                \"right\"\n            ], o = {\n                property: this._getProperty(\"padding\", s),\n                value: this.options.sidenavMode === \"over\" ? 0 : this.width\n            }, r = {\n                property: this._getProperty(\"margin\", n),\n                value: this.options.sidenavMode === \"push\" ? -1 * this.width : 0\n            };\n            b.trigger(this._element, \"update.te.sidenav\", {\n                margin: r,\n                padding: o\n            }), this._content && (this._content.className = \"\", this._setContentOffsets(t, {\n                padding: o,\n                margin: r\n            }, e));\n        }\n        _updateTogglerAria(t) {\n            this.toggler.setAttribute(\"aria-expanded\", t);\n        }\n        static toggleSidenav() {\n            return function(t) {\n                const e = g.closest(t.target, wa), s = v.getDataAttributes(e).target;\n                g.find(s).forEach((n)=>{\n                    (bi.getInstance(n) || new bi(n)).toggle();\n                });\n            };\n        }\n        static jQueryInterface(t, e) {\n            return this.each(function() {\n                let s = P.getData(this, ko);\n                const n = typeof t == \"object\" && t;\n                if (!(!s && /dispose/.test(t)) && (s || (s = new bi(this, n)), typeof t == \"string\")) {\n                    if (typeof s[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    s[t](e);\n                }\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, ko);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const ka = \"stepper\", So = \"te.stepper\", Oo = `.${So}`, Vs = `data-te-${ka}`, Ws = \"horizontal\", _e = \"vertical\", Dy = {\n        stepperType: \"string\",\n        stepperLinear: \"boolean\",\n        stepperNoEditable: \"boolean\",\n        stepperActive: \"string\",\n        stepperCompleted: \"string\",\n        stepperInvalid: \"string\",\n        stepperDisabled: \"string\",\n        stepperVerticalBreakpoint: \"number\",\n        stepperMobileBreakpoint: \"number\",\n        stepperMobileBarBreakpoint: \"number\"\n    }, My = {\n        stepperType: Ws,\n        stepperLinear: !1,\n        stepperNoEditable: !1,\n        stepperActive: \"\",\n        stepperCompleted: \"\",\n        stepperInvalid: \"\",\n        stepperDisabled: \"\",\n        stepperVerticalBreakpoint: 0,\n        stepperMobileBreakpoint: 0,\n        stepperMobileBarBreakpoint: 4\n    }, _d = `mousedown${Oo}`, gd = `keydown${Oo}`, Iy = `keyup${Oo}`, md = `resize${Oo}`, ze = `[${Vs}-step-ref]`, yt = `[${Vs}-head-ref]`, bd = `[${Vs}-head-text-ref]`, Do = `[${Vs}-head-icon-ref]`, wt = `[${Vs}-content-ref]`;\n    class vd {\n        constructor(t, e){\n            this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = g.find(`${ze}`, this._element), this._currentView = \"\", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (P.setData(t, So, this), this._init());\n        }\n        static get NAME() {\n            return ka;\n        }\n        get activeStep() {\n            return this._steps[this._activeStepIndex];\n        }\n        get activeStepIndex() {\n            return this._activeStepIndex;\n        }\n        dispose() {\n            this._steps.forEach((t)=>{\n                b.off(t, _d), b.off(t, gd);\n            }), b.off(window, md), P.removeData(this._element, So), this._element = null;\n        }\n        changeStep(t) {\n            this._toggleStep(t);\n        }\n        nextStep() {\n            this._toggleStep(this._activeStepIndex + 1);\n        }\n        previousStep() {\n            this._toggleStep(this._activeStepIndex - 1);\n        }\n        _init() {\n            const t = g.find(`${ze}`, this._element)[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), e = g.find(`${bd}`, this._element), s = g.find(`${Do}`, this._element);\n            switch(t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(this._activeStepIndex, \"add\", this._options.stepperActive), e[this._activeStepIndex].classList.add(\"font-medium\"), s[this._activeStepIndex].classList.add(\"!bg-primary-100\"), s[this._activeStepIndex].classList.add(\"!text-primary-700\")) : (e[this._activeStepIndex].classList.add(\"font-medium\"), s[this._activeStepIndex].classList.add(\"!bg-primary-100\"), s[this._activeStepIndex].classList.add(\"!text-primary-700\"), this._toggleStepClass(this._activeStepIndex, \"add\", this._options.stepperActive)), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType){\n                case _e:\n                    this._toggleVertical();\n                    break;\n                default:\n                    this._toggleHorizontal();\n                    break;\n            }\n            (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._element);\n            return t = {\n                ...My,\n                ...e,\n                ...t\n            }, W(ka, t, Dy), t;\n        }\n        _bindMouseDown() {\n            this._steps.forEach((t)=>{\n                const e = g.findOne(`${yt}`, t);\n                b.on(e, _d, (s)=>{\n                    const n = g.parents(s.target, `${ze}`)[0], o = this._steps.indexOf(n);\n                    s.preventDefault(), this._toggleStep(o);\n                });\n            });\n        }\n        _bindResize() {\n            b.on(window, md, ()=>{\n                this._currentView === _e && this._setSingleStepHeight(this.activeStep), this._currentView === Ws && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();\n            });\n        }\n        _toggleStepperView() {\n            const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, s = this._options.stepperMobileBreakpoint > window.innerWidth;\n            t && this._currentView !== Ws && this._toggleHorizontal(), e && !s && this._currentView !== _e && (this._steps.forEach((n)=>{\n                const o = g.findOne(`${wt}`, n);\n                this._resetStepperHeight(), this._showElement(o);\n            }), this._toggleVertical());\n        }\n        _toggleStep(t) {\n            this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(g.findOne(`${wt}`, this._steps[t])), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === Ws ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(g.findOne(`${yt}`, this.activeStep), g.findOne(`${yt}`, this._steps[t])), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), this._steps.forEach((e, s)=>{\n                e[this._activeStepIndex] !== s && e.removeAttribute(\"data-te\");\n            }));\n        }\n        _resetStepperHeight() {\n            this._element.style.height = \"\";\n        }\n        _setStepsHeight() {\n            this._steps.forEach((t)=>{\n                const e = g.findOne(`${wt}`, t), s = window.getComputedStyle(e);\n                this._verticalStepperStyles.push({\n                    paddingTop: parseFloat(s.paddingTop),\n                    paddingBottom: parseFloat(s.paddingBottom)\n                });\n                const n = e.scrollHeight;\n                e.style.height = `${n}px`;\n            });\n        }\n        _setSingleStepHeight(t) {\n            const e = g.findOne(`${wt}`, t), s = this.activeStep === t, n = this._steps.indexOf(t);\n            let o;\n            s ? (e.style.height = \"\", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;\n        }\n        _toggleVertical() {\n            this._currentView = _e, this._setStepsHeight(), this._hideInactiveSteps();\n        }\n        _toggleHorizontal() {\n            this._currentView = Ws, this._setHeight(this.activeStep), this._hideInactiveSteps();\n        }\n        _toggleStepperClass() {\n            g.findOne(\"[data-te-stepper-type]\", this._element) !== null && this._steps.forEach((e)=>{\n                g.findOne(`${wt}`, e).classList.remove(\"!my-0\"), g.findOne(`${wt}`, e).classList.remove(\"!py-0\"), g.findOne(`${wt}`, e).classList.remove(\"!h-0\");\n            });\n        }\n        _toggleStepClass(t, e, s) {\n            s && this._steps[t].classList[e](s);\n        }\n        _bindKeysNavigation() {\n            this._toggleStepTabIndex(!1, g.findOne(`${yt}`, this.activeStep)), this._steps.forEach((t)=>{\n                const e = g.findOne(`${yt}`, t);\n                b.on(e, gd, (s)=>{\n                    const n = g.parents(s.currentTarget, `${ze}`)[0], o = g.next(n, `${ze}`)[0], r = g.prev(n, `${ze}`)[0], a = g.findOne(`${yt}`, n), l = g.findOne(`${yt}`, this.activeStep);\n                    let c = null, h = null;\n                    if (o && (c = g.findOne(`${yt}`, o)), r && (h = g.findOne(`${yt}`, r)), s.keyCode === Zi && this._currentView !== _e && (h ? (this._toggleStepTabIndex(a, h), this._toggleOutlineStyles(a, h), h.focus()) : c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), s.keyCode === Qi && this._currentView !== _e && (c ? (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus()) : h && (this._toggleStepTabIndex(a, h), this._toggleOutlineStyles(a, h), h.focus())), s.keyCode === ut && this._currentView === _e && (s.preventDefault(), c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), s.keyCode === Tt && this._currentView === _e && (s.preventDefault(), h && (this._toggleStepTabIndex(a, h), this._toggleOutlineStyles(a, h), h.focus())), s.keyCode === Ji) {\n                        const d = g.findOne(`${yt}`, this._steps[0]);\n                        this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus();\n                    }\n                    if (s.keyCode === ts) {\n                        const d = this._steps[this._steps.length - 1], u = g.findOne(`${yt}`, d);\n                        this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus();\n                    }\n                    (s.keyCode === Pt || s.keyCode === oo) && (s.preventDefault(), this.changeStep(this._steps.indexOf(n))), s.keyCode === Rs && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());\n                }), b.on(e, Iy, (s)=>{\n                    const n = g.parents(s.currentTarget, `${ze}`)[0], o = g.findOne(`${yt}`, n), r = g.findOne(`${yt}`, this.activeStep);\n                    s.keyCode === Rs && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());\n                });\n            });\n        }\n        _toggleStepTabIndex(t, e) {\n            t && t.setAttribute(\"tabIndex\", -1), e && e.setAttribute(\"tabIndex\", 0);\n        }\n        _toggleOutlineStyles(t, e) {\n            t && (t.style.outline = \"\"), e && (e.style.outline = \"revert\");\n        }\n        _toggleDisabled() {\n            const t = g.find(`${yt}`, this._element), e = g.find(`${Do}`, this._element);\n            t[this._activeStepIndex].classList.add(\"color-[#858585]\"), t[this._activeStepIndex].classList.add(\"cursor-default\"), e[this._activeStepIndex].classList.add(\"!bg-[#858585]\"), this._toggleStepClass(this._activeStepIndex, \"add\", this._options.stepperDisabled);\n        }\n        _toggleActive(t) {\n            const e = g.find(`${bd}`, this._element), s = g.find(`${Do}`, this._element);\n            e[t].classList.add(\"font-medium\"), s[t].classList.add(\"!bg-primary-100\"), s[t].classList.add(\"!text-primary-700\"), s[t].classList.remove(\"!bg-success-100\"), s[t].classList.remove(\"!text-success-700\"), e[this._activeStepIndex].classList.remove(\"font-medium\"), s[this._activeStepIndex].classList.remove(\"!bg-primary-100\"), s[this._activeStepIndex].classList.remove(\"!text-primary-700\"), this._toggleStepClass(t, \"add\", this._options.stepperActive), this._toggleStepClass(this._activeStepIndex, \"remove\", this._options.stepperActive);\n        }\n        _toggleCompleted(t) {\n            const e = g.find(`${Do}`, this._element);\n            e[t].classList.add(\"!bg-success-100\"), e[t].classList.add(\"!text-success-700\"), e[t].classList.remove(\"!bg-danger-100\"), e[t].classList.remove(\"!text-danger-700\"), this._toggleStepClass(t, \"add\", this._options.stepperCompleted), this._toggleStepClass(t, \"remove\", this._options.stepperInvalid);\n        }\n        _hideInactiveSteps() {\n            this._steps.forEach((t)=>{\n                t.getAttribute(\"data-te\") || this._hideElement(g.findOne(`${wt}`, t));\n            });\n        }\n        _setHeight(t) {\n            const e = g.findOne(`${wt}`, t), s = getComputedStyle(e), n = g.findOne(`${yt}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(s.marginTop) + parseFloat(s.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);\n            this._element.style.height = `${a + r}px`;\n        }\n        _hideElement(t) {\n            !g.parents(t, `${ze}`)[0].getAttribute(\"data-te\") && this._currentView !== _e || (t.classList.add(\"!my-0\"), t.classList.add(\"!py-0\"), t.classList.add(\"!h-0\"));\n        }\n        _showElement(t) {\n            this._currentView === _e ? (t.classList.remove(\"!my-0\"), t.classList.remove(\"!py-0\"), t.classList.remove(\"!h-0\")) : t.style.display = \"block\";\n        }\n        _animateHorizontalStep(t) {\n            const e = t > this._activeStepIndex, s = g.findOne(`${wt}`, this._steps[t]), n = g.findOne(`${wt}`, this.activeStep);\n            let o, r;\n            this._steps.forEach((h, d)=>{\n                const u = g.findOne(`${wt}`, h);\n                d !== t && d !== this._activeStepIndex && this._hideElement(u);\n            });\n            const a = \"translate-x-[150%]\", l = \"-translate-x-[150%]\", c = \"translate-0\";\n            e ? (r = l, o = c, s.classList.remove(\"translate-x-[150%]\"), s.classList.remove(\"-translate-x-[150%]\")) : (r = a, o = c, s.classList.remove(\"-translate-x-[150%]\"), s.classList.remove(\"translate-x-[150%]\")), n.classList.add(r), s.classList.add(o), this._setHeight(this._steps[t]);\n        }\n        _animateVerticalStep(t) {\n            const e = g.findOne(`${wt}`, this._steps[t]), s = g.findOne(`${wt}`, this.activeStep);\n            this._hideElement(s), this._showElement(e);\n        }\n        static getInstance(t) {\n            return P.getData(t, So);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const yd = \"data-te-input-state-active\", Mo = \"data-te-input-selected\", xd = \"data-te-input-multiple-active\", Ed = \"[data-te-form-check-input]\";\n    class Cd {\n        constructor(t, e, s, n, o, r, a, l, c, h, d){\n            this.id = t, this.nativeOption = e, this.multiple = s, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = c, this.groupId = h, this.icon = d, this.node = null, this.active = !1;\n        }\n        select() {\n            this.multiple ? this._selectMultiple() : this._selectSingle();\n        }\n        _selectSingle() {\n            this.selected || (this.node.setAttribute(Mo, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));\n        }\n        _selectMultiple() {\n            if (!this.selected) {\n                const t = g.findOne(Ed, this.node);\n                t.checked = !0, this.node.setAttribute(Mo, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);\n            }\n        }\n        deselect() {\n            this.multiple ? this._deselectMultiple() : this._deselectSingle();\n        }\n        _deselectSingle() {\n            this.selected && (this.node.removeAttribute(Mo), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));\n        }\n        _deselectMultiple() {\n            if (this.selected) {\n                const t = g.findOne(Ed, this.node);\n                t.checked = !1, this.node.removeAttribute(Mo), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);\n            }\n        }\n        setNode(t) {\n            this.node = t;\n        }\n        setActiveStyles() {\n            if (!this.active) {\n                if (this.multiple) {\n                    this.node.setAttribute(xd, \"\");\n                    return;\n                }\n                this.active = !0, this.node.setAttribute(yd, \"\");\n            }\n        }\n        removeActiveStyles() {\n            this.active && (this.active = !1, this.node.removeAttribute(yd)), this.multiple && this.node.removeAttribute(xd);\n        }\n    }\n    class Ly {\n        constructor(t = !1){\n            this._multiple = t, this._selections = [];\n        }\n        select(t) {\n            this._multiple ? this._selections.push(t) : this._selections = [\n                t\n            ];\n        }\n        deselect(t) {\n            if (this._multiple) {\n                const e = this._selections.findIndex((s)=>t === s);\n                this._selections.splice(e, 1);\n            } else this._selections = [];\n        }\n        clear() {\n            this._selections = [];\n        }\n        get selection() {\n            return this._selections[0];\n        }\n        get selections() {\n            return this._selections;\n        }\n        get label() {\n            return this._selections[0] && this.selection.label;\n        }\n        get labels() {\n            return this._selections.map((t)=>t.label).join(\", \");\n        }\n        get value() {\n            return this.selections[0] && this.selection.value;\n        }\n        get values() {\n            return this._selections.map((t)=>t.value);\n        }\n    }\n    function Sa(i) {\n        return i.filter((t)=>!t.disabled).every((t)=>t.selected);\n    }\n    const Py = \"data-te-select-form-outline-ref\", Ry = \"data-te-select-wrapper-ref\", Ny = \"data-te-select-input-ref\", $y = \"data-te-select-clear-btn-ref\", By = \"data-te-select-dropdown-container-ref\", Hy = \"data-te-select-dropdown-ref\", Fy = \"data-te-select-options-wrapper-ref\", Vy = \"data-te-select-options-list-ref\", Wy = \"data-te-select-input-filter-ref\", Td = \"data-te-select-option-ref\", zy = \"data-te-select-option-all-ref\", jy = \"data-te-select-option-text-ref\", Yy = \"data-te-form-check-input\", Ky = \"data-te-select-option-group-ref\", Uy = \"data-te-select-option-group-label-ref\", Ad = \"data-te-select-selected\", Xy = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n</svg>\n`, Gy = (i)=>{\n        i.code === \"Tab\" || i.code === \"Esc\" || i.preventDefault();\n    };\n    function Io(i, t, e, s, n) {\n        t.selectSize === \"default\" && v.addClass(i, e), t.selectSize === \"sm\" && v.addClass(i, s), t.selectSize === \"lg\" && v.addClass(i, n);\n    }\n    function qy(i, t, e, s) {\n        const n = document.createElement(\"div\");\n        n.setAttribute(\"id\", i), n.setAttribute(Ry, \"\");\n        const o = z(\"div\");\n        o.setAttribute(Py, \"\"), v.addClass(o, s.formOutline);\n        const r = z(\"input\"), a = t.selectFilter ? \"combobox\" : \"listbox\", l = t.multiple ? \"true\" : \"false\", c = t.disabled ? \"true\" : \"false\";\n        r.setAttribute(Ny, \"\"), v.addClass(r, s.selectInput), Io(r, t, s.selectInputSizeDefault, s.selectInputSizeSm, s.selectInputSizeLg), t.selectFormWhite && v.addClass(r, s.selectInputWhite), r.setAttribute(\"type\", \"text\"), r.setAttribute(\"role\", a), r.setAttribute(\"aria-multiselectable\", l), r.setAttribute(\"aria-disabled\", c), r.setAttribute(\"aria-haspopup\", \"true\"), r.setAttribute(\"aria-expanded\", !1), t.tabIndex && r.setAttribute(\"tabIndex\", t.tabIndex), t.disabled && r.setAttribute(\"disabled\", \"\"), t.selectPlaceholder !== \"\" && r.setAttribute(\"placeholder\", t.selectPlaceholder), t.selectValidation ? (v.addStyle(r, {\n            \"pointer-events\": \"none\",\n            \"caret-color\": \"transparent\"\n        }), v.addStyle(o, {\n            cursor: \"pointer\"\n        })) : r.setAttribute(\"readonly\", \"true\"), t.selectValidation && (r.setAttribute(\"required\", \"true\"), r.setAttribute(\"aria-required\", \"true\"), r.addEventListener(\"keydown\", Gy));\n        const h = z(\"div\");\n        v.addClass(h, s.selectValidationValid);\n        const d = document.createTextNode(`${t.selectValidFeedback}`);\n        h.appendChild(d);\n        const u = z(\"div\");\n        v.addClass(u, s.selectValidationInvalid);\n        const f = document.createTextNode(`${t.selectInvalidFeedback}`);\n        u.appendChild(f);\n        const p = z(\"span\");\n        p.setAttribute($y, \"\"), v.addClass(p, s.selectClearBtn), Io(p, t, s.selectClearBtnDefault, s.selectClearBtnSm, s.selectClearBtnLg), t.selectFormWhite && v.addClass(p, s.selectClearBtnWhite);\n        const _ = document.createTextNode(\"\");\n        p.appendChild(_), p.setAttribute(\"tabindex\", \"0\");\n        const m = z(\"span\");\n        return v.addClass(m, s.selectArrow), Io(m, t, s.selectArrowDefault, s.selectArrowSm, s.selectArrowLg), t.selectFormWhite && v.addClass(m, s.selectArrowWhite), m.innerHTML = Xy, o.appendChild(r), e && (v.addClass(e, s.selectLabel), Io(e, t, s.selectLabelSizeDefault, s.selectLabelSizeSm, s.selectLabelSizeLg), t.selectFormWhite && v.addClass(e, s.selectLabelWhite), o.appendChild(e)), t.selectValidation && (o.appendChild(h), o.appendChild(u)), t.selectClearButton && o.appendChild(p), o.appendChild(m), n.appendChild(o), n;\n    }\n    function wd(i, t, e, s, n, o, r, a) {\n        const l = document.createElement(\"div\");\n        l.setAttribute(By, \"\"), v.addClass(l, a.selectDropdownContainer), l.setAttribute(\"id\", `${i}`), l.style.width = `${e}px`;\n        const c = document.createElement(\"div\");\n        c.setAttribute(\"tabindex\", 0), c.setAttribute(Hy, \"\"), v.addClass(c, a.dropdown);\n        const h = z(\"div\");\n        h.setAttribute(Fy, \"\"), v.addClass(h, a.optionsWrapper), v.addClass(h, a.optionsWrapperScrollbar), h.style.maxHeight = `${s}px`;\n        const d = kd(o, n, t, a);\n        return h.appendChild(d), t.selectFilter && c.appendChild(Zy(t.selectSearchPlaceholder, a)), c.appendChild(h), r && c.appendChild(r), l.appendChild(c), l;\n    }\n    function kd(i, t, e, s) {\n        const n = z(\"div\");\n        n.setAttribute(Vy, \"\"), v.addClass(n, s.optionsList);\n        let o;\n        return e.multiple ? o = Jy(i, t, e, s) : o = Qy(i, e, s), o.forEach((r)=>{\n            n.appendChild(r);\n        }), n;\n    }\n    function Zy(i, t) {\n        const e = z(\"div\");\n        v.addClass(e, t.inputGroup);\n        const s = z(\"input\");\n        return s.setAttribute(Wy, \"\"), v.addClass(s, t.selectFilterInput), s.placeholder = i, s.setAttribute(\"role\", \"searchbox\"), s.setAttribute(\"type\", \"text\"), e.appendChild(s), e;\n    }\n    function Qy(i, t, e) {\n        return Sd(i, t, e);\n    }\n    function Jy(i, t, e, s) {\n        let n = null;\n        e.selectAll && (n = tx(t, i, e, s));\n        const o = Sd(i, e, s);\n        return n ? [\n            n,\n            ...o\n        ] : o;\n    }\n    function Sd(i, t, e) {\n        const s = [];\n        return i.forEach((n)=>{\n            if (Object.prototype.hasOwnProperty.call(n, \"options\")) {\n                const r = nx(n, t, e);\n                s.push(r);\n            } else s.push(Od(n, t, e));\n        }), s;\n    }\n    function tx(i, t, e, s) {\n        const n = Sa(t), o = z(\"div\");\n        return o.setAttribute(Td, \"\"), v.addClass(o, s.selectOption), o.setAttribute(zy, \"\"), v.addStyle(o, {\n            height: `${e.selectOptionHeight}px`\n        }), o.setAttribute(\"role\", \"option\"), o.setAttribute(\"aria-selected\", n), n && o.setAttribute(Ad, \"\"), o.appendChild(Dd(i, e, s)), i.setNode(o), o;\n    }\n    function Od(i, t, e) {\n        if (i.node) return i.node;\n        const s = z(\"div\");\n        return s.setAttribute(Td, \"\"), v.addClass(s, e.selectOption), v.addStyle(s, {\n            height: `${t.selectOptionHeight}px`\n        }), v.setDataAttribute(s, \"id\", i.id), s.setAttribute(\"role\", \"option\"), s.setAttribute(\"aria-selected\", i.selected), s.setAttribute(\"aria-disabled\", i.disabled), i.selected && s.setAttribute(Ad, \"\"), i.disabled && s.setAttribute(\"data-te-select-option-disabled\", !0), i.hidden && v.addClass(s, \"hidden\"), s.appendChild(Dd(i, t, e)), i.icon && s.appendChild(sx(i, e)), i.setNode(s), s;\n    }\n    function Dd(i, t, e) {\n        const s = z(\"span\");\n        s.setAttribute(jy, \"\"), v.addClass(s, e.selectOptionText);\n        const n = document.createTextNode(i.label);\n        return t.multiple && s.appendChild(ix(i, e)), s.appendChild(n), (i.secondaryText || typeof i.secondaryText == \"number\") && s.appendChild(ex(i.secondaryText, e)), s;\n    }\n    function ex(i, t) {\n        const e = z(\"span\");\n        v.addClass(e, t.selectOptionSecondaryText);\n        const s = document.createTextNode(i);\n        return e.appendChild(s), e;\n    }\n    function ix(i, t) {\n        const e = z(\"input\");\n        e.setAttribute(\"type\", \"checkbox\"), v.addClass(e, t.formCheckInput), e.setAttribute(Yy, \"\");\n        const s = z(\"label\");\n        return i.selected && e.setAttribute(\"checked\", !0), i.disabled && e.setAttribute(\"disabled\", !0), e.appendChild(s), e;\n    }\n    function sx(i, t) {\n        const e = z(\"span\"), s = z(\"img\");\n        return v.addClass(s, t.selectOptionIcon), s.src = i.icon, e.appendChild(s), e;\n    }\n    function nx(i, t, e) {\n        const s = z(\"div\");\n        s.setAttribute(Ky, \"\"), v.addClass(s, e.selectOptionGroup), s.setAttribute(\"role\", \"group\"), s.setAttribute(\"id\", i.id), i.hidden && v.addClass(s, \"hidden\");\n        const n = z(\"label\");\n        return n.setAttribute(Uy, \"\"), v.addClass(n, e.selectOptionGroupLabel), v.addStyle(n, {\n            height: `${t.selectOptionHeight}px`\n        }), n.setAttribute(\"for\", i.id), n.textContent = i.label, s.appendChild(n), i.options.forEach((o)=>{\n            s.appendChild(Od(o, t, e));\n        }), s;\n    }\n    function ox(i, t) {\n        const e = z(\"div\");\n        return e.innerHTML = i, v.addClass(e, t.selectLabel), v.addClass(e, t.selectFakeValue), e;\n    }\n    const Oa = \"select\", zs = \"te.select\", js = `.${zs}`, rx = `close${js}`, ax = `open${js}`, Md = `optionSelect${js}`, Id = `optionDeselect${js}`, lx = `valueChange${js}`, cx = \"change\", Ld = \"data-te-select-init\", Pd = \"data-te-select-no-results-ref\", Rd = \"data-te-select-open\", xt = \"data-te-input-state-active\", je = \"data-te-input-focused\", Da = \"data-te-input-disabled\", hx = \"data-te-select-option-group-label-ref\", dx = \"data-te-select-option-all-ref\", Ys = \"data-te-select-selected\", ux = \"[data-te-select-label-ref]\", Nd = \"[data-te-select-input-ref]\", fx = \"[data-te-select-input-filter-ref]\", px = \"[data-te-select-dropdown-ref]\", _x = \"[data-te-select-options-wrapper-ref]\", $d = \"[data-te-select-options-list-ref]\", gx = \"[data-te-select-option-ref]\", mx = \"[data-te-select-clear-btn-ref]\", bx = \"[data-te-select-custom-content-ref]\", vx = `[${Pd}]`, Bd = \"[data-te-select-form-outline-ref]\", yx = \"[data-te-select-toggle]\", Ma = \"[data-te-input-notch-ref]\", xx = 200, Ex = {\n        selectAutoSelect: !1,\n        selectContainer: \"body\",\n        selectClearButton: !1,\n        disabled: !1,\n        selectDisplayedLabels: 5,\n        selectFormWhite: !1,\n        multiple: !1,\n        selectOptionsSelectedLabel: \"options selected\",\n        selectOptionHeight: 38,\n        selectAll: !0,\n        selectAllLabel: \"Select all\",\n        selectSearchPlaceholder: \"Search...\",\n        selectSize: \"default\",\n        selectVisibleOptions: 5,\n        selectFilter: !1,\n        selectFilterDebounce: 300,\n        selectNoResultText: \"No results\",\n        selectValidation: !1,\n        selectValidFeedback: \"Valid\",\n        selectInvalidFeedback: \"Invalid\",\n        selectPlaceholder: \"\"\n    }, Cx = {\n        selectAutoSelect: \"boolean\",\n        selectContainer: \"string\",\n        selectClearButton: \"boolean\",\n        disabled: \"boolean\",\n        selectDisplayedLabels: \"number\",\n        selectFormWhite: \"boolean\",\n        multiple: \"boolean\",\n        selectOptionsSelectedLabel: \"string\",\n        selectOptionHeight: \"number\",\n        selectAll: \"boolean\",\n        selectAllLabel: \"string\",\n        selectSearchPlaceholder: \"string\",\n        selectSize: \"string\",\n        selectVisibleOptions: \"number\",\n        selectFilter: \"boolean\",\n        selectFilterDebounce: \"number\",\n        selectNoResultText: \"string\",\n        selectValidation: \"boolean\",\n        selectValidFeedback: \"string\",\n        selectInvalidFeedback: \"string\",\n        selectPlaceholder: \"string\"\n    }, Tx = {\n        dropdown: \"relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700\",\n        formCheckInput: \"relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent\",\n        formOutline: \"relative\",\n        initialized: \"hidden\",\n        inputGroup: \"flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200\",\n        noResult: \"flex items-center px-4\",\n        optionsList: \"list-none m-0 p-0\",\n        optionsWrapper: \"overflow-y-auto\",\n        optionsWrapperScrollbar: \"[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded\",\n        selectArrow: \"absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5\",\n        selectArrowWhite: \"text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white\",\n        selectArrowDefault: \"top-2\",\n        selectArrowLg: \"top-[13px]\",\n        selectArrowSm: \"top-1\",\n        selectClearBtn: \"absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200\",\n        selectClearBtnWhite: \"!text-gray-50\",\n        selectClearBtnDefault: \"top-2 text-base\",\n        selectClearBtnLg: \"top-[11px] text-base\",\n        selectClearBtnSm: \"top-1 text-[0.8rem]\",\n        selectDropdownContainer: \"z-[1070]\",\n        selectFakeValue: \"transform-none hidden data-[te-input-state-active]:block\",\n        selectFilterInput: \"relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200\",\n        selectInput: \"peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600\",\n        selectInputWhite: \"!text-gray-50\",\n        selectInputSizeDefault: \"py-[0.32rem] px-3 leading-[1.6]\",\n        selectInputSizeLg: \"py-[0.32rem] px-3 leading-[2.15]\",\n        selectInputSizeSm: \"py-[0.33rem] px-3 text-xs leading-[1.5]\",\n        selectLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary\",\n        selectLabelWhite: \"!text-gray-50\",\n        selectLabelSizeDefault: \"pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]\",\n        selectLabelSizeLg: \"pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]\",\n        selectLabelSizeSm: \"pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]\",\n        selectOption: \"flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30\",\n        selectOptionGroup: \"group/opt\",\n        selectOptionGroupLabel: \"flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300\",\n        selectOptionIcon: \"w-7 h-7 rounded-full\",\n        selectOptionSecondaryText: \"block text-[0.8rem] text-gray-500 dark:text-gray-300\",\n        selectOptionText: \"group\",\n        selectValidationValid: \"hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block\",\n        selectValidationInvalid: \"hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block\"\n    }, Ax = {\n        dropdown: \"string\",\n        formCheckInput: \"string\",\n        formOutline: \"string\",\n        initialized: \"string\",\n        inputGroup: \"string\",\n        noResult: \"string\",\n        optionsList: \"string\",\n        optionsWrapper: \"string\",\n        optionsWrapperScrollbar: \"string\",\n        selectArrow: \"string\",\n        selectArrowDefault: \"string\",\n        selectArrowLg: \"string\",\n        selectArrowSm: \"string\",\n        selectClearBtn: \"string\",\n        selectClearBtnDefault: \"string\",\n        selectClearBtnLg: \"string\",\n        selectClearBtnSm: \"string\",\n        selectDropdownContainer: \"string\",\n        selectFakeValue: \"string\",\n        selectFilterInput: \"string\",\n        selectInput: \"string\",\n        selectInputSizeDefault: \"string\",\n        selectInputSizeLg: \"string\",\n        selectInputSizeSm: \"string\",\n        selectLabel: \"string\",\n        selectLabelSizeDefault: \"string\",\n        selectLabelSizeLg: \"string\",\n        selectLabelSizeSm: \"string\",\n        selectOption: \"string\",\n        selectOptionGroup: \"string\",\n        selectOptionGroupLabel: \"string\",\n        selectOptionIcon: \"string\",\n        selectOptionSecondaryText: \"string\",\n        selectOptionText: \"string\"\n    };\n    class Lo {\n        constructor(t, e, s){\n            this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Ly(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = se(\"select-wrapper-\"), this._dropdownContainerId = se(\"select-dropdown-container-\"), this._selectAllId = se(\"select-all-\"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = g.next(this._element, ux)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = g.next(t, bx)[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && P.setData(t, zs, this);\n        }\n        static get NAME() {\n            return Oa;\n        }\n        get filterInput() {\n            return g.findOne(fx, this._dropdownContainer);\n        }\n        get dropdown() {\n            return g.findOne(px, this._dropdownContainer);\n        }\n        get optionsList() {\n            return g.findOne($d, this._dropdownContainer);\n        }\n        get optionsWrapper() {\n            return g.findOne(_x, this._dropdownContainer);\n        }\n        get clearButton() {\n            return g.findOne(mx, this._wrapper);\n        }\n        get options() {\n            return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;\n        }\n        get value() {\n            return this.multiple ? this._selectionModel.values : this._selectionModel.value;\n        }\n        get multiple() {\n            return this._config.multiple;\n        }\n        get hasSelectAll() {\n            return this.multiple && this._config.selectAll;\n        }\n        get hasSelection() {\n            return this._selectionModel.selection || this._selectionModel.selections.length > 0;\n        }\n        _getConfig(t) {\n            const e = v.getDataAttributes(this._element);\n            return t = {\n                ...Ex,\n                ...e,\n                ...t\n            }, this._element.hasAttribute(\"multiple\") && (t.multiple = !0), this._element.hasAttribute(\"disabled\") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute(\"tabIndex\")), W(Oa, t, Cx), t;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Tx,\n                ...e,\n                ...t\n            }, W(Oa, t, Ax), t;\n        }\n        _getOptionsToRender(t) {\n            const e = [];\n            return t.childNodes.forEach((n)=>{\n                if (n.nodeName === \"OPTGROUP\") {\n                    const o = {\n                        id: se(\"group-\"),\n                        label: n.label,\n                        disabled: n.hasAttribute(\"disabled\"),\n                        hidden: n.hasAttribute(\"hidden\"),\n                        options: []\n                    };\n                    n.childNodes.forEach((a)=>{\n                        a.nodeName === \"OPTION\" && o.options.push(this._createOptionObject(a, o));\n                    }), e.push(o);\n                } else n.nodeName === \"OPTION\" && e.push(this._createOptionObject(n));\n            }), e;\n        }\n        _getPlainOptions(t) {\n            if (!g.findOne(\"optgroup\", this._element)) return t;\n            const s = [];\n            return t.forEach((n)=>{\n                Object.prototype.hasOwnProperty.call(n, \"options\") ? n.options.forEach((r)=>{\n                    s.push(r);\n                }) : s.push(n);\n            }), s;\n        }\n        _createOptionObject(t, e = {}) {\n            const s = se(\"option-\"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(Ys), a = t.hasAttribute(\"disabled\") || o, l = t.hasAttribute(\"hidden\") || e && e.hidden, c = this.multiple, h = t.value, d = t.label, u = v.getDataAttribute(t, \"selectSecondaryText\"), f = v.getDataAttribute(t, \"select-icon\");\n            return new Cd(s, t, c, h, d, r, a, l, u, n, f);\n        }\n        _getNavigationOptions() {\n            const t = this.options.filter((e)=>!e.hidden);\n            return this.hasSelectAll ? [\n                this._selectAllOption,\n                ...t\n            ] : t;\n        }\n        _init() {\n            this._renderMaterialWrapper(), this._wrapper = g.findOne(`#${this._wrapperId}`), this._input = g.findOne(Nd, this._wrapper), this._config.disabled && this._input.setAttribute(Da, \"\");\n            const t = this._config.selectContainer;\n            t === \"body\" ? this._container = document.body : this._container = g.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = wd(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes), this._setFirstActiveOption(), this._listenToFocusChange();\n        }\n        _renderMaterialWrapper() {\n            const t = qy(this._wrapperId, this._config, this._label, this._classes);\n            this._element.parentNode.insertBefore(t, this._element), v.addClass(this._element, this._classes.initialized), t.appendChild(this._element);\n        }\n        _initOutlineInput() {\n            const t = g.findOne(Bd, this._wrapper);\n            new Z(t, {\n                inputFormWhite: this._config.selectFormWhite\n            }).init(), this._notch = g.findOne(Ma, this._wrapper);\n        }\n        _bindComponentEvents() {\n            this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();\n        }\n        _setDefaultSelections() {\n            this.options.forEach((t)=>{\n                t.selected && this._selectionModel.select(t);\n            });\n        }\n        _listenToComponentKeydown() {\n            b.on(this._wrapper, \"keydown\", this._handleKeydown.bind(this));\n        }\n        _handleKeydown(t) {\n            this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);\n        }\n        _handleOpenKeydown(t) {\n            const e = t.keyCode, s = e === ro || e === Tt && t.altKey || e === Rs;\n            if (e === Rs && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), s) {\n                this.close(), this._input.focus();\n                return;\n            }\n            switch(e){\n                case ut:\n                    this._setNextOptionActive(), this._scrollToOption(this._activeOption);\n                    break;\n                case Tt:\n                    this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);\n                    break;\n                case Ji:\n                    this._setFirstOptionActive(), this._scrollToOption(this._activeOption);\n                    break;\n                case ts:\n                    this._setLastOptionActive(), this._scrollToOption(this._activeOption);\n                    break;\n                case Pt:\n                    t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));\n                    return;\n                default:\n                    return;\n            }\n            t.preventDefault();\n        }\n        _handleClosedKeydown(t) {\n            const e = t.keyCode;\n            if (e === Pt && t.preventDefault(), (e === Pt || e === ut && t.altKey || e === ut && this.multiple) && this.open(), this.multiple) switch(e){\n                case ut:\n                    this.open();\n                    break;\n                case Tt:\n                    this.open();\n                    break;\n                default:\n                    return;\n            }\n            else switch(e){\n                case ut:\n                    this._setNextOptionActive(), this._handleSelection(this._activeOption);\n                    break;\n                case Tt:\n                    this._setPreviousOptionActive(), this._handleSelection(this._activeOption);\n                    break;\n                case Ji:\n                    this._setFirstOptionActive(), this._handleSelection(this._activeOption);\n                    break;\n                case ts:\n                    this._setLastOptionActive(), this._handleSelection(this._activeOption);\n                    break;\n                default:\n                    return;\n            }\n            t.preventDefault();\n        }\n        _scrollToOption(t) {\n            if (!t) return;\n            let e;\n            const s = this.options.filter((h)=>!h.hidden);\n            this.hasSelectAll ? e = s.indexOf(t) + 1 : e = s.indexOf(t);\n            const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, c = r.scrollTop;\n            if (e > -1) {\n                const h = o * l, d = h + l > c + a;\n                h < c ? r.scrollTop = h : d ? r.scrollTop = h - a + l : r.scrollTop = c;\n            }\n        }\n        _getNumberOfGroupsBeforeOption(t) {\n            const e = this.options.filter((r)=>!r.hidden), s = this._optionsToRender.filter((r)=>!r.hidden), n = this.hasSelectAll ? t - 1 : t;\n            let o = 0;\n            for(let r = 0; r <= n; r++)e[r].groupId && s[o] && s[o].id && e[r].groupId === s[o].id && o++;\n            return o;\n        }\n        _setNextOptionActive() {\n            let t = this._activeOptionIndex + 1;\n            const e = this._getNavigationOptions();\n            if (e[t]) {\n                for(; e[t].disabled;)if (t += 1, !e[t]) return;\n                this._updateActiveOption(e[t], t);\n            }\n        }\n        _setPreviousOptionActive() {\n            let t = this._activeOptionIndex - 1;\n            const e = this._getNavigationOptions();\n            if (e[t]) {\n                for(; e[t].disabled;)if (t -= 1, !e[t]) return;\n                this._updateActiveOption(e[t], t);\n            }\n        }\n        _setFirstOptionActive() {\n            const e = this._getNavigationOptions();\n            this._updateActiveOption(e[0], 0);\n        }\n        _setLastOptionActive() {\n            const t = this._getNavigationOptions(), e = t.length - 1;\n            this._updateActiveOption(t[e], e);\n        }\n        _updateActiveOption(t, e) {\n            const s = this._activeOption;\n            s && s.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;\n        }\n        _listenToWrapperClick() {\n            b.on(this._wrapper, \"click\", ()=>{\n                this.toggle();\n            });\n        }\n        _listenToClearBtnClick() {\n            b.on(this.clearButton, \"click\", (t)=>{\n                t.preventDefault(), t.stopPropagation(), this._handleClear();\n            });\n        }\n        _listenToClearBtnKeydown() {\n            b.on(this.clearButton, \"keydown\", (t)=>{\n                t.keyCode === Pt && (this._handleClear(), t.preventDefault(), t.stopPropagation());\n            });\n        }\n        _handleClear() {\n            if (this.multiple) this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();\n            else {\n                const t = this._selectionModel.selection;\n                this._selectionModel.clear(), t.deselect();\n            }\n            this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();\n        }\n        _listenToOptionsClick() {\n            b.on(this.optionsWrapper, \"click\", (t)=>{\n                if (t.target.hasAttribute(hx)) return;\n                const s = t.target.nodeName === \"DIV\" ? t.target : g.closest(t.target, gx);\n                if (s.hasAttribute(dx)) {\n                    this._handleSelectAll();\n                    return;\n                }\n                const o = s.dataset.teId, r = this.options.find((a)=>a.id === o);\n                r && !r.disabled && this._handleSelection(r);\n            });\n        }\n        _handleSelectAll() {\n            this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n        }\n        _selectAllOptions(t) {\n            t.forEach((e)=>{\n                !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());\n            });\n        }\n        _deselectAllOptions(t) {\n            t.forEach((e)=>{\n                e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());\n            });\n        }\n        _handleSelection(t) {\n            this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n        }\n        _handleAutoSelection(t) {\n            this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n        }\n        _handleSingleSelection(t) {\n            this._singleOptionSelect(t), this.close(), this._input.focus();\n        }\n        _singleOptionSelect(t) {\n            const e = this._selectionModel.selections[0];\n            e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(Ys, !1), b.trigger(this._element, Id, {\n                value: e.value\n            })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(Ys, !0), b.trigger(this._element, Md, {\n                value: t.value\n            }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());\n        }\n        _handleMultiSelection(t) {\n            t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(Ys, !1), b.trigger(this._element, Id, {\n                value: t.value\n            })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(Ys, !0), b.trigger(this._element, Md, {\n                value: t.value\n            })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n        }\n        _emitValueChangeEvent(t) {\n            b.trigger(this._element, lx, {\n                value: t\n            });\n        }\n        _emitNativeChangeEvent() {\n            b.trigger(this._element, cx);\n        }\n        _updateInputValue() {\n            const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;\n            let e;\n            this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = \"\" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = \" \" : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = \"\" : this._input.value = this._optionsToRender[0].label;\n        }\n        _isSelectionValid(t) {\n            return !(t && (t.disabled || t.value === \"\"));\n        }\n        _isLabelEmpty(t) {\n            return !!(t && t.label === \"\");\n        }\n        _appendFakeValue() {\n            if (!this._selectionModel.selection || this._selectionModel._multiple) return;\n            const t = this._selectionModel.selection.label;\n            this._fakeValue = ox(t, this._classes), g.findOne(Bd, this._wrapper).appendChild(this._fakeValue);\n        }\n        _updateLabelPosition() {\n            const t = this._element.hasAttribute(Ld), e = this._input.value !== \"\";\n            this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(xt, \"\"), this._notch.setAttribute(xt, \"\")) : (this._label.removeAttribute(xt), this._notch.removeAttribute(xt, \"\")));\n        }\n        _updateLabelPositionWhileClosing() {\n            this._label && (this._input.value !== \"\" || this._isFakeValueActive ? (this._label.setAttribute(xt, \"\"), this._notch.setAttribute(xt, \"\")) : (this._label.removeAttribute(xt), this._notch.removeAttribute(xt)));\n        }\n        _updateFakeLabelPosition() {\n            this._fakeValue && (this._input.value === \"\" && this._fakeValue.innerHTML !== \"\" ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(xt, \"\")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(xt)));\n        }\n        _updateClearButtonVisibility() {\n            if (!this.clearButton) return;\n            this._selectionModel.selection || this._selectionModel.selections.length > 0 ? v.addStyle(this.clearButton, {\n                display: \"block\"\n            }) : v.addStyle(this.clearButton, {\n                display: \"none\"\n            });\n        }\n        _updateSelectAllState() {\n            const t = this._selectAllOption.selected, e = Sa(this.options);\n            !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();\n        }\n        toggle() {\n            this._isOpen ? this.close() : this.open();\n        }\n        open() {\n            const t = this._config.disabled, e = b.trigger(this._element, ax);\n            this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(()=>{\n                this.filterInput.focus();\n            }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());\n        }\n        _openDropdown() {\n            this._popper = Fi(this._input, this._dropdownContainer, {\n                placement: \"bottom-start\",\n                modifiers: [\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: [\n                                0,\n                                1\n                            ]\n                        }\n                    }\n                ]\n            }), this._container.appendChild(this._dropdownContainer), setTimeout(()=>{\n                this.dropdown.setAttribute(Rd, \"\");\n            }, 0);\n        }\n        _updateDropdownWidth() {\n            const t = this._input.offsetWidth;\n            v.addStyle(this._dropdownContainer, {\n                width: `${t}px`\n            });\n        }\n        _setFirstActiveOption() {\n            const t = this._getNavigationOptions(), e = this._activeOption;\n            e && e.removeActiveStyles();\n            const s = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;\n            s ? (this._activeOption = s, s.setActiveStyles(), this._activeOptionIndex = t.findIndex((n)=>n === s)) : (this._activeOption = null, this._activeOptionIndex = -1);\n        }\n        _setInputActiveStyles() {\n            this._input.setAttribute(je, \"\"), g.findOne(Ma, this._wrapper).setAttribute(je, \"\");\n        }\n        _listenToWindowResize() {\n            b.on(window, \"resize\", this._handleWindowResize.bind(this));\n        }\n        _handleWindowResize() {\n            this._dropdownContainer && this._updateDropdownWidth();\n        }\n        _listenToSelectSearch() {\n            this.filterInput.addEventListener(\"input\", (t)=>{\n                const e = t.target.value, s = this._config.selectFilterDebounce;\n                this._debounceFilter(e, s);\n            });\n        }\n        _debounceFilter(t, e) {\n            this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(()=>{\n                this._filterOptions(t);\n            }, e);\n        }\n        _filterOptions(t) {\n            const e = [];\n            this._optionsToRender.forEach((o)=>{\n                const r = Object.prototype.hasOwnProperty.call(o, \"options\"), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};\n                r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);\n            });\n            const s = this._config.selectNoResultText !== \"\", n = e.length !== 0;\n            if (n) this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();\n            else if (!n && s) {\n                const o = this._getNoResultTemplate();\n                this.optionsWrapper.innerHTML = o;\n            }\n        }\n        _updateOptionsListTemplate(t) {\n            const e = g.findOne($d, this._dropdownContainer) || g.findOne(vx, this._dropdownContainer), s = kd(t, this._selectAllOption, this._config, this._classes);\n            this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(s);\n        }\n        _getNoResultTemplate() {\n            return `<div class=\"${this._classes.noResult}\" ${Pd} style=\"height: ${this._config.selectOptionHeight}px\">${this._config.selectNoResultText}</div>`;\n        }\n        _filter(t, e) {\n            const s = t.toLowerCase();\n            return e.filter((n)=>n.label.toLowerCase().includes(s));\n        }\n        _listenToDropdownKeydown() {\n            b.on(this.dropdown, \"keydown\", this._handleOpenKeydown.bind(this));\n        }\n        _listenToOutsideClick() {\n            this._outsideClick = this._handleOutSideClick.bind(this), b.on(document, \"click\", this._outsideClick);\n        }\n        _listenToFocusChange(t = !0) {\n            if (t === !1) {\n                b.remove(this._input, \"focus\", ()=>this._notch.setAttribute(je, \"\")), b.remove(this._input, \"blur\", ()=>this._notch.removeAttribute(je));\n                return;\n            }\n            b.on(this._input, \"focus\", ()=>this._notch.setAttribute(je, \"\")), b.on(this._input, \"blur\", ()=>this._notch.removeAttribute(je));\n        }\n        _handleOutSideClick(t) {\n            const e = this._wrapper && this._wrapper.contains(t.target), s = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);\n            let o;\n            this._toggleButton || (this._elementToggle = g.find(yx)), this._elementToggle && this._elementToggle.forEach((r)=>{\n                const a = v.getDataAttribute(r, \"select-toggle\");\n                (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));\n            }), !e && !s && !n && !o && this.close();\n        }\n        close() {\n            const t = b.trigger(this._element, rx);\n            !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(Rd), setTimeout(()=>{\n                this._input.removeAttribute(je), this._input.blur(), g.findOne(Ma, this._wrapper).removeAttribute(je), this._label && !this.hasSelection && (this._label.removeAttribute(xt), this._notch.setAttribute(xt, \"\"), this._input.removeAttribute(xt), this._notch.removeAttribute(xt)), this._updateLabelPositionWhileClosing();\n            }, 0), setTimeout(()=>{\n                this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, b.off(this.dropdown, \"transitionend\");\n            }, xx));\n        }\n        _resetFilterState() {\n            this.filterInput.value = \"\", this._filteredOptionsList = null;\n        }\n        _removeDropdownEvents() {\n            b.off(document, \"click\", this._outsideClick), this._config.selectFilter && b.off(this.dropdown, \"keydown\"), b.off(this.optionsWrapper, \"click\");\n        }\n        _addMutationObserver() {\n            this._mutationObserver = new MutationObserver(()=>{\n                this._wrapper && (this._updateSelections(), this._updateDisabledState());\n            }), this._observeMutationObserver();\n        }\n        _updateSelections() {\n            this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();\n            const t = this._config.filter && this.filterInput && this.filterInput.value;\n            this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = wd(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes);\n        }\n        _updateDisabledState() {\n            const t = g.findOne(Nd, this._wrapper);\n            this._element.hasAttribute(\"disabled\") ? (this._config.disabled = !0, t.setAttribute(\"disabled\", \"\"), t.setAttribute(Da, \"\")) : (this._config.disabled = !1, t.removeAttribute(\"disabled\"), t.removeAttribute(Da));\n        }\n        _observeMutationObserver() {\n            this._mutationObserver && this._mutationObserver.observe(this._element, {\n                attributes: !0,\n                childList: !0,\n                characterData: !0,\n                subtree: !0\n            });\n        }\n        _disconnectMutationObserver() {\n            this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);\n        }\n        _createSelectAllOption() {\n            const t = this._selectAllId, e = null, s = !0, n = \"select-all\", o = this._config.selectAllLabel, r = Sa(this.options), a = !1, l = !1, c = null, h = null, d = null;\n            return new Cd(t, e, s, n, o, r, a, l, c, h, d);\n        }\n        dispose() {\n            this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), P.removeData(this._element, zs);\n        }\n        _removeComponentEvents() {\n            b.off(this.input, \"click\"), b.off(this.wrapper, this._handleKeydown.bind(this)), b.off(this.clearButton, \"click\"), b.off(this.clearButton, \"keydown\"), b.off(window, \"resize\", this._handleWindowResize.bind(this));\n        }\n        _destroyMaterialSelect() {\n            this._isOpen && this.close(), this._destroyMaterialTemplate();\n        }\n        _destroyMaterialTemplate() {\n            const t = this._wrapper.parentNode, e = g.find(\"label\", this._wrapper);\n            t.appendChild(this._element), e.forEach((s)=>{\n                t.appendChild(s);\n            }), e.forEach((s)=>{\n                s.removeAttribute(xt);\n            }), v.removeClass(this._element, this._classes.initialized), this._element.removeActiveStyles(Ld), t.removeChild(this._wrapper);\n        }\n        setValue(t) {\n            this.options.filter((s)=>s.selected).forEach((s)=>s.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((s)=>{\n                this._selectByValue(s);\n            }) : this._selectByValue(t), this._updateSelections();\n        }\n        _selectByValue(t) {\n            const e = this.options.find((s)=>s.value === t);\n            return e ? (e.nativeOption.selected = !0, !0) : !1;\n        }\n        static jQueryInterface(t, e) {\n            return this.each(function() {\n                let s = P.getData(this, zs);\n                const n = typeof t == \"object\" && t;\n                if (!(!s && /dispose/.test(t)) && (s || (s = new Lo(this, n)), typeof t == \"string\")) {\n                    if (typeof s[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                    s[t](e);\n                }\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, zs);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const wx = (i)=>{\n        Nl(()=>{\n            const t = Rl();\n            if (t) {\n                const e = i.NAME, s = t.fn[e];\n                t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = ()=>(t.fn[e] = s, i.jQueryInterface);\n            }\n        });\n    }, kx = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}`, t, function(e) {\n            e.preventDefault(), i.getOrCreateInstance(this).toggle();\n        });\n    }, Sx = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}.data-api`, t, function(e) {\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName) && e.preventDefault(), ei(this)) return;\n            i.getOrCreateInstance(this).show();\n        });\n    }, Ox = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}.data-api`, t, function(e) {\n            const s = Ie(this);\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName) && e.preventDefault(), ei(this)) return;\n            b.one(s, i.EVENT_HIDDEN, ()=>{\n                ne(this) && this.focus();\n            });\n            const n = g.findOne(i.OPEN_SELECTOR);\n            n && n !== s && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\n        });\n    }, Dx = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}`, t, (e)=>{\n            e.preventDefault();\n            const s = e.target.closest(t);\n            i.getOrCreateInstance(s).toggle();\n        });\n    }, Mx = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}`, t, function(e) {\n            const s = Ie(this);\n            [\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName) && e.preventDefault(), b.one(s, i.EVENT_SHOW, (r)=>{\n                r.defaultPrevented || b.one(s, i.EVENT_HIDDEN, ()=>{\n                    ne(this) && this.focus();\n                });\n            });\n            const n = g.findOne(`[${i.OPEN_SELECTOR}=\"true\"]`);\n            n && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\n        });\n    }, Ix = (i, t)=>{\n        b.one(document, \"mousedown\", t, i.autoInitial(new i));\n    }, Lx = (i, t)=>{\n        b.on(document, `click.te.${i.NAME}.data-api`, t, function(e) {\n            (e.target.tagName === \"A\" || e.delegateTarget && e.delegateTarget.tagName === \"A\") && e.preventDefault();\n            const s = yr(this);\n            g.find(s).forEach((o)=>{\n                i.getOrCreateInstance(o, {\n                    toggle: !1\n                }).toggle();\n            });\n        });\n    }, Ye = {\n        plugins: {\n            legend: {\n                labels: {\n                    color: \"rgb(102,102,102)\"\n                }\n            }\n        }\n    }, Po = {\n        line: {\n            options: {\n                ...Ye,\n                elements: {\n                    line: {\n                        backgroundColor: \"rgba(59, 112, 202, 0.0)\",\n                        borderColor: \"rgb(59, 112, 202)\",\n                        borderWidth: 2,\n                        tension: 0\n                    },\n                    point: {\n                        borderColor: \"rgb(59, 112, 202)\",\n                        backgroundColor: \"rgb(59, 112, 202)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                },\n                tooltips: {\n                    intersect: !1,\n                    mode: \"index\"\n                },\n                datasets: {\n                    borderColor: \"red\"\n                },\n                scales: {\n                    x: {\n                        stacked: !0,\n                        grid: {\n                            display: !1\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    },\n                    y: {\n                        stacked: !1,\n                        grid: {\n                            borderDash: [\n                                2\n                            ],\n                            drawBorder: !1,\n                            zeroLineColor: \"rgba(0,0,0,0)\",\n                            zeroLineBorderDash: [\n                                2\n                            ],\n                            zeroLineBorderDashOffset: [\n                                2\n                            ]\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    }\n                }\n            }\n        },\n        bar: {\n            options: {\n                ...Ye,\n                backgroundColor: \"rgb(59, 112, 202)\",\n                borderWidth: 0,\n                responsive: !0,\n                legend: {\n                    display: !0\n                },\n                tooltips: {\n                    intersect: !1,\n                    mode: \"index\"\n                },\n                scales: {\n                    x: {\n                        stacked: !0,\n                        grid: {\n                            display: !1\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    },\n                    y: {\n                        stacked: !0,\n                        grid: {\n                            borderDash: [\n                                2\n                            ],\n                            drawBorder: !1,\n                            zeroLineColor: \"rgba(0,0,0,0)\",\n                            zeroLineBorderDash: [\n                                2\n                            ],\n                            zeroLineBorderDashOffset: [\n                                2\n                            ]\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    }\n                }\n            }\n        },\n        pie: {\n            options: {\n                ...Ye,\n                elements: {\n                    arc: {\n                        backgroundColor: \"rgb(59, 112, 202)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                }\n            }\n        },\n        doughnut: {\n            options: {\n                ...Ye,\n                elements: {\n                    arc: {\n                        backgroundColor: \"rgb(59, 112, 202)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                }\n            }\n        },\n        polarArea: {\n            options: {\n                ...Ye,\n                elements: {\n                    arc: {\n                        backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                }\n            }\n        },\n        radar: {\n            options: {\n                ...Ye,\n                elements: {\n                    line: {\n                        backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n                        borderColor: \"rgb(59, 112, 202)\",\n                        borderWidth: 2\n                    },\n                    point: {\n                        borderColor: \"rgb(59, 112, 202)\",\n                        backgroundColor: \"rgb(59, 112, 202)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                }\n            }\n        },\n        scatter: {\n            options: {\n                ...Ye,\n                elements: {\n                    line: {\n                        backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n                        borderColor: \"rgb(59, 112, 202)\",\n                        borderWidth: 2,\n                        tension: 0\n                    },\n                    point: {\n                        borderColor: \"rgb(59, 112, 202)\",\n                        backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                },\n                tooltips: {\n                    intersect: !1,\n                    mode: \"index\"\n                },\n                datasets: {\n                    borderColor: \"red\"\n                },\n                scales: {\n                    x: {\n                        stacked: !0,\n                        grid: {\n                            display: !1\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    },\n                    y: {\n                        stacked: !1,\n                        grid: {\n                            borderDash: [\n                                2\n                            ],\n                            drawBorder: !1,\n                            zeroLineColor: \"rgba(0,0,0,0)\",\n                            zeroLineBorderDash: [\n                                2\n                            ],\n                            zeroLineBorderDashOffset: [\n                                2\n                            ]\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    }\n                }\n            }\n        },\n        bubble: {\n            options: {\n                ...Ye,\n                elements: {\n                    point: {\n                        borderColor: \"rgb(59, 112, 202)\",\n                        backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n                    }\n                },\n                responsive: !0,\n                legend: {\n                    display: !0\n                },\n                scales: {\n                    x: {\n                        grid: {\n                            display: !1\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    },\n                    y: {\n                        grid: {\n                            borderDash: [\n                                2\n                            ],\n                            drawBorder: !1,\n                            zeroLineColor: \"rgba(0,0,0,0)\",\n                            zeroLineBorderDash: [\n                                2\n                            ],\n                            zeroLineBorderDashOffset: [\n                                2\n                            ]\n                        },\n                        ticks: {\n                            fontColor: \"rgba(0,0,0, 0.5)\"\n                        }\n                    }\n                }\n            }\n        }\n    }, Ks = {\n        alert: {\n            name: \"Alert\",\n            selector: \"[data-te-alert-init]\",\n            isToggler: !1\n        },\n        animation: {\n            name: \"Animate\",\n            selector: \"[data-te-animation-init]\",\n            isToggler: !1\n        },\n        carousel: {\n            name: \"Carousel\",\n            selector: \"[data-te-carousel-init]\",\n            isToggler: !1\n        },\n        chips: {\n            name: \"ChipsInput\",\n            selector: \"[data-te-chips-init]\",\n            isToggler: !1\n        },\n        chip: {\n            name: \"Chip\",\n            selector: \"[data-te-chip-init]\",\n            isToggler: !1\n        },\n        datepicker: {\n            name: \"Datepicker\",\n            selector: \"[data-te-datepicker-init]\",\n            isToggler: !1\n        },\n        input: {\n            name: \"Input\",\n            selector: \"[data-te-input-wrapper-init]\",\n            isToggler: !1\n        },\n        scrollspy: {\n            name: \"ScrollSpy\",\n            selector: \"[data-te-spy='scroll']\",\n            isToggler: !1\n        },\n        select: {\n            name: \"Select\",\n            selector: \"[data-te-select-init]\",\n            isToggler: !1\n        },\n        sidenav: {\n            name: \"Sidenav\",\n            selector: \"[data-te-sidenav-init]\",\n            isToggler: !1\n        },\n        stepper: {\n            name: \"Stepper\",\n            selector: \"[data-te-stepper-init]\",\n            isToggler: !1\n        },\n        timepicker: {\n            name: \"Timepicker\",\n            selector: \"[data-te-timepicker-init]\",\n            isToggler: !1\n        },\n        toast: {\n            name: \"Toast\",\n            selector: \"[data-te-toast-init]\",\n            isToggler: !1\n        },\n        chart: {\n            name: \"Chart\",\n            selector: \"[data-te-chart]\",\n            isToggler: !1,\n            advanced: (i, t)=>{\n                const e = (o)=>o[0] === \"{\" && o[o.length - 1] === \"}\" || o[0] === \"[\" && o[o.length - 1] === \"]\", s = (o)=>typeof o != \"string\" ? o : e(o) ? JSON.parse(o.replace(/'/g, '\"')) : o, n = (o)=>{\n                    const r = {};\n                    return Object.keys(o).forEach((a)=>{\n                        if (a.match(/dataset.*/)) {\n                            const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));\n                            r[l] = s(o[a]);\n                        }\n                    }), r;\n                };\n                g.find(t).forEach((o)=>{\n                    if (v.getDataAttribute(o, \"chart\") !== \"bubble\" && v.getDataAttribute(o, \"chart\") !== \"scatter\") {\n                        const r = v.getDataAttributes(o), a = {\n                            data: {\n                                datasets: [\n                                    n(r)\n                                ]\n                            }\n                        };\n                        return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '\"'))), new i(o, {\n                            ...a,\n                            ...Po[a.type]\n                        });\n                    }\n                    return null;\n                });\n            }\n        },\n        button: {\n            name: \"Button\",\n            selector: \"[data-te-toggle='button']\",\n            isToggler: !0,\n            callback: Dx\n        },\n        collapse: {\n            name: \"Collapse\",\n            selector: \"[data-te-collapse-init]\",\n            isToggler: !0,\n            callback: Lx\n        },\n        dropdown: {\n            name: \"Dropdown\",\n            selector: \"[data-te-dropdown-toggle-ref]\",\n            isToggler: !0,\n            callback: kx\n        },\n        modal: {\n            name: \"Modal\",\n            selector: \"[data-te-toggle='modal']\",\n            isToggler: !0,\n            callback: Mx\n        },\n        ripple: {\n            name: \"Ripple\",\n            selector: \"[data-te-ripple-init]\",\n            isToggler: !0,\n            callback: Ix\n        },\n        offcanvas: {\n            name: \"Offcanvas\",\n            selector: \"[data-te-offcanvas-toggle]\",\n            isToggler: !0,\n            callback: Ox\n        },\n        tab: {\n            name: \"Tab\",\n            selector: \"[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']\",\n            isToggler: !0,\n            callback: Sx\n        }\n    }, Px = (i)=>Ks[i.NAME] || null, Rx = (i)=>{\n        if (!i || [].includes(i.NAME)) return;\n        [].push(i.NAME);\n        const t = Px(i), e = (t == null ? void 0 : t.isToggler) || !1;\n        if (wx(i), t != null && t.advanced) {\n            t == null || t.advanced(i, t == null ? void 0 : t.selector);\n            return;\n        }\n        if (e) {\n            t == null || t.callback(i, t == null ? void 0 : t.selector);\n            return;\n        }\n        g.find(t == null ? void 0 : t.selector).forEach((s)=>{\n            let n = i.getInstance(s);\n            n || (n = new i(s));\n        });\n    }, Nx = (i)=>{\n        i.forEach((t)=>Rx(t));\n    }, Ia = (i, t = !1)=>{\n        const e = Object.keys(Ks).map((s)=>{\n            if (!!document.body.querySelector(Ks[s].selector)) {\n                const o = i[Ks[s].name];\n                return !o && ![].includes(s) && t && console.warn(`Please import ${Ks[s].name} from \"tw-elements\" package and add it to a object parameter inside \"initTE\" function`), o;\n            }\n        });\n        Nx(e);\n    }, $x = ({ inputID: i, labelText: t }, e)=>(Ia({\n            Input: Z\n        }, !1), `<div data-te-chips-input-wrapper data-te-input-wrapper-init class=\"${e.chipsInputWrapper}\">\n      <input\n          type=\"text\"\n          class=\"${e.chipsInput}\"\n          id=\"${i}\"\n          placeholder=\"Example label\" />\n        <label\n          for=\"${i}\"\n          class=\"${e.chipsLabel}\"\n          >${t}\n        </label>\n\n        <div data-te-input-notch-ref class=\"${e.chipsNotchesWrapper}\">\n        <div class=\"${e.chipsNotchesLeading}\" data-te-input-notch-leading-ref style=\"width: 9px;\"></div>\n        <div class=\"${e.chipsNotchesMiddle}\" data-te-input-notch-middle-ref style=\"width: 87.2px;\"></div>\n        <div class=\"${e.chipsNotchesTrailing}\" data-te-input-notch-trailing-ref></div>\n      </div>\n    </div>`), Bx = ({ text: i, iconSVG: t }, e)=>`<div data-te-chip-init data-te-ripple-init class=\"${e.chipElement}\">\n    <span data-te-chip-text>${i}</span> \n      <span data-te-chip-close class=\"${e.chipCloseIcon}\">\n        ${t}\n      </span>\n  </div>`, Ro = \"chip\", Hx = `te.${Ro}`, Hd = \"data-te-chip-close\", La = `[${Hd}]`, Fx = \"delete.te.chips\", Vx = \"select.te.chip\", Wx = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-3 h-3\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" /></svg>', zx = {\n        text: \"string\",\n        closeIcon: \"boolean\",\n        img: \"object\",\n        iconSVG: \"string\"\n    }, jx = {\n        text: \"\",\n        closeIcon: !1,\n        img: {\n            path: \"\",\n            alt: \"\"\n        },\n        iconSVG: Wx\n    }, Yx = {\n        icon: \"float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out\",\n        chipElement: \"flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded\",\n        chipCloseIcon: \"w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out\"\n    }, Kx = {\n        icon: \"string\",\n        chipElement: \"string\",\n        chipCloseIcon: \"string\"\n    };\n    class vi {\n        constructor(t, e = {}, s){\n            this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(s);\n        }\n        static get NAME() {\n            return Ro;\n        }\n        init() {\n            this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();\n        }\n        dispose() {\n            this._element = null, this._options = null, b.off(this._element, \"click\");\n        }\n        appendChip() {\n            const { text: t, closeIcon: e, iconSVG: s } = this._options;\n            return Bx({\n                text: t,\n                closeIcon: e,\n                iconSVG: s\n            }, this._classes);\n        }\n        _appendCloseIcon(t = this._element) {\n            if (!(g.find(La, this._element).length > 0) && this._options.closeIcon) {\n                const e = z(\"span\");\n                e.classList = this._classes.icon, e.setAttribute(Hd), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement(\"beforeend\", e);\n            }\n        }\n        _handleClickOnChip() {\n            b.on(this._element, \"click\", (t)=>{\n                const { textContent: e } = t.target, s = {};\n                s.tag = e.trim(), b.trigger(Vx, {\n                    event: t,\n                    obj: s\n                });\n            });\n        }\n        _handleDelete() {\n            g.find(La, this._element).length !== 0 && b.on(this._element, \"click\", La, ()=>{\n                b.trigger(this._element, Fx), this._element.remove();\n            });\n        }\n        _handleTextChip() {\n            this._element.innerText === \"\" && (this._element.innerText = this._options.text);\n        }\n        _getConfig(t) {\n            const e = {\n                ...jx,\n                ...v.getDataAttributes(this._element),\n                ...t\n            };\n            return W(Ro, e, zx), e;\n        }\n        _getClasses(t) {\n            const e = v.getDataClassAttributes(this._element);\n            return t = {\n                ...Yx,\n                ...e,\n                ...t\n            }, W(Ro, t, Kx), t;\n        }\n        static getInstance(t) {\n            return P.getData(t, Hx);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    }\n    const Us = \"chips\", Xs = `data-te-${Us}`, Fd = `te.${Us}`, Ux = `${Xs}-init`, Bt = `${Xs}-active`, Vd = `${Xs}-initial`, Wd = `${Xs}-placeholder`, Xx = `${Xs}-input-wrapper`, Pa = \"data-te-chip-init\", zd = \"data-te-chip-close\", jd = \"data-te-chip-text\", Gx = `[${Bt}]`, Ra = `[${Pa}]`, qx = `${Ra}${Gx}`, Na = `[${zd}]`, Zx = `[${Xx}]`, Qx = `[${jd}]`, Jx = `[${Wd}]`, tE = \"data-te-input-notch-leading-ref\", eE = \"data-te-input-notch-middle-ref\", iE = `[${tE}]`, sE = `[${eE}]`, os = \"data-te-input-state-active\", $a = \"[data-te-input-notch-ref]\", nE = \"add.te.chips\", oE = \"arrowDown.te.chips\", rE = \"arrowLeft.te.chips\", aE = \"arrowRight.te.chips\", lE = \"arrowUp.te.chips\", Yd = \"delete.te.chips\", Kd = \"select.te.chips\", cE = {\n        inputID: \"string\",\n        parentSelector: \"string\",\n        initialValues: \"array\",\n        editable: \"boolean\",\n        labelText: \"string\"\n    }, hE = {\n        inputID: se(\"chips-input-\"),\n        parentSelector: \"\",\n        initialValues: [\n            {\n                tag: \"init1\"\n            },\n            {\n                tag: \"init2\"\n            }\n        ],\n        editable: !1,\n        labelText: \"Example label\"\n    }, dE = {\n        opacity: \"opacity-0\",\n        inputWrapperPadding: \"p-[5px]\",\n        transition: \"transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n        contentEditable: \"outline-none !border-[3px] !border-solid !border-[#b2b3b4]\",\n        chipsInputWrapper: \"relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n        chipsInput: \"peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0\",\n        chipsLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200\",\n        chipsNotchesWrapper: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\n        chipsNotchesLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n        chipsNotchesMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n        chipsNotchesTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\"\n    }, uE = {\n        opacity: \"string\",\n        inputWrapperPadding: \"string\",\n        transition: \"string\",\n        contentEditable: \"string\",\n        chipsInputWrapper: \"string\",\n        chipsInput: \"string\",\n        chipsLabel: \"string\",\n        chipsNotchesWrapper: \"string\",\n        chipsNotchesLeading: \"string\",\n        chipsNotchesMiddle: \"string\",\n        chipsNotchesTrailing: \"string\"\n    };\n    class Ud extends vi {\n        constructor(e, s = {}, n){\n            super(e, s);\n            Ee(this, \"_handleBlurInput\", ({ target: e })=>{\n                e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(Bt, \"\"), this.input.setAttribute(os, \"\"), g.findOne($a, this.input.parentNode).setAttribute(os, \"\"), this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \"))) : (e.removeAttribute(Bt), this.input.removeAttribute(os), g.findOne($a, this.input.parentNode).removeAttribute(os), this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \"))), this.allChips.forEach((s)=>s.removeAttribute(Bt));\n            });\n            this._element = e, this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._element && P.setData(e, Fd, this), this._options = this._getConfig(s), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();\n        }\n        static get NAME() {\n            return Us;\n        }\n        get activeChip() {\n            return g.findOne(qx, this._element);\n        }\n        get input() {\n            return g.findOne(\"input\", this._element);\n        }\n        get allChips() {\n            return g.find(Ra, this._element);\n        }\n        get chipsInputWrapper() {\n            return g.findOne(Zx, this._element);\n        }\n        init() {\n            this._setChipsClass(), this._appendInputToElement(Wd), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._getLabelData(), this._getLabelWidth(), this._getNotchData(), this._applyNotch();\n        }\n        dispose() {\n            this._element = null, this._options = null;\n        }\n        _getNotchData() {\n            this._notchMiddle = g.findOne(sE, this._element), this._notchLeading = g.findOne(iE, this._element);\n        }\n        _getLabelData() {\n            this._label = g.findOne(\"label\", this._element);\n        }\n        _getLabelWidth() {\n            this._labelWidth = this._label.clientWidth * .8 + 8;\n        }\n        _applyNotch() {\n            this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\n        }\n        _setChipsClass() {\n            this._element.setAttribute(Ux, \"\");\n        }\n        _handleDeleteEvents(e) {\n            const [s] = this.allChips.slice(-1);\n            if (this.activeChip === null) s.remove(), this._handleEvents(e, Yd);\n            else {\n                const n = this.allChips.findIndex((a)=>a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];\n                if (this.activeChip === null) return;\n                this.activeChip.remove(), this._handleEvents(e, Yd), this.numberClicks = n, o.setAttribute(Bt, \"\"), this.allChips.forEach((a)=>{\n                    a.hasAttribute(Bt) && (r.push(a), r.length > 1 && this.allChips.forEach((l)=>l.remove()));\n                });\n            }\n        }\n        _handleUpEvents(e) {\n            this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, aE), this._handleEvents(e, lE);\n        }\n        _handleDownEvents(e) {\n            this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, rE), this._handleEvents(e, oE);\n        }\n        _keyboardEvents(e) {\n            const { target: s, keyCode: n, ctrlKey: o } = e;\n            s.value.length > 0 || this.allChips.length === 0 || (n === Lv || n === Pv ? this._handleDeleteEvents(e) : n === Qi || n === Tt ? this._handleUpEvents(e) : n === Zi || n === ut ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());\n        }\n        _handleKeyboard() {\n            b.on(this.input, \"keydown\", (e)=>this._keyboardEvents(e));\n        }\n        _handleEditable() {\n            const { editable: e } = this._options;\n            e && this.allChips.forEach((s)=>{\n                b.on(s, \"dblclick\", (n)=>{\n                    const o = g.findOne(Na, s);\n                    s.classList.add(...this._classes.contentEditable.split(\" \")), s.contentEditable = !0, s.focus(), setTimeout(()=>{\n                        v.addStyle(o, {\n                            display: \"none\"\n                        });\n                    }, 200), o.classList.add(...this._classes.opacity.split(\" \")), n.target.textContent, b.trigger(s, Kd, {\n                        event: n,\n                        allChips: this.allChips\n                    });\n                }), b.on(document, \"click\", ({ target: n })=>{\n                    const o = g.findOne(Na, s), r = g.findOne(Qx, s), a = n === s, l = s && s.contains(n);\n                    !a && !l && (s.contentEditable = !1, s.classList.remove(...this._classes.contentEditable.split(\" \")), r.textContent !== \"\" && setTimeout(()=>{\n                        v.addStyle(o, {\n                            display: \"block\"\n                        }), o.classList.remove(...this._classes.opacity.split(\" \"));\n                    }, 160)), r.textContent === \"\" && (setTimeout(()=>{\n                        s.classList.add(...this._classes.opacity.split(\" \"));\n                    }, 200), setTimeout(()=>{\n                        s.remove();\n                    }, 300));\n                });\n            });\n        }\n        _handleRemoveActiveClass() {\n            this.allChips.forEach((e)=>e.removeAttribute(Bt));\n        }\n        _handleAddActiveClass() {\n            this.allChips.forEach((e)=>e.setAttribute(Bt, \"\"));\n        }\n        _handleRightKeyboardArrow(e) {\n            this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);\n        }\n        _handleLeftKeyboardArrow(e) {\n            this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);\n        }\n        _handleActiveChipAfterRemove(e) {\n            const s = e === 0 ? 1 : e - 1;\n            return this.allChips[s];\n        }\n        _handleClicksOnChips() {\n            b.on(this._element, \"click\", ()=>{\n                this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \")), this.input.removeAttribute(Bt));\n            });\n        }\n        _handleTextContent() {\n            const e = [];\n            return this.allChips.forEach((s)=>e.push({\n                    tag: s.textContent.trim()\n                })), e;\n        }\n        _handleEvents(e, s) {\n            const n = this._handleTextContent(), o = this.allChips.filter((r)=>r.hasAttribute(Bt) && r);\n            b.trigger(this._element, s, {\n                event: e,\n                allChips: this.allChips,\n                arrOfObjects: n,\n                active: o,\n                activeObj: {\n                    tag: o.length <= 0 ? \"\" : o[0].textContent.trim()\n                }\n            });\n        }\n        _handleChipsFocus() {\n            b.on(this._element, \"click\", ({ target: { attributes: e } })=>{\n                const s = [\n                    ...e\n                ];\n                s.includes(Pa) || s.includes(zd) || s.includes(jd) || this.input.focus();\n            });\n        }\n        _handleInitialValue() {\n            if (this._appendInputToElement(Vd), this._element.hasAttribute(Vd)) {\n                const { initialValues: e } = this._options;\n                e.forEach(({ tag: s })=>this._handleCreateChip(this.input, s)), g.findOne($a, this.input.parentNode).setAttribute(os, \"\"), this.input.setAttribute(Bt, \"\"), this.input.setAttribute(os, \"\");\n            }\n            this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \")), this.chipsInputWrapper.classList.add(...this._classes.transition.split(\" \")));\n        }\n        _handleKeysInputToElement(e) {\n            const { keyCode: s, target: n } = e;\n            if (n.hasAttribute(Pa)) {\n                const o = g.findOne(Na, n);\n                s === Pt && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(\" \")), n.textContent !== \"\" ? setTimeout(()=>{\n                    v.addStyle(o, {\n                        display: \"block\"\n                    }), o.classList.remove(...this._classes.opacity.split(\" \"));\n                }, 160) : n.textContent === \"\" && (setTimeout(()=>{\n                    n.classList.add(...this._classes.opacity.split(\" \"));\n                }, 200), setTimeout(()=>{\n                    n.remove();\n                }, 300)));\n                return;\n            }\n            if (s === Pt) {\n                if (n.value === \"\") return;\n                this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, nE);\n            }\n            this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \")), this.chipsInputWrapper.classList.add(...this._classes.transition.split(\" \"))) : this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \"));\n        }\n        _handleInputText() {\n            const e = g.findOne(Jx, this._element);\n            b.on(this._element, \"keyup\", e, (s)=>this._handleKeysInputToElement(s)), b.on(this.input, \"blur\", (s)=>this._handleBlurInput(s));\n        }\n        _appendInputToElement(e) {\n            if (!this._element.hasAttribute(e)) return;\n            const s = $x(this._options, this._classes);\n            this._element.insertAdjacentHTML(\"beforeend\", s);\n        }\n        _handleCreateChip(e, s) {\n            const n = z(\"div\"), o = vi.getInstance(n), r = new vi(o, {\n                text: s\n            }, this._classes);\n            this._options.parentSelector !== \"\" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML(\"beforeend\", r.appendChip()) : e.insertAdjacentHTML(\"beforebegin\", r.appendChip()), e.value = \"\", g.find(Ra).forEach((a)=>{\n                let l = vi.getInstance(a);\n                return l || (l = new vi(a, {}, this._classes)), l.init();\n            }), this._handleEditable();\n        }\n        _handleChipsOnSelect() {\n            this.allChips.forEach((e)=>{\n                b.on(this._element, \"click\", (s)=>{\n                    b.trigger(e, Kd, {\n                        event: s,\n                        allChips: this.allChips\n                    });\n                });\n            });\n        }\n        _handleAddActiveClassWithKebyboard(e) {\n            let s;\n            this.allChips[e - 1] === void 0 ? s = this.allChips[e - 2] : s = this.allChips[e - 1], s.setAttribute(Bt);\n        }\n        _getConfig(e) {\n            const s = {\n                ...hE,\n                ...v.getDataAttributes(this._element),\n                ...e\n            };\n            return W(Us, s, cE), s;\n        }\n        _getClasses(e) {\n            const s = v.getDataClassAttributes(this._element);\n            return e = {\n                ...dE,\n                ...s,\n                ...e\n            }, W(Us, e, uE), e;\n        }\n        static getInstance(e) {\n            return P.getData(e, Fd);\n        }\n        static getOrCreateInstance(e, s = {}) {\n            return this.getInstance(e) || new this(e, typeof s == \"object\" ? s : null);\n        }\n    }\n    var fE = function(t) {\n        return pE(t) && !_E(t);\n    };\n    function pE(i) {\n        return !!i && typeof i == \"object\";\n    }\n    function _E(i) {\n        var t = Object.prototype.toString.call(i);\n        return t === \"[object RegExp]\" || t === \"[object Date]\" || bE(i);\n    }\n    var gE = typeof Symbol == \"function\" && Symbol.for, mE = gE ? Symbol.for(\"react.element\") : 60103;\n    function bE(i) {\n        return i.$$typeof === mE;\n    }\n    function vE(i) {\n        return Array.isArray(i) ? [] : {};\n    }\n    function Gs(i, t) {\n        return t.clone !== !1 && t.isMergeableObject(i) ? rs(vE(i), i, t) : i;\n    }\n    function yE(i, t, e) {\n        return i.concat(t).map(function(s) {\n            return Gs(s, e);\n        });\n    }\n    function xE(i, t) {\n        if (!t.customMerge) return rs;\n        var e = t.customMerge(i);\n        return typeof e == \"function\" ? e : rs;\n    }\n    function EE(i) {\n        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(i).filter(function(t) {\n            return Object.propertyIsEnumerable.call(i, t);\n        }) : [];\n    }\n    function Xd(i) {\n        return Object.keys(i).concat(EE(i));\n    }\n    function Gd(i, t) {\n        try {\n            return t in i;\n        } catch  {\n            return !1;\n        }\n    }\n    function CE(i, t) {\n        return Gd(i, t) && !(Object.hasOwnProperty.call(i, t) && Object.propertyIsEnumerable.call(i, t));\n    }\n    function TE(i, t, e) {\n        var s = {};\n        return e.isMergeableObject(i) && Xd(i).forEach(function(n) {\n            s[n] = Gs(i[n], e);\n        }), Xd(t).forEach(function(n) {\n            CE(i, n) || (Gd(i, n) && e.isMergeableObject(t[n]) ? s[n] = xE(n, e)(i[n], t[n], e) : s[n] = Gs(t[n], e));\n        }), s;\n    }\n    function rs(i, t, e) {\n        e = e || {}, e.arrayMerge = e.arrayMerge || yE, e.isMergeableObject = e.isMergeableObject || fE, e.cloneUnlessOtherwiseSpecified = Gs;\n        var s = Array.isArray(t), n = Array.isArray(i), o = s === n;\n        return o ? s ? e.arrayMerge(i, t, e) : TE(i, t, e) : Gs(t, e);\n    }\n    rs.all = function(t, e) {\n        if (!Array.isArray(t)) throw new Error(\"first argument should be an array\");\n        return t.reduce(function(s, n) {\n            return rs(s, n, e);\n        }, {});\n    };\n    var AE = rs, Ba = AE;\n    const qd = \"chart\", No = \"te.chart\", wE = \"chart\", Zd = (i, t, e)=>{\n        const s = (n, o, r)=>{\n            const a = n.slice();\n            return o.forEach((l, c)=>{\n                typeof a[c] > \"u\" ? a[c] = r.cloneUnlessOtherwiseSpecified(l, r) : r.isMergeableObject(l) ? a[c] = Ba(n[c], l, r) : n.indexOf(l) === -1 && a.push(l);\n            }), a;\n        };\n        return Ba(e[t], i, {\n            arrayMerge: s\n        });\n    }, kE = {\n        darkTicksColor: \"#fff\",\n        darkLabelColor: \"#fff\",\n        darkGridLinesColor: \"#555\",\n        darkmodeOff: \"undefined\",\n        darkBgColor: \"#262626\",\n        options: null\n    }, SE = {\n        darkTicksColor: \"string\",\n        darkLabelColor: \"string\",\n        darkGridLinesColor: \"string\",\n        darkmodeOff: \"(string|null)\",\n        darkBgColor: \"string\",\n        options: \"(object|null)\"\n    };\n    let Qd = class Yp {\n        constructor(t, e, s = {}, n = {}){\n            this._waitForCharts(t, e, s, n);\n        }\n        async _getChartjs() {\n            const { Chart: t, ArcElement: e, LineElement: s, BarElement: n, PointElement: o, BarController: r, BubbleController: a, DoughnutController: l, LineController: c, PieController: h, PolarAreaController: d, RadarController: u, ScatterController: f, CategoryScale: p, LinearScale: _, LogarithmicScale: m, RadialLinearScale: y, TimeScale: x, TimeSeriesScale: E, Decimation: C, Filler: T, Legend: A, Title: w, Tooltip: S, SubTitle: k } = await Promise.resolve().then(()=>tk);\n            return t.register(e, s, n, o, r, a, l, c, h, d, u, f, p, _, m, y, x, E, C, T, A, w, S, k), t;\n        }\n        async _getChartDataLabels() {\n            const { ChartDataLabels: t } = await Promise.resolve().then(()=>Ck);\n            return t;\n        }\n        async _waitForCharts(t, e, s = {}, n = {}) {\n            this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = s, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector(\"html\"), this._prevConfig = null, this._observer = null, this._element && (P.setData(t, No, this), v.addClass(this._element, wE), this._chartConstructor()), this._darkOptions.darkmodeOff !== null && (this._handleMode(this.systemColorMode), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {\n                attributes: !0\n            }));\n        }\n        static get NAME() {\n            return qd;\n        }\n        get systemColorMode() {\n            return localStorage.theme || (this._darkModeClassContainer.classList.contains(\"dark\") ? \"dark\" : \"light\");\n        }\n        dispose() {\n            this._observer.disconnect(), P.removeData(this._element, No), this._element = null;\n        }\n        update(t, e) {\n            t && (this._data = {\n                ...this._data,\n                ...t\n            }, this._chart.data = this._data), this._prevConfig = this._chart.options, this._options = {\n                ...this._options,\n                ...e\n            }, this._chart.options = Ba(this._chart.options, this._options), this._chart.update();\n        }\n        _getDarkConfig(t) {\n            let e = {};\n            const s = v.getDataAttributes(this._element);\n            Object.keys(s).forEach((c)=>c.startsWith(\"dark\") && (e[c] = s[c])), e = {\n                ...kE,\n                ...e\n            };\n            const n = {\n                y: {\n                    ticks: {\n                        color: e.darkTicksColor\n                    },\n                    grid: {\n                        color: e.darkGridLinesColor\n                    }\n                },\n                x: {\n                    ticks: {\n                        color: e.darkTicksColor\n                    },\n                    grid: {\n                        color: e.darkGridLinesColor\n                    }\n                }\n            }, o = {\n                r: {\n                    ticks: {\n                        color: e.darkTicksColor,\n                        backdropColor: e.darkBgColor\n                    },\n                    grid: {\n                        color: e.darkGridLinesColor\n                    },\n                    pointLabels: {\n                        color: e.darkTicksColor\n                    }\n                }\n            }, l = {\n                scales: [\n                    \"pie\",\n                    \"doughnut\",\n                    \"polarArea\",\n                    \"radar\"\n                ].includes(this._type) ? [\n                    \"polarArea\",\n                    \"radar\"\n                ].includes(this._type) ? o : {} : n,\n                plugins: {\n                    legend: {\n                        labels: {\n                            color: e.darkLabelColor\n                        }\n                    }\n                }\n            };\n            return t = {\n                ...e,\n                options: {\n                    ...l\n                },\n                ...t\n            }, W(qd, t, SE), t;\n        }\n        _chartConstructor() {\n            if (this._data) {\n                this._createCanvas();\n                const t = Zd(this._options, this._type, Po), e = [];\n                t.dataLabelsPlugin && e.push(this._ChartDataLabels), this._chart = new this._Chartjs(this._canvas, {\n                    ...this._data,\n                    ...t,\n                    plugins: e\n                });\n            }\n        }\n        _createCanvas() {\n            this._canvas || (this._element.nodeName === \"CANVAS\" ? this._canvas = this._element : (this._canvas = z(\"canvas\"), this._element.appendChild(this._canvas)));\n        }\n        _handleMode(t) {\n            t === \"dark\" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));\n        }\n        _observerCallback(t) {\n            for (const e of t)e.type === \"attributes\" && this._handleMode(this.systemColorMode);\n        }\n        _changeDatasetBorderColor(t = !0) {\n            [\n                ...this._data.data.datasets\n            ].forEach((e)=>[\n                    \"pie\",\n                    \"doughnut\",\n                    \"polarArea\"\n                ].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : \"#fff\"));\n        }\n        static jQueryInterface(t, e, s) {\n            return this.each(function() {\n                let n = P.getData(this, No);\n                if (!(!n && /dispose/.test(t))) {\n                    if (!n) {\n                        const o = e ? Zd(e, s, Po) : Po[s];\n                        n = new Yp(this, {\n                            ...t,\n                            ...o\n                        });\n                    }\n                    if (typeof t == \"string\") {\n                        if (typeof n[t] > \"u\") throw new TypeError(`No method named \"${t}\"`);\n                        n[t](e, s);\n                    }\n                }\n            });\n        }\n        static getInstance(t) {\n            return P.getData(t, No);\n        }\n        static getOrCreateInstance(t, e = {}) {\n            return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n        }\n    };\n    Ia({\n        Animate: qn,\n        Alert: As,\n        Button: On,\n        ChipsInput: Ud,\n        Chip: vi,\n        Dropdown: $t,\n        Carousel: ae,\n        Collapse: re,\n        Offcanvas: zi,\n        Modal: Ss,\n        Popover: zn,\n        ScrollSpy: Is,\n        Select: Lo,\n        Tab: Un,\n        Toast: Ls,\n        Tooltip: Ms,\n        Ripple: Ui,\n        Datepicker: Ph,\n        Timepicker: od,\n        Sidenav: bi,\n        Stepper: vd,\n        Input: Z,\n        Chart: Qd\n    }); /*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n    function Te() {}\n    const OE = function() {\n        let i = 0;\n        return function() {\n            return i++;\n        };\n    }();\n    function N(i) {\n        return i === null || typeof i > \"u\";\n    }\n    function Q(i) {\n        if (Array.isArray && Array.isArray(i)) return !0;\n        const t = Object.prototype.toString.call(i);\n        return t.slice(0, 7) === \"[object\" && t.slice(-6) === \"Array]\";\n    }\n    function $(i) {\n        return i !== null && Object.prototype.toString.call(i) === \"[object Object]\";\n    }\n    const rt = (i)=>(typeof i == \"number\" || i instanceof Number) && isFinite(+i);\n    function Ht(i, t) {\n        return rt(i) ? i : t;\n    }\n    function R(i, t) {\n        return typeof i > \"u\" ? t : i;\n    }\n    const DE = (i, t)=>typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 : i / t, Jd = (i, t)=>typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 * t : +i;\n    function G(i, t, e) {\n        if (i && typeof i.call == \"function\") return i.apply(e, t);\n    }\n    function U(i, t, e, s) {\n        let n, o, r;\n        if (Q(i)) {\n            if (o = i.length, s) for(n = o - 1; n >= 0; n--)t.call(e, i[n], n);\n            else for(n = 0; n < o; n++)t.call(e, i[n], n);\n        } else if ($(i)) for(r = Object.keys(i), o = r.length, n = 0; n < o; n++)t.call(e, i[r[n]], r[n]);\n    }\n    function $o(i, t) {\n        let e, s, n, o;\n        if (!i || !t || i.length !== t.length) return !1;\n        for(e = 0, s = i.length; e < s; ++e)if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n        return !0;\n    }\n    function Bo(i) {\n        if (Q(i)) return i.map(Bo);\n        if ($(i)) {\n            const t = Object.create(null), e = Object.keys(i), s = e.length;\n            let n = 0;\n            for(; n < s; ++n)t[e[n]] = Bo(i[e[n]]);\n            return t;\n        }\n        return i;\n    }\n    function tu(i) {\n        return [\n            \"__proto__\",\n            \"prototype\",\n            \"constructor\"\n        ].indexOf(i) === -1;\n    }\n    function ME(i, t, e, s) {\n        if (!tu(i)) return;\n        const n = t[i], o = e[i];\n        $(n) && $(o) ? ge(n, o, s) : t[i] = Bo(o);\n    }\n    function ge(i, t, e) {\n        const s = Q(t) ? t : [\n            t\n        ], n = s.length;\n        if (!$(i)) return i;\n        e = e || {};\n        const o = e.merger || ME;\n        for(let r = 0; r < n; ++r){\n            if (t = s[r], !$(t)) continue;\n            const a = Object.keys(t);\n            for(let l = 0, c = a.length; l < c; ++l)o(a[l], i, t, e);\n        }\n        return i;\n    }\n    function qs(i, t) {\n        return ge(i, t, {\n            merger: IE\n        });\n    }\n    function IE(i, t, e) {\n        if (!tu(i)) return;\n        const s = t[i], n = e[i];\n        $(s) && $(n) ? qs(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = Bo(n));\n    }\n    const eu = {\n        \"\": (i)=>i,\n        x: (i)=>i.x,\n        y: (i)=>i.y\n    };\n    function Ke(i, t) {\n        return (eu[t] || (eu[t] = LE(t)))(i);\n    }\n    function LE(i) {\n        const t = PE(i);\n        return (e)=>{\n            for (const s of t){\n                if (s === \"\") break;\n                e = e && e[s];\n            }\n            return e;\n        };\n    }\n    function PE(i) {\n        const t = i.split(\".\"), e = [];\n        let s = \"\";\n        for (const n of t)s += n, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (e.push(s), s = \"\");\n        return e;\n    }\n    function Ha(i) {\n        return i.charAt(0).toUpperCase() + i.slice(1);\n    }\n    const Ft = (i)=>typeof i < \"u\", Ue = (i)=>typeof i == \"function\", iu = (i, t)=>{\n        if (i.size !== t.size) return !1;\n        for (const e of i)if (!t.has(e)) return !1;\n        return !0;\n    };\n    function RE(i) {\n        return i.type === \"mouseup\" || i.type === \"click\" || i.type === \"contextmenu\";\n    }\n    const et = Math.PI, q = 2 * et, NE = q + et, Ho = Number.POSITIVE_INFINITY, $E = et / 180, nt = et / 2, Zs = et / 4, su = et * 2 / 3, Vt = Math.log10, me = Math.sign;\n    function nu(i) {\n        const t = Math.round(i);\n        i = Qs(i, t, i / 1e3) ? t : i;\n        const e = Math.pow(10, Math.floor(Vt(i))), s = i / e;\n        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;\n    }\n    function BE(i) {\n        const t = [], e = Math.sqrt(i);\n        let s;\n        for(s = 1; s < e; s++)i % s === 0 && (t.push(s), t.push(i / s));\n        return e === (e | 0) && t.push(e), t.sort((n, o)=>n - o).pop(), t;\n    }\n    function as(i) {\n        return !isNaN(parseFloat(i)) && isFinite(i);\n    }\n    function Qs(i, t, e) {\n        return Math.abs(i - t) < e;\n    }\n    function HE(i, t) {\n        const e = Math.round(i);\n        return e - t <= i && e + t >= i;\n    }\n    function ou(i, t, e) {\n        let s, n, o;\n        for(s = 0, n = i.length; s < n; s++)o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));\n    }\n    function Jt(i) {\n        return i * (et / 180);\n    }\n    function Fa(i) {\n        return i * (180 / et);\n    }\n    function ru(i) {\n        if (!rt(i)) return;\n        let t = 1, e = 0;\n        for(; Math.round(i * t) / t !== i;)t *= 10, e++;\n        return e;\n    }\n    function au(i, t) {\n        const e = t.x - i.x, s = t.y - i.y, n = Math.sqrt(e * e + s * s);\n        let o = Math.atan2(s, e);\n        return o < -0.5 * et && (o += q), {\n            angle: o,\n            distance: n\n        };\n    }\n    function Va(i, t) {\n        return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));\n    }\n    function FE(i, t) {\n        return (i - t + NE) % q - et;\n    }\n    function Nt(i) {\n        return (i % q + q) % q;\n    }\n    function Js(i, t, e, s) {\n        const n = Nt(i), o = Nt(t), r = Nt(e), a = Nt(o - n), l = Nt(r - n), c = Nt(n - o), h = Nt(n - r);\n        return n === o || n === r || s && o === r || a > l && c < h;\n    }\n    function ct(i, t, e) {\n        return Math.max(t, Math.min(e, i));\n    }\n    function VE(i) {\n        return ct(i, -32768, 32767);\n    }\n    function Ae(i, t, e, s = 1e-6) {\n        return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;\n    }\n    function Wa(i, t, e) {\n        e = e || ((r)=>i[r] < t);\n        let s = i.length - 1, n = 0, o;\n        for(; s - n > 1;)o = n + s >> 1, e(o) ? n = o : s = o;\n        return {\n            lo: n,\n            hi: s\n        };\n    }\n    const we = (i, t, e, s)=>Wa(i, e, s ? (n)=>i[n][t] <= e : (n)=>i[n][t] < e), WE = (i, t, e)=>Wa(i, e, (s)=>i[s][t] >= e);\n    function zE(i, t, e) {\n        let s = 0, n = i.length;\n        for(; s < n && i[s] < t;)s++;\n        for(; n > s && i[n - 1] > e;)n--;\n        return s > 0 || n < i.length ? i.slice(s, n) : i;\n    }\n    const lu = [\n        \"push\",\n        \"pop\",\n        \"shift\",\n        \"splice\",\n        \"unshift\"\n    ];\n    function jE(i, t) {\n        if (i._chartjs) {\n            i._chartjs.listeners.push(t);\n            return;\n        }\n        Object.defineProperty(i, \"_chartjs\", {\n            configurable: !0,\n            enumerable: !1,\n            value: {\n                listeners: [\n                    t\n                ]\n            }\n        }), lu.forEach((e)=>{\n            const s = \"_onData\" + Ha(e), n = i[e];\n            Object.defineProperty(i, e, {\n                configurable: !0,\n                enumerable: !1,\n                value (...o) {\n                    const r = n.apply(this, o);\n                    return i._chartjs.listeners.forEach((a)=>{\n                        typeof a[s] == \"function\" && a[s](...o);\n                    }), r;\n                }\n            });\n        });\n    }\n    function cu(i, t) {\n        const e = i._chartjs;\n        if (!e) return;\n        const s = e.listeners, n = s.indexOf(t);\n        n !== -1 && s.splice(n, 1), !(s.length > 0) && (lu.forEach((o)=>{\n            delete i[o];\n        }), delete i._chartjs);\n    }\n    function hu(i) {\n        const t = new Set;\n        let e, s;\n        for(e = 0, s = i.length; e < s; ++e)t.add(i[e]);\n        return t.size === s ? i : Array.from(t);\n    }\n    const du = function() {\n        return typeof window > \"u\" ? function(i) {\n            return i();\n        } : window.requestAnimationFrame;\n    }();\n    function uu(i, t, e) {\n        const s = e || ((r)=>Array.prototype.slice.call(r));\n        let n = !1, o = [];\n        return function(...r) {\n            o = s(r), n || (n = !0, du.call(window, ()=>{\n                n = !1, i.apply(t, o);\n            }));\n        };\n    }\n    function YE(i, t) {\n        let e;\n        return function(...s) {\n            return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;\n        };\n    }\n    const za = (i)=>i === \"start\" ? \"left\" : i === \"end\" ? \"right\" : \"center\", pt = (i, t, e)=>i === \"start\" ? t : i === \"end\" ? e : (t + e) / 2, KE = (i, t, e, s)=>i === (s ? \"left\" : \"right\") ? e : i === \"center\" ? (t + e) / 2 : t;\n    function fu(i, t, e) {\n        const s = t.length;\n        let n = 0, o = s;\n        if (i._sorted) {\n            const { iScale: r, _parsed: a } = i, l = r.axis, { min: c, max: h, minDefined: d, maxDefined: u } = r.getUserBounds();\n            d && (n = ct(Math.min(we(a, r.axis, c).lo, e ? s : we(t, l, r.getPixelForValue(c)).lo), 0, s - 1)), u ? o = ct(Math.max(we(a, r.axis, h, !0).hi + 1, e ? 0 : we(t, l, r.getPixelForValue(h), !0).hi + 1), n, s) - n : o = s - n;\n        }\n        return {\n            start: n,\n            count: o\n        };\n    }\n    function pu(i) {\n        const { xScale: t, yScale: e, _scaleRanges: s } = i, n = {\n            xmin: t.min,\n            xmax: t.max,\n            ymin: e.min,\n            ymax: e.max\n        };\n        if (!s) return i._scaleRanges = n, !0;\n        const o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;\n        return Object.assign(s, n), o;\n    }\n    const Fo = (i)=>i === 0 || i === 1, _u = (i, t, e)=>-(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * q / e)), gu = (i, t, e)=>Math.pow(2, -10 * i) * Math.sin((i - t) * q / e) + 1, tn = {\n        linear: (i)=>i,\n        easeInQuad: (i)=>i * i,\n        easeOutQuad: (i)=>-i * (i - 2),\n        easeInOutQuad: (i)=>(i /= .5) < 1 ? .5 * i * i : -0.5 * (--i * (i - 2) - 1),\n        easeInCubic: (i)=>i * i * i,\n        easeOutCubic: (i)=>(i -= 1) * i * i + 1,\n        easeInOutCubic: (i)=>(i /= .5) < 1 ? .5 * i * i * i : .5 * ((i -= 2) * i * i + 2),\n        easeInQuart: (i)=>i * i * i * i,\n        easeOutQuart: (i)=>-((i -= 1) * i * i * i - 1),\n        easeInOutQuart: (i)=>(i /= .5) < 1 ? .5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2),\n        easeInQuint: (i)=>i * i * i * i * i,\n        easeOutQuint: (i)=>(i -= 1) * i * i * i * i + 1,\n        easeInOutQuint: (i)=>(i /= .5) < 1 ? .5 * i * i * i * i * i : .5 * ((i -= 2) * i * i * i * i + 2),\n        easeInSine: (i)=>-Math.cos(i * nt) + 1,\n        easeOutSine: (i)=>Math.sin(i * nt),\n        easeInOutSine: (i)=>-0.5 * (Math.cos(et * i) - 1),\n        easeInExpo: (i)=>i === 0 ? 0 : Math.pow(2, 10 * (i - 1)),\n        easeOutExpo: (i)=>i === 1 ? 1 : -Math.pow(2, -10 * i) + 1,\n        easeInOutExpo: (i)=>Fo(i) ? i : i < .5 ? .5 * Math.pow(2, 10 * (i * 2 - 1)) : .5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2),\n        easeInCirc: (i)=>i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1),\n        easeOutCirc: (i)=>Math.sqrt(1 - (i -= 1) * i),\n        easeInOutCirc: (i)=>(i /= .5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : .5 * (Math.sqrt(1 - (i -= 2) * i) + 1),\n        easeInElastic: (i)=>Fo(i) ? i : _u(i, .075, .3),\n        easeOutElastic: (i)=>Fo(i) ? i : gu(i, .075, .3),\n        easeInOutElastic (i) {\n            return Fo(i) ? i : i < .5 ? .5 * _u(i * 2, .1125, .45) : .5 + .5 * gu(i * 2 - 1, .1125, .45);\n        },\n        easeInBack (i) {\n            return i * i * (2.70158 * i - 1.70158);\n        },\n        easeOutBack (i) {\n            return (i -= 1) * i * (2.70158 * i + 1.70158) + 1;\n        },\n        easeInOutBack (i) {\n            let t = 1.70158;\n            return (i /= .5) < 1 ? .5 * (i * i * (((t *= 1.525) + 1) * i - t)) : .5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);\n        },\n        easeInBounce: (i)=>1 - tn.easeOutBounce(1 - i),\n        easeOutBounce (i) {\n            return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + .75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + .9375 : 7.5625 * (i -= 2.625 / 2.75) * i + .984375;\n        },\n        easeInOutBounce: (i)=>i < .5 ? tn.easeInBounce(i * 2) * .5 : tn.easeOutBounce(i * 2 - 1) * .5 + .5\n    }; /*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */ \n    function en(i) {\n        return i + .5 | 0;\n    }\n    const Xe = (i, t, e)=>Math.max(Math.min(i, e), t);\n    function sn(i) {\n        return Xe(en(i * 2.55), 0, 255);\n    }\n    function Ge(i) {\n        return Xe(en(i * 255), 0, 255);\n    }\n    function ke(i) {\n        return Xe(en(i / 2.55) / 100, 0, 1);\n    }\n    function mu(i) {\n        return Xe(en(i * 100), 0, 100);\n    }\n    const Wt = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, ja = [\n        ...\"0123456789ABCDEF\"\n    ], UE = (i)=>ja[i & 15], XE = (i)=>ja[(i & 240) >> 4] + ja[i & 15], Vo = (i)=>(i & 240) >> 4 === (i & 15), GE = (i)=>Vo(i.r) && Vo(i.g) && Vo(i.b) && Vo(i.a);\n    function qE(i) {\n        var t = i.length, e;\n        return i[0] === \"#\" && (t === 4 || t === 5 ? e = {\n            r: 255 & Wt[i[1]] * 17,\n            g: 255 & Wt[i[2]] * 17,\n            b: 255 & Wt[i[3]] * 17,\n            a: t === 5 ? Wt[i[4]] * 17 : 255\n        } : (t === 7 || t === 9) && (e = {\n            r: Wt[i[1]] << 4 | Wt[i[2]],\n            g: Wt[i[3]] << 4 | Wt[i[4]],\n            b: Wt[i[5]] << 4 | Wt[i[6]],\n            a: t === 9 ? Wt[i[7]] << 4 | Wt[i[8]] : 255\n        })), e;\n    }\n    const ZE = (i, t)=>i < 255 ? t(i) : \"\";\n    function QE(i) {\n        var t = GE(i) ? UE : XE;\n        return i ? \"#\" + t(i.r) + t(i.g) + t(i.b) + ZE(i.a, t) : void 0;\n    }\n    const JE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function bu(i, t, e) {\n        const s = t * Math.min(e, 1 - e), n = (o, r = (o + i / 30) % 12)=>e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);\n        return [\n            n(0),\n            n(8),\n            n(4)\n        ];\n    }\n    function tC(i, t, e) {\n        const s = (n, o = (n + i / 60) % 6)=>e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);\n        return [\n            s(5),\n            s(3),\n            s(1)\n        ];\n    }\n    function eC(i, t, e) {\n        const s = bu(i, 1, .5);\n        let n;\n        for(t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++)s[n] *= 1 - t - e, s[n] += t;\n        return s;\n    }\n    function iC(i, t, e, s, n) {\n        return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;\n    }\n    function Ya(i) {\n        const e = i.r / 255, s = i.g / 255, n = i.b / 255, o = Math.max(e, s, n), r = Math.min(e, s, n), a = (o + r) / 2;\n        let l, c, h;\n        return o !== r && (h = o - r, c = a > .5 ? h / (2 - o - r) : h / (o + r), l = iC(e, s, n, h, o), l = l * 60 + .5), [\n            l | 0,\n            c || 0,\n            a\n        ];\n    }\n    function Ka(i, t, e, s) {\n        return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(Ge);\n    }\n    function Ua(i, t, e) {\n        return Ka(bu, i, t, e);\n    }\n    function sC(i, t, e) {\n        return Ka(eC, i, t, e);\n    }\n    function nC(i, t, e) {\n        return Ka(tC, i, t, e);\n    }\n    function vu(i) {\n        return (i % 360 + 360) % 360;\n    }\n    function oC(i) {\n        const t = JE.exec(i);\n        let e = 255, s;\n        if (!t) return;\n        t[5] !== s && (e = t[6] ? sn(+t[5]) : Ge(+t[5]));\n        const n = vu(+t[2]), o = +t[3] / 100, r = +t[4] / 100;\n        return t[1] === \"hwb\" ? s = sC(n, o, r) : t[1] === \"hsv\" ? s = nC(n, o, r) : s = Ua(n, o, r), {\n            r: s[0],\n            g: s[1],\n            b: s[2],\n            a: e\n        };\n    }\n    function rC(i, t) {\n        var e = Ya(i);\n        e[0] = vu(e[0] + t), e = Ua(e), i.r = e[0], i.g = e[1], i.b = e[2];\n    }\n    function aC(i) {\n        if (!i) return;\n        const t = Ya(i), e = t[0], s = mu(t[1]), n = mu(t[2]);\n        return i.a < 255 ? `hsla(${e}, ${s}%, ${n}%, ${ke(i.a)})` : `hsl(${e}, ${s}%, ${n}%)`;\n    }\n    const yu = {\n        x: \"dark\",\n        Z: \"light\",\n        Y: \"re\",\n        X: \"blu\",\n        W: \"gr\",\n        V: \"medium\",\n        U: \"slate\",\n        A: \"ee\",\n        T: \"ol\",\n        S: \"or\",\n        B: \"ra\",\n        C: \"lateg\",\n        D: \"ights\",\n        R: \"in\",\n        Q: \"turquois\",\n        E: \"hi\",\n        P: \"ro\",\n        O: \"al\",\n        N: \"le\",\n        M: \"de\",\n        L: \"yello\",\n        F: \"en\",\n        K: \"ch\",\n        G: \"arks\",\n        H: \"ea\",\n        I: \"ightg\",\n        J: \"wh\"\n    }, xu = {\n        OiceXe: \"f0f8ff\",\n        antiquewEte: \"faebd7\",\n        aqua: \"ffff\",\n        aquamarRe: \"7fffd4\",\n        azuY: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"0\",\n        blanKedOmond: \"ffebcd\",\n        Xe: \"ff\",\n        XeviTet: \"8a2be2\",\n        bPwn: \"a52a2a\",\n        burlywood: \"deb887\",\n        caMtXe: \"5f9ea0\",\n        KartYuse: \"7fff00\",\n        KocTate: \"d2691e\",\n        cSO: \"ff7f50\",\n        cSnflowerXe: \"6495ed\",\n        cSnsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"ffff\",\n        xXe: \"8b\",\n        xcyan: \"8b8b\",\n        xgTMnPd: \"b8860b\",\n        xWay: \"a9a9a9\",\n        xgYF: \"6400\",\n        xgYy: \"a9a9a9\",\n        xkhaki: \"bdb76b\",\n        xmagFta: \"8b008b\",\n        xTivegYF: \"556b2f\",\n        xSange: \"ff8c00\",\n        xScEd: \"9932cc\",\n        xYd: \"8b0000\",\n        xsOmon: \"e9967a\",\n        xsHgYF: \"8fbc8f\",\n        xUXe: \"483d8b\",\n        xUWay: \"2f4f4f\",\n        xUgYy: \"2f4f4f\",\n        xQe: \"ced1\",\n        xviTet: \"9400d3\",\n        dAppRk: \"ff1493\",\n        dApskyXe: \"bfff\",\n        dimWay: \"696969\",\n        dimgYy: \"696969\",\n        dodgerXe: \"1e90ff\",\n        fiYbrick: \"b22222\",\n        flSOwEte: \"fffaf0\",\n        foYstWAn: \"228b22\",\n        fuKsia: \"ff00ff\",\n        gaRsbSo: \"dcdcdc\",\n        ghostwEte: \"f8f8ff\",\n        gTd: \"ffd700\",\n        gTMnPd: \"daa520\",\n        Way: \"808080\",\n        gYF: \"8000\",\n        gYFLw: \"adff2f\",\n        gYy: \"808080\",\n        honeyMw: \"f0fff0\",\n        hotpRk: \"ff69b4\",\n        RdianYd: \"cd5c5c\",\n        Rdigo: \"4b0082\",\n        ivSy: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavFMr: \"e6e6fa\",\n        lavFMrXsh: \"fff0f5\",\n        lawngYF: \"7cfc00\",\n        NmoncEffon: \"fffacd\",\n        ZXe: \"add8e6\",\n        ZcSO: \"f08080\",\n        Zcyan: \"e0ffff\",\n        ZgTMnPdLw: \"fafad2\",\n        ZWay: \"d3d3d3\",\n        ZgYF: \"90ee90\",\n        ZgYy: \"d3d3d3\",\n        ZpRk: \"ffb6c1\",\n        ZsOmon: \"ffa07a\",\n        ZsHgYF: \"20b2aa\",\n        ZskyXe: \"87cefa\",\n        ZUWay: \"778899\",\n        ZUgYy: \"778899\",\n        ZstAlXe: \"b0c4de\",\n        ZLw: \"ffffe0\",\n        lime: \"ff00\",\n        limegYF: \"32cd32\",\n        lRF: \"faf0e6\",\n        magFta: \"ff00ff\",\n        maPon: \"800000\",\n        VaquamarRe: \"66cdaa\",\n        VXe: \"cd\",\n        VScEd: \"ba55d3\",\n        VpurpN: \"9370db\",\n        VsHgYF: \"3cb371\",\n        VUXe: \"7b68ee\",\n        VsprRggYF: \"fa9a\",\n        VQe: \"48d1cc\",\n        VviTetYd: \"c71585\",\n        midnightXe: \"191970\",\n        mRtcYam: \"f5fffa\",\n        mistyPse: \"ffe4e1\",\n        moccasR: \"ffe4b5\",\n        navajowEte: \"ffdead\",\n        navy: \"80\",\n        Tdlace: \"fdf5e6\",\n        Tive: \"808000\",\n        TivedBb: \"6b8e23\",\n        Sange: \"ffa500\",\n        SangeYd: \"ff4500\",\n        ScEd: \"da70d6\",\n        pOegTMnPd: \"eee8aa\",\n        pOegYF: \"98fb98\",\n        pOeQe: \"afeeee\",\n        pOeviTetYd: \"db7093\",\n        papayawEp: \"ffefd5\",\n        pHKpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pRk: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powMrXe: \"b0e0e6\",\n        purpN: \"800080\",\n        YbeccapurpN: \"663399\",\n        Yd: \"ff0000\",\n        Psybrown: \"bc8f8f\",\n        PyOXe: \"4169e1\",\n        saddNbPwn: \"8b4513\",\n        sOmon: \"fa8072\",\n        sandybPwn: \"f4a460\",\n        sHgYF: \"2e8b57\",\n        sHshell: \"fff5ee\",\n        siFna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyXe: \"87ceeb\",\n        UXe: \"6a5acd\",\n        UWay: \"708090\",\n        UgYy: \"708090\",\n        snow: \"fffafa\",\n        sprRggYF: \"ff7f\",\n        stAlXe: \"4682b4\",\n        tan: \"d2b48c\",\n        teO: \"8080\",\n        tEstN: \"d8bfd8\",\n        tomato: \"ff6347\",\n        Qe: \"40e0d0\",\n        viTet: \"ee82ee\",\n        JHt: \"f5deb3\",\n        wEte: \"ffffff\",\n        wEtesmoke: \"f5f5f5\",\n        Lw: \"ffff00\",\n        LwgYF: \"9acd32\"\n    };\n    function lC() {\n        const i = {}, t = Object.keys(xu), e = Object.keys(yu);\n        let s, n, o, r, a;\n        for(s = 0; s < t.length; s++){\n            for(r = a = t[s], n = 0; n < e.length; n++)o = e[n], a = a.replace(o, yu[o]);\n            o = parseInt(xu[r], 16), i[a] = [\n                o >> 16 & 255,\n                o >> 8 & 255,\n                o & 255\n            ];\n        }\n        return i;\n    }\n    let Wo;\n    function cC(i) {\n        Wo || (Wo = lC(), Wo.transparent = [\n            0,\n            0,\n            0,\n            0\n        ]);\n        const t = Wo[i.toLowerCase()];\n        return t && {\n            r: t[0],\n            g: t[1],\n            b: t[2],\n            a: t.length === 4 ? t[3] : 255\n        };\n    }\n    const hC = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function dC(i) {\n        const t = hC.exec(i);\n        let e = 255, s, n, o;\n        if (t) {\n            if (t[7] !== s) {\n                const r = +t[7];\n                e = t[8] ? sn(r) : Xe(r * 255, 0, 255);\n            }\n            return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? sn(s) : Xe(s, 0, 255)), n = 255 & (t[4] ? sn(n) : Xe(n, 0, 255)), o = 255 & (t[6] ? sn(o) : Xe(o, 0, 255)), {\n                r: s,\n                g: n,\n                b: o,\n                a: e\n            };\n        }\n    }\n    function uC(i) {\n        return i && (i.a < 255 ? `rgba(${i.r}, ${i.g}, ${i.b}, ${ke(i.a)})` : `rgb(${i.r}, ${i.g}, ${i.b})`);\n    }\n    const Xa = (i)=>i <= .0031308 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - .055, ls = (i)=>i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4);\n    function fC(i, t, e) {\n        const s = ls(ke(i.r)), n = ls(ke(i.g)), o = ls(ke(i.b));\n        return {\n            r: Ge(Xa(s + e * (ls(ke(t.r)) - s))),\n            g: Ge(Xa(n + e * (ls(ke(t.g)) - n))),\n            b: Ge(Xa(o + e * (ls(ke(t.b)) - o))),\n            a: i.a + e * (t.a - i.a)\n        };\n    }\n    function zo(i, t, e) {\n        if (i) {\n            let s = Ya(i);\n            s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Ua(s), i.r = s[0], i.g = s[1], i.b = s[2];\n        }\n    }\n    function Eu(i, t) {\n        return i && Object.assign(t || {}, i);\n    }\n    function Cu(i) {\n        var t = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 255\n        };\n        return Array.isArray(i) ? i.length >= 3 && (t = {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: 255\n        }, i.length > 3 && (t.a = Ge(i[3]))) : (t = Eu(i, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        }), t.a = Ge(t.a)), t;\n    }\n    function pC(i) {\n        return i.charAt(0) === \"r\" ? dC(i) : oC(i);\n    }\n    class jo {\n        constructor(t){\n            if (t instanceof jo) return t;\n            const e = typeof t;\n            let s;\n            e === \"object\" ? s = Cu(t) : e === \"string\" && (s = qE(t) || cC(t) || pC(t)), this._rgb = s, this._valid = !!s;\n        }\n        get valid() {\n            return this._valid;\n        }\n        get rgb() {\n            var t = Eu(this._rgb);\n            return t && (t.a = ke(t.a)), t;\n        }\n        set rgb(t) {\n            this._rgb = Cu(t);\n        }\n        rgbString() {\n            return this._valid ? uC(this._rgb) : void 0;\n        }\n        hexString() {\n            return this._valid ? QE(this._rgb) : void 0;\n        }\n        hslString() {\n            return this._valid ? aC(this._rgb) : void 0;\n        }\n        mix(t, e) {\n            if (t) {\n                const s = this.rgb, n = t.rgb;\n                let o;\n                const r = e === o ? .5 : e, a = 2 * r - 1, l = s.a - n.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;\n                o = 1 - c, s.r = 255 & c * s.r + o * n.r + .5, s.g = 255 & c * s.g + o * n.g + .5, s.b = 255 & c * s.b + o * n.b + .5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;\n            }\n            return this;\n        }\n        interpolate(t, e) {\n            return t && (this._rgb = fC(this._rgb, t._rgb, e)), this;\n        }\n        clone() {\n            return new jo(this.rgb);\n        }\n        alpha(t) {\n            return this._rgb.a = Ge(t), this;\n        }\n        clearer(t) {\n            const e = this._rgb;\n            return e.a *= 1 - t, this;\n        }\n        greyscale() {\n            const t = this._rgb, e = en(t.r * .3 + t.g * .59 + t.b * .11);\n            return t.r = t.g = t.b = e, this;\n        }\n        opaquer(t) {\n            const e = this._rgb;\n            return e.a *= 1 + t, this;\n        }\n        negate() {\n            const t = this._rgb;\n            return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n        }\n        lighten(t) {\n            return zo(this._rgb, 2, t), this;\n        }\n        darken(t) {\n            return zo(this._rgb, 2, -t), this;\n        }\n        saturate(t) {\n            return zo(this._rgb, 1, t), this;\n        }\n        desaturate(t) {\n            return zo(this._rgb, 1, -t), this;\n        }\n        rotate(t) {\n            return rC(this._rgb, t), this;\n        }\n    }\n    function Tu(i) {\n        return new jo(i);\n    }\n    function Au(i) {\n        if (i && typeof i == \"object\") {\n            const t = i.toString();\n            return t === \"[object CanvasPattern]\" || t === \"[object CanvasGradient]\";\n        }\n        return !1;\n    }\n    function wu(i) {\n        return Au(i) ? i : Tu(i);\n    }\n    function Ga(i) {\n        return Au(i) ? i : Tu(i).saturate(.5).darken(.1).hexString();\n    }\n    const yi = Object.create(null), qa = Object.create(null);\n    function nn(i, t) {\n        if (!t) return i;\n        const e = t.split(\".\");\n        for(let s = 0, n = e.length; s < n; ++s){\n            const o = e[s];\n            i = i[o] || (i[o] = Object.create(null));\n        }\n        return i;\n    }\n    function Za(i, t, e) {\n        return typeof t == \"string\" ? ge(nn(i, t), e) : ge(nn(i, \"\"), t);\n    }\n    class _C {\n        constructor(t){\n            this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (e)=>e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n                \"mousemove\",\n                \"mouseout\",\n                \"click\",\n                \"touchstart\",\n                \"touchmove\"\n            ], this.font = {\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                size: 12,\n                style: \"normal\",\n                lineHeight: 1.2,\n                weight: null\n            }, this.hover = {}, this.hoverBackgroundColor = (e, s)=>Ga(s.backgroundColor), this.hoverBorderColor = (e, s)=>Ga(s.borderColor), this.hoverColor = (e, s)=>Ga(s.color), this.indexAxis = \"x\", this.interaction = {\n                mode: \"nearest\",\n                intersect: !0,\n                includeInvisible: !1\n            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);\n        }\n        set(t, e) {\n            return Za(this, t, e);\n        }\n        get(t) {\n            return nn(this, t);\n        }\n        describe(t, e) {\n            return Za(qa, t, e);\n        }\n        override(t, e) {\n            return Za(yi, t, e);\n        }\n        route(t, e, s, n) {\n            const o = nn(this, t), r = nn(this, s), a = \"_\" + e;\n            Object.defineProperties(o, {\n                [a]: {\n                    value: o[e],\n                    writable: !0\n                },\n                [e]: {\n                    enumerable: !0,\n                    get () {\n                        const l = this[a], c = r[n];\n                        return $(l) ? Object.assign({}, c, l) : R(l, c);\n                    },\n                    set (l) {\n                        this[a] = l;\n                    }\n                }\n            });\n        }\n    }\n    var B = new _C({\n        _scriptable: (i)=>!i.startsWith(\"on\"),\n        _indexable: (i)=>i !== \"events\",\n        hover: {\n            _fallback: \"interaction\"\n        },\n        interaction: {\n            _scriptable: !1,\n            _indexable: !1\n        }\n    });\n    function gC(i) {\n        return !i || N(i.size) || N(i.family) ? null : (i.style ? i.style + \" \" : \"\") + (i.weight ? i.weight + \" \" : \"\") + i.size + \"px \" + i.family;\n    }\n    function Yo(i, t, e, s, n) {\n        let o = t[n];\n        return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;\n    }\n    function mC(i, t, e, s) {\n        s = s || {};\n        let n = s.data = s.data || {}, o = s.garbageCollect = s.garbageCollect || [];\n        s.font !== t && (n = s.data = {}, o = s.garbageCollect = [], s.font = t), i.save(), i.font = t;\n        let r = 0;\n        const a = e.length;\n        let l, c, h, d, u;\n        for(l = 0; l < a; l++)if (d = e[l], d != null && Q(d) !== !0) r = Yo(i, n, o, r, d);\n        else if (Q(d)) for(c = 0, h = d.length; c < h; c++)u = d[c], u != null && !Q(u) && (r = Yo(i, n, o, r, u));\n        i.restore();\n        const f = o.length / 2;\n        if (f > e.length) {\n            for(l = 0; l < f; l++)delete n[o[l]];\n            o.splice(0, f);\n        }\n        return r;\n    }\n    function xi(i, t, e) {\n        const s = i.currentDevicePixelRatio, n = e !== 0 ? Math.max(e / 2, .5) : 0;\n        return Math.round((t - n) * s) / s + n;\n    }\n    function ku(i, t) {\n        t = t || i.getContext(\"2d\"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore();\n    }\n    function Qa(i, t, e, s) {\n        Su(i, t, e, s, null);\n    }\n    function Su(i, t, e, s, n) {\n        let o, r, a, l, c, h;\n        const d = t.pointStyle, u = t.rotation, f = t.radius;\n        let p = (u || 0) * $E;\n        if (d && typeof d == \"object\" && (o = d.toString(), o === \"[object HTMLImageElement]\" || o === \"[object HTMLCanvasElement]\")) {\n            i.save(), i.translate(e, s), i.rotate(p), i.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), i.restore();\n            return;\n        }\n        if (!(isNaN(f) || f <= 0)) {\n            switch(i.beginPath(), d){\n                default:\n                    n ? i.ellipse(e, s, n / 2, f, 0, 0, q) : i.arc(e, s, f, 0, q), i.closePath();\n                    break;\n                case \"triangle\":\n                    i.moveTo(e + Math.sin(p) * f, s - Math.cos(p) * f), p += su, i.lineTo(e + Math.sin(p) * f, s - Math.cos(p) * f), p += su, i.lineTo(e + Math.sin(p) * f, s - Math.cos(p) * f), i.closePath();\n                    break;\n                case \"rectRounded\":\n                    c = f * .516, l = f - c, r = Math.cos(p + Zs) * l, a = Math.sin(p + Zs) * l, i.arc(e - r, s - a, c, p - et, p - nt), i.arc(e + a, s - r, c, p - nt, p), i.arc(e + r, s + a, c, p, p + nt), i.arc(e - a, s + r, c, p + nt, p + et), i.closePath();\n                    break;\n                case \"rect\":\n                    if (!u) {\n                        l = Math.SQRT1_2 * f, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);\n                        break;\n                    }\n                    p += Zs;\n                case \"rectRot\":\n                    r = Math.cos(p) * f, a = Math.sin(p) * f, i.moveTo(e - r, s - a), i.lineTo(e + a, s - r), i.lineTo(e + r, s + a), i.lineTo(e - a, s + r), i.closePath();\n                    break;\n                case \"crossRot\":\n                    p += Zs;\n                case \"cross\":\n                    r = Math.cos(p) * f, a = Math.sin(p) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n                    break;\n                case \"star\":\n                    r = Math.cos(p) * f, a = Math.sin(p) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r), p += Zs, r = Math.cos(p) * f, a = Math.sin(p) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n                    break;\n                case \"line\":\n                    r = n ? n / 2 : Math.cos(p) * f, a = Math.sin(p) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);\n                    break;\n                case \"dash\":\n                    i.moveTo(e, s), i.lineTo(e + Math.cos(p) * f, s + Math.sin(p) * f);\n                    break;\n            }\n            i.fill(), t.borderWidth > 0 && i.stroke();\n        }\n    }\n    function on(i, t, e) {\n        return e = e || .5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;\n    }\n    function Ko(i, t) {\n        i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();\n    }\n    function Uo(i) {\n        i.restore();\n    }\n    function bC(i, t, e, s, n) {\n        if (!t) return i.lineTo(e.x, e.y);\n        if (n === \"middle\") {\n            const o = (t.x + e.x) / 2;\n            i.lineTo(o, t.y), i.lineTo(o, e.y);\n        } else n === \"after\" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);\n        i.lineTo(e.x, e.y);\n    }\n    function vC(i, t, e, s) {\n        if (!t) return i.lineTo(e.x, e.y);\n        i.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y);\n    }\n    function Ei(i, t, e, s, n, o = {}) {\n        const r = Q(t) ? t : [\n            t\n        ], a = o.strokeWidth > 0 && o.strokeColor !== \"\";\n        let l, c;\n        for(i.save(), i.font = n.string, yC(i, o), l = 0; l < r.length; ++l)c = r[l], a && (o.strokeColor && (i.strokeStyle = o.strokeColor), N(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), xC(i, e, s, c, o), s += n.lineHeight;\n        i.restore();\n    }\n    function yC(i, t) {\n        t.translation && i.translate(t.translation[0], t.translation[1]), N(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);\n    }\n    function xC(i, t, e, s, n) {\n        if (n.strikethrough || n.underline) {\n            const o = i.measureText(s), r = t - o.actualBoundingBoxLeft, a = t + o.actualBoundingBoxRight, l = e - o.actualBoundingBoxAscent, c = e + o.actualBoundingBoxDescent, h = n.strikethrough ? (l + c) / 2 : c;\n            i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();\n        }\n    }\n    function rn(i, t) {\n        const { x: e, y: s, w: n, h: o, radius: r } = t;\n        i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, -nt, et, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, et, nt, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, nt, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -nt, !0), i.lineTo(e + r.topLeft, s);\n    }\n    const EC = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/), CC = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\n    function TC(i, t) {\n        const e = (\"\" + i).match(EC);\n        if (!e || e[1] === \"normal\") return t * 1.2;\n        switch(i = +e[2], e[3]){\n            case \"px\":\n                return i;\n            case \"%\":\n                i /= 100;\n                break;\n        }\n        return t * i;\n    }\n    const AC = (i)=>+i || 0;\n    function Ja(i, t) {\n        const e = {}, s = $(t), n = s ? Object.keys(t) : t, o = $(i) ? s ? (r)=>R(i[r], i[t[r]]) : (r)=>i[r] : ()=>i;\n        for (const r of n)e[r] = AC(o(r));\n        return e;\n    }\n    function Ou(i) {\n        return Ja(i, {\n            top: \"y\",\n            right: \"x\",\n            bottom: \"y\",\n            left: \"x\"\n        });\n    }\n    function Ci(i) {\n        return Ja(i, [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]);\n    }\n    function ht(i) {\n        const t = Ou(i);\n        return t.width = t.left + t.right, t.height = t.top + t.bottom, t;\n    }\n    function lt(i, t) {\n        i = i || {}, t = t || B.font;\n        let e = R(i.size, t.size);\n        typeof e == \"string\" && (e = parseInt(e, 10));\n        let s = R(i.style, t.style);\n        s && !(\"\" + s).match(CC) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = \"\");\n        const n = {\n            family: R(i.family, t.family),\n            lineHeight: TC(R(i.lineHeight, t.lineHeight), e),\n            size: e,\n            style: s,\n            weight: R(i.weight, t.weight),\n            string: \"\"\n        };\n        return n.string = gC(n), n;\n    }\n    function tt(i, t, e, s) {\n        let n = !0, o, r, a;\n        for(o = 0, r = i.length; o < r; ++o)if (a = i[o], a !== void 0 && (t !== void 0 && typeof a == \"function\" && (a = a(t), n = !1), e !== void 0 && Q(a) && (a = a[e % a.length], n = !1), a !== void 0)) return s && !n && (s.cacheable = !1), a;\n    }\n    function wC(i, t, e) {\n        const { min: s, max: n } = i, o = Jd(t, (n - s) / 2), r = (a, l)=>e && a === 0 ? 0 : a + l;\n        return {\n            min: r(s, -Math.abs(o)),\n            max: r(n, o)\n        };\n    }\n    function qe(i, t) {\n        return Object.assign(Object.create(i), t);\n    }\n    function tl(i, t = [\n        \"\"\n    ], e = i, s, n = ()=>i[0]) {\n        Ft(s) || (s = Pu(\"_fallback\", i));\n        const o = {\n            [Symbol.toStringTag]: \"Object\",\n            _cacheable: !0,\n            _scopes: i,\n            _rootScopes: e,\n            _fallback: s,\n            _getTarget: n,\n            override: (r)=>tl([\n                    r,\n                    ...i\n                ], t, e, s)\n        };\n        return new Proxy(o, {\n            deleteProperty (r, a) {\n                return delete r[a], delete r._keys, delete i[0][a], !0;\n            },\n            get (r, a) {\n                return Mu(r, a, ()=>PC(a, t, i, r));\n            },\n            getOwnPropertyDescriptor (r, a) {\n                return Reflect.getOwnPropertyDescriptor(r._scopes[0], a);\n            },\n            getPrototypeOf () {\n                return Reflect.getPrototypeOf(i[0]);\n            },\n            has (r, a) {\n                return Ru(r).includes(a);\n            },\n            ownKeys (r) {\n                return Ru(r);\n            },\n            set (r, a, l) {\n                const c = r._storage || (r._storage = n());\n                return r[a] = c[a] = l, delete r._keys, !0;\n            }\n        });\n    }\n    function cs(i, t, e, s) {\n        const n = {\n            _cacheable: !1,\n            _proxy: i,\n            _context: t,\n            _subProxy: e,\n            _stack: new Set,\n            _descriptors: Du(i, s),\n            setContext: (o)=>cs(i, o, e, s),\n            override: (o)=>cs(i.override(o), t, e, s)\n        };\n        return new Proxy(n, {\n            deleteProperty (o, r) {\n                return delete o[r], delete i[r], !0;\n            },\n            get (o, r, a) {\n                return Mu(o, r, ()=>SC(o, r, a));\n            },\n            getOwnPropertyDescriptor (o, r) {\n                return o._descriptors.allKeys ? Reflect.has(i, r) ? {\n                    enumerable: !0,\n                    configurable: !0\n                } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);\n            },\n            getPrototypeOf () {\n                return Reflect.getPrototypeOf(i);\n            },\n            has (o, r) {\n                return Reflect.has(i, r);\n            },\n            ownKeys () {\n                return Reflect.ownKeys(i);\n            },\n            set (o, r, a) {\n                return i[r] = a, delete o[r], !0;\n            }\n        });\n    }\n    function Du(i, t = {\n        scriptable: !0,\n        indexable: !0\n    }) {\n        const { _scriptable: e = t.scriptable, _indexable: s = t.indexable, _allKeys: n = t.allKeys } = i;\n        return {\n            allKeys: n,\n            scriptable: e,\n            indexable: s,\n            isScriptable: Ue(e) ? e : ()=>e,\n            isIndexable: Ue(s) ? s : ()=>s\n        };\n    }\n    const kC = (i, t)=>i ? i + Ha(t) : t, el = (i, t)=>$(t) && i !== \"adapters\" && (Object.getPrototypeOf(t) === null || t.constructor === Object);\n    function Mu(i, t, e) {\n        if (Object.prototype.hasOwnProperty.call(i, t)) return i[t];\n        const s = e();\n        return i[t] = s, s;\n    }\n    function SC(i, t, e) {\n        const { _proxy: s, _context: n, _subProxy: o, _descriptors: r } = i;\n        let a = s[t];\n        return Ue(a) && r.isScriptable(t) && (a = OC(t, a, i, e)), Q(a) && a.length && (a = DC(t, a, i, r.isIndexable)), el(t, a) && (a = cs(a, n, o && o[t], r)), a;\n    }\n    function OC(i, t, e, s) {\n        const { _proxy: n, _context: o, _subProxy: r, _stack: a } = e;\n        if (a.has(i)) throw new Error(\"Recursion detected: \" + Array.from(a).join(\"->\") + \"->\" + i);\n        return a.add(i), t = t(o, r || s), a.delete(i), el(i, t) && (t = il(n._scopes, n, i, t)), t;\n    }\n    function DC(i, t, e, s) {\n        const { _proxy: n, _context: o, _subProxy: r, _descriptors: a } = e;\n        if (Ft(o.index) && s(i)) t = t[o.index % t.length];\n        else if ($(t[0])) {\n            const l = t, c = n._scopes.filter((h)=>h !== l);\n            t = [];\n            for (const h of l){\n                const d = il(c, n, i, h);\n                t.push(cs(d, o, r && r[i], a));\n            }\n        }\n        return t;\n    }\n    function Iu(i, t, e) {\n        return Ue(i) ? i(t, e) : i;\n    }\n    const MC = (i, t)=>i === !0 ? t : typeof i == \"string\" ? Ke(t, i) : void 0;\n    function IC(i, t, e, s, n) {\n        for (const o of t){\n            const r = MC(e, o);\n            if (r) {\n                i.add(r);\n                const a = Iu(r._fallback, e, n);\n                if (Ft(a) && a !== e && a !== s) return a;\n            } else if (r === !1 && Ft(s) && e !== s) return null;\n        }\n        return !1;\n    }\n    function il(i, t, e, s) {\n        const n = t._rootScopes, o = Iu(t._fallback, e, s), r = [\n            ...i,\n            ...n\n        ], a = new Set;\n        a.add(s);\n        let l = Lu(a, r, e, o || e, s);\n        return l === null || Ft(o) && o !== e && (l = Lu(a, r, o, l, s), l === null) ? !1 : tl(Array.from(a), [\n            \"\"\n        ], n, o, ()=>LC(t, e, s));\n    }\n    function Lu(i, t, e, s, n) {\n        for(; e;)e = IC(i, t, e, s, n);\n        return e;\n    }\n    function LC(i, t, e) {\n        const s = i._getTarget();\n        t in s || (s[t] = {});\n        const n = s[t];\n        return Q(n) && $(e) ? e : n;\n    }\n    function PC(i, t, e, s) {\n        let n;\n        for (const o of t)if (n = Pu(kC(o, i), e), Ft(n)) return el(i, n) ? il(e, s, i, n) : n;\n    }\n    function Pu(i, t) {\n        for (const e of t){\n            if (!e) continue;\n            const s = e[i];\n            if (Ft(s)) return s;\n        }\n    }\n    function Ru(i) {\n        let t = i._keys;\n        return t || (t = i._keys = RC(i._scopes)), t;\n    }\n    function RC(i) {\n        const t = new Set;\n        for (const e of i)for (const s of Object.keys(e).filter((n)=>!n.startsWith(\"_\")))t.add(s);\n        return Array.from(t);\n    }\n    function Nu(i, t, e, s) {\n        const { iScale: n } = i, { key: o = \"r\" } = this._parsing, r = new Array(s);\n        let a, l, c, h;\n        for(a = 0, l = s; a < l; ++a)c = a + e, h = t[c], r[a] = {\n            r: n.parse(Ke(h, o), c)\n        };\n        return r;\n    }\n    const NC = Number.EPSILON || 1e-14, hs = (i, t)=>t < i.length && !i[t].skip && i[t], $u = (i)=>i === \"x\" ? \"y\" : \"x\";\n    function $C(i, t, e, s) {\n        const n = i.skip ? t : i, o = t, r = e.skip ? t : e, a = Va(o, n), l = Va(r, o);\n        let c = a / (a + l), h = l / (a + l);\n        c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;\n        const d = s * c, u = s * h;\n        return {\n            previous: {\n                x: o.x - d * (r.x - n.x),\n                y: o.y - d * (r.y - n.y)\n            },\n            next: {\n                x: o.x + u * (r.x - n.x),\n                y: o.y + u * (r.y - n.y)\n            }\n        };\n    }\n    function BC(i, t, e) {\n        const s = i.length;\n        let n, o, r, a, l, c = hs(i, 0);\n        for(let h = 0; h < s - 1; ++h)if (l = c, c = hs(i, h + 1), !(!l || !c)) {\n            if (Qs(t[h], 0, NC)) {\n                e[h] = e[h + 1] = 0;\n                continue;\n            }\n            n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);\n        }\n    }\n    function HC(i, t, e = \"x\") {\n        const s = $u(e), n = i.length;\n        let o, r, a, l = hs(i, 0);\n        for(let c = 0; c < n; ++c){\n            if (r = a, a = l, l = hs(i, c + 1), !a) continue;\n            const h = a[e], d = a[s];\n            r && (o = (h - r[e]) / 3, a[`cp1${e}`] = h - o, a[`cp1${s}`] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[`cp2${e}`] = h + o, a[`cp2${s}`] = d + o * t[c]);\n        }\n    }\n    function FC(i, t = \"x\") {\n        const e = $u(t), s = i.length, n = Array(s).fill(0), o = Array(s);\n        let r, a, l, c = hs(i, 0);\n        for(r = 0; r < s; ++r)if (a = l, l = c, c = hs(i, r + 1), !!l) {\n            if (c) {\n                const h = c[t] - l[t];\n                n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;\n            }\n            o[r] = a ? c ? me(n[r - 1]) !== me(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];\n        }\n        BC(i, n, o), HC(i, o, t);\n    }\n    function Xo(i, t, e) {\n        return Math.max(Math.min(i, e), t);\n    }\n    function VC(i, t) {\n        let e, s, n, o, r, a = on(i[0], t);\n        for(e = 0, s = i.length; e < s; ++e)r = o, o = a, a = e < s - 1 && on(i[e + 1], t), o && (n = i[e], r && (n.cp1x = Xo(n.cp1x, t.left, t.right), n.cp1y = Xo(n.cp1y, t.top, t.bottom)), a && (n.cp2x = Xo(n.cp2x, t.left, t.right), n.cp2y = Xo(n.cp2y, t.top, t.bottom)));\n    }\n    function WC(i, t, e, s, n) {\n        let o, r, a, l;\n        if (t.spanGaps && (i = i.filter((c)=>!c.skip)), t.cubicInterpolationMode === \"monotone\") FC(i, n);\n        else {\n            let c = s ? i[i.length - 1] : i[0];\n            for(o = 0, r = i.length; o < r; ++o)a = i[o], l = $C(c, a, i[Math.min(o + 1, r - (s ? 0 : 1)) % r], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;\n        }\n        t.capBezierPoints && VC(i, e);\n    }\n    function Bu() {\n        return typeof window < \"u\" && typeof document < \"u\";\n    }\n    function sl(i) {\n        let t = i.parentNode;\n        return t && t.toString() === \"[object ShadowRoot]\" && (t = t.host), t;\n    }\n    function Go(i, t, e) {\n        let s;\n        return typeof i == \"string\" ? (s = parseInt(i, 10), i.indexOf(\"%\") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;\n    }\n    const qo = (i)=>window.getComputedStyle(i, null);\n    function zC(i, t) {\n        return qo(i).getPropertyValue(t);\n    }\n    const jC = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    function Ti(i, t, e) {\n        const s = {};\n        e = e ? \"-\" + e : \"\";\n        for(let n = 0; n < 4; n++){\n            const o = jC[n];\n            s[o] = parseFloat(i[t + \"-\" + o + e]) || 0;\n        }\n        return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n    }\n    const YC = (i, t, e)=>(i > 0 || t > 0) && (!e || !e.shadowRoot);\n    function KC(i, t) {\n        const e = i.touches, s = e && e.length ? e[0] : i, { offsetX: n, offsetY: o } = s;\n        let r = !1, a, l;\n        if (YC(n, o, i.target)) a = n, l = o;\n        else {\n            const c = t.getBoundingClientRect();\n            a = s.clientX - c.left, l = s.clientY - c.top, r = !0;\n        }\n        return {\n            x: a,\n            y: l,\n            box: r\n        };\n    }\n    function Ai(i, t) {\n        if (\"native\" in i) return i;\n        const { canvas: e, currentDevicePixelRatio: s } = t, n = qo(e), o = n.boxSizing === \"border-box\", r = Ti(n, \"padding\"), a = Ti(n, \"border\", \"width\"), { x: l, y: c, box: h } = KC(i, e), d = r.left + (h && a.left), u = r.top + (h && a.top);\n        let { width: f, height: p } = t;\n        return o && (f -= r.width + a.width, p -= r.height + a.height), {\n            x: Math.round((l - d) / f * e.width / s),\n            y: Math.round((c - u) / p * e.height / s)\n        };\n    }\n    function UC(i, t, e) {\n        let s, n;\n        if (t === void 0 || e === void 0) {\n            const o = sl(i);\n            if (!o) t = i.clientWidth, e = i.clientHeight;\n            else {\n                const r = o.getBoundingClientRect(), a = qo(o), l = Ti(a, \"border\", \"width\"), c = Ti(a, \"padding\");\n                t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = Go(a.maxWidth, o, \"clientWidth\"), n = Go(a.maxHeight, o, \"clientHeight\");\n            }\n        }\n        return {\n            width: t,\n            height: e,\n            maxWidth: s || Ho,\n            maxHeight: n || Ho\n        };\n    }\n    const nl = (i)=>Math.round(i * 10) / 10;\n    function XC(i, t, e, s) {\n        const n = qo(i), o = Ti(n, \"margin\"), r = Go(n.maxWidth, i, \"clientWidth\") || Ho, a = Go(n.maxHeight, i, \"clientHeight\") || Ho, l = UC(i, t, e);\n        let { width: c, height: h } = l;\n        if (n.boxSizing === \"content-box\") {\n            const d = Ti(n, \"border\", \"width\"), u = Ti(n, \"padding\");\n            c -= u.width + d.width, h -= u.height + d.height;\n        }\n        return c = Math.max(0, c - o.width), h = Math.max(0, s ? Math.floor(c / s) : h - o.height), c = nl(Math.min(c, r, l.maxWidth)), h = nl(Math.min(h, a, l.maxHeight)), c && !h && (h = nl(c / 2)), {\n            width: c,\n            height: h\n        };\n    }\n    function Hu(i, t, e) {\n        const s = t || 1, n = Math.floor(i.height * s), o = Math.floor(i.width * s);\n        i.height = n / s, i.width = o / s;\n        const r = i.canvas;\n        return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = `${i.height}px`, r.style.width = `${i.width}px`), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;\n    }\n    const GC = function() {\n        let i = !1;\n        try {\n            const t = {\n                get passive () {\n                    return i = !0, !1;\n                }\n            };\n            window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t);\n        } catch  {}\n        return i;\n    }();\n    function Fu(i, t) {\n        const e = zC(i, t), s = e && e.match(/^(\\d+)(\\.\\d+)?px$/);\n        return s ? +s[1] : void 0;\n    }\n    function wi(i, t, e, s) {\n        return {\n            x: i.x + e * (t.x - i.x),\n            y: i.y + e * (t.y - i.y)\n        };\n    }\n    function qC(i, t, e, s) {\n        return {\n            x: i.x + e * (t.x - i.x),\n            y: s === \"middle\" ? e < .5 ? i.y : t.y : s === \"after\" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y\n        };\n    }\n    function ZC(i, t, e, s) {\n        const n = {\n            x: i.cp2x,\n            y: i.cp2y\n        }, o = {\n            x: t.cp1x,\n            y: t.cp1y\n        }, r = wi(i, n, e), a = wi(n, o, e), l = wi(o, t, e), c = wi(r, a, e), h = wi(a, l, e);\n        return wi(c, h, e);\n    }\n    const Vu = new Map;\n    function QC(i, t) {\n        t = t || {};\n        const e = i + JSON.stringify(t);\n        let s = Vu.get(e);\n        return s || (s = new Intl.NumberFormat(i, t), Vu.set(e, s)), s;\n    }\n    function an(i, t, e) {\n        return QC(t, e).format(i);\n    }\n    const JC = function(i, t) {\n        return {\n            x (e) {\n                return i + i + t - e;\n            },\n            setWidth (e) {\n                t = e;\n            },\n            textAlign (e) {\n                return e === \"center\" ? e : e === \"right\" ? \"left\" : \"right\";\n            },\n            xPlus (e, s) {\n                return e - s;\n            },\n            leftForLtr (e, s) {\n                return e - s;\n            }\n        };\n    }, tT = function() {\n        return {\n            x (i) {\n                return i;\n            },\n            setWidth (i) {},\n            textAlign (i) {\n                return i;\n            },\n            xPlus (i, t) {\n                return i + t;\n            },\n            leftForLtr (i, t) {\n                return i;\n            }\n        };\n    };\n    function ds(i, t, e) {\n        return i ? JC(t, e) : tT();\n    }\n    function Wu(i, t) {\n        let e, s;\n        (t === \"ltr\" || t === \"rtl\") && (e = i.canvas.style, s = [\n            e.getPropertyValue(\"direction\"),\n            e.getPropertyPriority(\"direction\")\n        ], e.setProperty(\"direction\", t, \"important\"), i.prevTextDirection = s);\n    }\n    function zu(i, t) {\n        t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty(\"direction\", t[0], t[1]));\n    }\n    function ju(i) {\n        return i === \"angle\" ? {\n            between: Js,\n            compare: FE,\n            normalize: Nt\n        } : {\n            between: Ae,\n            compare: (t, e)=>t - e,\n            normalize: (t)=>t\n        };\n    }\n    function Yu({ start: i, end: t, count: e, loop: s, style: n }) {\n        return {\n            start: i % e,\n            end: t % e,\n            loop: s && (t - i + 1) % e === 0,\n            style: n\n        };\n    }\n    function eT(i, t, e) {\n        const { property: s, start: n, end: o } = e, { between: r, normalize: a } = ju(s), l = t.length;\n        let { start: c, end: h, loop: d } = i, u, f;\n        if (d) {\n            for(c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u)c--, h--;\n            c %= l, h %= l;\n        }\n        return h < c && (h += l), {\n            start: c,\n            end: h,\n            loop: d,\n            style: i.style\n        };\n    }\n    function Ku(i, t, e) {\n        if (!e) return [\n            i\n        ];\n        const { property: s, start: n, end: o } = e, r = t.length, { compare: a, between: l, normalize: c } = ju(s), { start: h, end: d, loop: u, style: f } = eT(i, t, e), p = [];\n        let _ = !1, m = null, y, x, E;\n        const C = ()=>l(n, E, y) && a(n, E) !== 0, T = ()=>a(o, y) === 0 || l(o, E, y), A = ()=>_ || C(), w = ()=>!_ || T();\n        for(let S = h, k = h; S <= d; ++S)x = t[S % r], !x.skip && (y = c(x[s]), y !== E && (_ = l(y, n, o), m === null && A() && (m = a(y, n) === 0 ? S : k), m !== null && w() && (p.push(Yu({\n            start: m,\n            end: S,\n            loop: u,\n            count: r,\n            style: f\n        })), m = null), k = S, E = y));\n        return m !== null && p.push(Yu({\n            start: m,\n            end: d,\n            loop: u,\n            count: r,\n            style: f\n        })), p;\n    }\n    function Uu(i, t) {\n        const e = [], s = i.segments;\n        for(let n = 0; n < s.length; n++){\n            const o = Ku(s[n], i.points, t);\n            o.length && e.push(...o);\n        }\n        return e;\n    }\n    function iT(i, t, e, s) {\n        let n = 0, o = t - 1;\n        if (e && !s) for(; n < t && !i[n].skip;)n++;\n        for(; n < t && i[n].skip;)n++;\n        for(n %= t, e && (o += n); o > n && i[o % t].skip;)o--;\n        return o %= t, {\n            start: n,\n            end: o\n        };\n    }\n    function sT(i, t, e, s) {\n        const n = i.length, o = [];\n        let r = t, a = i[t], l;\n        for(l = t + 1; l <= e; ++l){\n            const c = i[l % n];\n            c.skip || c.stop ? a.skip || (s = !1, o.push({\n                start: t % n,\n                end: (l - 1) % n,\n                loop: s\n            }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;\n        }\n        return r !== null && o.push({\n            start: t % n,\n            end: r % n,\n            loop: s\n        }), o;\n    }\n    function nT(i, t) {\n        const e = i.points, s = i.options.spanGaps, n = e.length;\n        if (!n) return [];\n        const o = !!i._loop, { start: r, end: a } = iT(e, n, o, s);\n        if (s === !0) return Xu(i, [\n            {\n                start: r,\n                end: a,\n                loop: o\n            }\n        ], e, t);\n        const l = a < r ? a + n : a, c = !!i._fullLoop && r === 0 && a === n - 1;\n        return Xu(i, sT(e, r, l, c), e, t);\n    }\n    function Xu(i, t, e, s) {\n        return !s || !s.setContext || !e ? t : oT(i, t, e, s);\n    }\n    function oT(i, t, e, s) {\n        const n = i._chart.getContext(), o = Gu(i.options), { _datasetIndex: r, options: { spanGaps: a } } = i, l = e.length, c = [];\n        let h = o, d = t[0].start, u = d;\n        function f(p, _, m, y) {\n            const x = a ? -1 : 1;\n            if (p !== _) {\n                for(p += l; e[p % l].skip;)p -= x;\n                for(; e[_ % l].skip;)_ += x;\n                p % l !== _ % l && (c.push({\n                    start: p % l,\n                    end: _ % l,\n                    loop: m,\n                    style: y\n                }), h = y, d = _ % l);\n            }\n        }\n        for (const p of t){\n            d = a ? d : p.start;\n            let _ = e[d % l], m;\n            for(u = d + 1; u <= p.end; u++){\n                const y = e[u % l];\n                m = Gu(s.setContext(qe(n, {\n                    type: \"segment\",\n                    p0: _,\n                    p1: y,\n                    p0DataIndex: (u - 1) % l,\n                    p1DataIndex: u % l,\n                    datasetIndex: r\n                }))), rT(m, h) && f(d, u - 1, p.loop, h), _ = y, h = m;\n            }\n            d < u - 1 && f(d, u - 1, p.loop, h);\n        }\n        return c;\n    }\n    function Gu(i) {\n        return {\n            backgroundColor: i.backgroundColor,\n            borderCapStyle: i.borderCapStyle,\n            borderDash: i.borderDash,\n            borderDashOffset: i.borderDashOffset,\n            borderJoinStyle: i.borderJoinStyle,\n            borderWidth: i.borderWidth,\n            borderColor: i.borderColor\n        };\n    }\n    function rT(i, t) {\n        return t && JSON.stringify(i) !== JSON.stringify(t);\n    } /*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n    class aT {\n        constructor(){\n            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0;\n        }\n        _notify(t, e, s, n) {\n            const o = e.listeners[n], r = e.duration;\n            o.forEach((a)=>a({\n                    chart: t,\n                    initial: e.initial,\n                    numSteps: r,\n                    currentStep: Math.min(s - e.start, r)\n                }));\n        }\n        _refresh() {\n            this._request || (this._running = !0, this._request = du.call(window, ()=>{\n                this._update(), this._request = null, this._running && this._refresh();\n            }));\n        }\n        _update(t = Date.now()) {\n            let e = 0;\n            this._charts.forEach((s, n)=>{\n                if (!s.running || !s.items.length) return;\n                const o = s.items;\n                let r = o.length - 1, a = !1, l;\n                for(; r >= 0; --r)l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());\n                a && (n.draw(), this._notify(n, s, t, \"progress\")), o.length || (s.running = !1, this._notify(n, s, t, \"complete\"), s.initial = !1), e += o.length;\n            }), this._lastDate = t, e === 0 && (this._running = !1);\n        }\n        _getAnims(t) {\n            const e = this._charts;\n            let s = e.get(t);\n            return s || (s = {\n                running: !1,\n                initial: !0,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            }, e.set(t, s)), s;\n        }\n        listen(t, e, s) {\n            this._getAnims(t).listeners[e].push(s);\n        }\n        add(t, e) {\n            !e || !e.length || this._getAnims(t).items.push(...e);\n        }\n        has(t) {\n            return this._getAnims(t).items.length > 0;\n        }\n        start(t) {\n            const e = this._charts.get(t);\n            e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((s, n)=>Math.max(s, n._duration), 0), this._refresh());\n        }\n        running(t) {\n            if (!this._running) return !1;\n            const e = this._charts.get(t);\n            return !(!e || !e.running || !e.items.length);\n        }\n        stop(t) {\n            const e = this._charts.get(t);\n            if (!e || !e.items.length) return;\n            const s = e.items;\n            let n = s.length - 1;\n            for(; n >= 0; --n)s[n].cancel();\n            e.items = [], this._notify(t, e, Date.now(), \"complete\");\n        }\n        remove(t) {\n            return this._charts.delete(t);\n        }\n    }\n    var be = new aT;\n    const qu = \"transparent\", lT = {\n        boolean (i, t, e) {\n            return e > .5 ? t : i;\n        },\n        color (i, t, e) {\n            const s = wu(i || qu), n = s.valid && wu(t || qu);\n            return n && n.valid ? n.mix(s, e).hexString() : t;\n        },\n        number (i, t, e) {\n            return i + (t - i) * e;\n        }\n    };\n    class Zu {\n        constructor(t, e, s, n){\n            const o = e[s];\n            n = tt([\n                t.to,\n                n,\n                o,\n                t.from\n            ]);\n            const r = tt([\n                t.from,\n                o,\n                n\n            ]);\n            this._active = !0, this._fn = t.fn || lT[t.type || typeof r], this._easing = tn[t.easing] || tn.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;\n        }\n        active() {\n            return this._active;\n        }\n        update(t, e, s) {\n            if (this._active) {\n                this._notify(!1);\n                const n = this._target[this._prop], o = s - this._start, r = this._duration - o;\n                this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = tt([\n                    t.to,\n                    e,\n                    n,\n                    t.from\n                ]), this._from = tt([\n                    t.from,\n                    n,\n                    e\n                ]);\n            }\n        }\n        cancel() {\n            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n        }\n        tick(t) {\n            const e = t - this._start, s = this._duration, n = this._prop, o = this._from, r = this._loop, a = this._to;\n            let l;\n            if (this._active = o !== a && (r || e < s), !this._active) {\n                this._target[n] = a, this._notify(!0);\n                return;\n            }\n            if (e < 0) {\n                this._target[n] = o;\n                return;\n            }\n            l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);\n        }\n        wait() {\n            const t = this._promises || (this._promises = []);\n            return new Promise((e, s)=>{\n                t.push({\n                    res: e,\n                    rej: s\n                });\n            });\n        }\n        _notify(t) {\n            const e = t ? \"res\" : \"rej\", s = this._promises || [];\n            for(let n = 0; n < s.length; n++)s[n][e]();\n        }\n    }\n    const cT = [\n        \"x\",\n        \"y\",\n        \"borderWidth\",\n        \"radius\",\n        \"tension\"\n    ], hT = [\n        \"color\",\n        \"borderColor\",\n        \"backgroundColor\"\n    ];\n    B.set(\"animation\", {\n        delay: void 0,\n        duration: 1e3,\n        easing: \"easeOutQuart\",\n        fn: void 0,\n        from: void 0,\n        loop: void 0,\n        to: void 0,\n        type: void 0\n    });\n    const dT = Object.keys(B.animation);\n    B.describe(\"animation\", {\n        _fallback: !1,\n        _indexable: !1,\n        _scriptable: (i)=>i !== \"onProgress\" && i !== \"onComplete\" && i !== \"fn\"\n    }), B.set(\"animations\", {\n        colors: {\n            type: \"color\",\n            properties: hT\n        },\n        numbers: {\n            type: \"number\",\n            properties: cT\n        }\n    }), B.describe(\"animations\", {\n        _fallback: \"animation\"\n    }), B.set(\"transitions\", {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    easing: \"linear\",\n                    fn: (i)=>i | 0\n                }\n            }\n        }\n    });\n    class ol {\n        constructor(t, e){\n            this._chart = t, this._properties = new Map, this.configure(e);\n        }\n        configure(t) {\n            if (!$(t)) return;\n            const e = this._properties;\n            Object.getOwnPropertyNames(t).forEach((s)=>{\n                const n = t[s];\n                if (!$(n)) return;\n                const o = {};\n                for (const r of dT)o[r] = n[r];\n                (Q(n.properties) && n.properties || [\n                    s\n                ]).forEach((r)=>{\n                    (r === s || !e.has(r)) && e.set(r, o);\n                });\n            });\n        }\n        _animateOptions(t, e) {\n            const s = e.options, n = fT(t, s);\n            if (!n) return [];\n            const o = this._createAnimations(n, s);\n            return s.$shared && uT(t.options.$animations, s).then(()=>{\n                t.options = s;\n            }, ()=>{}), o;\n        }\n        _createAnimations(t, e) {\n            const s = this._properties, n = [], o = t.$animations || (t.$animations = {}), r = Object.keys(e), a = Date.now();\n            let l;\n            for(l = r.length - 1; l >= 0; --l){\n                const c = r[l];\n                if (c.charAt(0) === \"$\") continue;\n                if (c === \"options\") {\n                    n.push(...this._animateOptions(t, e));\n                    continue;\n                }\n                const h = e[c];\n                let d = o[c];\n                const u = s.get(c);\n                if (d) {\n                    if (u && d.active()) {\n                        d.update(u, h, a);\n                        continue;\n                    } else d.cancel();\n                }\n                if (!u || !u.duration) {\n                    t[c] = h;\n                    continue;\n                }\n                o[c] = d = new Zu(u, t, c, h), n.push(d);\n            }\n            return n;\n        }\n        update(t, e) {\n            if (this._properties.size === 0) {\n                Object.assign(t, e);\n                return;\n            }\n            const s = this._createAnimations(t, e);\n            if (s.length) return be.add(this._chart, s), !0;\n        }\n    }\n    function uT(i, t) {\n        const e = [], s = Object.keys(t);\n        for(let n = 0; n < s.length; n++){\n            const o = i[s[n]];\n            o && o.active() && e.push(o.wait());\n        }\n        return Promise.all(e);\n    }\n    function fT(i, t) {\n        if (!t) return;\n        let e = i.options;\n        if (!e) {\n            i.options = t;\n            return;\n        }\n        return e.$shared && (i.options = e = Object.assign({}, e, {\n            $shared: !1,\n            $animations: {}\n        })), e;\n    }\n    function Qu(i, t) {\n        const e = i && i.options || {}, s = e.reverse, n = e.min === void 0 ? t : 0, o = e.max === void 0 ? t : 0;\n        return {\n            start: s ? o : n,\n            end: s ? n : o\n        };\n    }\n    function pT(i, t, e) {\n        if (e === !1) return !1;\n        const s = Qu(i, e), n = Qu(t, e);\n        return {\n            top: n.end,\n            right: s.end,\n            bottom: n.start,\n            left: s.start\n        };\n    }\n    function _T(i) {\n        let t, e, s, n;\n        return $(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {\n            top: t,\n            right: e,\n            bottom: s,\n            left: n,\n            disabled: i === !1\n        };\n    }\n    function Ju(i, t) {\n        const e = [], s = i._getSortedDatasetMetas(t);\n        let n, o;\n        for(n = 0, o = s.length; n < o; ++n)e.push(s[n].index);\n        return e;\n    }\n    function tf(i, t, e, s = {}) {\n        const n = i.keys, o = s.mode === \"single\";\n        let r, a, l, c;\n        if (t !== null) {\n            for(r = 0, a = n.length; r < a; ++r){\n                if (l = +n[r], l === e) {\n                    if (s.all) continue;\n                    break;\n                }\n                c = i.values[l], rt(c) && (o || t === 0 || me(t) === me(c)) && (t += c);\n            }\n            return t;\n        }\n    }\n    function gT(i) {\n        const t = Object.keys(i), e = new Array(t.length);\n        let s, n, o;\n        for(s = 0, n = t.length; s < n; ++s)o = t[s], e[s] = {\n            x: o,\n            y: i[o]\n        };\n        return e;\n    }\n    function ef(i, t) {\n        const e = i && i.options.stacked;\n        return e || e === void 0 && t.stack !== void 0;\n    }\n    function mT(i, t, e) {\n        return `${i.id}.${t.id}.${e.stack || e.type}`;\n    }\n    function bT(i) {\n        const { min: t, max: e, minDefined: s, maxDefined: n } = i.getUserBounds();\n        return {\n            min: s ? t : Number.NEGATIVE_INFINITY,\n            max: n ? e : Number.POSITIVE_INFINITY\n        };\n    }\n    function vT(i, t, e) {\n        const s = i[t] || (i[t] = {});\n        return s[e] || (s[e] = {});\n    }\n    function sf(i, t, e, s) {\n        for (const n of t.getMatchingVisibleMetas(s).reverse()){\n            const o = i[n.index];\n            if (e && o > 0 || !e && o < 0) return n.index;\n        }\n        return null;\n    }\n    function nf(i, t) {\n        const { chart: e, _cachedMeta: s } = i, n = e._stacks || (e._stacks = {}), { iScale: o, vScale: r, index: a } = s, l = o.axis, c = r.axis, h = mT(o, r, s), d = t.length;\n        let u;\n        for(let f = 0; f < d; ++f){\n            const p = t[f], { [l]: _, [c]: m } = p, y = p._stacks || (p._stacks = {});\n            u = y[c] = vT(n, h, _), u[a] = m, u._top = sf(u, r, !0, s.type), u._bottom = sf(u, r, !1, s.type);\n        }\n    }\n    function rl(i, t) {\n        const e = i.scales;\n        return Object.keys(e).filter((s)=>e[s].axis === t).shift();\n    }\n    function yT(i, t) {\n        return qe(i, {\n            active: !1,\n            dataset: void 0,\n            datasetIndex: t,\n            index: t,\n            mode: \"default\",\n            type: \"dataset\"\n        });\n    }\n    function xT(i, t, e) {\n        return qe(i, {\n            active: !1,\n            dataIndex: t,\n            parsed: void 0,\n            raw: void 0,\n            element: e,\n            index: t,\n            mode: \"default\",\n            type: \"data\"\n        });\n    }\n    function ln(i, t) {\n        const e = i.controller.index, s = i.vScale && i.vScale.axis;\n        if (s) {\n            t = t || i._parsed;\n            for (const n of t){\n                const o = n._stacks;\n                if (!o || o[s] === void 0 || o[s][e] === void 0) return;\n                delete o[s][e];\n            }\n        }\n    }\n    const al = (i)=>i === \"reset\" || i === \"none\", of = (i, t)=>t ? i : Object.assign({}, i), ET = (i, t, e)=>i && !t.hidden && t._stacked && {\n            keys: Ju(e, !0),\n            values: null\n        };\n    class zt {\n        constructor(t, e){\n            this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();\n        }\n        initialize() {\n            const t = this._cachedMeta;\n            this.configure(), this.linkScales(), t._stacked = ef(t.vScale, t), this.addElements();\n        }\n        updateIndex(t) {\n            this.index !== t && ln(this._cachedMeta), this.index = t;\n        }\n        linkScales() {\n            const t = this.chart, e = this._cachedMeta, s = this.getDataset(), n = (d, u, f, p)=>d === \"x\" ? u : d === \"r\" ? p : f, o = e.xAxisID = R(s.xAxisID, rl(t, \"x\")), r = e.yAxisID = R(s.yAxisID, rl(t, \"y\")), a = e.rAxisID = R(s.rAxisID, rl(t, \"r\")), l = e.indexAxis, c = e.iAxisID = n(l, o, r, a), h = e.vAxisID = n(l, r, o, a);\n            e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);\n        }\n        getDataset() {\n            return this.chart.data.datasets[this.index];\n        }\n        getMeta() {\n            return this.chart.getDatasetMeta(this.index);\n        }\n        getScaleForId(t) {\n            return this.chart.scales[t];\n        }\n        _getOtherScale(t) {\n            const e = this._cachedMeta;\n            return t === e.iScale ? e.vScale : e.iScale;\n        }\n        reset() {\n            this._update(\"reset\");\n        }\n        _destroy() {\n            const t = this._cachedMeta;\n            this._data && cu(this._data, this), t._stacked && ln(t);\n        }\n        _dataCheck() {\n            const t = this.getDataset(), e = t.data || (t.data = []), s = this._data;\n            if ($(e)) this._data = gT(e);\n            else if (s !== e) {\n                if (s) {\n                    cu(s, this);\n                    const n = this._cachedMeta;\n                    ln(n), n._parsed = [];\n                }\n                e && Object.isExtensible(e) && jE(e, this), this._syncList = [], this._data = e;\n            }\n        }\n        addElements() {\n            const t = this._cachedMeta;\n            this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType);\n        }\n        buildOrUpdateElements(t) {\n            const e = this._cachedMeta, s = this.getDataset();\n            let n = !1;\n            this._dataCheck();\n            const o = e._stacked;\n            e._stacked = ef(e.vScale, e), e.stack !== s.stack && (n = !0, ln(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && nf(this, e._parsed);\n        }\n        configure() {\n            const t = this.chart.config, e = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), e, !0);\n            this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n        }\n        parse(t, e) {\n            const { _cachedMeta: s, _data: n } = this, { iScale: o, _stacked: r } = s, a = o.axis;\n            let l = t === 0 && e === n.length ? !0 : s._sorted, c = t > 0 && s._parsed[t - 1], h, d, u;\n            if (this._parsing === !1) s._parsed = n, s._sorted = !0, u = n;\n            else {\n                Q(n[t]) ? u = this.parseArrayData(s, n, t, e) : $(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);\n                const f = ()=>d[a] === null || c && d[a] < c[a];\n                for(h = 0; h < e; ++h)s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);\n                s._sorted = l;\n            }\n            r && nf(this, u);\n        }\n        parsePrimitiveData(t, e, s, n) {\n            const { iScale: o, vScale: r } = t, a = o.axis, l = r.axis, c = o.getLabels(), h = o === r, d = new Array(n);\n            let u, f, p;\n            for(u = 0, f = n; u < f; ++u)p = u + s, d[u] = {\n                [a]: h || o.parse(c[p], p),\n                [l]: r.parse(e[p], p)\n            };\n            return d;\n        }\n        parseArrayData(t, e, s, n) {\n            const { xScale: o, yScale: r } = t, a = new Array(n);\n            let l, c, h, d;\n            for(l = 0, c = n; l < c; ++l)h = l + s, d = e[h], a[l] = {\n                x: o.parse(d[0], h),\n                y: r.parse(d[1], h)\n            };\n            return a;\n        }\n        parseObjectData(t, e, s, n) {\n            const { xScale: o, yScale: r } = t, { xAxisKey: a = \"x\", yAxisKey: l = \"y\" } = this._parsing, c = new Array(n);\n            let h, d, u, f;\n            for(h = 0, d = n; h < d; ++h)u = h + s, f = e[u], c[h] = {\n                x: o.parse(Ke(f, a), u),\n                y: r.parse(Ke(f, l), u)\n            };\n            return c;\n        }\n        getParsed(t) {\n            return this._cachedMeta._parsed[t];\n        }\n        getDataElement(t) {\n            return this._cachedMeta.data[t];\n        }\n        applyStack(t, e, s) {\n            const n = this.chart, o = this._cachedMeta, r = e[t.axis], a = {\n                keys: Ju(n, !0),\n                values: e._stacks[t.axis]\n            };\n            return tf(a, r, o.index, {\n                mode: s\n            });\n        }\n        updateRangeFromParsed(t, e, s, n) {\n            const o = s[e.axis];\n            let r = o === null ? NaN : o;\n            const a = n && s._stacks[e.axis];\n            n && a && (n.values = a, r = tf(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);\n        }\n        getMinMax(t, e) {\n            const s = this._cachedMeta, n = s._parsed, o = s._sorted && t === s.iScale, r = n.length, a = this._getOtherScale(t), l = ET(e, s, this.chart), c = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            }, { min: h, max: d } = bT(a);\n            let u, f;\n            function p() {\n                f = n[u];\n                const _ = f[a.axis];\n                return !rt(f[t.axis]) || h > _ || d < _;\n            }\n            for(u = 0; u < r && !(!p() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u);\n            if (o) {\n                for(u = r - 1; u >= 0; --u)if (!p()) {\n                    this.updateRangeFromParsed(c, t, f, l);\n                    break;\n                }\n            }\n            return c;\n        }\n        getAllParsedValues(t) {\n            const e = this._cachedMeta._parsed, s = [];\n            let n, o, r;\n            for(n = 0, o = e.length; n < o; ++n)r = e[n][t.axis], rt(r) && s.push(r);\n            return s;\n        }\n        getMaxOverflow() {\n            return !1;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, s = e.iScale, n = e.vScale, o = this.getParsed(t);\n            return {\n                label: s ? \"\" + s.getLabelForValue(o[s.axis]) : \"\",\n                value: n ? \"\" + n.getLabelForValue(o[n.axis]) : \"\"\n            };\n        }\n        _update(t) {\n            const e = this._cachedMeta;\n            this.update(t || \"default\"), e._clip = _T(R(this.options.clip, pT(e.xScale, e.yScale, this.getMaxOverflow())));\n        }\n        update(t) {}\n        draw() {\n            const t = this._ctx, e = this.chart, s = this._cachedMeta, n = s.data || [], o = e.chartArea, r = [], a = this._drawStart || 0, l = this._drawCount || n.length - a, c = this.options.drawActiveElementsOnTop;\n            let h;\n            for(s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h){\n                const d = n[h];\n                d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));\n            }\n            for(h = 0; h < r.length; ++h)r[h].draw(t, o);\n        }\n        getStyle(t, e) {\n            const s = e ? \"active\" : \"default\";\n            return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);\n        }\n        getContext(t, e, s) {\n            const n = this.getDataset();\n            let o;\n            if (t >= 0 && t < this._cachedMeta.data.length) {\n                const r = this._cachedMeta.data[t];\n                o = r.$context || (r.$context = xT(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;\n            } else o = this.$context || (this.$context = yT(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;\n            return o.active = !!e, o.mode = s, o;\n        }\n        resolveDatasetElementOptions(t) {\n            return this._resolveElementOptions(this.datasetElementType.id, t);\n        }\n        resolveDataElementOptions(t, e) {\n            return this._resolveElementOptions(this.dataElementType.id, e, t);\n        }\n        _resolveElementOptions(t, e = \"default\", s) {\n            const n = e === \"active\", o = this._cachedDataOpts, r = t + \"-\" + e, a = o[r], l = this.enableOptionSharing && Ft(s);\n            if (a) return of(a, l);\n            const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), d = n ? [\n                `${t}Hover`,\n                \"hover\",\n                t,\n                \"\"\n            ] : [\n                t,\n                \"\"\n            ], u = c.getOptionScopes(this.getDataset(), h), f = Object.keys(B.elements[t]), p = ()=>this.getContext(s, n), _ = c.resolveNamedOptions(u, f, p, d);\n            return _.$shared && (_.$shared = l, o[r] = Object.freeze(of(_, l))), _;\n        }\n        _resolveAnimations(t, e, s) {\n            const n = this.chart, o = this._cachedDataOpts, r = `animation-${e}`, a = o[r];\n            if (a) return a;\n            let l;\n            if (n.options.animation !== !1) {\n                const h = this.chart.config, d = h.datasetAnimationScopeKeys(this._type, e), u = h.getOptionScopes(this.getDataset(), d);\n                l = h.createResolver(u, this.getContext(t, s, e));\n            }\n            const c = new ol(n, l && l.animations);\n            return l && l._cacheable && (o[r] = Object.freeze(c)), c;\n        }\n        getSharedOptions(t) {\n            if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n        }\n        includeOptions(t, e) {\n            return !e || al(t) || this.chart._animationsDisabled;\n        }\n        _getSharedOptions(t, e) {\n            const s = this.resolveDataElementOptions(t, e), n = this._sharedOptions, o = this.getSharedOptions(s), r = this.includeOptions(e, o) || o !== n;\n            return this.updateSharedOptions(o, e, s), {\n                sharedOptions: o,\n                includeOptions: r\n            };\n        }\n        updateElement(t, e, s, n) {\n            al(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);\n        }\n        updateSharedOptions(t, e, s) {\n            t && !al(e) && this._resolveAnimations(void 0, e).update(t, s);\n        }\n        _setStyle(t, e, s, n) {\n            t.active = n;\n            const o = this.getStyle(e, n);\n            this._resolveAnimations(e, s, n).update(t, {\n                options: !n && this.getSharedOptions(o) || o\n            });\n        }\n        removeHoverStyle(t, e, s) {\n            this._setStyle(t, s, \"active\", !1);\n        }\n        setHoverStyle(t, e, s) {\n            this._setStyle(t, s, \"active\", !0);\n        }\n        _removeDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !1);\n        }\n        _setDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !0);\n        }\n        _resyncElements(t) {\n            const e = this._data, s = this._cachedMeta.data;\n            for (const [a, l, c] of this._syncList)this[a](l, c);\n            this._syncList = [];\n            const n = s.length, o = e.length, r = Math.min(o, n);\n            r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);\n        }\n        _insertElements(t, e, s = !0) {\n            const n = this._cachedMeta, o = n.data, r = t + e;\n            let a;\n            const l = (c)=>{\n                for(c.length += e, a = c.length - 1; a >= r; a--)c[a] = c[a - e];\n            };\n            for(l(o), a = t; a < r; ++a)o[a] = new this.dataElementType;\n            this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, \"reset\");\n        }\n        updateElements(t, e, s, n) {}\n        _removeElements(t, e) {\n            const s = this._cachedMeta;\n            if (this._parsing) {\n                const n = s._parsed.splice(t, e);\n                s._stacked && ln(s, n);\n            }\n            s.data.splice(t, e);\n        }\n        _sync(t) {\n            if (this._parsing) this._syncList.push(t);\n            else {\n                const [e, s, n] = t;\n                this[e](s, n);\n            }\n            this.chart._dataChanges.push([\n                this.index,\n                ...t\n            ]);\n        }\n        _onDataPush() {\n            const t = arguments.length;\n            this._sync([\n                \"_insertElements\",\n                this.getDataset().data.length - t,\n                t\n            ]);\n        }\n        _onDataPop() {\n            this._sync([\n                \"_removeElements\",\n                this._cachedMeta.data.length - 1,\n                1\n            ]);\n        }\n        _onDataShift() {\n            this._sync([\n                \"_removeElements\",\n                0,\n                1\n            ]);\n        }\n        _onDataSplice(t, e) {\n            e && this._sync([\n                \"_removeElements\",\n                t,\n                e\n            ]);\n            const s = arguments.length - 2;\n            s && this._sync([\n                \"_insertElements\",\n                t,\n                s\n            ]);\n        }\n        _onDataUnshift() {\n            this._sync([\n                \"_insertElements\",\n                0,\n                arguments.length\n            ]);\n        }\n    }\n    zt.defaults = {}, zt.prototype.datasetElementType = null, zt.prototype.dataElementType = null;\n    function CT(i, t) {\n        if (!i._cache.$bar) {\n            const e = i.getMatchingVisibleMetas(t);\n            let s = [];\n            for(let n = 0, o = e.length; n < o; n++)s = s.concat(e[n].controller.getAllParsedValues(i));\n            i._cache.$bar = hu(s.sort((n, o)=>n - o));\n        }\n        return i._cache.$bar;\n    }\n    function TT(i) {\n        const t = i.iScale, e = CT(t, i.type);\n        let s = t._length, n, o, r, a;\n        const l = ()=>{\n            r === 32767 || r === -32768 || (Ft(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);\n        };\n        for(n = 0, o = e.length; n < o; ++n)r = t.getPixelForValue(e[n]), l();\n        for(a = void 0, n = 0, o = t.ticks.length; n < o; ++n)r = t.getPixelForTick(n), l();\n        return s;\n    }\n    function AT(i, t, e, s) {\n        const n = e.barThickness;\n        let o, r;\n        return N(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {\n            chunk: o / s,\n            ratio: r,\n            start: t.pixels[i] - o / 2\n        };\n    }\n    function wT(i, t, e, s) {\n        const n = t.pixels, o = n[i];\n        let r = i > 0 ? n[i - 1] : null, a = i < n.length - 1 ? n[i + 1] : null;\n        const l = e.categoryPercentage;\n        r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);\n        const c = o - (o - Math.min(r, a)) / 2 * l;\n        return {\n            chunk: Math.abs(a - r) / 2 * l / s,\n            ratio: e.barPercentage,\n            start: c\n        };\n    }\n    function kT(i, t, e, s) {\n        const n = e.parse(i[0], s), o = e.parse(i[1], s), r = Math.min(n, o), a = Math.max(n, o);\n        let l = r, c = a;\n        Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {\n            barStart: l,\n            barEnd: c,\n            start: n,\n            end: o,\n            min: r,\n            max: a\n        };\n    }\n    function rf(i, t, e, s) {\n        return Q(i) ? kT(i, t, e, s) : t[e.axis] = e.parse(i, s), t;\n    }\n    function af(i, t, e, s) {\n        const n = i.iScale, o = i.vScale, r = n.getLabels(), a = n === o, l = [];\n        let c, h, d, u;\n        for(c = e, h = e + s; c < h; ++c)u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(rf(u, d, o, c));\n        return l;\n    }\n    function ll(i) {\n        return i && i.barStart !== void 0 && i.barEnd !== void 0;\n    }\n    function ST(i, t, e) {\n        return i !== 0 ? me(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);\n    }\n    function OT(i) {\n        let t, e, s, n, o;\n        return i.horizontal ? (t = i.base > i.x, e = \"left\", s = \"right\") : (t = i.base < i.y, e = \"bottom\", s = \"top\"), t ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n            start: e,\n            end: s,\n            reverse: t,\n            top: n,\n            bottom: o\n        };\n    }\n    function DT(i, t, e, s) {\n        let n = t.borderSkipped;\n        const o = {};\n        if (!n) {\n            i.borderSkipped = o;\n            return;\n        }\n        if (n === !0) {\n            i.borderSkipped = {\n                top: !0,\n                right: !0,\n                bottom: !0,\n                left: !0\n            };\n            return;\n        }\n        const { start: r, end: a, reverse: l, top: c, bottom: h } = OT(i);\n        n === \"middle\" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[lf(h, r, a, l)] = !0, n = c)), o[lf(n, r, a, l)] = !0, i.borderSkipped = o;\n    }\n    function lf(i, t, e, s) {\n        return s ? (i = MT(i, t, e), i = cf(i, e, t)) : i = cf(i, t, e), i;\n    }\n    function MT(i, t, e) {\n        return i === t ? e : i === e ? t : i;\n    }\n    function cf(i, t, e) {\n        return i === \"start\" ? t : i === \"end\" ? e : i;\n    }\n    function IT(i, { inflateAmount: t }, e) {\n        i.inflateAmount = t === \"auto\" ? e === 1 ? .33 : 0 : t;\n    }\n    class cn extends zt {\n        parsePrimitiveData(t, e, s, n) {\n            return af(t, e, s, n);\n        }\n        parseArrayData(t, e, s, n) {\n            return af(t, e, s, n);\n        }\n        parseObjectData(t, e, s, n) {\n            const { iScale: o, vScale: r } = t, { xAxisKey: a = \"x\", yAxisKey: l = \"y\" } = this._parsing, c = o.axis === \"x\" ? a : l, h = r.axis === \"x\" ? a : l, d = [];\n            let u, f, p, _;\n            for(u = s, f = s + n; u < f; ++u)_ = e[u], p = {}, p[o.axis] = o.parse(Ke(_, c), u), d.push(rf(Ke(_, h), p, r, u));\n            return d;\n        }\n        updateRangeFromParsed(t, e, s, n) {\n            super.updateRangeFromParsed(t, e, s, n);\n            const o = s._custom;\n            o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));\n        }\n        getMaxOverflow() {\n            return 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, { iScale: s, vScale: n } = e, o = this.getParsed(t), r = o._custom, a = ll(r) ? \"[\" + r.start + \", \" + r.end + \"]\" : \"\" + n.getLabelForValue(o[n.axis]);\n            return {\n                label: \"\" + s.getLabelForValue(o[s.axis]),\n                value: a\n            };\n        }\n        initialize() {\n            this.enableOptionSharing = !0, super.initialize();\n            const t = this._cachedMeta;\n            t.stack = this.getDataset().stack;\n        }\n        update(t) {\n            const e = this._cachedMeta;\n            this.updateElements(e.data, 0, e.data.length, t);\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", { index: r, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), h = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n            for(let f = e; f < e + s; f++){\n                const p = this.getParsed(f), _ = o || N(p[a.axis]) ? {\n                    base: l,\n                    head: l\n                } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, h), y = (p._stacks || {})[a.axis], x = {\n                    horizontal: c,\n                    base: _.base,\n                    enableBorderRadius: !y || ll(p._custom) || r === y._top || r === y._bottom,\n                    x: c ? _.head : m.center,\n                    y: c ? m.center : _.head,\n                    height: c ? m.size : Math.abs(_.size),\n                    width: c ? Math.abs(_.size) : m.size\n                };\n                u && (x.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n                const E = x.options || t[f].options;\n                DT(x, E, y, r), IT(x, E, h.ratio), this.updateElement(t[f], f, x, n);\n            }\n        }\n        _getStacks(t, e) {\n            const { iScale: s } = this._cachedMeta, n = s.getMatchingVisibleMetas(this._type).filter((l)=>l.controller.options.grouped), o = s.options.stacked, r = [], a = (l)=>{\n                const c = l.controller.getParsed(e), h = c && c[l.vScale.axis];\n                if (N(h) || isNaN(h)) return !0;\n            };\n            for (const l of n)if (!(e !== void 0 && a(l)) && ((o === !1 || r.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && r.push(l.stack), l.index === t)) break;\n            return r.length || r.push(void 0), r;\n        }\n        _getStackCount(t) {\n            return this._getStacks(void 0, t).length;\n        }\n        _getStackIndex(t, e, s) {\n            const n = this._getStacks(t, s), o = e !== void 0 ? n.indexOf(e) : -1;\n            return o === -1 ? n.length - 1 : o;\n        }\n        _getRuler() {\n            const t = this.options, e = this._cachedMeta, s = e.iScale, n = [];\n            let o, r;\n            for(o = 0, r = e.data.length; o < r; ++o)n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));\n            const a = t.barThickness;\n            return {\n                min: a || TT(e),\n                pixels: n,\n                start: s._startPixel,\n                end: s._endPixel,\n                stackCount: this._getStackCount(),\n                scale: s,\n                grouped: t.grouped,\n                ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n            };\n        }\n        _calculateBarValuePixels(t) {\n            const { _cachedMeta: { vScale: e, _stacked: s }, options: { base: n, minBarLength: o } } = this, r = n || 0, a = this.getParsed(t), l = a._custom, c = ll(l);\n            let h = a[e.axis], d = 0, u = s ? this.applyStack(e, a, s) : h, f, p;\n            u !== h && (d = u - h, u = h), c && (h = l.barStart, u = l.barEnd - l.barStart, h !== 0 && me(h) !== me(l.barEnd) && (d = 0), d += h);\n            const _ = !N(n) && !c ? n : d;\n            let m = e.getPixelForValue(_);\n            if (this.chart.getDataVisibility(t) ? f = e.getPixelForValue(d + u) : f = m, p = f - m, Math.abs(p) < o) {\n                p = ST(p, e, r) * o, h === r && (m -= p / 2);\n                const y = e.getPixelForDecimal(0), x = e.getPixelForDecimal(1), E = Math.min(y, x), C = Math.max(y, x);\n                m = Math.max(Math.min(m, C), E), f = m + p;\n            }\n            if (m === e.getPixelForValue(r)) {\n                const y = me(p) * e.getLineWidthForValue(r) / 2;\n                m += y, p -= y;\n            }\n            return {\n                size: p,\n                base: m,\n                head: f,\n                center: f + p / 2\n            };\n        }\n        _calculateBarIndexPixels(t, e) {\n            const s = e.scale, n = this.options, o = n.skipNull, r = R(n.maxBarThickness, 1 / 0);\n            let a, l;\n            if (e.grouped) {\n                const c = o ? this._getStackCount(t) : e.stackCount, h = n.barThickness === \"flex\" ? wT(t, e, n, c) : AT(t, e, n, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n                a = h.start + h.chunk * d + h.chunk / 2, l = Math.min(r, h.chunk * h.ratio);\n            } else a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);\n            return {\n                base: a - l / 2,\n                head: a + l / 2,\n                center: a,\n                size: l\n            };\n        }\n        draw() {\n            const t = this._cachedMeta, e = t.vScale, s = t.data, n = s.length;\n            let o = 0;\n            for(; o < n; ++o)this.getParsed(o)[e.axis] !== null && s[o].draw(this._ctx);\n        }\n    }\n    cn.id = \"bar\", cn.defaults = {\n        datasetElementType: !1,\n        dataElementType: \"bar\",\n        categoryPercentage: .8,\n        barPercentage: .9,\n        grouped: !0,\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"base\",\n                    \"width\",\n                    \"height\"\n                ]\n            }\n        }\n    }, cn.overrides = {\n        scales: {\n            _index_: {\n                type: \"category\",\n                offset: !0,\n                grid: {\n                    offset: !0\n                }\n            },\n            _value_: {\n                type: \"linear\",\n                beginAtZero: !0\n            }\n        }\n    };\n    class hn extends zt {\n        initialize() {\n            this.enableOptionSharing = !0, super.initialize();\n        }\n        parsePrimitiveData(t, e, s, n) {\n            const o = super.parsePrimitiveData(t, e, s, n);\n            for(let r = 0; r < o.length; r++)o[r]._custom = this.resolveDataElementOptions(r + s).radius;\n            return o;\n        }\n        parseArrayData(t, e, s, n) {\n            const o = super.parseArrayData(t, e, s, n);\n            for(let r = 0; r < o.length; r++){\n                const a = e[s + r];\n                o[r]._custom = R(a[2], this.resolveDataElementOptions(r + s).radius);\n            }\n            return o;\n        }\n        parseObjectData(t, e, s, n) {\n            const o = super.parseObjectData(t, e, s, n);\n            for(let r = 0; r < o.length; r++){\n                const a = e[s + r];\n                o[r]._custom = R(a && a.r && +a.r, this.resolveDataElementOptions(r + s).radius);\n            }\n            return o;\n        }\n        getMaxOverflow() {\n            const t = this._cachedMeta.data;\n            let e = 0;\n            for(let s = t.length - 1; s >= 0; --s)e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2);\n            return e > 0 && e;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, { xScale: s, yScale: n } = e, o = this.getParsed(t), r = s.getLabelForValue(o.x), a = n.getLabelForValue(o.y), l = o._custom;\n            return {\n                label: e.label,\n                value: \"(\" + r + \", \" + a + (l ? \", \" + l : \"\") + \")\"\n            };\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this.updateElements(e, 0, e.length, t);\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", { iScale: r, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, n), h = r.axis, d = a.axis;\n            for(let u = e; u < e + s; u++){\n                const f = t[u], p = !o && this.getParsed(u), _ = {}, m = _[h] = o ? r.getPixelForDecimal(.5) : r.getPixelForValue(p[h]), y = _[d] = o ? a.getBasePixel() : a.getPixelForValue(p[d]);\n                _.skip = isNaN(m) || isNaN(y), c && (_.options = l || this.resolveDataElementOptions(u, f.active ? \"active\" : n), o && (_.options.radius = 0)), this.updateElement(f, u, _, n);\n            }\n        }\n        resolveDataElementOptions(t, e) {\n            const s = this.getParsed(t);\n            let n = super.resolveDataElementOptions(t, e);\n            n.$shared && (n = Object.assign({}, n, {\n                $shared: !1\n            }));\n            const o = n.radius;\n            return e !== \"active\" && (n.radius = 0), n.radius += R(s && s._custom, o), n;\n        }\n    }\n    hn.id = \"bubble\", hn.defaults = {\n        datasetElementType: !1,\n        dataElementType: \"point\",\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"borderWidth\",\n                    \"radius\"\n                ]\n            }\n        }\n    }, hn.overrides = {\n        scales: {\n            x: {\n                type: \"linear\"\n            },\n            y: {\n                type: \"linear\"\n            }\n        },\n        plugins: {\n            tooltip: {\n                callbacks: {\n                    title () {\n                        return \"\";\n                    }\n                }\n            }\n        }\n    };\n    function LT(i, t, e) {\n        let s = 1, n = 1, o = 0, r = 0;\n        if (t < q) {\n            const a = i, l = a + t, c = Math.cos(a), h = Math.sin(a), d = Math.cos(l), u = Math.sin(l), f = (E, C, T)=>Js(E, a, l, !0) ? 1 : Math.max(C, C * e, T, T * e), p = (E, C, T)=>Js(E, a, l, !0) ? -1 : Math.min(C, C * e, T, T * e), _ = f(0, c, d), m = f(nt, h, u), y = p(et, c, d), x = p(et + nt, h, u);\n            s = (_ - y) / 2, n = (m - x) / 2, o = -(_ + y) / 2, r = -(m + x) / 2;\n        }\n        return {\n            ratioX: s,\n            ratioY: n,\n            offsetX: o,\n            offsetY: r\n        };\n    }\n    class ki extends zt {\n        constructor(t, e){\n            super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n        }\n        linkScales() {}\n        parse(t, e) {\n            const s = this.getDataset().data, n = this._cachedMeta;\n            if (this._parsing === !1) n._parsed = s;\n            else {\n                let o = (l)=>+s[l];\n                if ($(s[t])) {\n                    const { key: l = \"value\" } = this._parsing;\n                    o = (c)=>+Ke(s[c], l);\n                }\n                let r, a;\n                for(r = t, a = t + e; r < a; ++r)n._parsed[r] = o(r);\n            }\n        }\n        _getRotation() {\n            return Jt(this.options.rotation - 90);\n        }\n        _getCircumference() {\n            return Jt(this.options.circumference);\n        }\n        _getRotationExtents() {\n            let t = q, e = -q;\n            for(let s = 0; s < this.chart.data.datasets.length; ++s)if (this.chart.isDatasetVisible(s)) {\n                const n = this.chart.getDatasetMeta(s).controller, o = n._getRotation(), r = n._getCircumference();\n                t = Math.min(t, o), e = Math.max(e, o + r);\n            }\n            return {\n                rotation: t,\n                circumference: e - t\n            };\n        }\n        update(t) {\n            const e = this.chart, { chartArea: s } = e, n = this._cachedMeta, o = n.data, r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(s.width, s.height) - r) / 2, 0), l = Math.min(DE(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: p, offsetY: _ } = LT(d, h, l), m = (s.width - r) / u, y = (s.height - r) / f, x = Math.max(Math.min(m, y) / 2, 0), E = Jd(this.options.radius, x), C = Math.max(E * l, 0), T = (E - C) / this._getVisibleDatasetWeightTotal();\n            this.offsetX = p * E, this.offsetY = _ * E, n.total = this.calculateTotal(), this.outerRadius = E - T * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - T * c, 0), this.updateElements(o, 0, o.length, t);\n        }\n        _circumference(t, e) {\n            const s = this.options, n = this._cachedMeta, o = this._getCircumference();\n            return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / q);\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", r = this.chart, a = r.chartArea, c = r.options.animation, h = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, u = o && c.animateScale, f = u ? 0 : this.innerRadius, p = u ? 0 : this.outerRadius, { sharedOptions: _, includeOptions: m } = this._getSharedOptions(e, n);\n            let y = this._getRotation(), x;\n            for(x = 0; x < e; ++x)y += this._circumference(x, o);\n            for(x = e; x < e + s; ++x){\n                const E = this._circumference(x, o), C = t[x], T = {\n                    x: h + this.offsetX,\n                    y: d + this.offsetY,\n                    startAngle: y,\n                    endAngle: y + E,\n                    circumference: E,\n                    outerRadius: p,\n                    innerRadius: f\n                };\n                m && (T.options = _ || this.resolveDataElementOptions(x, C.active ? \"active\" : n)), y += E, this.updateElement(C, x, T, n);\n            }\n        }\n        calculateTotal() {\n            const t = this._cachedMeta, e = t.data;\n            let s = 0, n;\n            for(n = 0; n < e.length; n++){\n                const o = t._parsed[n];\n                o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));\n            }\n            return s;\n        }\n        calculateCircumference(t) {\n            const e = this._cachedMeta.total;\n            return e > 0 && !isNaN(t) ? q * (Math.abs(t) / e) : 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = an(e._parsed[t], s.options.locale);\n            return {\n                label: n[t] || \"\",\n                value: o\n            };\n        }\n        getMaxBorderWidth(t) {\n            let e = 0;\n            const s = this.chart;\n            let n, o, r, a, l;\n            if (!t) {\n                for(n = 0, o = s.data.datasets.length; n < o; ++n)if (s.isDatasetVisible(n)) {\n                    r = s.getDatasetMeta(n), t = r.data, a = r.controller;\n                    break;\n                }\n            }\n            if (!t) return 0;\n            for(n = 0, o = t.length; n < o; ++n)l = a.resolveDataElementOptions(n), l.borderAlign !== \"inner\" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));\n            return e;\n        }\n        getMaxOffset(t) {\n            let e = 0;\n            for(let s = 0, n = t.length; s < n; ++s){\n                const o = this.resolveDataElementOptions(s);\n                e = Math.max(e, o.offset || 0, o.hoverOffset || 0);\n            }\n            return e;\n        }\n        _getRingWeightOffset(t) {\n            let e = 0;\n            for(let s = 0; s < t; ++s)this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));\n            return e;\n        }\n        _getRingWeight(t) {\n            return Math.max(R(this.chart.data.datasets[t].weight, 1), 0);\n        }\n        _getVisibleDatasetWeightTotal() {\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n        }\n    }\n    ki.id = \"doughnut\", ki.defaults = {\n        datasetElementType: !1,\n        dataElementType: \"arc\",\n        animation: {\n            animateRotate: !0,\n            animateScale: !1\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"circumference\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\",\n                    \"startAngle\",\n                    \"x\",\n                    \"y\",\n                    \"offset\",\n                    \"borderWidth\",\n                    \"spacing\"\n                ]\n            }\n        },\n        cutout: \"50%\",\n        rotation: 0,\n        circumference: 360,\n        radius: \"100%\",\n        spacing: 0,\n        indexAxis: \"r\"\n    }, ki.descriptors = {\n        _scriptable: (i)=>i !== \"spacing\",\n        _indexable: (i)=>i !== \"spacing\"\n    }, ki.overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (i) {\n                        const t = i.data;\n                        if (t.labels.length && t.datasets.length) {\n                            const { labels: { pointStyle: e } } = i.legend.options;\n                            return t.labels.map((s, n)=>{\n                                const r = i.getDatasetMeta(0).controller.getStyle(n);\n                                return {\n                                    text: s,\n                                    fillStyle: r.backgroundColor,\n                                    strokeStyle: r.borderColor,\n                                    lineWidth: r.borderWidth,\n                                    pointStyle: e,\n                                    hidden: !i.getDataVisibility(n),\n                                    index: n\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (i, t, e) {\n                    e.chart.toggleDataVisibility(t.index), e.chart.update();\n                }\n            },\n            tooltip: {\n                callbacks: {\n                    title () {\n                        return \"\";\n                    },\n                    label (i) {\n                        let t = i.label;\n                        const e = \": \" + i.formattedValue;\n                        return Q(t) ? (t = t.slice(), t[0] += e) : t += e, t;\n                    }\n                }\n            }\n        }\n    };\n    class dn extends zt {\n        initialize() {\n            this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n        }\n        update(t) {\n            const e = this._cachedMeta, { dataset: s, data: n = [], _dataset: o } = e, r = this.chart._animationsDisabled;\n            let { start: a, count: l } = fu(e, n, r);\n            this._drawStart = a, this._drawCount = l, pu(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;\n            const c = this.resolveDatasetElementOptions(t);\n            this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {\n                animated: !r,\n                options: c\n            }, t), this.updateElements(n, a, l, t);\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: d } = this._getSharedOptions(e, n), u = r.axis, f = a.axis, { spanGaps: p, segment: _ } = this.options, m = as(p) ? p : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || o || n === \"none\";\n            let x = e > 0 && this.getParsed(e - 1);\n            for(let E = e; E < e + s; ++E){\n                const C = t[E], T = this.getParsed(E), A = y ? C : {}, w = N(T[f]), S = A[u] = r.getPixelForValue(T[u], E), k = A[f] = o || w ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, T, l) : T[f], E);\n                A.skip = isNaN(S) || isNaN(k) || w, A.stop = E > 0 && Math.abs(T[u] - x[u]) > m, _ && (A.parsed = T, A.raw = c.data[E]), d && (A.options = h || this.resolveDataElementOptions(E, C.active ? \"active\" : n)), y || this.updateElement(C, E, A, n), x = T;\n            }\n        }\n        getMaxOverflow() {\n            const t = this._cachedMeta, e = t.dataset, s = e.options && e.options.borderWidth || 0, n = t.data || [];\n            if (!n.length) return s;\n            const o = n[0].size(this.resolveDataElementOptions(0)), r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));\n            return Math.max(s, o, r) / 2;\n        }\n        draw() {\n            const t = this._cachedMeta;\n            t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n        }\n    }\n    dn.id = \"line\", dn.defaults = {\n        datasetElementType: \"line\",\n        dataElementType: \"point\",\n        showLine: !0,\n        spanGaps: !1\n    }, dn.overrides = {\n        scales: {\n            _index_: {\n                type: \"category\"\n            },\n            _value_: {\n                type: \"linear\"\n            }\n        }\n    };\n    class un extends zt {\n        constructor(t, e){\n            super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = an(e._parsed[t].r, s.options.locale);\n            return {\n                label: n[t] || \"\",\n                value: o\n            };\n        }\n        parseObjectData(t, e, s, n) {\n            return Nu.bind(this)(t, e, s, n);\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this._updateRadius(), this.updateElements(e, 0, e.length, t);\n        }\n        getMinMax() {\n            const t = this._cachedMeta, e = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n            return t.data.forEach((s, n)=>{\n                const o = this.getParsed(n).r;\n                !isNaN(o) && this.chart.getDataVisibility(n) && (o < e.min && (e.min = o), o > e.max && (e.max = o));\n            }), e;\n        }\n        _updateRadius() {\n            const t = this.chart, e = t.chartArea, s = t.options, n = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(n / 2, 0), r = Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0), a = (o - r) / t.getVisibleDatasetCount();\n            this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", r = this.chart, l = r.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - .5 * et;\n            let f = u, p;\n            const _ = 360 / this.countVisibleElements();\n            for(p = 0; p < e; ++p)f += this._computeAngle(p, n, _);\n            for(p = e; p < e + s; p++){\n                const m = t[p];\n                let y = f, x = f + this._computeAngle(p, n, _), E = r.getDataVisibility(p) ? c.getDistanceFromCenterForValue(this.getParsed(p).r) : 0;\n                f = x, o && (l.animateScale && (E = 0), l.animateRotate && (y = x = u));\n                const C = {\n                    x: h,\n                    y: d,\n                    innerRadius: 0,\n                    outerRadius: E,\n                    startAngle: y,\n                    endAngle: x,\n                    options: this.resolveDataElementOptions(p, m.active ? \"active\" : n)\n                };\n                this.updateElement(m, p, C, n);\n            }\n        }\n        countVisibleElements() {\n            const t = this._cachedMeta;\n            let e = 0;\n            return t.data.forEach((s, n)=>{\n                !isNaN(this.getParsed(n).r) && this.chart.getDataVisibility(n) && e++;\n            }), e;\n        }\n        _computeAngle(t, e, s) {\n            return this.chart.getDataVisibility(t) ? Jt(this.resolveDataElementOptions(t, e).angle || s) : 0;\n        }\n    }\n    un.id = \"polarArea\", un.defaults = {\n        dataElementType: \"arc\",\n        animation: {\n            animateRotate: !0,\n            animateScale: !0\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\"\n                ]\n            }\n        },\n        indexAxis: \"r\",\n        startAngle: 0\n    }, un.overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (i) {\n                        const t = i.data;\n                        if (t.labels.length && t.datasets.length) {\n                            const { labels: { pointStyle: e } } = i.legend.options;\n                            return t.labels.map((s, n)=>{\n                                const r = i.getDatasetMeta(0).controller.getStyle(n);\n                                return {\n                                    text: s,\n                                    fillStyle: r.backgroundColor,\n                                    strokeStyle: r.borderColor,\n                                    lineWidth: r.borderWidth,\n                                    pointStyle: e,\n                                    hidden: !i.getDataVisibility(n),\n                                    index: n\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (i, t, e) {\n                    e.chart.toggleDataVisibility(t.index), e.chart.update();\n                }\n            },\n            tooltip: {\n                callbacks: {\n                    title () {\n                        return \"\";\n                    },\n                    label (i) {\n                        return i.chart.data.labels[i.dataIndex] + \": \" + i.formattedValue;\n                    }\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: \"radialLinear\",\n                angleLines: {\n                    display: !1\n                },\n                beginAtZero: !0,\n                grid: {\n                    circular: !0\n                },\n                pointLabels: {\n                    display: !1\n                },\n                startAngle: 0\n            }\n        }\n    };\n    class Zo extends ki {\n    }\n    Zo.id = \"pie\", Zo.defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: \"100%\"\n    };\n    class fn extends zt {\n        getLabelAndValue(t) {\n            const e = this._cachedMeta.vScale, s = this.getParsed(t);\n            return {\n                label: e.getLabels()[t],\n                value: \"\" + e.getLabelForValue(s[e.axis])\n            };\n        }\n        parseObjectData(t, e, s, n) {\n            return Nu.bind(this)(t, e, s, n);\n        }\n        update(t) {\n            const e = this._cachedMeta, s = e.dataset, n = e.data || [], o = e.iScale.getLabels();\n            if (s.points = n, t !== \"resize\") {\n                const r = this.resolveDatasetElementOptions(t);\n                this.options.showLine || (r.borderWidth = 0);\n                const a = {\n                    _loop: !0,\n                    _fullLoop: o.length === n.length,\n                    options: r\n                };\n                this.updateElement(s, void 0, a, t);\n            }\n            this.updateElements(n, 0, n.length, t);\n        }\n        updateElements(t, e, s, n) {\n            const o = this._cachedMeta.rScale, r = n === \"reset\";\n            for(let a = e; a < e + s; a++){\n                const l = t[a], c = this.resolveDataElementOptions(a, l.active ? \"active\" : n), h = o.getPointPositionForValue(a, this.getParsed(a).r), d = r ? o.xCenter : h.x, u = r ? o.yCenter : h.y, f = {\n                    x: d,\n                    y: u,\n                    angle: h.angle,\n                    skip: isNaN(d) || isNaN(u),\n                    options: c\n                };\n                this.updateElement(l, a, f, n);\n            }\n        }\n    }\n    fn.id = \"radar\", fn.defaults = {\n        datasetElementType: \"line\",\n        dataElementType: \"point\",\n        indexAxis: \"r\",\n        showLine: !0,\n        elements: {\n            line: {\n                fill: \"start\"\n            }\n        }\n    }, fn.overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: \"radialLinear\"\n            }\n        }\n    };\n    let jt = class {\n        constructor(){\n            this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;\n        }\n        tooltipPosition(t) {\n            const { x: e, y: s } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: s\n            };\n        }\n        hasValue() {\n            return as(this.x) && as(this.y);\n        }\n        getProps(t, e) {\n            const s = this.$animations;\n            if (!e || !s) return this;\n            const n = {};\n            return t.forEach((o)=>{\n                n[o] = s[o] && s[o].active() ? s[o]._to : this[o];\n            }), n;\n        }\n    };\n    jt.defaults = {}, jt.defaultRoutes = void 0;\n    const hf = {\n        values (i) {\n            return Q(i) ? i : \"\" + i;\n        },\n        numeric (i, t, e) {\n            if (i === 0) return \"0\";\n            const s = this.chart.options.locale;\n            let n, o = i;\n            if (e.length > 1) {\n                const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));\n                (c < 1e-4 || c > 1e15) && (n = \"scientific\"), o = PT(i, e);\n            }\n            const r = Vt(Math.abs(o)), a = Math.max(Math.min(-1 * Math.floor(r), 20), 0), l = {\n                notation: n,\n                minimumFractionDigits: a,\n                maximumFractionDigits: a\n            };\n            return Object.assign(l, this.options.ticks.format), an(i, s, l);\n        },\n        logarithmic (i, t, e) {\n            if (i === 0) return \"0\";\n            const s = i / Math.pow(10, Math.floor(Vt(i)));\n            return s === 1 || s === 2 || s === 5 ? hf.numeric.call(this, i, t, e) : \"\";\n        }\n    };\n    function PT(i, t) {\n        let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;\n        return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;\n    }\n    var pn = {\n        formatters: hf\n    };\n    B.set(\"scale\", {\n        display: !0,\n        offset: !1,\n        reverse: !1,\n        beginAtZero: !1,\n        bounds: \"ticks\",\n        grace: 0,\n        grid: {\n            display: !0,\n            lineWidth: 1,\n            drawBorder: !0,\n            drawOnChartArea: !0,\n            drawTicks: !0,\n            tickLength: 8,\n            tickWidth: (i, t)=>t.lineWidth,\n            tickColor: (i, t)=>t.color,\n            offset: !1,\n            borderDash: [],\n            borderDashOffset: 0,\n            borderWidth: 1\n        },\n        title: {\n            display: !1,\n            text: \"\",\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: !1,\n            textStrokeWidth: 0,\n            textStrokeColor: \"\",\n            padding: 3,\n            display: !0,\n            autoSkip: !0,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: pn.formatters.values,\n            minor: {},\n            major: {},\n            align: \"center\",\n            crossAlign: \"near\",\n            showLabelBackdrop: !1,\n            backdropColor: \"rgba(255, 255, 255, 0.75)\",\n            backdropPadding: 2\n        }\n    }), B.route(\"scale.ticks\", \"color\", \"\", \"color\"), B.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), B.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\"), B.route(\"scale.title\", \"color\", \"\", \"color\"), B.describe(\"scale\", {\n        _fallback: !1,\n        _scriptable: (i)=>!i.startsWith(\"before\") && !i.startsWith(\"after\") && i !== \"callback\" && i !== \"parser\",\n        _indexable: (i)=>i !== \"borderDash\" && i !== \"tickBorderDash\"\n    }), B.describe(\"scales\", {\n        _fallback: \"scale\"\n    }), B.describe(\"scale.ticks\", {\n        _scriptable: (i)=>i !== \"backdropPadding\" && i !== \"callback\",\n        _indexable: (i)=>i !== \"backdropPadding\"\n    });\n    function RT(i, t) {\n        const e = i.options.ticks, s = e.maxTicksLimit || NT(i), n = e.major.enabled ? BT(t) : [], o = n.length, r = n[0], a = n[o - 1], l = [];\n        if (o > s) return HT(t, l, n, o / s), l;\n        const c = $T(n, t, s);\n        if (o > 0) {\n            let h, d;\n            const u = o > 1 ? Math.round((a - r) / (o - 1)) : null;\n            for(Qo(t, l, c, N(u) ? 0 : r - u, r), h = 0, d = o - 1; h < d; h++)Qo(t, l, c, n[h], n[h + 1]);\n            return Qo(t, l, c, a, N(u) ? t.length : a + u), l;\n        }\n        return Qo(t, l, c), l;\n    }\n    function NT(i) {\n        const t = i.options.offset, e = i._tickSize(), s = i._length / e + (t ? 0 : 1), n = i._maxLength / e;\n        return Math.floor(Math.min(s, n));\n    }\n    function $T(i, t, e) {\n        const s = FT(i), n = t.length / e;\n        if (!s) return Math.max(n, 1);\n        const o = BE(s);\n        for(let r = 0, a = o.length - 1; r < a; r++){\n            const l = o[r];\n            if (l > n) return l;\n        }\n        return Math.max(n, 1);\n    }\n    function BT(i) {\n        const t = [];\n        let e, s;\n        for(e = 0, s = i.length; e < s; e++)i[e].major && t.push(e);\n        return t;\n    }\n    function HT(i, t, e, s) {\n        let n = 0, o = e[0], r;\n        for(s = Math.ceil(s), r = 0; r < i.length; r++)r === o && (t.push(i[r]), n++, o = e[n * s]);\n    }\n    function Qo(i, t, e, s, n) {\n        const o = R(s, 0), r = Math.min(R(n, i.length), i.length);\n        let a = 0, l, c, h;\n        for(e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0;)a++, h = Math.round(o + a * e);\n        for(c = Math.max(o, 0); c < r; c++)c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));\n    }\n    function FT(i) {\n        const t = i.length;\n        let e, s;\n        if (t < 2) return !1;\n        for(s = i[0], e = 1; e < t; ++e)if (i[e] - i[e - 1] !== s) return !1;\n        return s;\n    }\n    const VT = (i)=>i === \"left\" ? \"right\" : i === \"right\" ? \"left\" : i, df = (i, t, e)=>t === \"top\" || t === \"left\" ? i[t] + e : i[t] - e;\n    function uf(i, t) {\n        const e = [], s = i.length / t, n = i.length;\n        let o = 0;\n        for(; o < n; o += s)e.push(i[Math.floor(o)]);\n        return e;\n    }\n    function WT(i, t, e) {\n        const s = i.ticks.length, n = Math.min(t, s - 1), o = i._startPixel, r = i._endPixel, a = 1e-6;\n        let l = i.getPixelForTick(n), c;\n        if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a))) return l;\n    }\n    function zT(i, t) {\n        U(i, (e)=>{\n            const s = e.gc, n = s.length / 2;\n            let o;\n            if (n > t) {\n                for(o = 0; o < n; ++o)delete e.data[s[o]];\n                s.splice(0, n);\n            }\n        });\n    }\n    function _n(i) {\n        return i.drawTicks ? i.tickLength : 0;\n    }\n    function ff(i, t) {\n        if (!i.display) return 0;\n        const e = lt(i.font, t), s = ht(i.padding);\n        return (Q(i.text) ? i.text.length : 1) * e.lineHeight + s.height;\n    }\n    function jT(i, t) {\n        return qe(i, {\n            scale: t,\n            type: \"scale\"\n        });\n    }\n    function YT(i, t, e) {\n        return qe(i, {\n            tick: e,\n            index: t,\n            type: \"tick\"\n        });\n    }\n    function KT(i, t, e) {\n        let s = za(i);\n        return (e && t !== \"right\" || !e && t === \"right\") && (s = VT(s)), s;\n    }\n    function UT(i, t, e, s) {\n        const { top: n, left: o, bottom: r, right: a, chart: l } = i, { chartArea: c, scales: h } = l;\n        let d = 0, u, f, p;\n        const _ = r - n, m = a - o;\n        if (i.isHorizontal()) {\n            if (f = pt(s, o, a), $(e)) {\n                const y = Object.keys(e)[0], x = e[y];\n                p = h[y].getPixelForValue(x) + _ - t;\n            } else e === \"center\" ? p = (c.bottom + c.top) / 2 + _ - t : p = df(i, e, t);\n            u = a - o;\n        } else {\n            if ($(e)) {\n                const y = Object.keys(e)[0], x = e[y];\n                f = h[y].getPixelForValue(x) - m + t;\n            } else e === \"center\" ? f = (c.left + c.right) / 2 - m + t : f = df(i, e, t);\n            p = pt(s, r, n), d = e === \"left\" ? -nt : nt;\n        }\n        return {\n            titleX: f,\n            titleY: p,\n            maxWidth: u,\n            rotation: d\n        };\n    }\n    class Ze extends jt {\n        constructor(t){\n            super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n        }\n        init(t) {\n            this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n        }\n        parse(t, e) {\n            return t;\n        }\n        getUserBounds() {\n            let { _userMin: t, _userMax: e, _suggestedMin: s, _suggestedMax: n } = this;\n            return t = Ht(t, Number.POSITIVE_INFINITY), e = Ht(e, Number.NEGATIVE_INFINITY), s = Ht(s, Number.POSITIVE_INFINITY), n = Ht(n, Number.NEGATIVE_INFINITY), {\n                min: Ht(t, s),\n                max: Ht(e, n),\n                minDefined: rt(t),\n                maxDefined: rt(e)\n            };\n        }\n        getMinMax(t) {\n            let { min: e, max: s, minDefined: n, maxDefined: o } = this.getUserBounds(), r;\n            if (n && o) return {\n                min: e,\n                max: s\n            };\n            const a = this.getMatchingVisibleMetas();\n            for(let l = 0, c = a.length; l < c; ++l)r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));\n            return e = o && e > s ? s : e, s = n && e > s ? e : s, {\n                min: Ht(e, Ht(s, e)),\n                max: Ht(s, Ht(e, s))\n            };\n        }\n        getPadding() {\n            return {\n                left: this.paddingLeft || 0,\n                top: this.paddingTop || 0,\n                right: this.paddingRight || 0,\n                bottom: this.paddingBottom || 0\n            };\n        }\n        getTicks() {\n            return this.ticks;\n        }\n        getLabels() {\n            const t = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n        }\n        beforeLayout() {\n            this._cache = {}, this._dataLimitsCached = !1;\n        }\n        beforeUpdate() {\n            G(this.options.beforeUpdate, [\n                this\n            ]);\n        }\n        update(t, e, s) {\n            const { beginAtZero: n, grace: o, ticks: r } = this.options, a = r.sampleSize;\n            this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = wC(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n            const l = a < this.ticks.length;\n            this._convertTicksToLabels(l ? uf(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === \"auto\") && (this.ticks = RT(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n        }\n        configure() {\n            let t = this.options.reverse, e, s;\n            this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;\n        }\n        afterUpdate() {\n            G(this.options.afterUpdate, [\n                this\n            ]);\n        }\n        beforeSetDimensions() {\n            G(this.options.beforeSetDimensions, [\n                this\n            ]);\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n        }\n        afterSetDimensions() {\n            G(this.options.afterSetDimensions, [\n                this\n            ]);\n        }\n        _callHooks(t) {\n            this.chart.notifyPlugins(t, this.getContext()), G(this.options[t], [\n                this\n            ]);\n        }\n        beforeDataLimits() {\n            this._callHooks(\"beforeDataLimits\");\n        }\n        determineDataLimits() {}\n        afterDataLimits() {\n            this._callHooks(\"afterDataLimits\");\n        }\n        beforeBuildTicks() {\n            this._callHooks(\"beforeBuildTicks\");\n        }\n        buildTicks() {\n            return [];\n        }\n        afterBuildTicks() {\n            this._callHooks(\"afterBuildTicks\");\n        }\n        beforeTickToLabelConversion() {\n            G(this.options.beforeTickToLabelConversion, [\n                this\n            ]);\n        }\n        generateTickLabels(t) {\n            const e = this.options.ticks;\n            let s, n, o;\n            for(s = 0, n = t.length; s < n; s++)o = t[s], o.label = G(e.callback, [\n                o.value,\n                s,\n                t\n            ], this);\n        }\n        afterTickToLabelConversion() {\n            G(this.options.afterTickToLabelConversion, [\n                this\n            ]);\n        }\n        beforeCalculateLabelRotation() {\n            G(this.options.beforeCalculateLabelRotation, [\n                this\n            ]);\n        }\n        calculateLabelRotation() {\n            const t = this.options, e = t.ticks, s = this.ticks.length, n = e.minRotation || 0, o = e.maxRotation;\n            let r = n, a, l, c;\n            if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {\n                this.labelRotation = n;\n                return;\n            }\n            const h = this._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = ct(this.chart.width - d, 0, this.maxWidth);\n            a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? .5 : 1)), l = this.maxHeight - _n(t.grid) - e.padding - ff(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Fa(Math.min(Math.asin(ct((h.highest.height + 6) / a, -1, 1)), Math.asin(ct(l / c, -1, 1)) - Math.asin(ct(u / c, -1, 1)))), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;\n        }\n        afterCalculateLabelRotation() {\n            G(this.options.afterCalculateLabelRotation, [\n                this\n            ]);\n        }\n        afterAutoSkip() {}\n        beforeFit() {\n            G(this.options.beforeFit, [\n                this\n            ]);\n        }\n        fit() {\n            const t = {\n                width: 0,\n                height: 0\n            }, { chart: e, options: { ticks: s, title: n, grid: o } } = this, r = this._isVisible(), a = this.isHorizontal();\n            if (r) {\n                const l = ff(n, e.options.font);\n                if (a ? (t.width = this.maxWidth, t.height = _n(o) + l) : (t.height = this.maxHeight, t.width = _n(o) + l), s.display && this.ticks.length) {\n                    const { first: c, last: h, widest: d, highest: u } = this._getLabelSizes(), f = s.padding * 2, p = Jt(this.labelRotation), _ = Math.cos(p), m = Math.sin(p);\n                    if (a) {\n                        const y = s.mirror ? 0 : m * d.width + _ * u.height;\n                        t.height = Math.min(this.maxHeight, t.height + y + f);\n                    } else {\n                        const y = s.mirror ? 0 : _ * d.width + m * u.height;\n                        t.width = Math.min(this.maxWidth, t.width + y + f);\n                    }\n                    this._calculatePadding(c, h, m, _);\n                }\n            }\n            this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n        }\n        _calculatePadding(t, e, s, n) {\n            const { ticks: { align: o, padding: r }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== \"top\" && this.axis === \"x\";\n            if (this.isHorizontal()) {\n                const h = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);\n                let u = 0, f = 0;\n                l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === \"start\" ? f = e.width : o === \"end\" ? u = t.width : o !== \"inner\" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);\n            } else {\n                let h = e.height / 2, d = t.height / 2;\n                o === \"start\" ? (h = 0, d = t.height) : o === \"end\" && (h = e.height, d = 0), this.paddingTop = h + r, this.paddingBottom = d + r;\n            }\n        }\n        _handleMargins() {\n            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n        }\n        afterFit() {\n            G(this.options.afterFit, [\n                this\n            ]);\n        }\n        isHorizontal() {\n            const { axis: t, position: e } = this.options;\n            return e === \"top\" || e === \"bottom\" || t === \"x\";\n        }\n        isFullSize() {\n            return this.options.fullSize;\n        }\n        _convertTicksToLabels(t) {\n            this.beforeTickToLabelConversion(), this.generateTickLabels(t);\n            let e, s;\n            for(e = 0, s = t.length; e < s; e++)N(t[e].label) && (t.splice(e, 1), s--, e--);\n            this.afterTickToLabelConversion();\n        }\n        _getLabelSizes() {\n            let t = this._labelSizes;\n            if (!t) {\n                const e = this.options.ticks.sampleSize;\n                let s = this.ticks;\n                e < s.length && (s = uf(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length);\n            }\n            return t;\n        }\n        _computeLabelSizes(t, e) {\n            const { ctx: s, _longestTextCache: n } = this, o = [], r = [];\n            let a = 0, l = 0, c, h, d, u, f, p, _, m, y, x, E;\n            for(c = 0; c < e; ++c){\n                if (u = t[c].label, f = this._resolveTickFontOptions(c), s.font = p = f.string, _ = n[p] = n[p] || {\n                    data: {},\n                    gc: []\n                }, m = f.lineHeight, y = x = 0, !N(u) && !Q(u)) y = Yo(s, _.data, _.gc, y, u), x = m;\n                else if (Q(u)) for(h = 0, d = u.length; h < d; ++h)E = u[h], !N(E) && !Q(E) && (y = Yo(s, _.data, _.gc, y, E), x += m);\n                o.push(y), r.push(x), a = Math.max(y, a), l = Math.max(x, l);\n            }\n            zT(n, e);\n            const C = o.indexOf(a), T = r.indexOf(l), A = (w)=>({\n                    width: o[w] || 0,\n                    height: r[w] || 0\n                });\n            return {\n                first: A(0),\n                last: A(e - 1),\n                widest: A(C),\n                highest: A(T),\n                widths: o,\n                heights: r\n            };\n        }\n        getLabelForValue(t) {\n            return t;\n        }\n        getPixelForValue(t, e) {\n            return NaN;\n        }\n        getValueForPixel(t) {}\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getPixelForDecimal(t) {\n            this._reversePixels && (t = 1 - t);\n            const e = this._startPixel + t * this._length;\n            return VE(this._alignToPixels ? xi(this.chart, e, 0) : e);\n        }\n        getDecimalForPixel(t) {\n            const e = (t - this._startPixel) / this._length;\n            return this._reversePixels ? 1 - e : e;\n        }\n        getBasePixel() {\n            return this.getPixelForValue(this.getBaseValue());\n        }\n        getBaseValue() {\n            const { min: t, max: e } = this;\n            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n        }\n        getContext(t) {\n            const e = this.ticks || [];\n            if (t >= 0 && t < e.length) {\n                const s = e[t];\n                return s.$context || (s.$context = YT(this.getContext(), t, s));\n            }\n            return this.$context || (this.$context = jT(this.chart.getContext(), this));\n        }\n        _tickSize() {\n            const t = this.options.ticks, e = Jt(this.labelRotation), s = Math.abs(Math.cos(e)), n = Math.abs(Math.sin(e)), o = this._getLabelSizes(), r = t.autoSkipPadding || 0, a = o ? o.widest.width + r : 0, l = o ? o.highest.height + r : 0;\n            return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;\n        }\n        _isVisible() {\n            const t = this.options.display;\n            return t !== \"auto\" ? !!t : this.getMatchingVisibleMetas().length > 0;\n        }\n        _computeGridLineItems(t) {\n            const e = this.axis, s = this.chart, n = this.options, { grid: o, position: r } = n, a = o.offset, l = this.isHorizontal(), h = this.ticks.length + (a ? 1 : 0), d = _n(o), u = [], f = o.setContext(this.getContext()), p = f.drawBorder ? f.borderWidth : 0, _ = p / 2, m = function(I) {\n                return xi(s, I, p);\n            };\n            let y, x, E, C, T, A, w, S, k, D, O, M;\n            if (r === \"top\") y = m(this.bottom), A = this.bottom - d, S = y - _, D = m(t.top) + _, M = t.bottom;\n            else if (r === \"bottom\") y = m(this.top), D = t.top, M = m(t.bottom) - _, A = y + _, S = this.top + d;\n            else if (r === \"left\") y = m(this.right), T = this.right - d, w = y - _, k = m(t.left) + _, O = t.right;\n            else if (r === \"right\") y = m(this.left), k = t.left, O = m(t.right) - _, T = y + _, w = this.left + d;\n            else if (e === \"x\") {\n                if (r === \"center\") y = m((t.top + t.bottom) / 2 + .5);\n                else if ($(r)) {\n                    const I = Object.keys(r)[0], F = r[I];\n                    y = m(this.chart.scales[I].getPixelForValue(F));\n                }\n                D = t.top, M = t.bottom, A = y + _, S = A + d;\n            } else if (e === \"y\") {\n                if (r === \"center\") y = m((t.left + t.right) / 2);\n                else if ($(r)) {\n                    const I = Object.keys(r)[0], F = r[I];\n                    y = m(this.chart.scales[I].getPixelForValue(F));\n                }\n                T = y - _, w = T - d, k = t.left, O = t.right;\n            }\n            const L = R(n.ticks.maxTicksLimit, h), X = Math.max(1, Math.ceil(h / L));\n            for(x = 0; x < h; x += X){\n                const I = o.setContext(this.getContext(x)), F = I.lineWidth, Y = I.color, Yt = I.borderDash || [], ee = I.borderDashOffset, ie = I.tickWidth, ti = I.tickColor, Kt = I.tickBorderDash || [], ye = I.tickBorderDashOffset;\n                E = WT(this, x, a), E !== void 0 && (C = xi(s, E, F), l ? T = w = k = O = C : A = S = D = M = C, u.push({\n                    tx1: T,\n                    ty1: A,\n                    tx2: w,\n                    ty2: S,\n                    x1: k,\n                    y1: D,\n                    x2: O,\n                    y2: M,\n                    width: F,\n                    color: Y,\n                    borderDash: Yt,\n                    borderDashOffset: ee,\n                    tickWidth: ie,\n                    tickColor: ti,\n                    tickBorderDash: Kt,\n                    tickBorderDashOffset: ye\n                }));\n            }\n            return this._ticksLength = h, this._borderValue = y, u;\n        }\n        _computeLabelItems(t) {\n            const e = this.axis, s = this.options, { position: n, ticks: o } = s, r = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = o, u = _n(s.grid), f = u + h, p = d ? -h : f, _ = -Jt(this.labelRotation), m = [];\n            let y, x, E, C, T, A, w, S, k, D, O, M, L = \"middle\";\n            if (n === \"top\") A = this.bottom - p, w = this._getXAxisLabelAlignment();\n            else if (n === \"bottom\") A = this.top + p, w = this._getXAxisLabelAlignment();\n            else if (n === \"left\") {\n                const I = this._getYAxisLabelAlignment(u);\n                w = I.textAlign, T = I.x;\n            } else if (n === \"right\") {\n                const I = this._getYAxisLabelAlignment(u);\n                w = I.textAlign, T = I.x;\n            } else if (e === \"x\") {\n                if (n === \"center\") A = (t.top + t.bottom) / 2 + f;\n                else if ($(n)) {\n                    const I = Object.keys(n)[0], F = n[I];\n                    A = this.chart.scales[I].getPixelForValue(F) + f;\n                }\n                w = this._getXAxisLabelAlignment();\n            } else if (e === \"y\") {\n                if (n === \"center\") T = (t.left + t.right) / 2 - f;\n                else if ($(n)) {\n                    const I = Object.keys(n)[0], F = n[I];\n                    T = this.chart.scales[I].getPixelForValue(F);\n                }\n                w = this._getYAxisLabelAlignment(u).textAlign;\n            }\n            e === \"y\" && (l === \"start\" ? L = \"top\" : l === \"end\" && (L = \"bottom\"));\n            const X = this._getLabelSizes();\n            for(y = 0, x = a.length; y < x; ++y){\n                E = a[y], C = E.label;\n                const I = o.setContext(this.getContext(y));\n                S = this.getPixelForTick(y) + o.labelOffset, k = this._resolveTickFontOptions(y), D = k.lineHeight, O = Q(C) ? C.length : 1;\n                const F = O / 2, Y = I.color, Yt = I.textStrokeColor, ee = I.textStrokeWidth;\n                let ie = w;\n                r ? (T = S, w === \"inner\" && (y === x - 1 ? ie = this.options.reverse ? \"left\" : \"right\" : y === 0 ? ie = this.options.reverse ? \"right\" : \"left\" : ie = \"center\"), n === \"top\" ? c === \"near\" || _ !== 0 ? M = -O * D + D / 2 : c === \"center\" ? M = -X.highest.height / 2 - F * D + D : M = -X.highest.height + D / 2 : c === \"near\" || _ !== 0 ? M = D / 2 : c === \"center\" ? M = X.highest.height / 2 - F * D : M = X.highest.height - O * D, d && (M *= -1)) : (A = S, M = (1 - O) * D / 2);\n                let ti;\n                if (I.showLabelBackdrop) {\n                    const Kt = ht(I.backdropPadding), ye = X.heights[y], xe = X.widths[y];\n                    let Ut = A + M - Kt.top, Me = T - Kt.left;\n                    switch(L){\n                        case \"middle\":\n                            Ut -= ye / 2;\n                            break;\n                        case \"bottom\":\n                            Ut -= ye;\n                            break;\n                    }\n                    switch(w){\n                        case \"center\":\n                            Me -= xe / 2;\n                            break;\n                        case \"right\":\n                            Me -= xe;\n                            break;\n                    }\n                    ti = {\n                        left: Me,\n                        top: Ut,\n                        width: xe + Kt.width,\n                        height: ye + Kt.height,\n                        color: I.backdropColor\n                    };\n                }\n                m.push({\n                    rotation: _,\n                    label: C,\n                    font: k,\n                    color: Y,\n                    strokeColor: Yt,\n                    strokeWidth: ee,\n                    textOffset: M,\n                    textAlign: ie,\n                    textBaseline: L,\n                    translation: [\n                        T,\n                        A\n                    ],\n                    backdrop: ti\n                });\n            }\n            return m;\n        }\n        _getXAxisLabelAlignment() {\n            const { position: t, ticks: e } = this.options;\n            if (-Jt(this.labelRotation)) return t === \"top\" ? \"left\" : \"right\";\n            let n = \"center\";\n            return e.align === \"start\" ? n = \"left\" : e.align === \"end\" ? n = \"right\" : e.align === \"inner\" && (n = \"inner\"), n;\n        }\n        _getYAxisLabelAlignment(t) {\n            const { position: e, ticks: { crossAlign: s, mirror: n, padding: o } } = this.options, r = this._getLabelSizes(), a = t + o, l = r.widest.width;\n            let c, h;\n            return e === \"left\" ? n ? (h = this.right + o, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h += l)) : (h = this.right - a, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h = this.left)) : e === \"right\" ? n ? (h = this.left + o, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h -= l)) : (h = this.left + a, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h = this.right)) : c = \"right\", {\n                textAlign: c,\n                x: h\n            };\n        }\n        _computeLabelArea() {\n            if (this.options.ticks.mirror) return;\n            const t = this.chart, e = this.options.position;\n            if (e === \"left\" || e === \"right\") return {\n                top: 0,\n                left: this.left,\n                bottom: t.height,\n                right: this.right\n            };\n            if (e === \"top\" || e === \"bottom\") return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: t.width\n            };\n        }\n        drawBackground() {\n            const { ctx: t, options: { backgroundColor: e }, left: s, top: n, width: o, height: r } = this;\n            e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());\n        }\n        getLineWidthForValue(t) {\n            const e = this.options.grid;\n            if (!this._isVisible() || !e.display) return 0;\n            const n = this.ticks.findIndex((o)=>o.value === t);\n            return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;\n        }\n        drawGrid(t) {\n            const e = this.options.grid, s = this.ctx, n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n            let o, r;\n            const a = (l, c, h)=>{\n                !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());\n            };\n            if (e.display) for(o = 0, r = n.length; o < r; ++o){\n                const l = n[o];\n                e.drawOnChartArea && a({\n                    x: l.x1,\n                    y: l.y1\n                }, {\n                    x: l.x2,\n                    y: l.y2\n                }, l), e.drawTicks && a({\n                    x: l.tx1,\n                    y: l.ty1\n                }, {\n                    x: l.tx2,\n                    y: l.ty2\n                }, {\n                    color: l.tickColor,\n                    width: l.tickWidth,\n                    borderDash: l.tickBorderDash,\n                    borderDashOffset: l.tickBorderDashOffset\n                });\n            }\n        }\n        drawBorder() {\n            const { chart: t, ctx: e, options: { grid: s } } = this, n = s.setContext(this.getContext()), o = s.drawBorder ? n.borderWidth : 0;\n            if (!o) return;\n            const r = s.setContext(this.getContext(0)).lineWidth, a = this._borderValue;\n            let l, c, h, d;\n            this.isHorizontal() ? (l = xi(t, this.left, o) - o / 2, c = xi(t, this.right, r) + r / 2, h = d = a) : (h = xi(t, this.top, o) - o / 2, d = xi(t, this.bottom, r) + r / 2, l = c = a), e.save(), e.lineWidth = n.borderWidth, e.strokeStyle = n.borderColor, e.beginPath(), e.moveTo(l, h), e.lineTo(c, d), e.stroke(), e.restore();\n        }\n        drawLabels(t) {\n            if (!this.options.ticks.display) return;\n            const s = this.ctx, n = this._computeLabelArea();\n            n && Ko(s, n);\n            const o = this._labelItems || (this._labelItems = this._computeLabelItems(t));\n            let r, a;\n            for(r = 0, a = o.length; r < a; ++r){\n                const l = o[r], c = l.font, h = l.label;\n                l.backdrop && (s.fillStyle = l.backdrop.color, s.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height));\n                let d = l.textOffset;\n                Ei(s, h, 0, d, c, l);\n            }\n            n && Uo(s);\n        }\n        drawTitle() {\n            const { ctx: t, options: { position: e, title: s, reverse: n } } = this;\n            if (!s.display) return;\n            const o = lt(s.font), r = ht(s.padding), a = s.align;\n            let l = o.lineHeight / 2;\n            e === \"bottom\" || e === \"center\" || $(e) ? (l += r.bottom, Q(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;\n            const { titleX: c, titleY: h, maxWidth: d, rotation: u } = UT(this, l, e, a);\n            Ei(t, s.text, 0, 0, o, {\n                color: s.color,\n                maxWidth: d,\n                rotation: u,\n                textAlign: KT(a, e, n),\n                textBaseline: \"middle\",\n                translation: [\n                    c,\n                    h\n                ]\n            });\n        }\n        draw(t) {\n            this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n        }\n        _layers() {\n            const t = this.options, e = t.ticks && t.ticks.z || 0, s = R(t.grid && t.grid.z, -1);\n            return !this._isVisible() || this.draw !== Ze.prototype.draw ? [\n                {\n                    z: e,\n                    draw: (n)=>{\n                        this.draw(n);\n                    }\n                }\n            ] : [\n                {\n                    z: s,\n                    draw: (n)=>{\n                        this.drawBackground(), this.drawGrid(n), this.drawTitle();\n                    }\n                },\n                {\n                    z: s + 1,\n                    draw: ()=>{\n                        this.drawBorder();\n                    }\n                },\n                {\n                    z: e,\n                    draw: (n)=>{\n                        this.drawLabels(n);\n                    }\n                }\n            ];\n        }\n        getMatchingVisibleMetas(t) {\n            const e = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + \"AxisID\", n = [];\n            let o, r;\n            for(o = 0, r = e.length; o < r; ++o){\n                const a = e[o];\n                a[s] === this.id && (!t || a.type === t) && n.push(a);\n            }\n            return n;\n        }\n        _resolveTickFontOptions(t) {\n            const e = this.options.ticks.setContext(this.getContext(t));\n            return lt(e.font);\n        }\n        _maxDigits() {\n            const t = this._resolveTickFontOptions(0).lineHeight;\n            return (this.isHorizontal() ? this.width : this.height) / t;\n        }\n    }\n    class Jo {\n        constructor(t, e, s){\n            this.type = t, this.scope = e, this.override = s, this.items = Object.create(null);\n        }\n        isForType(t) {\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n        }\n        register(t) {\n            const e = Object.getPrototypeOf(t);\n            let s;\n            qT(e) && (s = this.register(e));\n            const n = this.items, o = t.id, r = this.scope + \".\" + o;\n            if (!o) throw new Error(\"class does not have id: \" + t);\n            return o in n || (n[o] = t, XT(t, r, s), this.override && B.override(t.id, t.overrides)), r;\n        }\n        get(t) {\n            return this.items[t];\n        }\n        unregister(t) {\n            const e = this.items, s = t.id, n = this.scope;\n            s in e && delete e[s], n && s in B[n] && (delete B[n][s], this.override && delete yi[s]);\n        }\n    }\n    function XT(i, t, e) {\n        const s = ge(Object.create(null), [\n            e ? B.get(e) : {},\n            B.get(t),\n            i.defaults\n        ]);\n        B.set(t, s), i.defaultRoutes && GT(t, i.defaultRoutes), i.descriptors && B.describe(t, i.descriptors);\n    }\n    function GT(i, t) {\n        Object.keys(t).forEach((e)=>{\n            const s = e.split(\".\"), n = s.pop(), o = [\n                i\n            ].concat(s).join(\".\"), r = t[e].split(\".\"), a = r.pop(), l = r.join(\".\");\n            B.route(o, n, l, a);\n        });\n    }\n    function qT(i) {\n        return \"id\" in i && \"defaults\" in i;\n    }\n    class ZT {\n        constructor(){\n            this.controllers = new Jo(zt, \"datasets\", !0), this.elements = new Jo(jt, \"elements\"), this.plugins = new Jo(Object, \"plugins\"), this.scales = new Jo(Ze, \"scales\"), this._typedRegistries = [\n                this.controllers,\n                this.scales,\n                this.elements\n            ];\n        }\n        add(...t) {\n            this._each(\"register\", t);\n        }\n        remove(...t) {\n            this._each(\"unregister\", t);\n        }\n        addControllers(...t) {\n            this._each(\"register\", t, this.controllers);\n        }\n        addElements(...t) {\n            this._each(\"register\", t, this.elements);\n        }\n        addPlugins(...t) {\n            this._each(\"register\", t, this.plugins);\n        }\n        addScales(...t) {\n            this._each(\"register\", t, this.scales);\n        }\n        getController(t) {\n            return this._get(t, this.controllers, \"controller\");\n        }\n        getElement(t) {\n            return this._get(t, this.elements, \"element\");\n        }\n        getPlugin(t) {\n            return this._get(t, this.plugins, \"plugin\");\n        }\n        getScale(t) {\n            return this._get(t, this.scales, \"scale\");\n        }\n        removeControllers(...t) {\n            this._each(\"unregister\", t, this.controllers);\n        }\n        removeElements(...t) {\n            this._each(\"unregister\", t, this.elements);\n        }\n        removePlugins(...t) {\n            this._each(\"unregister\", t, this.plugins);\n        }\n        removeScales(...t) {\n            this._each(\"unregister\", t, this.scales);\n        }\n        _each(t, e, s) {\n            [\n                ...e\n            ].forEach((n)=>{\n                const o = s || this._getRegistryForType(n);\n                s || o.isForType(n) || o === this.plugins && n.id ? this._exec(t, o, n) : U(n, (r)=>{\n                    const a = s || this._getRegistryForType(r);\n                    this._exec(t, a, r);\n                });\n            });\n        }\n        _exec(t, e, s) {\n            const n = Ha(t);\n            G(s[\"before\" + n], [], s), e[t](s), G(s[\"after\" + n], [], s);\n        }\n        _getRegistryForType(t) {\n            for(let e = 0; e < this._typedRegistries.length; e++){\n                const s = this._typedRegistries[e];\n                if (s.isForType(t)) return s;\n            }\n            return this.plugins;\n        }\n        _get(t, e, s) {\n            const n = e.get(t);\n            if (n === void 0) throw new Error('\"' + t + '\" is not a registered ' + s + \".\");\n            return n;\n        }\n    }\n    var te = new ZT;\n    class gn extends zt {\n        update(t) {\n            const e = this._cachedMeta, { data: s = [] } = e, n = this.chart._animationsDisabled;\n            let { start: o, count: r } = fu(e, s, n);\n            if (this._drawStart = o, this._drawCount = r, pu(e) && (o = 0, r = s.length), this.options.showLine) {\n                const { dataset: a, _dataset: l } = e;\n                a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;\n                const c = this.resolveDatasetElementOptions(t);\n                c.segment = this.options.segment, this.updateElement(a, void 0, {\n                    animated: !n,\n                    options: c\n                }, t);\n            }\n            this.updateElements(s, o, r, t);\n        }\n        addElements() {\n            const { showLine: t } = this.options;\n            !this.datasetElementType && t && (this.datasetElementType = te.getElement(\"line\")), super.addElements();\n        }\n        updateElements(t, e, s, n) {\n            const o = n === \"reset\", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(h), u = this.includeOptions(n, d), f = r.axis, p = a.axis, { spanGaps: _, segment: m } = this.options, y = as(_) ? _ : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || n === \"none\";\n            let E = e > 0 && this.getParsed(e - 1);\n            for(let C = e; C < e + s; ++C){\n                const T = t[C], A = this.getParsed(C), w = x ? T : {}, S = N(A[p]), k = w[f] = r.getPixelForValue(A[f], C), D = w[p] = o || S ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, A, l) : A[p], C);\n                w.skip = isNaN(k) || isNaN(D) || S, w.stop = C > 0 && Math.abs(A[f] - E[f]) > y, m && (w.parsed = A, w.raw = c.data[C]), u && (w.options = d || this.resolveDataElementOptions(C, T.active ? \"active\" : n)), x || this.updateElement(T, C, w, n), E = A;\n            }\n            this.updateSharedOptions(d, n, h);\n        }\n        getMaxOverflow() {\n            const t = this._cachedMeta, e = t.data || [];\n            if (!this.options.showLine) {\n                let a = 0;\n                for(let l = e.length - 1; l >= 0; --l)a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);\n                return a > 0 && a;\n            }\n            const s = t.dataset, n = s.options && s.options.borderWidth || 0;\n            if (!e.length) return n;\n            const o = e[0].size(this.resolveDataElementOptions(0)), r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n            return Math.max(n, o, r) / 2;\n        }\n    }\n    gn.id = \"scatter\", gn.defaults = {\n        datasetElementType: !1,\n        dataElementType: \"point\",\n        showLine: !1,\n        fill: !1\n    }, gn.overrides = {\n        interaction: {\n            mode: \"point\"\n        },\n        plugins: {\n            tooltip: {\n                callbacks: {\n                    title () {\n                        return \"\";\n                    },\n                    label (i) {\n                        return \"(\" + i.label + \", \" + i.formattedValue + \")\";\n                    }\n                }\n            }\n        },\n        scales: {\n            x: {\n                type: \"linear\"\n            },\n            y: {\n                type: \"linear\"\n            }\n        }\n    };\n    var pf = Object.freeze({\n        __proto__: null,\n        BarController: cn,\n        BubbleController: hn,\n        DoughnutController: ki,\n        LineController: dn,\n        PolarAreaController: un,\n        PieController: Zo,\n        RadarController: fn,\n        ScatterController: gn\n    });\n    function Si() {\n        throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n    }\n    class cl {\n        constructor(t){\n            this.options = t || {};\n        }\n        init(t) {}\n        formats() {\n            return Si();\n        }\n        parse(t, e) {\n            return Si();\n        }\n        format(t, e) {\n            return Si();\n        }\n        add(t, e, s) {\n            return Si();\n        }\n        diff(t, e, s) {\n            return Si();\n        }\n        startOf(t, e, s) {\n            return Si();\n        }\n        endOf(t, e) {\n            return Si();\n        }\n    }\n    cl.override = function(i) {\n        Object.assign(cl.prototype, i);\n    };\n    var _f = {\n        _date: cl\n    };\n    function QT(i, t, e, s) {\n        const { controller: n, data: o, _sorted: r } = i, a = n._cachedMeta.iScale;\n        if (a && t === a.axis && t !== \"r\" && r && o.length) {\n            const l = a._reversePixels ? WE : we;\n            if (s) {\n                if (n._sharedOptions) {\n                    const c = o[0], h = typeof c.getRange == \"function\" && c.getRange(t);\n                    if (h) {\n                        const d = l(o, t, e - h), u = l(o, t, e + h);\n                        return {\n                            lo: d.lo,\n                            hi: u.hi\n                        };\n                    }\n                }\n            } else return l(o, t, e);\n        }\n        return {\n            lo: 0,\n            hi: o.length - 1\n        };\n    }\n    function mn(i, t, e, s, n) {\n        const o = i.getSortedVisibleDatasetMetas(), r = e[t];\n        for(let a = 0, l = o.length; a < l; ++a){\n            const { index: c, data: h } = o[a], { lo: d, hi: u } = QT(o[a], t, r, n);\n            for(let f = d; f <= u; ++f){\n                const p = h[f];\n                p.skip || s(p, c, f);\n            }\n        }\n    }\n    function JT(i) {\n        const t = i.indexOf(\"x\") !== -1, e = i.indexOf(\"y\") !== -1;\n        return function(s, n) {\n            const o = t ? Math.abs(s.x - n.x) : 0, r = e ? Math.abs(s.y - n.y) : 0;\n            return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n        };\n    }\n    function hl(i, t, e, s, n) {\n        const o = [];\n        return !n && !i.isPointInArea(t) || mn(i, e, t, function(a, l, c) {\n            !n && !on(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({\n                element: a,\n                datasetIndex: l,\n                index: c\n            });\n        }, !0), o;\n    }\n    function tA(i, t, e, s) {\n        let n = [];\n        function o(r, a, l) {\n            const { startAngle: c, endAngle: h } = r.getProps([\n                \"startAngle\",\n                \"endAngle\"\n            ], s), { angle: d } = au(r, {\n                x: t.x,\n                y: t.y\n            });\n            Js(d, c, h) && n.push({\n                element: r,\n                datasetIndex: a,\n                index: l\n            });\n        }\n        return mn(i, e, t, o), n;\n    }\n    function eA(i, t, e, s, n, o) {\n        let r = [];\n        const a = JT(e);\n        let l = Number.POSITIVE_INFINITY;\n        function c(h, d, u) {\n            const f = h.inRange(t.x, t.y, n);\n            if (s && !f) return;\n            const p = h.getCenterPoint(n);\n            if (!(!!o || i.isPointInArea(p)) && !f) return;\n            const m = a(t, p);\n            m < l ? (r = [\n                {\n                    element: h,\n                    datasetIndex: d,\n                    index: u\n                }\n            ], l = m) : m === l && r.push({\n                element: h,\n                datasetIndex: d,\n                index: u\n            });\n        }\n        return mn(i, e, t, c), r;\n    }\n    function dl(i, t, e, s, n, o) {\n        return !o && !i.isPointInArea(t) ? [] : e === \"r\" && !s ? tA(i, t, e, n) : eA(i, t, e, s, n, o);\n    }\n    function gf(i, t, e, s, n) {\n        const o = [], r = e === \"x\" ? \"inXRange\" : \"inYRange\";\n        let a = !1;\n        return mn(i, e, t, (l, c, h)=>{\n            l[r](t[e], n) && (o.push({\n                element: l,\n                datasetIndex: c,\n                index: h\n            }), a = a || l.inRange(t.x, t.y, n));\n        }), s && !a ? [] : o;\n    }\n    var mf = {\n        evaluateInteractionItems: mn,\n        modes: {\n            index (i, t, e, s) {\n                const n = Ai(t, i), o = e.axis || \"x\", r = e.includeInvisible || !1, a = e.intersect ? hl(i, n, o, s, r) : dl(i, n, o, !1, s, r), l = [];\n                return a.length ? (i.getSortedVisibleDatasetMetas().forEach((c)=>{\n                    const h = a[0].index, d = c.data[h];\n                    d && !d.skip && l.push({\n                        element: d,\n                        datasetIndex: c.index,\n                        index: h\n                    });\n                }), l) : [];\n            },\n            dataset (i, t, e, s) {\n                const n = Ai(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n                let a = e.intersect ? hl(i, n, o, s, r) : dl(i, n, o, !1, s, r);\n                if (a.length > 0) {\n                    const l = a[0].datasetIndex, c = i.getDatasetMeta(l).data;\n                    a = [];\n                    for(let h = 0; h < c.length; ++h)a.push({\n                        element: c[h],\n                        datasetIndex: l,\n                        index: h\n                    });\n                }\n                return a;\n            },\n            point (i, t, e, s) {\n                const n = Ai(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n                return hl(i, n, o, s, r);\n            },\n            nearest (i, t, e, s) {\n                const n = Ai(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n                return dl(i, n, o, e.intersect, s, r);\n            },\n            x (i, t, e, s) {\n                const n = Ai(t, i);\n                return gf(i, n, \"x\", e.intersect, s);\n            },\n            y (i, t, e, s) {\n                const n = Ai(t, i);\n                return gf(i, n, \"y\", e.intersect, s);\n            }\n        }\n    };\n    const bf = [\n        \"left\",\n        \"top\",\n        \"right\",\n        \"bottom\"\n    ];\n    function bn(i, t) {\n        return i.filter((e)=>e.pos === t);\n    }\n    function vf(i, t) {\n        return i.filter((e)=>bf.indexOf(e.pos) === -1 && e.box.axis === t);\n    }\n    function vn(i, t) {\n        return i.sort((e, s)=>{\n            const n = t ? s : e, o = t ? e : s;\n            return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;\n        });\n    }\n    function iA(i) {\n        const t = [];\n        let e, s, n, o, r, a;\n        for(e = 0, s = (i || []).length; e < s; ++e)n = i[e], ({ position: o, options: { stack: r, stackWeight: a = 1 } } = n), t.push({\n            index: e,\n            box: n,\n            pos: o,\n            horizontal: n.isHorizontal(),\n            weight: n.weight,\n            stack: r && o + r,\n            stackWeight: a\n        });\n        return t;\n    }\n    function sA(i) {\n        const t = {};\n        for (const e of i){\n            const { stack: s, pos: n, stackWeight: o } = e;\n            if (!s || !bf.includes(n)) continue;\n            const r = t[s] || (t[s] = {\n                count: 0,\n                placed: 0,\n                weight: 0,\n                size: 0\n            });\n            r.count++, r.weight += o;\n        }\n        return t;\n    }\n    function nA(i, t) {\n        const e = sA(i), { vBoxMaxWidth: s, hBoxMaxHeight: n } = t;\n        let o, r, a;\n        for(o = 0, r = i.length; o < r; ++o){\n            a = i[o];\n            const { fullSize: l } = a.box, c = e[a.stack], h = c && a.stackWeight / c.weight;\n            a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);\n        }\n        return e;\n    }\n    function oA(i) {\n        const t = iA(i), e = vn(t.filter((c)=>c.box.fullSize), !0), s = vn(bn(t, \"left\"), !0), n = vn(bn(t, \"right\")), o = vn(bn(t, \"top\"), !0), r = vn(bn(t, \"bottom\")), a = vf(t, \"x\"), l = vf(t, \"y\");\n        return {\n            fullSize: e,\n            leftAndTop: s.concat(o),\n            rightAndBottom: n.concat(l).concat(r).concat(a),\n            chartArea: bn(t, \"chartArea\"),\n            vertical: s.concat(n).concat(l),\n            horizontal: o.concat(r).concat(a)\n        };\n    }\n    function yf(i, t, e, s) {\n        return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);\n    }\n    function xf(i, t) {\n        i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);\n    }\n    function rA(i, t, e, s) {\n        const { pos: n, box: o } = e, r = i.maxPadding;\n        if (!$(n)) {\n            e.size && (i[n] -= e.size);\n            const d = s[e.stack] || {\n                size: 0,\n                count: 1\n            };\n            d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;\n        }\n        o.getPadding && xf(r, o.getPadding());\n        const a = Math.max(0, t.outerWidth - yf(r, i, \"left\", \"right\")), l = Math.max(0, t.outerHeight - yf(r, i, \"top\", \"bottom\")), c = a !== i.w, h = l !== i.h;\n        return i.w = a, i.h = l, e.horizontal ? {\n            same: c,\n            other: h\n        } : {\n            same: h,\n            other: c\n        };\n    }\n    function aA(i) {\n        const t = i.maxPadding;\n        function e(s) {\n            const n = Math.max(t[s] - i[s], 0);\n            return i[s] += n, n;\n        }\n        i.y += e(\"top\"), i.x += e(\"left\"), e(\"right\"), e(\"bottom\");\n    }\n    function lA(i, t) {\n        const e = t.maxPadding;\n        function s(n) {\n            const o = {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            };\n            return n.forEach((r)=>{\n                o[r] = Math.max(t[r], e[r]);\n            }), o;\n        }\n        return s(i ? [\n            \"left\",\n            \"right\"\n        ] : [\n            \"top\",\n            \"bottom\"\n        ]);\n    }\n    function yn(i, t, e, s) {\n        const n = [];\n        let o, r, a, l, c, h;\n        for(o = 0, r = i.length, c = 0; o < r; ++o){\n            a = i[o], l = a.box, l.update(a.width || t.w, a.height || t.h, lA(a.horizontal, t));\n            const { same: d, other: u } = rA(t, e, a, s);\n            c |= d && n.length, h = h || u, l.fullSize || n.push(a);\n        }\n        return c && yn(n, t, e, s) || h;\n    }\n    function tr(i, t, e, s, n) {\n        i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;\n    }\n    function Ef(i, t, e, s) {\n        const n = e.padding;\n        let { x: o, y: r } = t;\n        for (const a of i){\n            const l = a.box, c = s[a.stack] || {\n                count: 1,\n                placed: 0,\n                weight: 1\n            }, h = a.stackWeight / c.weight || 1;\n            if (a.horizontal) {\n                const d = t.w * h, u = c.size || l.height;\n                Ft(c.start) && (r = c.start), l.fullSize ? tr(l, n.left, r, e.outerWidth - n.right - n.left, u) : tr(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;\n            } else {\n                const d = t.h * h, u = c.size || l.width;\n                Ft(c.start) && (o = c.start), l.fullSize ? tr(l, o, n.top, u, e.outerHeight - n.bottom - n.top) : tr(l, o, t.top + c.placed, u, d), c.start = o, c.placed += d, o = l.right;\n            }\n        }\n        t.x = o, t.y = r;\n    }\n    B.set(\"layout\", {\n        autoPadding: !0,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n    var dt = {\n        addBox (i, t) {\n            i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || \"top\", t.weight = t.weight || 0, t._layers = t._layers || function() {\n                return [\n                    {\n                        z: 0,\n                        draw (e) {\n                            t.draw(e);\n                        }\n                    }\n                ];\n            }, i.boxes.push(t);\n        },\n        removeBox (i, t) {\n            const e = i.boxes ? i.boxes.indexOf(t) : -1;\n            e !== -1 && i.boxes.splice(e, 1);\n        },\n        configure (i, t, e) {\n            t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;\n        },\n        update (i, t, e, s) {\n            if (!i) return;\n            const n = ht(i.options.layout.padding), o = Math.max(t - n.width, 0), r = Math.max(e - n.height, 0), a = oA(i.boxes), l = a.vertical, c = a.horizontal;\n            U(i.boxes, (_)=>{\n                typeof _.beforeLayout == \"function\" && _.beforeLayout();\n            });\n            const h = l.reduce((_, m)=>m.box.options && m.box.options.display === !1 ? _ : _ + 1, 0) || 1, d = Object.freeze({\n                outerWidth: t,\n                outerHeight: e,\n                padding: n,\n                availableWidth: o,\n                availableHeight: r,\n                vBoxMaxWidth: o / 2 / h,\n                hBoxMaxHeight: r / 2\n            }), u = Object.assign({}, n);\n            xf(u, ht(s));\n            const f = Object.assign({\n                maxPadding: u,\n                w: o,\n                h: r,\n                x: n.left,\n                y: n.top\n            }, n), p = nA(l.concat(c), d);\n            yn(a.fullSize, f, d, p), yn(l, f, d, p), yn(c, f, d, p) && yn(l, f, d, p), aA(f), Ef(a.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, Ef(a.rightAndBottom, f, d, p), i.chartArea = {\n                left: f.left,\n                top: f.top,\n                right: f.left + f.w,\n                bottom: f.top + f.h,\n                height: f.h,\n                width: f.w\n            }, U(a.chartArea, (_)=>{\n                const m = _.box;\n                Object.assign(m, i.chartArea), m.update(f.w, f.h, {\n                    left: 0,\n                    top: 0,\n                    right: 0,\n                    bottom: 0\n                });\n            });\n        }\n    };\n    class ul {\n        acquireContext(t, e) {}\n        releaseContext(t) {\n            return !1;\n        }\n        addEventListener(t, e, s) {}\n        removeEventListener(t, e, s) {}\n        getDevicePixelRatio() {\n            return 1;\n        }\n        getMaximumSize(t, e, s, n) {\n            return e = Math.max(0, e || t.width), s = s || t.height, {\n                width: e,\n                height: Math.max(0, n ? Math.floor(e / n) : s)\n            };\n        }\n        isAttached(t) {\n            return !0;\n        }\n        updateConfig(t) {}\n    }\n    class Cf extends ul {\n        acquireContext(t) {\n            return t && t.getContext && t.getContext(\"2d\") || null;\n        }\n        updateConfig(t) {\n            t.options.animation = !1;\n        }\n    }\n    const er = \"$chartjs\", cA = {\n        touchstart: \"mousedown\",\n        touchmove: \"mousemove\",\n        touchend: \"mouseup\",\n        pointerenter: \"mouseenter\",\n        pointerdown: \"mousedown\",\n        pointermove: \"mousemove\",\n        pointerup: \"mouseup\",\n        pointerleave: \"mouseout\",\n        pointerout: \"mouseout\"\n    }, Tf = (i)=>i === null || i === \"\";\n    function hA(i, t) {\n        const e = i.style, s = i.getAttribute(\"height\"), n = i.getAttribute(\"width\");\n        if (i[er] = {\n            initial: {\n                height: s,\n                width: n,\n                style: {\n                    display: e.display,\n                    height: e.height,\n                    width: e.width\n                }\n            }\n        }, e.display = e.display || \"block\", e.boxSizing = e.boxSizing || \"border-box\", Tf(n)) {\n            const o = Fu(i, \"width\");\n            o !== void 0 && (i.width = o);\n        }\n        if (Tf(s)) {\n            if (i.style.height === \"\") i.height = i.width / (t || 2);\n            else {\n                const o = Fu(i, \"height\");\n                o !== void 0 && (i.height = o);\n            }\n        }\n        return i;\n    }\n    const Af = GC ? {\n        passive: !0\n    } : !1;\n    function dA(i, t, e) {\n        i.addEventListener(t, e, Af);\n    }\n    function uA(i, t, e) {\n        i.canvas.removeEventListener(t, e, Af);\n    }\n    function fA(i, t) {\n        const e = cA[i.type] || i.type, { x: s, y: n } = Ai(i, t);\n        return {\n            type: e,\n            chart: t,\n            native: i,\n            x: s !== void 0 ? s : null,\n            y: n !== void 0 ? n : null\n        };\n    }\n    function ir(i, t) {\n        for (const e of i)if (e === t || e.contains(t)) return !0;\n    }\n    function pA(i, t, e) {\n        const s = i.canvas, n = new MutationObserver((o)=>{\n            let r = !1;\n            for (const a of o)r = r || ir(a.addedNodes, s), r = r && !ir(a.removedNodes, s);\n            r && e();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    function _A(i, t, e) {\n        const s = i.canvas, n = new MutationObserver((o)=>{\n            let r = !1;\n            for (const a of o)r = r || ir(a.removedNodes, s), r = r && !ir(a.addedNodes, s);\n            r && e();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    const xn = new Map;\n    let wf = 0;\n    function kf() {\n        const i = window.devicePixelRatio;\n        i !== wf && (wf = i, xn.forEach((t, e)=>{\n            e.currentDevicePixelRatio !== i && t();\n        }));\n    }\n    function gA(i, t) {\n        xn.size || window.addEventListener(\"resize\", kf), xn.set(i, t);\n    }\n    function mA(i) {\n        xn.delete(i), xn.size || window.removeEventListener(\"resize\", kf);\n    }\n    function bA(i, t, e) {\n        const s = i.canvas, n = s && sl(s);\n        if (!n) return;\n        const o = uu((a, l)=>{\n            const c = n.clientWidth;\n            e(a, l), c < n.clientWidth && e();\n        }, window), r = new ResizeObserver((a)=>{\n            const l = a[0], c = l.contentRect.width, h = l.contentRect.height;\n            c === 0 && h === 0 || o(c, h);\n        });\n        return r.observe(n), gA(i, o), r;\n    }\n    function fl(i, t, e) {\n        e && e.disconnect(), t === \"resize\" && mA(i);\n    }\n    function vA(i, t, e) {\n        const s = i.canvas, n = uu((o)=>{\n            i.ctx !== null && e(fA(o, i));\n        }, i, (o)=>{\n            const r = o[0];\n            return [\n                r,\n                r.offsetX,\n                r.offsetY\n            ];\n        });\n        return dA(s, t, n), n;\n    }\n    class Sf extends ul {\n        acquireContext(t, e) {\n            const s = t && t.getContext && t.getContext(\"2d\");\n            return s && s.canvas === t ? (hA(t, e), s) : null;\n        }\n        releaseContext(t) {\n            const e = t.canvas;\n            if (!e[er]) return !1;\n            const s = e[er].initial;\n            [\n                \"height\",\n                \"width\"\n            ].forEach((o)=>{\n                const r = s[o];\n                N(r) ? e.removeAttribute(o) : e.setAttribute(o, r);\n            });\n            const n = s.style || {};\n            return Object.keys(n).forEach((o)=>{\n                e.style[o] = n[o];\n            }), e.width = e.width, delete e[er], !0;\n        }\n        addEventListener(t, e, s) {\n            this.removeEventListener(t, e);\n            const n = t.$proxies || (t.$proxies = {}), r = {\n                attach: pA,\n                detach: _A,\n                resize: bA\n            }[e] || vA;\n            n[e] = r(t, e, s);\n        }\n        removeEventListener(t, e) {\n            const s = t.$proxies || (t.$proxies = {}), n = s[e];\n            if (!n) return;\n            (({\n                attach: fl,\n                detach: fl,\n                resize: fl\n            })[e] || uA)(t, e, n), s[e] = void 0;\n        }\n        getDevicePixelRatio() {\n            return window.devicePixelRatio;\n        }\n        getMaximumSize(t, e, s, n) {\n            return XC(t, e, s, n);\n        }\n        isAttached(t) {\n            const e = sl(t);\n            return !!(e && e.isConnected);\n        }\n    }\n    function Of(i) {\n        return !Bu() || typeof OffscreenCanvas < \"u\" && i instanceof OffscreenCanvas ? Cf : Sf;\n    }\n    class yA {\n        constructor(){\n            this._init = [];\n        }\n        notify(t, e, s, n) {\n            e === \"beforeInit\" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n            const o = n ? this._descriptors(t).filter(n) : this._descriptors(t), r = this._notify(o, t, e, s);\n            return e === \"afterDestroy\" && (this._notify(o, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), r;\n        }\n        _notify(t, e, s, n) {\n            n = n || {};\n            for (const o of t){\n                const r = o.plugin, a = r[s], l = [\n                    e,\n                    n,\n                    o.options\n                ];\n                if (G(a, l, r) === !1 && n.cancelable) return !1;\n            }\n            return !0;\n        }\n        invalidate() {\n            N(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n        }\n        _descriptors(t) {\n            if (this._cache) return this._cache;\n            const e = this._cache = this._createDescriptors(t);\n            return this._notifyStateChanges(t), e;\n        }\n        _createDescriptors(t, e) {\n            const s = t && t.config, n = R(s.options && s.options.plugins, {}), o = xA(s);\n            return n === !1 && !e ? [] : CA(t, o, n, e);\n        }\n        _notifyStateChanges(t) {\n            const e = this._oldCache || [], s = this._cache, n = (o, r)=>o.filter((a)=>!r.some((l)=>a.plugin.id === l.plugin.id));\n            this._notify(n(e, s), t, \"stop\"), this._notify(n(s, e), t, \"start\");\n        }\n    }\n    function xA(i) {\n        const t = {}, e = [], s = Object.keys(te.plugins.items);\n        for(let o = 0; o < s.length; o++)e.push(te.getPlugin(s[o]));\n        const n = i.plugins || [];\n        for(let o = 0; o < n.length; o++){\n            const r = n[o];\n            e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);\n        }\n        return {\n            plugins: e,\n            localIds: t\n        };\n    }\n    function EA(i, t) {\n        return !t && i === !1 ? null : i === !0 ? {} : i;\n    }\n    function CA(i, { plugins: t, localIds: e }, s, n) {\n        const o = [], r = i.getContext();\n        for (const a of t){\n            const l = a.id, c = EA(s[l], n);\n            c !== null && o.push({\n                plugin: a,\n                options: TA(i.config, {\n                    plugin: a,\n                    local: e[l]\n                }, c, r)\n            });\n        }\n        return o;\n    }\n    function TA(i, { plugin: t, local: e }, s, n) {\n        const o = i.pluginScopeKeys(t), r = i.getOptionScopes(s, o);\n        return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [\n            \"\"\n        ], {\n            scriptable: !1,\n            indexable: !1,\n            allKeys: !0\n        });\n    }\n    function pl(i, t) {\n        const e = B.datasets[i] || {};\n        return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || \"x\";\n    }\n    function AA(i, t) {\n        let e = i;\n        return i === \"_index_\" ? e = t : i === \"_value_\" && (e = t === \"x\" ? \"y\" : \"x\"), e;\n    }\n    function wA(i, t) {\n        return i === t ? \"_index_\" : \"_value_\";\n    }\n    function kA(i) {\n        if (i === \"top\" || i === \"bottom\") return \"x\";\n        if (i === \"left\" || i === \"right\") return \"y\";\n    }\n    function _l(i, t) {\n        return i === \"x\" || i === \"y\" ? i : t.axis || kA(t.position) || i.charAt(0).toLowerCase();\n    }\n    function SA(i, t) {\n        const e = yi[i.type] || {\n            scales: {}\n        }, s = t.scales || {}, n = pl(i.type, t), o = Object.create(null), r = Object.create(null);\n        return Object.keys(s).forEach((a)=>{\n            const l = s[a];\n            if (!$(l)) return console.error(`Invalid scale configuration for scale: ${a}`);\n            if (l._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${a}`);\n            const c = _l(a, l), h = wA(c, n), d = e.scales || {};\n            o[c] = o[c] || a, r[a] = qs(Object.create(null), [\n                {\n                    axis: c\n                },\n                l,\n                d[c],\n                d[h]\n            ]);\n        }), i.data.datasets.forEach((a)=>{\n            const l = a.type || i.type, c = a.indexAxis || pl(l, t), d = (yi[l] || {}).scales || {};\n            Object.keys(d).forEach((u)=>{\n                const f = AA(u, c), p = a[f + \"AxisID\"] || o[f] || f;\n                r[p] = r[p] || Object.create(null), qs(r[p], [\n                    {\n                        axis: f\n                    },\n                    s[p],\n                    d[u]\n                ]);\n            });\n        }), Object.keys(r).forEach((a)=>{\n            const l = r[a];\n            qs(l, [\n                B.scales[l.type],\n                B.scale\n            ]);\n        }), r;\n    }\n    function Df(i) {\n        const t = i.options || (i.options = {});\n        t.plugins = R(t.plugins, {}), t.scales = SA(i, t);\n    }\n    function Mf(i) {\n        return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;\n    }\n    function OA(i) {\n        return i = i || {}, i.data = Mf(i.data), Df(i), i;\n    }\n    const If = new Map, Lf = new Set;\n    function sr(i, t) {\n        let e = If.get(i);\n        return e || (e = t(), If.set(i, e), Lf.add(e)), e;\n    }\n    const En = (i, t, e)=>{\n        const s = Ke(t, e);\n        s !== void 0 && i.add(s);\n    };\n    class DA {\n        constructor(t){\n            this._config = OA(t), this._scopeCache = new Map, this._resolverCache = new Map;\n        }\n        get platform() {\n            return this._config.platform;\n        }\n        get type() {\n            return this._config.type;\n        }\n        set type(t) {\n            this._config.type = t;\n        }\n        get data() {\n            return this._config.data;\n        }\n        set data(t) {\n            this._config.data = Mf(t);\n        }\n        get options() {\n            return this._config.options;\n        }\n        set options(t) {\n            this._config.options = t;\n        }\n        get plugins() {\n            return this._config.plugins;\n        }\n        update() {\n            const t = this._config;\n            this.clearCache(), Df(t);\n        }\n        clearCache() {\n            this._scopeCache.clear(), this._resolverCache.clear();\n        }\n        datasetScopeKeys(t) {\n            return sr(t, ()=>[\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetAnimationScopeKeys(t, e) {\n            return sr(`${t}.transition.${e}`, ()=>[\n                    [\n                        `datasets.${t}.transitions.${e}`,\n                        `transitions.${e}`\n                    ],\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetElementScopeKeys(t, e) {\n            return sr(`${t}-${e}`, ()=>[\n                    [\n                        `datasets.${t}.elements.${e}`,\n                        `datasets.${t}`,\n                        `elements.${e}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        pluginScopeKeys(t) {\n            const e = t.id, s = this.type;\n            return sr(`${s}-plugin-${e}`, ()=>[\n                    [\n                        `plugins.${e}`,\n                        ...t.additionalOptionScopes || []\n                    ]\n                ]);\n        }\n        _cachedScopes(t, e) {\n            const s = this._scopeCache;\n            let n = s.get(t);\n            return (!n || e) && (n = new Map, s.set(t, n)), n;\n        }\n        getOptionScopes(t, e, s) {\n            const { options: n, type: o } = this, r = this._cachedScopes(t, s), a = r.get(e);\n            if (a) return a;\n            const l = new Set;\n            e.forEach((h)=>{\n                t && (l.add(t), h.forEach((d)=>En(l, t, d))), h.forEach((d)=>En(l, n, d)), h.forEach((d)=>En(l, yi[o] || {}, d)), h.forEach((d)=>En(l, B, d)), h.forEach((d)=>En(l, qa, d));\n            });\n            const c = Array.from(l);\n            return c.length === 0 && c.push(Object.create(null)), Lf.has(e) && r.set(e, c), c;\n        }\n        chartOptionScopes() {\n            const { options: t, type: e } = this;\n            return [\n                t,\n                yi[e] || {},\n                B.datasets[e] || {},\n                {\n                    type: e\n                },\n                B,\n                qa\n            ];\n        }\n        resolveNamedOptions(t, e, s, n = [\n            \"\"\n        ]) {\n            const o = {\n                $shared: !0\n            }, { resolver: r, subPrefixes: a } = Pf(this._resolverCache, t, n);\n            let l = r;\n            if (IA(r, e)) {\n                o.$shared = !1, s = Ue(s) ? s() : s;\n                const c = this.createResolver(t, s, a);\n                l = cs(r, s, c);\n            }\n            for (const c of e)o[c] = l[c];\n            return o;\n        }\n        createResolver(t, e, s = [\n            \"\"\n        ], n) {\n            const { resolver: o } = Pf(this._resolverCache, t, s);\n            return $(e) ? cs(o, e, void 0, n) : o;\n        }\n    }\n    function Pf(i, t, e) {\n        let s = i.get(t);\n        s || (s = new Map, i.set(t, s));\n        const n = e.join();\n        let o = s.get(n);\n        return o || (o = {\n            resolver: tl(t, e),\n            subPrefixes: e.filter((a)=>!a.toLowerCase().includes(\"hover\"))\n        }, s.set(n, o)), o;\n    }\n    const MA = (i)=>$(i) && Object.getOwnPropertyNames(i).reduce((t, e)=>t || Ue(i[e]), !1);\n    function IA(i, t) {\n        const { isScriptable: e, isIndexable: s } = Du(i);\n        for (const n of t){\n            const o = e(n), r = s(n), a = (r || o) && i[n];\n            if (o && (Ue(a) || MA(a)) || r && Q(a)) return !0;\n        }\n        return !1;\n    }\n    var LA = \"3.9.1\";\n    const PA = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"chartArea\"\n    ];\n    function Rf(i, t) {\n        return i === \"top\" || i === \"bottom\" || PA.indexOf(i) === -1 && t === \"x\";\n    }\n    function Nf(i, t) {\n        return function(e, s) {\n            return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];\n        };\n    }\n    function $f(i) {\n        const t = i.chart, e = t.options.animation;\n        t.notifyPlugins(\"afterRender\"), G(e && e.onComplete, [\n            i\n        ], t);\n    }\n    function RA(i) {\n        const t = i.chart, e = t.options.animation;\n        G(e && e.onProgress, [\n            i\n        ], t);\n    }\n    function Bf(i) {\n        return Bu() && typeof i == \"string\" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;\n    }\n    const nr = {}, Hf = (i)=>{\n        const t = Bf(i);\n        return Object.values(nr).filter((e)=>e.canvas === t).pop();\n    };\n    function NA(i, t, e) {\n        const s = Object.keys(i);\n        for (const n of s){\n            const o = +n;\n            if (o >= t) {\n                const r = i[n];\n                delete i[n], (e > 0 || o > t) && (i[o + e] = r);\n            }\n        }\n    }\n    function $A(i, t, e, s) {\n        return !e || i.type === \"mouseout\" ? null : s ? t : i;\n    }\n    class gl {\n        constructor(t, e){\n            const s = this.config = new DA(e), n = Bf(t), o = Hf(n);\n            if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n            const r = s.createResolver(s.chartOptionScopes(), this.getContext());\n            this.platform = new (s.platform || Of(n)), this.platform.updateConfig(s);\n            const a = this.platform.acquireContext(n, r.aspectRatio), l = a && a.canvas, c = l && l.height, h = l && l.width;\n            if (this.id = OE(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new yA, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = YE((d)=>this.update(d), r.resizeDelay || 0), this._dataChanges = [], nr[this.id] = this, !a || !l) {\n                console.error(\"Failed to create chart: can't acquire context from the given item\");\n                return;\n            }\n            be.listen(this, \"complete\", $f), be.listen(this, \"progress\", RA), this._initialize(), this.attached && this.update();\n        }\n        get aspectRatio() {\n            const { options: { aspectRatio: t, maintainAspectRatio: e }, width: s, height: n, _aspectRatio: o } = this;\n            return N(t) ? e && o ? o : n ? s / n : null : t;\n        }\n        get data() {\n            return this.config.data;\n        }\n        set data(t) {\n            this.config.data = t;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(t) {\n            this.config.options = t;\n        }\n        _initialize() {\n            return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : Hu(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n        }\n        clear() {\n            return ku(this.canvas, this.ctx), this;\n        }\n        stop() {\n            return be.stop(this), this;\n        }\n        resize(t, e) {\n            be.running(this) ? this._resizeBeforeDraw = {\n                width: t,\n                height: e\n            } : this._resize(t, e);\n        }\n        _resize(t, e) {\n            const s = this.options, n = this.canvas, o = s.maintainAspectRatio && this.aspectRatio, r = this.platform.getMaximumSize(n, t, e, o), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? \"resize\" : \"attach\";\n            this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, Hu(this, a, !0) && (this.notifyPlugins(\"resize\", {\n                size: r\n            }), G(s.onResize, [\n                this,\n                r\n            ], this), this.attached && this._doResize(l) && this.render());\n        }\n        ensureScalesHaveIDs() {\n            const e = this.options.scales || {};\n            U(e, (s, n)=>{\n                s.id = n;\n            });\n        }\n        buildOrUpdateScales() {\n            const t = this.options, e = t.scales, s = this.scales, n = Object.keys(s).reduce((r, a)=>(r[a] = !1, r), {});\n            let o = [];\n            e && (o = o.concat(Object.keys(e).map((r)=>{\n                const a = e[r], l = _l(r, a), c = l === \"r\", h = l === \"x\";\n                return {\n                    options: a,\n                    dposition: c ? \"chartArea\" : h ? \"bottom\" : \"left\",\n                    dtype: c ? \"radialLinear\" : h ? \"category\" : \"linear\"\n                };\n            }))), U(o, (r)=>{\n                const a = r.options, l = a.id, c = _l(l, a), h = R(a.type, r.dtype);\n                (a.position === void 0 || Rf(a.position, c) !== Rf(r.dposition)) && (a.position = r.dposition), n[l] = !0;\n                let d = null;\n                if (l in s && s[l].type === h) d = s[l];\n                else {\n                    const u = te.getScale(h);\n                    d = new u({\n                        id: l,\n                        type: h,\n                        ctx: this.ctx,\n                        chart: this\n                    }), s[d.id] = d;\n                }\n                d.init(a, t);\n            }), U(n, (r, a)=>{\n                r || delete s[a];\n            }), U(s, (r)=>{\n                dt.configure(this, r, r.options), dt.addBox(this, r);\n            });\n        }\n        _updateMetasets() {\n            const t = this._metasets, e = this.data.datasets.length, s = t.length;\n            if (t.sort((n, o)=>n.index - o.index), s > e) {\n                for(let n = e; n < s; ++n)this._destroyDatasetMeta(n);\n                t.splice(e, s - e);\n            }\n            this._sortedMetasets = t.slice(0).sort(Nf(\"order\", \"index\"));\n        }\n        _removeUnreferencedMetasets() {\n            const { _metasets: t, data: { datasets: e } } = this;\n            t.length > e.length && delete this._stacks, t.forEach((s, n)=>{\n                e.filter((o)=>o === s._dataset).length === 0 && this._destroyDatasetMeta(n);\n            });\n        }\n        buildOrUpdateControllers() {\n            const t = [], e = this.data.datasets;\n            let s, n;\n            for(this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++){\n                const o = e[s];\n                let r = this.getDatasetMeta(s);\n                const a = o.type || this.config.type;\n                if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || pl(a, this.options), r.order = o.order || 0, r.index = s, r.label = \"\" + o.label, r.visible = this.isDatasetVisible(s), r.controller) r.controller.updateIndex(s), r.controller.linkScales();\n                else {\n                    const l = te.getController(a), { datasetElementType: c, dataElementType: h } = B.datasets[a];\n                    Object.assign(l.prototype, {\n                        dataElementType: te.getElement(h),\n                        datasetElementType: c && te.getElement(c)\n                    }), r.controller = new l(this, s), t.push(r.controller);\n                }\n            }\n            return this._updateMetasets(), t;\n        }\n        _resetElements() {\n            U(this.data.datasets, (t, e)=>{\n                this.getDatasetMeta(e).controller.reset();\n            }, this);\n        }\n        reset() {\n            this._resetElements(), this.notifyPlugins(\"reset\");\n        }\n        update(t) {\n            const e = this.config;\n            e.update();\n            const s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), n = this._animationsDisabled = !s.animation;\n            if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins(\"beforeUpdate\", {\n                mode: t,\n                cancelable: !0\n            }) === !1) return;\n            const o = this.buildOrUpdateControllers();\n            this.notifyPlugins(\"beforeElementsUpdate\");\n            let r = 0;\n            for(let c = 0, h = this.data.datasets.length; c < h; c++){\n                const { controller: d } = this.getDatasetMeta(c), u = !n && o.indexOf(d) === -1;\n                d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);\n            }\n            r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || U(o, (c)=>{\n                c.reset();\n            }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n                mode: t\n            }), this._layers.sort(Nf(\"z\", \"_idx\"));\n            const { _active: a, _lastEvent: l } = this;\n            l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n        }\n        _updateScales() {\n            U(this.scales, (t)=>{\n                dt.removeBox(this, t);\n            }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n        }\n        _checkEventBindings() {\n            const t = this.options, e = new Set(Object.keys(this._listeners)), s = new Set(t.events);\n            (!iu(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());\n        }\n        _updateHiddenIndices() {\n            const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n            for (const { method: s, start: n, count: o } of e){\n                const r = s === \"_removeElements\" ? -o : o;\n                NA(t, n, r);\n            }\n        }\n        _getUniformDataChanges() {\n            const t = this._dataChanges;\n            if (!t || !t.length) return;\n            this._dataChanges = [];\n            const e = this.data.datasets.length, s = (o)=>new Set(t.filter((r)=>r[0] === o).map((r, a)=>a + \",\" + r.splice(1).join(\",\"))), n = s(0);\n            for(let o = 1; o < e; o++)if (!iu(n, s(o))) return;\n            return Array.from(n).map((o)=>o.split(\",\")).map((o)=>({\n                    method: o[1],\n                    start: +o[2],\n                    count: +o[3]\n                }));\n        }\n        _updateLayout(t) {\n            if (this.notifyPlugins(\"beforeLayout\", {\n                cancelable: !0\n            }) === !1) return;\n            dt.update(this, this.width, this.height, t);\n            const e = this.chartArea, s = e.width <= 0 || e.height <= 0;\n            this._layers = [], U(this.boxes, (n)=>{\n                s && n.position === \"chartArea\" || (n.configure && n.configure(), this._layers.push(...n._layers()));\n            }, this), this._layers.forEach((n, o)=>{\n                n._idx = o;\n            }), this.notifyPlugins(\"afterLayout\");\n        }\n        _updateDatasets(t) {\n            if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n                mode: t,\n                cancelable: !0\n            }) !== !1) {\n                for(let e = 0, s = this.data.datasets.length; e < s; ++e)this.getDatasetMeta(e).controller.configure();\n                for(let e = 0, s = this.data.datasets.length; e < s; ++e)this._updateDataset(e, Ue(t) ? t({\n                    datasetIndex: e\n                }) : t);\n                this.notifyPlugins(\"afterDatasetsUpdate\", {\n                    mode: t\n                });\n            }\n        }\n        _updateDataset(t, e) {\n            const s = this.getDatasetMeta(t), n = {\n                meta: s,\n                index: t,\n                mode: e,\n                cancelable: !0\n            };\n            this.notifyPlugins(\"beforeDatasetUpdate\", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", n));\n        }\n        render() {\n            this.notifyPlugins(\"beforeRender\", {\n                cancelable: !0\n            }) !== !1 && (be.has(this) ? this.attached && !be.running(this) && be.start(this) : (this.draw(), $f({\n                chart: this\n            })));\n        }\n        draw() {\n            let t;\n            if (this._resizeBeforeDraw) {\n                const { width: s, height: n } = this._resizeBeforeDraw;\n                this._resize(s, n), this._resizeBeforeDraw = null;\n            }\n            if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins(\"beforeDraw\", {\n                cancelable: !0\n            }) === !1) return;\n            const e = this._layers;\n            for(t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea);\n            for(this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea);\n            this.notifyPlugins(\"afterDraw\");\n        }\n        _getSortedDatasetMetas(t) {\n            const e = this._sortedMetasets, s = [];\n            let n, o;\n            for(n = 0, o = e.length; n < o; ++n){\n                const r = e[n];\n                (!t || r.visible) && s.push(r);\n            }\n            return s;\n        }\n        getSortedVisibleDatasetMetas() {\n            return this._getSortedDatasetMetas(!0);\n        }\n        _drawDatasets() {\n            if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n                cancelable: !0\n            }) === !1) return;\n            const t = this.getSortedVisibleDatasetMetas();\n            for(let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]);\n            this.notifyPlugins(\"afterDatasetsDraw\");\n        }\n        _drawDataset(t) {\n            const e = this.ctx, s = t._clip, n = !s.disabled, o = this.chartArea, r = {\n                meta: t,\n                index: t.index,\n                cancelable: !0\n            };\n            this.notifyPlugins(\"beforeDatasetDraw\", r) !== !1 && (n && Ko(e, {\n                left: s.left === !1 ? 0 : o.left - s.left,\n                right: s.right === !1 ? this.width : o.right + s.right,\n                top: s.top === !1 ? 0 : o.top - s.top,\n                bottom: s.bottom === !1 ? this.height : o.bottom + s.bottom\n            }), t.controller.draw(), n && Uo(e), r.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", r));\n        }\n        isPointInArea(t) {\n            return on(t, this.chartArea, this._minPadding);\n        }\n        getElementsAtEventForMode(t, e, s, n) {\n            const o = mf.modes[e];\n            return typeof o == \"function\" ? o(this, t, s, n) : [];\n        }\n        getDatasetMeta(t) {\n            const e = this.data.datasets[t], s = this._metasets;\n            let n = s.filter((o)=>o && o._dataset === e).pop();\n            return n || (n = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: e && e.order || 0,\n                index: t,\n                _dataset: e,\n                _parsed: [],\n                _sorted: !1\n            }, s.push(n)), n;\n        }\n        getContext() {\n            return this.$context || (this.$context = qe(null, {\n                chart: this,\n                type: \"chart\"\n            }));\n        }\n        getVisibleDatasetCount() {\n            return this.getSortedVisibleDatasetMetas().length;\n        }\n        isDatasetVisible(t) {\n            const e = this.data.datasets[t];\n            if (!e) return !1;\n            const s = this.getDatasetMeta(t);\n            return typeof s.hidden == \"boolean\" ? !s.hidden : !e.hidden;\n        }\n        setDatasetVisibility(t, e) {\n            const s = this.getDatasetMeta(t);\n            s.hidden = !e;\n        }\n        toggleDataVisibility(t) {\n            this._hiddenIndices[t] = !this._hiddenIndices[t];\n        }\n        getDataVisibility(t) {\n            return !this._hiddenIndices[t];\n        }\n        _updateVisibility(t, e, s) {\n            const n = s ? \"show\" : \"hide\", o = this.getDatasetMeta(t), r = o.controller._resolveAnimations(void 0, n);\n            Ft(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, {\n                visible: s\n            }), this.update((a)=>a.datasetIndex === t ? n : void 0));\n        }\n        hide(t, e) {\n            this._updateVisibility(t, e, !1);\n        }\n        show(t, e) {\n            this._updateVisibility(t, e, !0);\n        }\n        _destroyDatasetMeta(t) {\n            const e = this._metasets[t];\n            e && e.controller && e.controller._destroy(), delete this._metasets[t];\n        }\n        _stop() {\n            let t, e;\n            for(this.stop(), be.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t);\n        }\n        destroy() {\n            this.notifyPlugins(\"beforeDestroy\");\n            const { canvas: t, ctx: e } = this;\n            this._stop(), this.config.clearCache(), t && (this.unbindEvents(), ku(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins(\"destroy\"), delete nr[this.id], this.notifyPlugins(\"afterDestroy\");\n        }\n        toBase64Image(...t) {\n            return this.canvas.toDataURL(...t);\n        }\n        bindEvents() {\n            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n        }\n        bindUserEvents() {\n            const t = this._listeners, e = this.platform, s = (o, r)=>{\n                e.addEventListener(this, o, r), t[o] = r;\n            }, n = (o, r, a)=>{\n                o.offsetX = r, o.offsetY = a, this._eventHandler(o);\n            };\n            U(this.options.events, (o)=>s(o, n));\n        }\n        bindResponsiveEvents() {\n            this._responsiveListeners || (this._responsiveListeners = {});\n            const t = this._responsiveListeners, e = this.platform, s = (l, c)=>{\n                e.addEventListener(this, l, c), t[l] = c;\n            }, n = (l, c)=>{\n                t[l] && (e.removeEventListener(this, l, c), delete t[l]);\n            }, o = (l, c)=>{\n                this.canvas && this.resize(l, c);\n            };\n            let r;\n            const a = ()=>{\n                n(\"attach\", a), this.attached = !0, this.resize(), s(\"resize\", o), s(\"detach\", r);\n            };\n            r = ()=>{\n                this.attached = !1, n(\"resize\", o), this._stop(), this._resize(0, 0), s(\"attach\", a);\n            }, e.isAttached(this.canvas) ? a() : r();\n        }\n        unbindEvents() {\n            U(this._listeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._listeners = {}, U(this._responsiveListeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._responsiveListeners = void 0;\n        }\n        updateHoverStyle(t, e, s) {\n            const n = s ? \"set\" : \"remove\";\n            let o, r, a, l;\n            for(e === \"dataset\" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller[\"_\" + n + \"DatasetHoverStyle\"]()), a = 0, l = t.length; a < l; ++a){\n                r = t[a];\n                const c = r && this.getDatasetMeta(r.datasetIndex).controller;\n                c && c[n + \"HoverStyle\"](r.element, r.datasetIndex, r.index);\n            }\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t) {\n            const e = this._active || [], s = t.map(({ datasetIndex: o, index: r })=>{\n                const a = this.getDatasetMeta(o);\n                if (!a) throw new Error(\"No dataset found at index \" + o);\n                return {\n                    datasetIndex: o,\n                    element: a.data[r],\n                    index: r\n                };\n            });\n            !$o(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));\n        }\n        notifyPlugins(t, e, s) {\n            return this._plugins.notify(this, t, e, s);\n        }\n        _updateHoverStyles(t, e, s) {\n            const n = this.options.hover, o = (l, c)=>l.filter((h)=>!c.some((d)=>h.datasetIndex === d.datasetIndex && h.index === d.index)), r = o(e, t), a = s ? t : o(t, e);\n            r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);\n        }\n        _eventHandler(t, e) {\n            const s = {\n                event: t,\n                replay: e,\n                cancelable: !0,\n                inChartArea: this.isPointInArea(t)\n            }, n = (r)=>(r.options.events || this.options.events).includes(t.native.type);\n            if (this.notifyPlugins(\"beforeEvent\", s, n) === !1) return;\n            const o = this._handleEvent(t, e, s.inChartArea);\n            return s.cancelable = !1, this.notifyPlugins(\"afterEvent\", s, n), (o || s.changed) && this.render(), this;\n        }\n        _handleEvent(t, e, s) {\n            const { _active: n = [], options: o } = this, r = e, a = this._getActiveElements(t, n, s, r), l = RE(t), c = $A(t, this._lastEvent, s, l);\n            s && (this._lastEvent = null, G(o.onHover, [\n                t,\n                a,\n                this\n            ], this), l && G(o.onClick, [\n                t,\n                a,\n                this\n            ], this));\n            const h = !$o(a, n);\n            return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;\n        }\n        _getActiveElements(t, e, s, n) {\n            if (t.type === \"mouseout\") return [];\n            if (!s) return e;\n            const o = this.options.hover;\n            return this.getElementsAtEventForMode(t, o.mode, o, n);\n        }\n    }\n    const Ff = ()=>U(gl.instances, (i)=>i._plugins.invalidate()), Qe = !0;\n    Object.defineProperties(gl, {\n        defaults: {\n            enumerable: Qe,\n            value: B\n        },\n        instances: {\n            enumerable: Qe,\n            value: nr\n        },\n        overrides: {\n            enumerable: Qe,\n            value: yi\n        },\n        registry: {\n            enumerable: Qe,\n            value: te\n        },\n        version: {\n            enumerable: Qe,\n            value: LA\n        },\n        getChart: {\n            enumerable: Qe,\n            value: Hf\n        },\n        register: {\n            enumerable: Qe,\n            value: (...i)=>{\n                te.add(...i), Ff();\n            }\n        },\n        unregister: {\n            enumerable: Qe,\n            value: (...i)=>{\n                te.remove(...i), Ff();\n            }\n        }\n    });\n    function Vf(i, t, e) {\n        const { startAngle: s, pixelMargin: n, x: o, y: r, outerRadius: a, innerRadius: l } = t;\n        let c = n / a;\n        i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + nt, s - nt), i.closePath(), i.clip();\n    }\n    function BA(i) {\n        return Ja(i, [\n            \"outerStart\",\n            \"outerEnd\",\n            \"innerStart\",\n            \"innerEnd\"\n        ]);\n    }\n    function HA(i, t, e, s) {\n        const n = BA(i.options.borderRadius), o = (e - t) / 2, r = Math.min(o, s * t / 2), a = (l)=>{\n            const c = (e - Math.min(o, l)) * s / 2;\n            return ct(l, 0, Math.min(o, c));\n        };\n        return {\n            outerStart: a(n.outerStart),\n            outerEnd: a(n.outerEnd),\n            innerStart: ct(n.innerStart, 0, r),\n            innerEnd: ct(n.innerEnd, 0, r)\n        };\n    }\n    function us(i, t, e, s) {\n        return {\n            x: e + i * Math.cos(t),\n            y: s + i * Math.sin(t)\n        };\n    }\n    function ml(i, t, e, s, n, o) {\n        const { x: r, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = t, d = Math.max(t.outerRadius + s + e - c, 0), u = h > 0 ? h + s + e + c : 0;\n        let f = 0;\n        const p = n - l;\n        if (s) {\n            const I = h > 0 ? h - s : 0, F = d > 0 ? d - s : 0, Y = (I + F) / 2, Yt = Y !== 0 ? p * Y / (Y + s) : p;\n            f = (p - Yt) / 2;\n        }\n        const _ = Math.max(.001, p * d - e / et) / d, m = (p - _) / 2, y = l + m + f, x = n - m - f, { outerStart: E, outerEnd: C, innerStart: T, innerEnd: A } = HA(t, u, d, x - y), w = d - E, S = d - C, k = y + E / w, D = x - C / S, O = u + T, M = u + A, L = y + T / O, X = x - A / M;\n        if (i.beginPath(), o) {\n            if (i.arc(r, a, d, k, D), C > 0) {\n                const Y = us(S, D, r, a);\n                i.arc(Y.x, Y.y, C, D, x + nt);\n            }\n            const I = us(M, x, r, a);\n            if (i.lineTo(I.x, I.y), A > 0) {\n                const Y = us(M, X, r, a);\n                i.arc(Y.x, Y.y, A, x + nt, X + Math.PI);\n            }\n            if (i.arc(r, a, u, x - A / u, y + T / u, !0), T > 0) {\n                const Y = us(O, L, r, a);\n                i.arc(Y.x, Y.y, T, L + Math.PI, y - nt);\n            }\n            const F = us(w, y, r, a);\n            if (i.lineTo(F.x, F.y), E > 0) {\n                const Y = us(w, k, r, a);\n                i.arc(Y.x, Y.y, E, y - nt, k);\n            }\n        } else {\n            i.moveTo(r, a);\n            const I = Math.cos(k) * d + r, F = Math.sin(k) * d + a;\n            i.lineTo(I, F);\n            const Y = Math.cos(D) * d + r, Yt = Math.sin(D) * d + a;\n            i.lineTo(Y, Yt);\n        }\n        i.closePath();\n    }\n    function FA(i, t, e, s, n) {\n        const { fullCircles: o, startAngle: r, circumference: a } = t;\n        let l = t.endAngle;\n        if (o) {\n            ml(i, t, e, s, r + q, n);\n            for(let c = 0; c < o; ++c)i.fill();\n            isNaN(a) || (l = r + a % q, a % q === 0 && (l += q));\n        }\n        return ml(i, t, e, s, l, n), i.fill(), l;\n    }\n    function VA(i, t, e) {\n        const { x: s, y: n, startAngle: o, pixelMargin: r, fullCircles: a } = t, l = Math.max(t.outerRadius - r, 0), c = t.innerRadius + r;\n        let h;\n        for(e && Vf(i, t, o + q), i.beginPath(), i.arc(s, n, c, o + q, o, !0), h = 0; h < a; ++h)i.stroke();\n        for(i.beginPath(), i.arc(s, n, l, o, o + q), h = 0; h < a; ++h)i.stroke();\n    }\n    function WA(i, t, e, s, n, o) {\n        const { options: r } = t, { borderWidth: a, borderJoinStyle: l } = r, c = r.borderAlign === \"inner\";\n        a && (c ? (i.lineWidth = a * 2, i.lineJoin = l || \"round\") : (i.lineWidth = a, i.lineJoin = l || \"bevel\"), t.fullCircles && VA(i, t, c), c && Vf(i, t, n), ml(i, t, e, s, n, o), i.stroke());\n    }\n    class fs extends jt {\n        constructor(t){\n            super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n        }\n        inRange(t, e, s) {\n            const n = this.getProps([\n                \"x\",\n                \"y\"\n            ], s), { angle: o, distance: r } = au(n, {\n                x: t,\n                y: e\n            }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: h, circumference: d } = this.getProps([\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"circumference\"\n            ], s), u = this.options.spacing / 2, p = R(d, l - a) >= q || Js(o, a, l), _ = Ae(r, c + u, h + u);\n            return p && _;\n        }\n        getCenterPoint(t) {\n            const { x: e, y: s, startAngle: n, endAngle: o, innerRadius: r, outerRadius: a } = this.getProps([\n                \"x\",\n                \"y\",\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"circumference\"\n            ], t), { offset: l, spacing: c } = this.options, h = (n + o) / 2, d = (r + a + c + l) / 2;\n            return {\n                x: e + Math.cos(h) * d,\n                y: s + Math.sin(h) * d\n            };\n        }\n        tooltipPosition(t) {\n            return this.getCenterPoint(t);\n        }\n        draw(t) {\n            const { options: e, circumference: s } = this, n = (e.offset || 0) / 2, o = (e.spacing || 0) / 2, r = e.circular;\n            if (this.pixelMargin = e.borderAlign === \"inner\" ? .33 : 0, this.fullCircles = s > q ? Math.floor(s / q) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;\n            t.save();\n            let a = 0;\n            if (n) {\n                a = n / 2;\n                const c = (this.startAngle + this.endAngle) / 2;\n                t.translate(Math.cos(c) * a, Math.sin(c) * a), this.circumference >= et && (a = n);\n            }\n            t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;\n            const l = FA(t, this, a, o, r);\n            WA(t, this, a, o, l, r), t.restore();\n        }\n    }\n    fs.id = \"arc\", fs.defaults = {\n        borderAlign: \"center\",\n        borderColor: \"#fff\",\n        borderJoinStyle: void 0,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: void 0,\n        circular: !0\n    }, fs.defaultRoutes = {\n        backgroundColor: \"backgroundColor\"\n    };\n    function Wf(i, t, e = t) {\n        i.lineCap = R(e.borderCapStyle, t.borderCapStyle), i.setLineDash(R(e.borderDash, t.borderDash)), i.lineDashOffset = R(e.borderDashOffset, t.borderDashOffset), i.lineJoin = R(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = R(e.borderWidth, t.borderWidth), i.strokeStyle = R(e.borderColor, t.borderColor);\n    }\n    function zA(i, t, e) {\n        i.lineTo(e.x, e.y);\n    }\n    function jA(i) {\n        return i.stepped ? bC : i.tension || i.cubicInterpolationMode === \"monotone\" ? vC : zA;\n    }\n    function zf(i, t, e = {}) {\n        const s = i.length, { start: n = 0, end: o = s - 1 } = e, { start: r, end: a } = t, l = Math.max(n, r), c = Math.min(o, a), h = n < r && o < r || n > a && o > a;\n        return {\n            count: s,\n            start: l,\n            loop: t.loop,\n            ilen: c < l && !h ? s + c - l : c - l\n        };\n    }\n    function YA(i, t, e, s) {\n        const { points: n, options: o } = t, { count: r, start: a, loop: l, ilen: c } = zf(n, e, s), h = jA(o);\n        let { move: d = !0, reverse: u } = s || {}, f, p, _;\n        for(f = 0; f <= c; ++f)p = n[(a + (u ? c - f : f)) % r], !p.skip && (d ? (i.moveTo(p.x, p.y), d = !1) : h(i, _, p, u, o.stepped), _ = p);\n        return l && (p = n[(a + (u ? c : 0)) % r], h(i, _, p, u, o.stepped)), !!l;\n    }\n    function KA(i, t, e, s) {\n        const n = t.points, { count: o, start: r, ilen: a } = zf(n, e, s), { move: l = !0, reverse: c } = s || {};\n        let h = 0, d = 0, u, f, p, _, m, y;\n        const x = (C)=>(r + (c ? a - C : C)) % o, E = ()=>{\n            _ !== m && (i.lineTo(h, m), i.lineTo(h, _), i.lineTo(h, y));\n        };\n        for(l && (f = n[x(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u){\n            if (f = n[x(u)], f.skip) continue;\n            const C = f.x, T = f.y, A = C | 0;\n            A === p ? (T < _ ? _ = T : T > m && (m = T), h = (d * h + C) / ++d) : (E(), i.lineTo(C, T), p = A, d = 0, _ = m = T), y = T;\n        }\n        E();\n    }\n    function bl(i) {\n        const t = i.options, e = t.borderDash && t.borderDash.length;\n        return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== \"monotone\" && !t.stepped && !e ? KA : YA;\n    }\n    function UA(i) {\n        return i.stepped ? qC : i.tension || i.cubicInterpolationMode === \"monotone\" ? ZC : wi;\n    }\n    function XA(i, t, e, s) {\n        let n = t._path;\n        n || (n = t._path = new Path2D, t.path(n, e, s) && n.closePath()), Wf(i, t.options), i.stroke(n);\n    }\n    function GA(i, t, e, s) {\n        const { segments: n, options: o } = t, r = bl(t);\n        for (const a of n)Wf(i, o, a.style), i.beginPath(), r(i, t, a, {\n            start: e,\n            end: e + s - 1\n        }) && i.closePath(), i.stroke();\n    }\n    const qA = typeof Path2D == \"function\";\n    function ZA(i, t, e, s) {\n        qA && !t.options.segment ? XA(i, t, e, s) : GA(i, t, e, s);\n    }\n    class Se extends jt {\n        constructor(t){\n            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n        }\n        updateControlPoints(t, e) {\n            const s = this.options;\n            if ((s.tension || s.cubicInterpolationMode === \"monotone\") && !s.stepped && !this._pointsUpdated) {\n                const n = s.spanGaps ? this._loop : this._fullLoop;\n                WC(this._points, s, t, n, e), this._pointsUpdated = !0;\n            }\n        }\n        set points(t) {\n            this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n        }\n        get points() {\n            return this._points;\n        }\n        get segments() {\n            return this._segments || (this._segments = nT(this, this.options.segment));\n        }\n        first() {\n            const t = this.segments, e = this.points;\n            return t.length && e[t[0].start];\n        }\n        last() {\n            const t = this.segments, e = this.points, s = t.length;\n            return s && e[t[s - 1].end];\n        }\n        interpolate(t, e) {\n            const s = this.options, n = t[e], o = this.points, r = Uu(this, {\n                property: e,\n                start: n,\n                end: n\n            });\n            if (!r.length) return;\n            const a = [], l = UA(s);\n            let c, h;\n            for(c = 0, h = r.length; c < h; ++c){\n                const { start: d, end: u } = r[c], f = o[d], p = o[u];\n                if (f === p) {\n                    a.push(f);\n                    continue;\n                }\n                const _ = Math.abs((n - f[e]) / (p[e] - f[e])), m = l(f, p, _, s.stepped);\n                m[e] = t[e], a.push(m);\n            }\n            return a.length === 1 ? a[0] : a;\n        }\n        pathSegment(t, e, s) {\n            return bl(this)(t, this, e, s);\n        }\n        path(t, e, s) {\n            const n = this.segments, o = bl(this);\n            let r = this._loop;\n            e = e || 0, s = s || this.points.length - e;\n            for (const a of n)r &= o(t, this, a, {\n                start: e,\n                end: e + s - 1\n            });\n            return !!r;\n        }\n        draw(t, e, s, n) {\n            const o = this.options || {};\n            (this.points || []).length && o.borderWidth && (t.save(), ZA(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n        }\n    }\n    Se.id = \"line\", Se.defaults = {\n        borderCapStyle: \"butt\",\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: \"miter\",\n        borderWidth: 3,\n        capBezierPoints: !0,\n        cubicInterpolationMode: \"default\",\n        fill: !1,\n        spanGaps: !1,\n        stepped: !1,\n        tension: 0\n    }, Se.defaultRoutes = {\n        backgroundColor: \"backgroundColor\",\n        borderColor: \"borderColor\"\n    }, Se.descriptors = {\n        _scriptable: !0,\n        _indexable: (i)=>i !== \"borderDash\" && i !== \"fill\"\n    };\n    function jf(i, t, e, s) {\n        const n = i.options, { [e]: o } = i.getProps([\n            e\n        ], s);\n        return Math.abs(t - o) < n.radius + n.hitRadius;\n    }\n    class ps extends jt {\n        constructor(t){\n            super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n        }\n        inRange(t, e, s) {\n            const n = this.options, { x: o, y: r } = this.getProps([\n                \"x\",\n                \"y\"\n            ], s);\n            return Math.pow(t - o, 2) + Math.pow(e - r, 2) < Math.pow(n.hitRadius + n.radius, 2);\n        }\n        inXRange(t, e) {\n            return jf(this, t, \"x\", e);\n        }\n        inYRange(t, e) {\n            return jf(this, t, \"y\", e);\n        }\n        getCenterPoint(t) {\n            const { x: e, y: s } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: s\n            };\n        }\n        size(t) {\n            t = t || this.options || {};\n            let e = t.radius || 0;\n            e = Math.max(e, e && t.hoverRadius || 0);\n            const s = e && t.borderWidth || 0;\n            return (e + s) * 2;\n        }\n        draw(t, e) {\n            const s = this.options;\n            this.skip || s.radius < .1 || !on(this, e, this.size(s) / 2) || (t.strokeStyle = s.borderColor, t.lineWidth = s.borderWidth, t.fillStyle = s.backgroundColor, Qa(t, s, this.x, this.y));\n        }\n        getRange() {\n            const t = this.options || {};\n            return t.radius + t.hitRadius;\n        }\n    }\n    ps.id = \"point\", ps.defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: \"circle\",\n        radius: 3,\n        rotation: 0\n    }, ps.defaultRoutes = {\n        backgroundColor: \"backgroundColor\",\n        borderColor: \"borderColor\"\n    };\n    function Yf(i, t) {\n        const { x: e, y: s, base: n, width: o, height: r } = i.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"width\",\n            \"height\"\n        ], t);\n        let a, l, c, h, d;\n        return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), {\n            left: a,\n            top: c,\n            right: l,\n            bottom: h\n        };\n    }\n    function Je(i, t, e, s) {\n        return i ? 0 : ct(t, e, s);\n    }\n    function QA(i, t, e) {\n        const s = i.options.borderWidth, n = i.borderSkipped, o = Ou(s);\n        return {\n            t: Je(n.top, o.top, 0, e),\n            r: Je(n.right, o.right, 0, t),\n            b: Je(n.bottom, o.bottom, 0, e),\n            l: Je(n.left, o.left, 0, t)\n        };\n    }\n    function JA(i, t, e) {\n        const { enableBorderRadius: s } = i.getProps([\n            \"enableBorderRadius\"\n        ]), n = i.options.borderRadius, o = Ci(n), r = Math.min(t, e), a = i.borderSkipped, l = s || $(n);\n        return {\n            topLeft: Je(!l || a.top || a.left, o.topLeft, 0, r),\n            topRight: Je(!l || a.top || a.right, o.topRight, 0, r),\n            bottomLeft: Je(!l || a.bottom || a.left, o.bottomLeft, 0, r),\n            bottomRight: Je(!l || a.bottom || a.right, o.bottomRight, 0, r)\n        };\n    }\n    function tw(i) {\n        const t = Yf(i), e = t.right - t.left, s = t.bottom - t.top, n = QA(i, e / 2, s / 2), o = JA(i, e / 2, s / 2);\n        return {\n            outer: {\n                x: t.left,\n                y: t.top,\n                w: e,\n                h: s,\n                radius: o\n            },\n            inner: {\n                x: t.left + n.l,\n                y: t.top + n.t,\n                w: e - n.l - n.r,\n                h: s - n.t - n.b,\n                radius: {\n                    topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),\n                    topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),\n                    bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),\n                    bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))\n                }\n            }\n        };\n    }\n    function vl(i, t, e, s) {\n        const n = t === null, o = e === null, a = i && !(n && o) && Yf(i, s);\n        return a && (n || Ae(t, a.left, a.right)) && (o || Ae(e, a.top, a.bottom));\n    }\n    function ew(i) {\n        return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;\n    }\n    function iw(i, t) {\n        i.rect(t.x, t.y, t.w, t.h);\n    }\n    function yl(i, t, e = {}) {\n        const s = i.x !== e.x ? -t : 0, n = i.y !== e.y ? -t : 0, o = (i.x + i.w !== e.x + e.w ? t : 0) - s, r = (i.y + i.h !== e.y + e.h ? t : 0) - n;\n        return {\n            x: i.x + s,\n            y: i.y + n,\n            w: i.w + o,\n            h: i.h + r,\n            radius: i.radius\n        };\n    }\n    class _s extends jt {\n        constructor(t){\n            super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n        }\n        draw(t) {\n            const { inflateAmount: e, options: { borderColor: s, backgroundColor: n } } = this, { inner: o, outer: r } = tw(this), a = ew(r.radius) ? rn : iw;\n            t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, yl(r, e, o)), t.clip(), a(t, yl(o, -e, r)), t.fillStyle = s, t.fill(\"evenodd\")), t.beginPath(), a(t, yl(o, e)), t.fillStyle = n, t.fill(), t.restore();\n        }\n        inRange(t, e, s) {\n            return vl(this, t, e, s);\n        }\n        inXRange(t, e) {\n            return vl(this, t, null, e);\n        }\n        inYRange(t, e) {\n            return vl(this, null, t, e);\n        }\n        getCenterPoint(t) {\n            const { x: e, y: s, base: n, horizontal: o } = this.getProps([\n                \"x\",\n                \"y\",\n                \"base\",\n                \"horizontal\"\n            ], t);\n            return {\n                x: o ? (e + n) / 2 : e,\n                y: o ? s : (s + n) / 2\n            };\n        }\n        getRange(t) {\n            return t === \"x\" ? this.width / 2 : this.height / 2;\n        }\n    }\n    _s.id = \"bar\", _s.defaults = {\n        borderSkipped: \"start\",\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: \"auto\",\n        pointStyle: void 0\n    }, _s.defaultRoutes = {\n        backgroundColor: \"backgroundColor\",\n        borderColor: \"borderColor\"\n    };\n    var Kf = Object.freeze({\n        __proto__: null,\n        ArcElement: fs,\n        LineElement: Se,\n        PointElement: ps,\n        BarElement: _s\n    });\n    function sw(i, t, e, s, n) {\n        const o = n.samples || s;\n        if (o >= e) return i.slice(t, t + e);\n        const r = [], a = (e - 2) / (o - 2);\n        let l = 0;\n        const c = t + e - 1;\n        let h = t, d, u, f, p, _;\n        for(r[l++] = i[h], d = 0; d < o - 2; d++){\n            let m = 0, y = 0, x;\n            const E = Math.floor((d + 1) * a) + 1 + t, C = Math.min(Math.floor((d + 2) * a) + 1, e) + t, T = C - E;\n            for(x = E; x < C; x++)m += i[x].x, y += i[x].y;\n            m /= T, y /= T;\n            const A = Math.floor(d * a) + 1 + t, w = Math.min(Math.floor((d + 1) * a) + 1, e) + t, { x: S, y: k } = i[h];\n            for(f = p = -1, x = A; x < w; x++)p = .5 * Math.abs((S - m) * (i[x].y - k) - (S - i[x].x) * (y - k)), p > f && (f = p, u = i[x], _ = x);\n            r[l++] = u, h = _;\n        }\n        return r[l++] = i[c], r;\n    }\n    function nw(i, t, e, s) {\n        let n = 0, o = 0, r, a, l, c, h, d, u, f, p, _;\n        const m = [], y = t + e - 1, x = i[t].x, C = i[y].x - x;\n        for(r = t; r < t + e; ++r){\n            a = i[r], l = (a.x - x) / C * s, c = a.y;\n            const T = l | 0;\n            if (T === h) c < p ? (p = c, d = r) : c > _ && (_ = c, u = r), n = (o * n + a.x) / ++o;\n            else {\n                const A = r - 1;\n                if (!N(d) && !N(u)) {\n                    const w = Math.min(d, u), S = Math.max(d, u);\n                    w !== f && w !== A && m.push({\n                        ...i[w],\n                        x: n\n                    }), S !== f && S !== A && m.push({\n                        ...i[S],\n                        x: n\n                    });\n                }\n                r > 0 && A !== f && m.push(i[A]), m.push(a), h = T, o = 0, p = _ = c, d = u = f = r;\n            }\n        }\n        return m;\n    }\n    function Uf(i) {\n        if (i._decimated) {\n            const t = i._data;\n            delete i._decimated, delete i._data, Object.defineProperty(i, \"data\", {\n                value: t\n            });\n        }\n    }\n    function Xf(i) {\n        i.data.datasets.forEach((t)=>{\n            Uf(t);\n        });\n    }\n    function ow(i, t) {\n        const e = t.length;\n        let s = 0, n;\n        const { iScale: o } = i, { min: r, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();\n        return l && (s = ct(we(t, o.axis, r).lo, 0, e - 1)), c ? n = ct(we(t, o.axis, a).hi + 1, s, e) - s : n = e - s, {\n            start: s,\n            count: n\n        };\n    }\n    var Gf = {\n        id: \"decimation\",\n        defaults: {\n            algorithm: \"min-max\",\n            enabled: !1\n        },\n        beforeElementsUpdate: (i, t, e)=>{\n            if (!e.enabled) {\n                Xf(i);\n                return;\n            }\n            const s = i.width;\n            i.data.datasets.forEach((n, o)=>{\n                const { _data: r, indexAxis: a } = n, l = i.getDatasetMeta(o), c = r || n.data;\n                if (tt([\n                    a,\n                    i.options.indexAxis\n                ]) === \"y\" || !l.controller.supportsDecimation) return;\n                const h = i.scales[l.xAxisID];\n                if (h.type !== \"linear\" && h.type !== \"time\" || i.options.parsing) return;\n                let { start: d, count: u } = ow(l, c);\n                const f = e.threshold || 4 * s;\n                if (u <= f) {\n                    Uf(n);\n                    return;\n                }\n                N(r) && (n._data = c, delete n.data, Object.defineProperty(n, \"data\", {\n                    configurable: !0,\n                    enumerable: !0,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(_) {\n                        this._data = _;\n                    }\n                }));\n                let p;\n                switch(e.algorithm){\n                    case \"lttb\":\n                        p = sw(c, d, u, s, e);\n                        break;\n                    case \"min-max\":\n                        p = nw(c, d, u, s);\n                        break;\n                    default:\n                        throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);\n                }\n                n._decimated = p;\n            });\n        },\n        destroy (i) {\n            Xf(i);\n        }\n    };\n    function rw(i, t, e) {\n        const s = i.segments, n = i.points, o = t.points, r = [];\n        for (const a of s){\n            let { start: l, end: c } = a;\n            c = El(l, c, n);\n            const h = xl(e, n[l], n[c], a.loop);\n            if (!t.segments) {\n                r.push({\n                    source: a,\n                    target: h,\n                    start: n[l],\n                    end: n[c]\n                });\n                continue;\n            }\n            const d = Uu(t, h);\n            for (const u of d){\n                const f = xl(e, o[u.start], o[u.end], u.loop), p = Ku(a, n, f);\n                for (const _ of p)r.push({\n                    source: _,\n                    target: u,\n                    start: {\n                        [e]: qf(h, f, \"start\", Math.max)\n                    },\n                    end: {\n                        [e]: qf(h, f, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n        return r;\n    }\n    function xl(i, t, e, s) {\n        if (s) return;\n        let n = t[i], o = e[i];\n        return i === \"angle\" && (n = Nt(n), o = Nt(o)), {\n            property: i,\n            start: n,\n            end: o\n        };\n    }\n    function aw(i, t) {\n        const { x: e = null, y: s = null } = i || {}, n = t.points, o = [];\n        return t.segments.forEach(({ start: r, end: a })=>{\n            a = El(r, a, n);\n            const l = n[r], c = n[a];\n            s !== null ? (o.push({\n                x: l.x,\n                y: s\n            }), o.push({\n                x: c.x,\n                y: s\n            })) : e !== null && (o.push({\n                x: e,\n                y: l.y\n            }), o.push({\n                x: e,\n                y: c.y\n            }));\n        }), o;\n    }\n    function El(i, t, e) {\n        for(; t > i; t--){\n            const s = e[t];\n            if (!isNaN(s.x) && !isNaN(s.y)) break;\n        }\n        return t;\n    }\n    function qf(i, t, e, s) {\n        return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;\n    }\n    function Zf(i, t) {\n        let e = [], s = !1;\n        return Q(i) ? (s = !0, e = i) : e = aw(i, t), e.length ? new Se({\n            points: e,\n            options: {\n                tension: 0\n            },\n            _loop: s,\n            _fullLoop: s\n        }) : null;\n    }\n    function Qf(i) {\n        return i && i.fill !== !1;\n    }\n    function lw(i, t, e) {\n        let n = i[t].fill;\n        const o = [\n            t\n        ];\n        let r;\n        if (!e) return n;\n        for(; n !== !1 && o.indexOf(n) === -1;){\n            if (!rt(n)) return n;\n            if (r = i[n], !r) return !1;\n            if (r.visible) return n;\n            o.push(n), n = r.fill;\n        }\n        return !1;\n    }\n    function cw(i, t, e) {\n        const s = fw(i);\n        if ($(s)) return isNaN(s.value) ? !1 : s;\n        let n = parseFloat(s);\n        return rt(n) && Math.floor(n) === n ? hw(s[0], t, n, e) : [\n            \"origin\",\n            \"start\",\n            \"end\",\n            \"stack\",\n            \"shape\"\n        ].indexOf(s) >= 0 && s;\n    }\n    function hw(i, t, e, s) {\n        return (i === \"-\" || i === \"+\") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;\n    }\n    function dw(i, t) {\n        let e = null;\n        return i === \"start\" ? e = t.bottom : i === \"end\" ? e = t.top : $(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;\n    }\n    function uw(i, t, e) {\n        let s;\n        return i === \"start\" ? s = e : i === \"end\" ? s = t.options.reverse ? t.min : t.max : $(i) ? s = i.value : s = t.getBaseValue(), s;\n    }\n    function fw(i) {\n        const t = i.options, e = t.fill;\n        let s = R(e && e.target, e);\n        return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? \"origin\" : s;\n    }\n    function pw(i) {\n        const { scale: t, index: e, line: s } = i, n = [], o = s.segments, r = s.points, a = _w(t, e);\n        a.push(Zf({\n            x: null,\n            y: t.bottom\n        }, s));\n        for(let l = 0; l < o.length; l++){\n            const c = o[l];\n            for(let h = c.start; h <= c.end; h++)gw(n, r[h], a);\n        }\n        return new Se({\n            points: n,\n            options: {}\n        });\n    }\n    function _w(i, t) {\n        const e = [], s = i.getMatchingVisibleMetas(\"line\");\n        for(let n = 0; n < s.length; n++){\n            const o = s[n];\n            if (o.index === t) break;\n            o.hidden || e.unshift(o.dataset);\n        }\n        return e;\n    }\n    function gw(i, t, e) {\n        const s = [];\n        for(let n = 0; n < e.length; n++){\n            const o = e[n], { first: r, last: a, point: l } = mw(o, t, \"x\");\n            if (!(!l || r && a)) {\n                if (r) s.unshift(l);\n                else if (i.push(l), !a) break;\n            }\n        }\n        i.push(...s);\n    }\n    function mw(i, t, e) {\n        const s = i.interpolate(t, e);\n        if (!s) return {};\n        const n = s[e], o = i.segments, r = i.points;\n        let a = !1, l = !1;\n        for(let c = 0; c < o.length; c++){\n            const h = o[c], d = r[h.start][e], u = r[h.end][e];\n            if (Ae(n, d, u)) {\n                a = n === d, l = n === u;\n                break;\n            }\n        }\n        return {\n            first: a,\n            last: l,\n            point: s\n        };\n    }\n    class Jf {\n        constructor(t){\n            this.x = t.x, this.y = t.y, this.radius = t.radius;\n        }\n        pathSegment(t, e, s) {\n            const { x: n, y: o, radius: r } = this;\n            return e = e || {\n                start: 0,\n                end: q\n            }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;\n        }\n        interpolate(t) {\n            const { x: e, y: s, radius: n } = this, o = t.angle;\n            return {\n                x: e + Math.cos(o) * n,\n                y: s + Math.sin(o) * n,\n                angle: o\n            };\n        }\n    }\n    function bw(i) {\n        const { chart: t, fill: e, line: s } = i;\n        if (rt(e)) return vw(t, e);\n        if (e === \"stack\") return pw(i);\n        if (e === \"shape\") return !0;\n        const n = yw(i);\n        return n instanceof Jf ? n : Zf(n, s);\n    }\n    function vw(i, t) {\n        const e = i.getDatasetMeta(t);\n        return e && i.isDatasetVisible(t) ? e.dataset : null;\n    }\n    function yw(i) {\n        return (i.scale || {}).getPointPositionForValue ? Ew(i) : xw(i);\n    }\n    function xw(i) {\n        const { scale: t = {}, fill: e } = i, s = dw(e, t);\n        if (rt(s)) {\n            const n = t.isHorizontal();\n            return {\n                x: n ? s : null,\n                y: n ? null : s\n            };\n        }\n        return null;\n    }\n    function Ew(i) {\n        const { scale: t, fill: e } = i, s = t.options, n = t.getLabels().length, o = s.reverse ? t.max : t.min, r = uw(e, t, o), a = [];\n        if (s.grid.circular) {\n            const l = t.getPointPositionForValue(0, o);\n            return new Jf({\n                x: l.x,\n                y: l.y,\n                radius: t.getDistanceFromCenterForValue(r)\n            });\n        }\n        for(let l = 0; l < n; ++l)a.push(t.getPointPositionForValue(l, r));\n        return a;\n    }\n    function Cl(i, t, e) {\n        const s = bw(t), { line: n, scale: o, axis: r } = t, a = n.options, l = a.fill, c = a.backgroundColor, { above: h = c, below: d = c } = l || {};\n        s && n.points.length && (Ko(i, e), Cw(i, {\n            line: n,\n            target: s,\n            above: h,\n            below: d,\n            area: e,\n            scale: o,\n            axis: r\n        }), Uo(i));\n    }\n    function Cw(i, t) {\n        const { line: e, target: s, above: n, below: o, area: r, scale: a } = t, l = e._loop ? \"angle\" : t.axis;\n        i.save(), l === \"x\" && o !== n && (tp(i, s, r.top), ep(i, {\n            line: e,\n            target: s,\n            color: n,\n            scale: a,\n            property: l\n        }), i.restore(), i.save(), tp(i, s, r.bottom)), ep(i, {\n            line: e,\n            target: s,\n            color: o,\n            scale: a,\n            property: l\n        }), i.restore();\n    }\n    function tp(i, t, e) {\n        const { segments: s, points: n } = t;\n        let o = !0, r = !1;\n        i.beginPath();\n        for (const a of s){\n            const { start: l, end: c } = a, h = n[l], d = n[El(l, c, n)];\n            o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n                move: r\n            }), r ? i.closePath() : i.lineTo(d.x, e);\n        }\n        i.lineTo(t.first().x, e), i.closePath(), i.clip();\n    }\n    function ep(i, t) {\n        const { line: e, target: s, property: n, color: o, scale: r } = t, a = rw(e, s, n);\n        for (const { source: l, target: c, start: h, end: d } of a){\n            const { style: { backgroundColor: u = o } = {} } = l, f = s !== !0;\n            i.save(), i.fillStyle = u, Tw(i, r, f && xl(n, h, d)), i.beginPath();\n            const p = !!e.pathSegment(i, l);\n            let _;\n            if (f) {\n                p ? i.closePath() : ip(i, s, d, n);\n                const m = !!s.pathSegment(i, c, {\n                    move: p,\n                    reverse: !0\n                });\n                _ = p && m, _ || ip(i, s, h, n);\n            }\n            i.closePath(), i.fill(_ ? \"evenodd\" : \"nonzero\"), i.restore();\n        }\n    }\n    function Tw(i, t, e) {\n        const { top: s, bottom: n } = t.chart.chartArea, { property: o, start: r, end: a } = e || {};\n        o === \"x\" && (i.beginPath(), i.rect(r, s, a - r, n - s), i.clip());\n    }\n    function ip(i, t, e, s) {\n        const n = t.interpolate(e, s);\n        n && i.lineTo(n.x, n.y);\n    }\n    var sp = {\n        id: \"filler\",\n        afterDatasetsUpdate (i, t, e) {\n            const s = (i.data.datasets || []).length, n = [];\n            let o, r, a, l;\n            for(r = 0; r < s; ++r)o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof Se && (l = {\n                visible: i.isDatasetVisible(r),\n                index: r,\n                fill: cw(a, r, s),\n                chart: i,\n                axis: o.controller.options.indexAxis,\n                scale: o.vScale,\n                line: a\n            }), o.$filler = l, n.push(l);\n            for(r = 0; r < s; ++r)l = n[r], !(!l || l.fill === !1) && (l.fill = lw(n, r, e.propagate));\n        },\n        beforeDraw (i, t, e) {\n            const s = e.drawTime === \"beforeDraw\", n = i.getSortedVisibleDatasetMetas(), o = i.chartArea;\n            for(let r = n.length - 1; r >= 0; --r){\n                const a = n[r].$filler;\n                a && (a.line.updateControlPoints(o, a.axis), s && a.fill && Cl(i.ctx, a, o));\n            }\n        },\n        beforeDatasetsDraw (i, t, e) {\n            if (e.drawTime !== \"beforeDatasetsDraw\") return;\n            const s = i.getSortedVisibleDatasetMetas();\n            for(let n = s.length - 1; n >= 0; --n){\n                const o = s[n].$filler;\n                Qf(o) && Cl(i.ctx, o, i.chartArea);\n            }\n        },\n        beforeDatasetDraw (i, t, e) {\n            const s = t.meta.$filler;\n            !Qf(s) || e.drawTime !== \"beforeDatasetDraw\" || Cl(i.ctx, s, i.chartArea);\n        },\n        defaults: {\n            propagate: !0,\n            drawTime: \"beforeDatasetDraw\"\n        }\n    };\n    const np = (i, t)=>{\n        let { boxHeight: e = t, boxWidth: s = t } = i;\n        return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {\n            boxWidth: s,\n            boxHeight: e,\n            itemHeight: Math.max(t, e)\n        };\n    }, Aw = (i, t)=>i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;\n    class op extends jt {\n        constructor(t){\n            super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e, s) {\n            this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n        }\n        buildLabels() {\n            const t = this.options.labels || {};\n            let e = G(t.generateLabels, [\n                this.chart\n            ], this) || [];\n            t.filter && (e = e.filter((s)=>t.filter(s, this.chart.data))), t.sort && (e = e.sort((s, n)=>t.sort(s, n, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n        }\n        fit() {\n            const { options: t, ctx: e } = this;\n            if (!t.display) {\n                this.width = this.height = 0;\n                return;\n            }\n            const s = t.labels, n = lt(s.font), o = n.size, r = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = np(s, o);\n            let c, h;\n            e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, o, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n        }\n        _fitRows(t, e, s, n) {\n            const { ctx: o, maxWidth: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [\n                0\n            ], h = n + a;\n            let d = t;\n            o.textAlign = \"left\", o.textBaseline = \"middle\";\n            let u = -1, f = -h;\n            return this.legendItems.forEach((p, _)=>{\n                const m = s + e / 2 + o.measureText(p.text).width;\n                (_ === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (_ > 0 ? 0 : 1)] = 0, f += h, u++), l[_] = {\n                    left: 0,\n                    top: f,\n                    row: u,\n                    width: m,\n                    height: n\n                }, c[c.length - 1] += m + a;\n            }), d;\n        }\n        _fitCols(t, e, s, n) {\n            const { ctx: o, maxHeight: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = r - t;\n            let d = a, u = 0, f = 0, p = 0, _ = 0;\n            return this.legendItems.forEach((m, y)=>{\n                const x = s + e / 2 + o.measureText(m.text).width;\n                y > 0 && f + n + 2 * a > h && (d += u + a, c.push({\n                    width: u,\n                    height: f\n                }), p += u + a, _++, u = f = 0), l[y] = {\n                    left: p,\n                    top: f,\n                    col: _,\n                    width: x,\n                    height: n\n                }, u = Math.max(u, x), f += n + a;\n            }), d += u, c.push({\n                width: u,\n                height: f\n            }), d;\n        }\n        adjustHitBoxes() {\n            if (!this.options.display) return;\n            const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: s, labels: { padding: n }, rtl: o } } = this, r = ds(o, this.left, this.width);\n            if (this.isHorizontal()) {\n                let a = 0, l = pt(s, this.left + n, this.right - this.lineWidths[a]);\n                for (const c of e)a !== c.row && (a = c.row, l = pt(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;\n            } else {\n                let a = 0, l = pt(s, this.top + t + n, this.bottom - this.columnSizes[a].height);\n                for (const c of e)c.col !== a && (a = c.col, l = pt(s, this.top + t + n, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + n, c.left = r.leftForLtr(r.x(c.left), c.width), l += c.height + n;\n            }\n        }\n        isHorizontal() {\n            return this.options.position === \"top\" || this.options.position === \"bottom\";\n        }\n        draw() {\n            if (this.options.display) {\n                const t = this.ctx;\n                Ko(t, this), this._draw(), Uo(t);\n            }\n        }\n        _draw() {\n            const { options: t, columnSizes: e, lineWidths: s, ctx: n } = this, { align: o, labels: r } = t, a = B.color, l = ds(t.rtl, this.left, this.width), c = lt(r.font), { color: h, padding: d } = r, u = c.size, f = u / 2;\n            let p;\n            this.drawTitle(), n.textAlign = l.textAlign(\"left\"), n.textBaseline = \"middle\", n.lineWidth = .5, n.font = c.string;\n            const { boxWidth: _, boxHeight: m, itemHeight: y } = np(r, u), x = function(w, S, k) {\n                if (isNaN(_) || _ <= 0 || isNaN(m) || m < 0) return;\n                n.save();\n                const D = R(k.lineWidth, 1);\n                if (n.fillStyle = R(k.fillStyle, a), n.lineCap = R(k.lineCap, \"butt\"), n.lineDashOffset = R(k.lineDashOffset, 0), n.lineJoin = R(k.lineJoin, \"miter\"), n.lineWidth = D, n.strokeStyle = R(k.strokeStyle, a), n.setLineDash(R(k.lineDash, [])), r.usePointStyle) {\n                    const O = {\n                        radius: m * Math.SQRT2 / 2,\n                        pointStyle: k.pointStyle,\n                        rotation: k.rotation,\n                        borderWidth: D\n                    }, M = l.xPlus(w, _ / 2), L = S + f;\n                    Su(n, O, M, L, r.pointStyleWidth && _);\n                } else {\n                    const O = S + Math.max((u - m) / 2, 0), M = l.leftForLtr(w, _), L = Ci(k.borderRadius);\n                    n.beginPath(), Object.values(L).some((X)=>X !== 0) ? rn(n, {\n                        x: M,\n                        y: O,\n                        w: _,\n                        h: m,\n                        radius: L\n                    }) : n.rect(M, O, _, m), n.fill(), D !== 0 && n.stroke();\n                }\n                n.restore();\n            }, E = function(w, S, k) {\n                Ei(n, k.text, w, S + y / 2, c, {\n                    strikethrough: k.hidden,\n                    textAlign: l.textAlign(k.textAlign)\n                });\n            }, C = this.isHorizontal(), T = this._computeTitleHeight();\n            C ? p = {\n                x: pt(o, this.left + d, this.right - s[0]),\n                y: this.top + d + T,\n                line: 0\n            } : p = {\n                x: this.left + d,\n                y: pt(o, this.top + T + d, this.bottom - e[0].height),\n                line: 0\n            }, Wu(this.ctx, t.textDirection);\n            const A = y + d;\n            this.legendItems.forEach((w, S)=>{\n                n.strokeStyle = w.fontColor || h, n.fillStyle = w.fontColor || h;\n                const k = n.measureText(w.text).width, D = l.textAlign(w.textAlign || (w.textAlign = r.textAlign)), O = _ + f + k;\n                let M = p.x, L = p.y;\n                l.setWidth(this.width), C ? S > 0 && M + O + d > this.right && (L = p.y += A, p.line++, M = p.x = pt(o, this.left + d, this.right - s[p.line])) : S > 0 && L + A > this.bottom && (M = p.x = M + e[p.line].width + d, p.line++, L = p.y = pt(o, this.top + T + d, this.bottom - e[p.line].height));\n                const X = l.x(M);\n                x(X, L, w), M = KE(D, M + _ + f, C ? M + O : this.right, t.rtl), E(l.x(M), L, w), C ? p.x += O + d : p.y += A;\n            }), zu(this.ctx, t.textDirection);\n        }\n        drawTitle() {\n            const t = this.options, e = t.title, s = lt(e.font), n = ht(e.padding);\n            if (!e.display) return;\n            const o = ds(t.rtl, this.left, this.width), r = this.ctx, a = e.position, l = s.size / 2, c = n.top + l;\n            let h, d = this.left, u = this.width;\n            if (this.isHorizontal()) u = Math.max(...this.lineWidths), h = this.top + c, d = pt(t.align, d, this.right - u);\n            else {\n                const p = this.columnSizes.reduce((_, m)=>Math.max(_, m.height), 0);\n                h = c + pt(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight());\n            }\n            const f = pt(a, d, d + u);\n            r.textAlign = o.textAlign(za(a)), r.textBaseline = \"middle\", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, Ei(r, e.text, f, h, s);\n        }\n        _computeTitleHeight() {\n            const t = this.options.title, e = lt(t.font), s = ht(t.padding);\n            return t.display ? e.lineHeight + s.height : 0;\n        }\n        _getLegendItemAt(t, e) {\n            let s, n, o;\n            if (Ae(t, this.left, this.right) && Ae(e, this.top, this.bottom)) {\n                for(o = this.legendHitBoxes, s = 0; s < o.length; ++s)if (n = o[s], Ae(t, n.left, n.left + n.width) && Ae(e, n.top, n.top + n.height)) return this.legendItems[s];\n            }\n            return null;\n        }\n        handleEvent(t) {\n            const e = this.options;\n            if (!ww(t.type, e)) return;\n            const s = this._getLegendItemAt(t.x, t.y);\n            if (t.type === \"mousemove\" || t.type === \"mouseout\") {\n                const n = this._hoveredItem, o = Aw(n, s);\n                n && !o && G(e.onLeave, [\n                    t,\n                    n,\n                    this\n                ], this), this._hoveredItem = s, s && !o && G(e.onHover, [\n                    t,\n                    s,\n                    this\n                ], this);\n            } else s && G(e.onClick, [\n                t,\n                s,\n                this\n            ], this);\n        }\n    }\n    function ww(i, t) {\n        return !!((i === \"mousemove\" || i === \"mouseout\") && (t.onHover || t.onLeave) || t.onClick && (i === \"click\" || i === \"mouseup\"));\n    }\n    var rp = {\n        id: \"legend\",\n        _element: op,\n        start (i, t, e) {\n            const s = i.legend = new op({\n                ctx: i.ctx,\n                options: e,\n                chart: i\n            });\n            dt.configure(i, s, e), dt.addBox(i, s);\n        },\n        stop (i) {\n            dt.removeBox(i, i.legend), delete i.legend;\n        },\n        beforeUpdate (i, t, e) {\n            const s = i.legend;\n            dt.configure(i, s, e), s.options = e;\n        },\n        afterUpdate (i) {\n            const t = i.legend;\n            t.buildLabels(), t.adjustHitBoxes();\n        },\n        afterEvent (i, t) {\n            t.replay || i.legend.handleEvent(t.event);\n        },\n        defaults: {\n            display: !0,\n            position: \"top\",\n            align: \"center\",\n            fullSize: !0,\n            reverse: !1,\n            weight: 1e3,\n            onClick (i, t, e) {\n                const s = t.datasetIndex, n = e.chart;\n                n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                color: (i)=>i.chart.options.color,\n                boxWidth: 40,\n                padding: 10,\n                generateLabels (i) {\n                    const t = i.data.datasets, { labels: { usePointStyle: e, pointStyle: s, textAlign: n, color: o } } = i.legend.options;\n                    return i._getSortedDatasetMetas().map((r)=>{\n                        const a = r.controller.getStyle(e ? 0 : void 0), l = ht(a.borderWidth);\n                        return {\n                            text: t[r.index].label,\n                            fillStyle: a.backgroundColor,\n                            fontColor: o,\n                            hidden: !r.visible,\n                            lineCap: a.borderCapStyle,\n                            lineDash: a.borderDash,\n                            lineDashOffset: a.borderDashOffset,\n                            lineJoin: a.borderJoinStyle,\n                            lineWidth: (l.width + l.height) / 4,\n                            strokeStyle: a.borderColor,\n                            pointStyle: s || a.pointStyle,\n                            rotation: a.rotation,\n                            textAlign: n || a.textAlign,\n                            borderRadius: 0,\n                            datasetIndex: r.index\n                        };\n                    }, this);\n                }\n            },\n            title: {\n                color: (i)=>i.chart.options.color,\n                display: !1,\n                position: \"center\",\n                text: \"\"\n            }\n        },\n        descriptors: {\n            _scriptable: (i)=>!i.startsWith(\"on\"),\n            labels: {\n                _scriptable: (i)=>![\n                        \"generateLabels\",\n                        \"filter\",\n                        \"sort\"\n                    ].includes(i)\n            }\n        }\n    };\n    class Tl extends jt {\n        constructor(t){\n            super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e) {\n            const s = this.options;\n            if (this.left = 0, this.top = 0, !s.display) {\n                this.width = this.height = this.right = this.bottom = 0;\n                return;\n            }\n            this.width = this.right = t, this.height = this.bottom = e;\n            const n = Q(s.text) ? s.text.length : 1;\n            this._padding = ht(s.padding);\n            const o = n * lt(s.font).lineHeight + this._padding.height;\n            this.isHorizontal() ? this.height = o : this.width = o;\n        }\n        isHorizontal() {\n            const t = this.options.position;\n            return t === \"top\" || t === \"bottom\";\n        }\n        _drawArgs(t) {\n            const { top: e, left: s, bottom: n, right: o, options: r } = this, a = r.align;\n            let l = 0, c, h, d;\n            return this.isHorizontal() ? (h = pt(a, s, o), d = e + t, c = o - s) : (r.position === \"left\" ? (h = s + t, d = pt(a, n, e), l = et * -0.5) : (h = o - t, d = pt(a, e, n), l = et * .5), c = n - e), {\n                titleX: h,\n                titleY: d,\n                maxWidth: c,\n                rotation: l\n            };\n        }\n        draw() {\n            const t = this.ctx, e = this.options;\n            if (!e.display) return;\n            const s = lt(e.font), o = s.lineHeight / 2 + this._padding.top, { titleX: r, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);\n            Ei(t, e.text, 0, 0, s, {\n                color: e.color,\n                maxWidth: l,\n                rotation: c,\n                textAlign: za(e.align),\n                textBaseline: \"middle\",\n                translation: [\n                    r,\n                    a\n                ]\n            });\n        }\n    }\n    function kw(i, t) {\n        const e = new Tl({\n            ctx: i.ctx,\n            options: t,\n            chart: i\n        });\n        dt.configure(i, e, t), dt.addBox(i, e), i.titleBlock = e;\n    }\n    var ap = {\n        id: \"title\",\n        _element: Tl,\n        start (i, t, e) {\n            kw(i, e);\n        },\n        stop (i) {\n            const t = i.titleBlock;\n            dt.removeBox(i, t), delete i.titleBlock;\n        },\n        beforeUpdate (i, t, e) {\n            const s = i.titleBlock;\n            dt.configure(i, s, e), s.options = e;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"bold\"\n            },\n            fullSize: !0,\n            padding: 10,\n            position: \"top\",\n            text: \"\",\n            weight: 2e3\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const or = new WeakMap;\n    var lp = {\n        id: \"subtitle\",\n        start (i, t, e) {\n            const s = new Tl({\n                ctx: i.ctx,\n                options: e,\n                chart: i\n            });\n            dt.configure(i, s, e), dt.addBox(i, s), or.set(i, s);\n        },\n        stop (i) {\n            dt.removeBox(i, or.get(i)), or.delete(i);\n        },\n        beforeUpdate (i, t, e) {\n            const s = or.get(i);\n            dt.configure(i, s, e), s.options = e;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"normal\"\n            },\n            fullSize: !0,\n            padding: 0,\n            position: \"top\",\n            text: \"\",\n            weight: 1500\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const Cn = {\n        average (i) {\n            if (!i.length) return !1;\n            let t, e, s = 0, n = 0, o = 0;\n            for(t = 0, e = i.length; t < e; ++t){\n                const r = i[t].element;\n                if (r && r.hasValue()) {\n                    const a = r.tooltipPosition();\n                    s += a.x, n += a.y, ++o;\n                }\n            }\n            return {\n                x: s / o,\n                y: n / o\n            };\n        },\n        nearest (i, t) {\n            if (!i.length) return !1;\n            let e = t.x, s = t.y, n = Number.POSITIVE_INFINITY, o, r, a;\n            for(o = 0, r = i.length; o < r; ++o){\n                const l = i[o].element;\n                if (l && l.hasValue()) {\n                    const c = l.getCenterPoint(), h = Va(t, c);\n                    h < n && (n = h, a = l);\n                }\n            }\n            if (a) {\n                const l = a.tooltipPosition();\n                e = l.x, s = l.y;\n            }\n            return {\n                x: e,\n                y: s\n            };\n        }\n    };\n    function ve(i, t) {\n        return t && (Q(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;\n    }\n    function Oe(i) {\n        return (typeof i == \"string\" || i instanceof String) && i.indexOf(`\n`) > -1 ? i.split(`\n`) : i;\n    }\n    function Sw(i, t) {\n        const { element: e, datasetIndex: s, index: n } = t, o = i.getDatasetMeta(s).controller, { label: r, value: a } = o.getLabelAndValue(n);\n        return {\n            chart: i,\n            label: r,\n            parsed: o.getParsed(n),\n            raw: i.data.datasets[s].data[n],\n            formattedValue: a,\n            dataset: o.getDataset(),\n            dataIndex: n,\n            datasetIndex: s,\n            element: e\n        };\n    }\n    function cp(i, t) {\n        const e = i.chart.ctx, { body: s, footer: n, title: o } = i, { boxWidth: r, boxHeight: a } = t, l = lt(t.bodyFont), c = lt(t.titleFont), h = lt(t.footerFont), d = o.length, u = n.length, f = s.length, p = ht(t.padding);\n        let _ = p.height, m = 0, y = s.reduce((C, T)=>C + T.before.length + T.lines.length + T.after.length, 0);\n        if (y += i.beforeBody.length + i.afterBody.length, d && (_ += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), y) {\n            const C = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;\n            _ += f * C + (y - f) * l.lineHeight + (y - 1) * t.bodySpacing;\n        }\n        u && (_ += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);\n        let x = 0;\n        const E = function(C) {\n            m = Math.max(m, e.measureText(C).width + x);\n        };\n        return e.save(), e.font = c.string, U(i.title, E), e.font = l.string, U(i.beforeBody.concat(i.afterBody), E), x = t.displayColors ? r + 2 + t.boxPadding : 0, U(s, (C)=>{\n            U(C.before, E), U(C.lines, E), U(C.after, E);\n        }), x = 0, e.font = h.string, U(i.footer, E), e.restore(), m += p.width, {\n            width: m,\n            height: _\n        };\n    }\n    function Ow(i, t) {\n        const { y: e, height: s } = t;\n        return e < s / 2 ? \"top\" : e > i.height - s / 2 ? \"bottom\" : \"center\";\n    }\n    function Dw(i, t, e, s) {\n        const { x: n, width: o } = s, r = e.caretSize + e.caretPadding;\n        if (i === \"left\" && n + o + r > t.width || i === \"right\" && n - o - r < 0) return !0;\n    }\n    function Mw(i, t, e, s) {\n        const { x: n, width: o } = e, { width: r, chartArea: { left: a, right: l } } = i;\n        let c = \"center\";\n        return s === \"center\" ? c = n <= (a + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? c = \"left\" : n >= r - o / 2 && (c = \"right\"), Dw(c, i, t, e) && (c = \"center\"), c;\n    }\n    function hp(i, t, e) {\n        const s = e.yAlign || t.yAlign || Ow(i, e);\n        return {\n            xAlign: e.xAlign || t.xAlign || Mw(i, t, e, s),\n            yAlign: s\n        };\n    }\n    function Iw(i, t) {\n        let { x: e, width: s } = i;\n        return t === \"right\" ? e -= s : t === \"center\" && (e -= s / 2), e;\n    }\n    function Lw(i, t, e) {\n        let { y: s, height: n } = i;\n        return t === \"top\" ? s += e : t === \"bottom\" ? s -= n + e : s -= n / 2, s;\n    }\n    function dp(i, t, e, s) {\n        const { caretSize: n, caretPadding: o, cornerRadius: r } = i, { xAlign: a, yAlign: l } = e, c = n + o, { topLeft: h, topRight: d, bottomLeft: u, bottomRight: f } = Ci(r);\n        let p = Iw(t, a);\n        const _ = Lw(t, l, c);\n        return l === \"center\" ? a === \"left\" ? p += c : a === \"right\" && (p -= c) : a === \"left\" ? p -= Math.max(h, u) + n : a === \"right\" && (p += Math.max(d, f) + n), {\n            x: ct(p, 0, s.width - t.width),\n            y: ct(_, 0, s.height - t.height)\n        };\n    }\n    function rr(i, t, e) {\n        const s = ht(e.padding);\n        return t === \"center\" ? i.x + i.width / 2 : t === \"right\" ? i.x + i.width - s.right : i.x + s.left;\n    }\n    function up(i) {\n        return ve([], Oe(i));\n    }\n    function Pw(i, t, e) {\n        return qe(i, {\n            tooltip: t,\n            tooltipItems: e,\n            type: \"tooltip\"\n        });\n    }\n    function fp(i, t) {\n        const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;\n        return e ? i.override(e) : i;\n    }\n    class Al extends jt {\n        constructor(t){\n            super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n        }\n        initialize(t) {\n            this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n        }\n        _resolveAnimations() {\n            const t = this._cachedAnimations;\n            if (t) return t;\n            const e = this.chart, s = this.options.setContext(this.getContext()), n = s.enabled && e.options.animation && s.animations, o = new ol(this.chart, n);\n            return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;\n        }\n        getContext() {\n            return this.$context || (this.$context = Pw(this.chart.getContext(), this, this._tooltipItems));\n        }\n        getTitle(t, e) {\n            const { callbacks: s } = e, n = s.beforeTitle.apply(this, [\n                t\n            ]), o = s.title.apply(this, [\n                t\n            ]), r = s.afterTitle.apply(this, [\n                t\n            ]);\n            let a = [];\n            return a = ve(a, Oe(n)), a = ve(a, Oe(o)), a = ve(a, Oe(r)), a;\n        }\n        getBeforeBody(t, e) {\n            return up(e.callbacks.beforeBody.apply(this, [\n                t\n            ]));\n        }\n        getBody(t, e) {\n            const { callbacks: s } = e, n = [];\n            return U(t, (o)=>{\n                const r = {\n                    before: [],\n                    lines: [],\n                    after: []\n                }, a = fp(s, o);\n                ve(r.before, Oe(a.beforeLabel.call(this, o))), ve(r.lines, a.label.call(this, o)), ve(r.after, Oe(a.afterLabel.call(this, o))), n.push(r);\n            }), n;\n        }\n        getAfterBody(t, e) {\n            return up(e.callbacks.afterBody.apply(this, [\n                t\n            ]));\n        }\n        getFooter(t, e) {\n            const { callbacks: s } = e, n = s.beforeFooter.apply(this, [\n                t\n            ]), o = s.footer.apply(this, [\n                t\n            ]), r = s.afterFooter.apply(this, [\n                t\n            ]);\n            let a = [];\n            return a = ve(a, Oe(n)), a = ve(a, Oe(o)), a = ve(a, Oe(r)), a;\n        }\n        _createItems(t) {\n            const e = this._active, s = this.chart.data, n = [], o = [], r = [];\n            let a = [], l, c;\n            for(l = 0, c = e.length; l < c; ++l)a.push(Sw(this.chart, e[l]));\n            return t.filter && (a = a.filter((h, d, u)=>t.filter(h, d, u, s))), t.itemSort && (a = a.sort((h, d)=>t.itemSort(h, d, s))), U(a, (h)=>{\n                const d = fp(t.callbacks, h);\n                n.push(d.labelColor.call(this, h)), o.push(d.labelPointStyle.call(this, h)), r.push(d.labelTextColor.call(this, h));\n            }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;\n        }\n        update(t, e) {\n            const s = this.options.setContext(this.getContext()), n = this._active;\n            let o, r = [];\n            if (!n.length) this.opacity !== 0 && (o = {\n                opacity: 0\n            });\n            else {\n                const a = Cn[s.position].call(this, n, this._eventPosition);\n                r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);\n                const l = this._size = cp(this, s), c = Object.assign({}, a, l), h = hp(this.chart, s, c), d = dp(s, c, h, this.chart);\n                this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {\n                    opacity: 1,\n                    x: d.x,\n                    y: d.y,\n                    width: l.width,\n                    height: l.height,\n                    caretX: a.x,\n                    caretY: a.y\n                };\n            }\n            this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay: e\n            });\n        }\n        drawCaret(t, e, s, n) {\n            const o = this.getCaretPosition(t, s, n);\n            e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);\n        }\n        getCaretPosition(t, e, s) {\n            const { xAlign: n, yAlign: o } = this, { caretSize: r, cornerRadius: a } = s, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: d } = Ci(a), { x: u, y: f } = t, { width: p, height: _ } = e;\n            let m, y, x, E, C, T;\n            return o === \"center\" ? (C = f + _ / 2, n === \"left\" ? (m = u, y = m - r, E = C + r, T = C - r) : (m = u + p, y = m + r, E = C - r, T = C + r), x = m) : (n === \"left\" ? y = u + Math.max(l, h) + r : n === \"right\" ? y = u + p - Math.max(c, d) - r : y = this.caretX, o === \"top\" ? (E = f, C = E - r, m = y - r, x = y + r) : (E = f + _, C = E + r, m = y + r, x = y - r), T = E), {\n                x1: m,\n                x2: y,\n                x3: x,\n                y1: E,\n                y2: C,\n                y3: T\n            };\n        }\n        drawTitle(t, e, s) {\n            const n = this.title, o = n.length;\n            let r, a, l;\n            if (o) {\n                const c = ds(s.rtl, this.x, this.width);\n                for(t.x = rr(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = \"middle\", r = lt(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l)e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);\n            }\n        }\n        _drawColorBox(t, e, s, n, o) {\n            const r = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: c, boxPadding: h } = o, d = lt(o.bodyFont), u = rr(this, \"left\", o), f = n.x(u), p = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, _ = e.y + p;\n            if (o.usePointStyle) {\n                const m = {\n                    radius: Math.min(c, l) / 2,\n                    pointStyle: a.pointStyle,\n                    rotation: a.rotation,\n                    borderWidth: 1\n                }, y = n.leftForLtr(f, c) + c / 2, x = _ + l / 2;\n                t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Qa(t, m, y, x), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Qa(t, m, y, x);\n            } else {\n                t.lineWidth = $(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;\n                const m = n.leftForLtr(f, c - h), y = n.leftForLtr(n.xPlus(f, 1), c - h - 2), x = Ci(r.borderRadius);\n                Object.values(x).some((E)=>E !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, rn(t, {\n                    x: m,\n                    y: _,\n                    w: c,\n                    h: l,\n                    radius: x\n                }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), rn(t, {\n                    x: y,\n                    y: _ + 1,\n                    w: c - 2,\n                    h: l - 2,\n                    radius: x\n                }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, _, c, l), t.strokeRect(m, _, c, l), t.fillStyle = r.backgroundColor, t.fillRect(y, _ + 1, c - 2, l - 2));\n            }\n            t.fillStyle = this.labelTextColors[s];\n        }\n        drawBody(t, e, s) {\n            const { body: n } = this, { bodySpacing: o, bodyAlign: r, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: h } = s, d = lt(s.bodyFont);\n            let u = d.lineHeight, f = 0;\n            const p = ds(s.rtl, this.x, this.width), _ = function(S) {\n                e.fillText(S, p.x(t.x + f), t.y + u / 2), t.y += u + o;\n            }, m = p.textAlign(r);\n            let y, x, E, C, T, A, w;\n            for(e.textAlign = r, e.textBaseline = \"middle\", e.font = d.string, t.x = rr(this, m, s), e.fillStyle = s.bodyColor, U(this.beforeBody, _), f = a && m !== \"right\" ? r === \"center\" ? c / 2 + h : c + 2 + h : 0, C = 0, A = n.length; C < A; ++C){\n                for(y = n[C], x = this.labelTextColors[C], e.fillStyle = x, U(y.before, _), E = y.lines, a && E.length && (this._drawColorBox(e, t, C, p, s), u = Math.max(d.lineHeight, l)), T = 0, w = E.length; T < w; ++T)_(E[T]), u = d.lineHeight;\n                U(y.after, _);\n            }\n            f = 0, u = d.lineHeight, U(this.afterBody, _), t.y -= o;\n        }\n        drawFooter(t, e, s) {\n            const n = this.footer, o = n.length;\n            let r, a;\n            if (o) {\n                const l = ds(s.rtl, this.x, this.width);\n                for(t.x = rr(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = \"middle\", r = lt(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a)e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;\n            }\n        }\n        drawBackground(t, e, s, n) {\n            const { xAlign: o, yAlign: r } = this, { x: a, y: l } = t, { width: c, height: h } = s, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: p } = Ci(n.cornerRadius);\n            e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === \"top\" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === \"center\" && o === \"right\" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - p), e.quadraticCurveTo(a + c, l + h, a + c - p, l + h), r === \"bottom\" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === \"center\" && o === \"left\" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();\n        }\n        _updateAnimationTarget(t) {\n            const e = this.chart, s = this.$animations, n = s && s.x, o = s && s.y;\n            if (n || o) {\n                const r = Cn[t.position].call(this, this._active, this._eventPosition);\n                if (!r) return;\n                const a = this._size = cp(this, t), l = Object.assign({}, r, this._size), c = hp(e, t, l), h = dp(t, l, c, e);\n                (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));\n            }\n        }\n        _willRender() {\n            return !!this.opacity;\n        }\n        draw(t) {\n            const e = this.options.setContext(this.getContext());\n            let s = this.opacity;\n            if (!s) return;\n            this._updateAnimationTarget(e);\n            const n = {\n                width: this.width,\n                height: this.height\n            }, o = {\n                x: this.x,\n                y: this.y\n            };\n            s = Math.abs(s) < .001 ? 0 : s;\n            const r = ht(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n            e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Wu(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), zu(t, e.textDirection), t.restore());\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t, e) {\n            const s = this._active, n = t.map(({ datasetIndex: a, index: l })=>{\n                const c = this.chart.getDatasetMeta(a);\n                if (!c) throw new Error(\"Cannot find a dataset at index \" + a);\n                return {\n                    datasetIndex: a,\n                    element: c.data[l],\n                    index: l\n                };\n            }), o = !$o(s, n), r = this._positionChanged(n, e);\n            (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n        }\n        handleEvent(t, e, s = !0) {\n            if (e && this._ignoreReplayEvents) return !1;\n            this._ignoreReplayEvents = !1;\n            const n = this.options, o = this._active || [], r = this._getActiveElements(t, o, e, s), a = this._positionChanged(r, t), l = e || !$o(r, o) || a;\n            return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {\n                x: t.x,\n                y: t.y\n            }, this.update(!0, e))), l;\n        }\n        _getActiveElements(t, e, s, n) {\n            const o = this.options;\n            if (t.type === \"mouseout\") return [];\n            if (!n) return e;\n            const r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);\n            return o.reverse && r.reverse(), r;\n        }\n        _positionChanged(t, e) {\n            const { caretX: s, caretY: n, options: o } = this, r = Cn[o.position].call(this, t, e);\n            return r !== !1 && (s !== r.x || n !== r.y);\n        }\n    }\n    Al.positioners = Cn;\n    var pp = {\n        id: \"tooltip\",\n        _element: Al,\n        positioners: Cn,\n        afterInit (i, t, e) {\n            e && (i.tooltip = new Al({\n                chart: i,\n                options: e\n            }));\n        },\n        beforeUpdate (i, t, e) {\n            i.tooltip && i.tooltip.initialize(e);\n        },\n        reset (i, t, e) {\n            i.tooltip && i.tooltip.initialize(e);\n        },\n        afterDraw (i) {\n            const t = i.tooltip;\n            if (t && t._willRender()) {\n                const e = {\n                    tooltip: t\n                };\n                if (i.notifyPlugins(\"beforeTooltipDraw\", e) === !1) return;\n                t.draw(i.ctx), i.notifyPlugins(\"afterTooltipDraw\", e);\n            }\n        },\n        afterEvent (i, t) {\n            if (i.tooltip) {\n                const e = t.replay;\n                i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);\n            }\n        },\n        defaults: {\n            enabled: !0,\n            external: null,\n            position: \"average\",\n            backgroundColor: \"rgba(0,0,0,0.8)\",\n            titleColor: \"#fff\",\n            titleFont: {\n                weight: \"bold\"\n            },\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleAlign: \"left\",\n            bodyColor: \"#fff\",\n            bodySpacing: 2,\n            bodyFont: {},\n            bodyAlign: \"left\",\n            footerColor: \"#fff\",\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFont: {\n                weight: \"bold\"\n            },\n            footerAlign: \"left\",\n            padding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            boxHeight: (i, t)=>t.bodyFont.size,\n            boxWidth: (i, t)=>t.bodyFont.size,\n            multiKeyBackground: \"#fff\",\n            displayColors: !0,\n            boxPadding: 0,\n            borderColor: \"rgba(0,0,0,0)\",\n            borderWidth: 0,\n            animation: {\n                duration: 400,\n                easing: \"easeOutQuart\"\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"width\",\n                        \"height\",\n                        \"caretX\",\n                        \"caretY\"\n                    ]\n                },\n                opacity: {\n                    easing: \"linear\",\n                    duration: 200\n                }\n            },\n            callbacks: {\n                beforeTitle: Te,\n                title (i) {\n                    if (i.length > 0) {\n                        const t = i[0], e = t.chart.data.labels, s = e ? e.length : 0;\n                        if (this && this.options && this.options.mode === \"dataset\") return t.dataset.label || \"\";\n                        if (t.label) return t.label;\n                        if (s > 0 && t.dataIndex < s) return e[t.dataIndex];\n                    }\n                    return \"\";\n                },\n                afterTitle: Te,\n                beforeBody: Te,\n                beforeLabel: Te,\n                label (i) {\n                    if (this && this.options && this.options.mode === \"dataset\") return i.label + \": \" + i.formattedValue || i.formattedValue;\n                    let t = i.dataset.label || \"\";\n                    t && (t += \": \");\n                    const e = i.formattedValue;\n                    return N(e) || (t += e), t;\n                },\n                labelColor (i) {\n                    const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n                    return {\n                        borderColor: e.borderColor,\n                        backgroundColor: e.backgroundColor,\n                        borderWidth: e.borderWidth,\n                        borderDash: e.borderDash,\n                        borderDashOffset: e.borderDashOffset,\n                        borderRadius: 0\n                    };\n                },\n                labelTextColor () {\n                    return this.options.bodyColor;\n                },\n                labelPointStyle (i) {\n                    const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n                    return {\n                        pointStyle: e.pointStyle,\n                        rotation: e.rotation\n                    };\n                },\n                afterLabel: Te,\n                afterBody: Te,\n                beforeFooter: Te,\n                footer: Te,\n                afterFooter: Te\n            }\n        },\n        defaultRoutes: {\n            bodyFont: \"font\",\n            footerFont: \"font\",\n            titleFont: \"font\"\n        },\n        descriptors: {\n            _scriptable: (i)=>i !== \"filter\" && i !== \"itemSort\" && i !== \"external\",\n            _indexable: !1,\n            callbacks: {\n                _scriptable: !1,\n                _indexable: !1\n            },\n            animation: {\n                _fallback: !1\n            },\n            animations: {\n                _fallback: \"animation\"\n            }\n        },\n        additionalOptionScopes: [\n            \"interaction\"\n        ]\n    }, _p = Object.freeze({\n        __proto__: null,\n        Decimation: Gf,\n        Filler: sp,\n        Legend: rp,\n        SubTitle: lp,\n        Title: ap,\n        Tooltip: pp\n    });\n    const Rw = (i, t, e, s)=>(typeof t == \"string\" ? (e = i.push(t) - 1, s.unshift({\n            index: e,\n            label: t\n        })) : isNaN(t) && (e = null), e);\n    function Nw(i, t, e, s) {\n        const n = i.indexOf(t);\n        if (n === -1) return Rw(i, t, e, s);\n        const o = i.lastIndexOf(t);\n        return n !== o ? e : n;\n    }\n    const $w = (i, t)=>i === null ? null : ct(Math.round(i), 0, t);\n    class Tn extends Ze {\n        constructor(t){\n            super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n        }\n        init(t) {\n            const e = this._addedLabels;\n            if (e.length) {\n                const s = this.getLabels();\n                for (const { index: n, label: o } of e)s[n] === o && s.splice(n, 1);\n                this._addedLabels = [];\n            }\n            super.init(t);\n        }\n        parse(t, e) {\n            if (N(t)) return null;\n            const s = this.getLabels();\n            return e = isFinite(e) && s[e] === t ? e : Nw(s, t, R(e, t), this._addedLabels), $w(e, s.length - 1);\n        }\n        determineDataLimits() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let { min: s, max: n } = this.getMinMax(!0);\n            this.options.bounds === \"ticks\" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;\n        }\n        buildTicks() {\n            const t = this.min, e = this.max, s = this.options.offset, n = [];\n            let o = this.getLabels();\n            o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? .5 : 0);\n            for(let r = t; r <= e; r++)n.push({\n                value: r\n            });\n            return n;\n        }\n        getLabelForValue(t) {\n            const e = this.getLabels();\n            return t >= 0 && t < e.length ? e[t] : t;\n        }\n        configure() {\n            super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n        }\n        getPixelForValue(t) {\n            return typeof t != \"number\" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getValueForPixel(t) {\n            return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n        }\n        getBasePixel() {\n            return this.bottom;\n        }\n    }\n    Tn.id = \"category\", Tn.defaults = {\n        ticks: {\n            callback: Tn.prototype.getLabelForValue\n        }\n    };\n    function Bw(i, t) {\n        const e = [], { bounds: n, step: o, min: r, max: a, precision: l, count: c, maxTicks: h, maxDigits: d, includeBounds: u } = i, f = o || 1, p = h - 1, { min: _, max: m } = t, y = !N(r), x = !N(a), E = !N(c), C = (m - _) / (d + 1);\n        let T = nu((m - _) / p / f) * f, A, w, S, k;\n        if (T < 1e-14 && !y && !x) return [\n            {\n                value: _\n            },\n            {\n                value: m\n            }\n        ];\n        k = Math.ceil(m / T) - Math.floor(_ / T), k > p && (T = nu(k * T / p / f) * f), N(l) || (A = Math.pow(10, l), T = Math.ceil(T * A) / A), n === \"ticks\" ? (w = Math.floor(_ / T) * T, S = Math.ceil(m / T) * T) : (w = _, S = m), y && x && o && HE((a - r) / o, T / 1e3) ? (k = Math.round(Math.min((a - r) / T, h)), T = (a - r) / k, w = r, S = a) : E ? (w = y ? r : w, S = x ? a : S, k = c - 1, T = (S - w) / k) : (k = (S - w) / T, Qs(k, Math.round(k), T / 1e3) ? k = Math.round(k) : k = Math.ceil(k));\n        const D = Math.max(ru(T), ru(w));\n        A = Math.pow(10, N(l) ? D : l), w = Math.round(w * A) / A, S = Math.round(S * A) / A;\n        let O = 0;\n        for(y && (u && w !== r ? (e.push({\n            value: r\n        }), w < r && O++, Qs(Math.round((w + O * T) * A) / A, r, gp(r, C, i)) && O++) : w < r && O++); O < k; ++O)e.push({\n            value: Math.round((w + O * T) * A) / A\n        });\n        return x && u && S !== a ? e.length && Qs(e[e.length - 1].value, a, gp(a, C, i)) ? e[e.length - 1].value = a : e.push({\n            value: a\n        }) : (!x || S === a) && e.push({\n            value: S\n        }), e;\n    }\n    function gp(i, t, { horizontal: e, minRotation: s }) {\n        const n = Jt(s), o = (e ? Math.sin(n) : Math.cos(n)) || .001, r = .75 * t * (\"\" + i).length;\n        return Math.min(t / o, r);\n    }\n    class ar extends Ze {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            return N(t) || (typeof t == \"number\" || t instanceof Number) && !isFinite(+t) ? null : +t;\n        }\n        handleTickRangeOptions() {\n            const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: s } = this.getUserBounds();\n            let { min: n, max: o } = this;\n            const r = (l)=>n = e ? n : l, a = (l)=>o = s ? o : l;\n            if (t) {\n                const l = me(n), c = me(o);\n                l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);\n            }\n            if (n === o) {\n                let l = 1;\n                (o >= Number.MAX_SAFE_INTEGER || n <= Number.MIN_SAFE_INTEGER) && (l = Math.abs(o * .05)), a(o + l), t || r(n - l);\n            }\n            this.min = n, this.max = o;\n        }\n        getTickLimit() {\n            const t = this.options.ticks;\n            let { maxTicksLimit: e, stepSize: s } = t, n;\n            return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${n} ticks. Limiting to 1000.`), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;\n        }\n        computeTickLimit() {\n            return Number.POSITIVE_INFINITY;\n        }\n        buildTicks() {\n            const t = this.options, e = t.ticks;\n            let s = this.getTickLimit();\n            s = Math.max(2, s);\n            const n = {\n                maxTicks: s,\n                bounds: t.bounds,\n                min: t.min,\n                max: t.max,\n                precision: e.precision,\n                step: e.stepSize,\n                count: e.count,\n                maxDigits: this._maxDigits(),\n                horizontal: this.isHorizontal(),\n                minRotation: e.minRotation || 0,\n                includeBounds: e.includeBounds !== !1\n            }, o = this._range || this, r = Bw(n, o);\n            return t.bounds === \"ticks\" && ou(r, this, \"value\"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;\n        }\n        configure() {\n            const t = this.ticks;\n            let e = this.min, s = this.max;\n            if (super.configure(), this.options.offset && t.length) {\n                const n = (s - e) / Math.max(t.length - 1, 1) / 2;\n                e -= n, s += n;\n            }\n            this._startValue = e, this._endValue = s, this._valueRange = s - e;\n        }\n        getLabelForValue(t) {\n            return an(t, this.chart.options.locale, this.options.ticks.format);\n        }\n    }\n    class lr extends ar {\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = rt(t) ? t : 0, this.max = rt(e) ? e : 1, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            const t = this.isHorizontal(), e = t ? this.width : this.height, s = Jt(this.options.ticks.minRotation), n = (t ? Math.sin(s) : Math.cos(s)) || .001, o = this._resolveTickFontOptions(0);\n            return Math.ceil(e / Math.min(40, o.lineHeight / n));\n        }\n        getPixelForValue(t) {\n            return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n        }\n    }\n    lr.id = \"linear\", lr.defaults = {\n        ticks: {\n            callback: pn.formatters.numeric\n        }\n    };\n    function mp(i) {\n        return i / Math.pow(10, Math.floor(Vt(i))) === 1;\n    }\n    function Hw(i, t) {\n        const e = Math.floor(Vt(t.max)), s = Math.ceil(t.max / Math.pow(10, e)), n = [];\n        let o = Ht(i.min, Math.pow(10, Math.floor(Vt(t.min)))), r = Math.floor(Vt(o)), a = Math.floor(o / Math.pow(10, r)), l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;\n        do n.push({\n            value: o,\n            major: mp(o)\n        }), ++a, a === 10 && (a = 1, ++r, l = r >= 0 ? 1 : l), o = Math.round(a * Math.pow(10, r) * l) / l;\n        while (r < e || r === e && a < s);\n        const c = Ht(i.max, o);\n        return n.push({\n            value: c,\n            major: mp(o)\n        }), n;\n    }\n    class cr extends Ze {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            const s = ar.prototype.parse.apply(this, [\n                t,\n                e\n            ]);\n            if (s === 0) {\n                this._zero = !0;\n                return;\n            }\n            return rt(s) && s > 0 ? s : null;\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = rt(t) ? Math.max(0, t) : null, this.max = rt(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();\n        }\n        handleTickRangeOptions() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let s = this.min, n = this.max;\n            const o = (l)=>s = t ? s : l, r = (l)=>n = e ? n : l, a = (l, c)=>Math.pow(10, Math.floor(Vt(l)) + c);\n            s === n && (s <= 0 ? (o(1), r(10)) : (o(a(s, -1)), r(a(n, 1)))), s <= 0 && o(a(n, -1)), n <= 0 && r(a(s, 1)), this._zero && this.min !== this._suggestedMin && s === a(this.min, 0) && o(a(s, -1)), this.min = s, this.max = n;\n        }\n        buildTicks() {\n            const t = this.options, e = {\n                min: this._userMin,\n                max: this._userMax\n            }, s = Hw(e, this);\n            return t.bounds === \"ticks\" && ou(s, this, \"value\"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;\n        }\n        getLabelForValue(t) {\n            return t === void 0 ? \"0\" : an(t, this.chart.options.locale, this.options.ticks.format);\n        }\n        configure() {\n            const t = this.min;\n            super.configure(), this._startValue = Vt(t), this._valueRange = Vt(this.max) - Vt(t);\n        }\n        getPixelForValue(t) {\n            return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Vt(t) - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            const e = this.getDecimalForPixel(t);\n            return Math.pow(10, this._startValue + e * this._valueRange);\n        }\n    }\n    cr.id = \"logarithmic\", cr.defaults = {\n        ticks: {\n            callback: pn.formatters.logarithmic,\n            major: {\n                enabled: !0\n            }\n        }\n    };\n    function wl(i) {\n        const t = i.ticks;\n        if (t.display && i.display) {\n            const e = ht(t.backdropPadding);\n            return R(t.font && t.font.size, B.font.size) + e.height;\n        }\n        return 0;\n    }\n    function Fw(i, t, e) {\n        return e = Q(e) ? e : [\n            e\n        ], {\n            w: mC(i, t.string, e),\n            h: e.length * t.lineHeight\n        };\n    }\n    function bp(i, t, e, s, n) {\n        return i === s || i === n ? {\n            start: t - e / 2,\n            end: t + e / 2\n        } : i < s || i > n ? {\n            start: t - e,\n            end: t\n        } : {\n            start: t,\n            end: t + e\n        };\n    }\n    function Vw(i) {\n        const t = {\n            l: i.left + i._padding.left,\n            r: i.right - i._padding.right,\n            t: i.top + i._padding.top,\n            b: i.bottom - i._padding.bottom\n        }, e = Object.assign({}, t), s = [], n = [], o = i._pointLabels.length, r = i.options.pointLabels, a = r.centerPointLabels ? et / o : 0;\n        for(let l = 0; l < o; l++){\n            const c = r.setContext(i.getPointLabelContext(l));\n            n[l] = c.padding;\n            const h = i.getPointPosition(l, i.drawingArea + n[l], a), d = lt(c.font), u = Fw(i.ctx, d, i._pointLabels[l]);\n            s[l] = u;\n            const f = Nt(i.getIndexAngle(l) + a), p = Math.round(Fa(f)), _ = bp(p, h.x, u.w, 0, 180), m = bp(p, h.y, u.h, 90, 270);\n            Ww(e, t, f, _, m);\n        }\n        i.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), i._pointLabelItems = zw(i, s, n);\n    }\n    function Ww(i, t, e, s, n) {\n        const o = Math.abs(Math.sin(e)), r = Math.abs(Math.cos(e));\n        let a = 0, l = 0;\n        s.start < t.l ? (a = (t.l - s.start) / o, i.l = Math.min(i.l, t.l - a)) : s.end > t.r && (a = (s.end - t.r) / o, i.r = Math.max(i.r, t.r + a)), n.start < t.t ? (l = (t.t - n.start) / r, i.t = Math.min(i.t, t.t - l)) : n.end > t.b && (l = (n.end - t.b) / r, i.b = Math.max(i.b, t.b + l));\n    }\n    function zw(i, t, e) {\n        const s = [], n = i._pointLabels.length, o = i.options, r = wl(o) / 2, a = i.drawingArea, l = o.pointLabels.centerPointLabels ? et / n : 0;\n        for(let c = 0; c < n; c++){\n            const h = i.getPointPosition(c, a + r + e[c], l), d = Math.round(Fa(Nt(h.angle + nt))), u = t[c], f = Kw(h.y, u.h, d), p = jw(d), _ = Yw(h.x, u.w, p);\n            s.push({\n                x: h.x,\n                y: f,\n                textAlign: p,\n                left: _,\n                top: f,\n                right: _ + u.w,\n                bottom: f + u.h\n            });\n        }\n        return s;\n    }\n    function jw(i) {\n        return i === 0 || i === 180 ? \"center\" : i < 180 ? \"left\" : \"right\";\n    }\n    function Yw(i, t, e) {\n        return e === \"right\" ? i -= t : e === \"center\" && (i -= t / 2), i;\n    }\n    function Kw(i, t, e) {\n        return e === 90 || e === 270 ? i -= t / 2 : (e > 270 || e < 90) && (i -= t), i;\n    }\n    function Uw(i, t) {\n        const { ctx: e, options: { pointLabels: s } } = i;\n        for(let n = t - 1; n >= 0; n--){\n            const o = s.setContext(i.getPointLabelContext(n)), r = lt(o.font), { x: a, y: l, textAlign: c, left: h, top: d, right: u, bottom: f } = i._pointLabelItems[n], { backdropColor: p } = o;\n            if (!N(p)) {\n                const _ = Ci(o.borderRadius), m = ht(o.backdropPadding);\n                e.fillStyle = p;\n                const y = h - m.left, x = d - m.top, E = u - h + m.width, C = f - d + m.height;\n                Object.values(_).some((T)=>T !== 0) ? (e.beginPath(), rn(e, {\n                    x: y,\n                    y: x,\n                    w: E,\n                    h: C,\n                    radius: _\n                }), e.fill()) : e.fillRect(y, x, E, C);\n            }\n            Ei(e, i._pointLabels[n], a, l + r.lineHeight / 2, r, {\n                color: o.color,\n                textAlign: c,\n                textBaseline: \"middle\"\n            });\n        }\n    }\n    function vp(i, t, e, s) {\n        const { ctx: n } = i;\n        if (e) n.arc(i.xCenter, i.yCenter, t, 0, q);\n        else {\n            let o = i.getPointPosition(0, t);\n            n.moveTo(o.x, o.y);\n            for(let r = 1; r < s; r++)o = i.getPointPosition(r, t), n.lineTo(o.x, o.y);\n        }\n    }\n    function Xw(i, t, e, s) {\n        const n = i.ctx, o = t.circular, { color: r, lineWidth: a } = t;\n        !o && !s || !r || !a || e < 0 || (n.save(), n.strokeStyle = r, n.lineWidth = a, n.setLineDash(t.borderDash), n.lineDashOffset = t.borderDashOffset, n.beginPath(), vp(i, e, o, s), n.closePath(), n.stroke(), n.restore());\n    }\n    function Gw(i, t, e) {\n        return qe(i, {\n            label: e,\n            index: t,\n            type: \"pointLabel\"\n        });\n    }\n    class gs extends ar {\n        constructor(t){\n            super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n        }\n        setDimensions() {\n            const t = this._padding = ht(wl(this.options) / 2), e = this.width = this.maxWidth - t.width, s = this.height = this.maxHeight - t.height;\n            this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s) / 2);\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!1);\n            this.min = rt(t) && !isNaN(t) ? t : 0, this.max = rt(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            return Math.ceil(this.drawingArea / wl(this.options));\n        }\n        generateTickLabels(t) {\n            ar.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, s)=>{\n                const n = G(this.options.pointLabels.callback, [\n                    e,\n                    s\n                ], this);\n                return n || n === 0 ? n : \"\";\n            }).filter((e, s)=>this.chart.getDataVisibility(s));\n        }\n        fit() {\n            const t = this.options;\n            t.display && t.pointLabels.display ? Vw(this) : this.setCenterPoint(0, 0, 0, 0);\n        }\n        setCenterPoint(t, e, s, n) {\n            this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, n));\n        }\n        getIndexAngle(t) {\n            const e = q / (this._pointLabels.length || 1), s = this.options.startAngle || 0;\n            return Nt(t * e + Jt(s));\n        }\n        getDistanceFromCenterForValue(t) {\n            if (N(t)) return NaN;\n            const e = this.drawingArea / (this.max - this.min);\n            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n        }\n        getValueForDistanceFromCenter(t) {\n            if (N(t)) return NaN;\n            const e = t / (this.drawingArea / (this.max - this.min));\n            return this.options.reverse ? this.max - e : this.min + e;\n        }\n        getPointLabelContext(t) {\n            const e = this._pointLabels || [];\n            if (t >= 0 && t < e.length) {\n                const s = e[t];\n                return Gw(this.getContext(), t, s);\n            }\n        }\n        getPointPosition(t, e, s = 0) {\n            const n = this.getIndexAngle(t) - nt + s;\n            return {\n                x: Math.cos(n) * e + this.xCenter,\n                y: Math.sin(n) * e + this.yCenter,\n                angle: n\n            };\n        }\n        getPointPositionForValue(t, e) {\n            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n        }\n        getBasePosition(t) {\n            return this.getPointPositionForValue(t || 0, this.getBaseValue());\n        }\n        getPointLabelPosition(t) {\n            const { left: e, top: s, right: n, bottom: o } = this._pointLabelItems[t];\n            return {\n                left: e,\n                top: s,\n                right: n,\n                bottom: o\n            };\n        }\n        drawBackground() {\n            const { backgroundColor: t, grid: { circular: e } } = this.options;\n            if (t) {\n                const s = this.ctx;\n                s.save(), s.beginPath(), vp(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore();\n            }\n        }\n        drawGrid() {\n            const t = this.ctx, e = this.options, { angleLines: s, grid: n } = e, o = this._pointLabels.length;\n            let r, a, l;\n            if (e.pointLabels.display && Uw(this, o), n.display && this.ticks.forEach((c, h)=>{\n                if (h !== 0) {\n                    a = this.getDistanceFromCenterForValue(c.value);\n                    const d = n.setContext(this.getContext(h - 1));\n                    Xw(this, d, a, o);\n                }\n            }), s.display) {\n                for(t.save(), r = o - 1; r >= 0; r--){\n                    const c = s.setContext(this.getPointLabelContext(r)), { color: h, lineWidth: d } = c;\n                    !d || !h || (t.lineWidth = d, t.strokeStyle = h, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(r, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n                }\n                t.restore();\n            }\n        }\n        drawBorder() {}\n        drawLabels() {\n            const t = this.ctx, e = this.options, s = e.ticks;\n            if (!s.display) return;\n            const n = this.getIndexAngle(0);\n            let o, r;\n            t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((a, l)=>{\n                if (l === 0 && !e.reverse) return;\n                const c = s.setContext(this.getContext(l)), h = lt(c.font);\n                if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {\n                    t.font = h.string, r = t.measureText(a.label).width, t.fillStyle = c.backdropColor;\n                    const d = ht(c.backdropPadding);\n                    t.fillRect(-r / 2 - d.left, -o - h.size / 2 - d.top, r + d.width, h.size + d.height);\n                }\n                Ei(t, a.label, 0, -o, h, {\n                    color: c.color\n                });\n            }), t.restore();\n        }\n        drawTitle() {}\n    }\n    gs.id = \"radialLinear\", gs.defaults = {\n        display: !0,\n        animate: !0,\n        position: \"chartArea\",\n        angleLines: {\n            display: !0,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0\n        },\n        grid: {\n            circular: !1\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: !0,\n            callback: pn.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: void 0,\n            backdropPadding: 2,\n            display: !0,\n            font: {\n                size: 10\n            },\n            callback (i) {\n                return i;\n            },\n            padding: 5,\n            centerPointLabels: !1\n        }\n    }, gs.defaultRoutes = {\n        \"angleLines.color\": \"borderColor\",\n        \"pointLabels.color\": \"color\",\n        \"ticks.color\": \"color\"\n    }, gs.descriptors = {\n        angleLines: {\n            _fallback: \"grid\"\n        }\n    };\n    const hr = {\n        millisecond: {\n            common: !0,\n            size: 1,\n            steps: 1e3\n        },\n        second: {\n            common: !0,\n            size: 1e3,\n            steps: 60\n        },\n        minute: {\n            common: !0,\n            size: 6e4,\n            steps: 60\n        },\n        hour: {\n            common: !0,\n            size: 36e5,\n            steps: 24\n        },\n        day: {\n            common: !0,\n            size: 864e5,\n            steps: 30\n        },\n        week: {\n            common: !1,\n            size: 6048e5,\n            steps: 4\n        },\n        month: {\n            common: !0,\n            size: 2628e6,\n            steps: 12\n        },\n        quarter: {\n            common: !1,\n            size: 7884e6,\n            steps: 4\n        },\n        year: {\n            common: !0,\n            size: 3154e7\n        }\n    }, kt = Object.keys(hr);\n    function qw(i, t) {\n        return i - t;\n    }\n    function yp(i, t) {\n        if (N(t)) return null;\n        const e = i._adapter, { parser: s, round: n, isoWeekday: o } = i._parseOpts;\n        let r = t;\n        return typeof s == \"function\" && (r = s(r)), rt(r) || (r = typeof s == \"string\" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === \"week\" && (as(o) || o === !0) ? e.startOf(r, \"isoWeek\", o) : e.startOf(r, n)), +r);\n    }\n    function xp(i, t, e, s) {\n        const n = kt.length;\n        for(let o = kt.indexOf(i); o < n - 1; ++o){\n            const r = hr[kt[o]], a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;\n            if (r.common && Math.ceil((e - t) / (a * r.size)) <= s) return kt[o];\n        }\n        return kt[n - 1];\n    }\n    function Zw(i, t, e, s, n) {\n        for(let o = kt.length - 1; o >= kt.indexOf(e); o--){\n            const r = kt[o];\n            if (hr[r].common && i._adapter.diff(n, s, r) >= t - 1) return r;\n        }\n        return kt[e ? kt.indexOf(e) : 0];\n    }\n    function Qw(i) {\n        for(let t = kt.indexOf(i) + 1, e = kt.length; t < e; ++t)if (hr[kt[t]].common) return kt[t];\n    }\n    function Ep(i, t, e) {\n        if (!e) i[t] = !0;\n        else if (e.length) {\n            const { lo: s, hi: n } = Wa(e, t), o = e[s] >= t ? e[s] : e[n];\n            i[o] = !0;\n        }\n    }\n    function Jw(i, t, e, s) {\n        const n = i._adapter, o = +n.startOf(t[0].value, s), r = t[t.length - 1].value;\n        let a, l;\n        for(a = o; a <= r; a = +n.add(a, 1, s))l = e[a], l >= 0 && (t[l].major = !0);\n        return t;\n    }\n    function Cp(i, t, e) {\n        const s = [], n = {}, o = t.length;\n        let r, a;\n        for(r = 0; r < o; ++r)a = t[r], n[a] = r, s.push({\n            value: a,\n            major: !1\n        });\n        return o === 0 || !e ? s : Jw(i, s, n, e);\n    }\n    class ms extends Ze {\n        constructor(t){\n            super(t), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n        }\n        init(t, e) {\n            const s = t.time || (t.time = {}), n = this._adapter = new _f._date(t.adapters.date);\n            n.init(e), qs(s.displayFormats, n.formats()), this._parseOpts = {\n                parser: s.parser,\n                round: s.round,\n                isoWeekday: s.isoWeekday\n            }, super.init(t), this._normalized = e.normalized;\n        }\n        parse(t, e) {\n            return t === void 0 ? null : yp(this, t);\n        }\n        beforeLayout() {\n            super.beforeLayout(), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            };\n        }\n        determineDataLimits() {\n            const t = this.options, e = this._adapter, s = t.time.unit || \"day\";\n            let { min: n, max: o, minDefined: r, maxDefined: a } = this.getUserBounds();\n            function l(c) {\n                !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));\n            }\n            (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") && l(this.getMinMax(!1))), n = rt(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = rt(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);\n        }\n        _getLabelBounds() {\n            const t = this.getLabelTimestamps();\n            let e = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;\n            return t.length && (e = t[0], s = t[t.length - 1]), {\n                min: e,\n                max: s\n            };\n        }\n        buildTicks() {\n            const t = this.options, e = t.time, s = t.ticks, n = s.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n            t.bounds === \"ticks\" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);\n            const o = this.min, r = this.max, a = zE(n, o, r);\n            return this._unit = e.unit || (s.autoSkip ? xp(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Zw(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === \"year\" ? void 0 : Qw(this._unit), this.initOffsets(n), t.reverse && a.reverse(), Cp(this, a, this._majorUnit);\n        }\n        afterAutoSkip() {\n            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t)=>+t.value));\n        }\n        initOffsets(t) {\n            let e = 0, s = 0, n, o;\n            this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);\n            const r = t.length < 3 ? .5 : .25;\n            e = ct(e, 0, r), s = ct(s, 0, r), this._offsets = {\n                start: e,\n                end: s,\n                factor: 1 / (e + 1 + s)\n            };\n        }\n        _generate() {\n            const t = this._adapter, e = this.min, s = this.max, n = this.options, o = n.time, r = o.unit || xp(o.minUnit, e, s, this._getLabelCapacity(e)), a = R(o.stepSize, 1), l = r === \"week\" ? o.isoWeekday : !1, c = as(l) || l === !0, h = {};\n            let d = e, u, f;\n            if (c && (d = +t.startOf(d, \"isoWeek\", l)), d = +t.startOf(d, c ? \"day\" : r), t.diff(s, e, r) > 1e5 * a) throw new Error(e + \" and \" + s + \" are too far apart with stepSize of \" + a + \" \" + r);\n            const p = n.ticks.source === \"data\" && this.getDataTimestamps();\n            for(u = d, f = 0; u < s; u = +t.add(u, a, r), f++)Ep(h, u, p);\n            return (u === s || n.bounds === \"ticks\" || f === 1) && Ep(h, u, p), Object.keys(h).sort((_, m)=>_ - m).map((_)=>+_);\n        }\n        getLabelForValue(t) {\n            const e = this._adapter, s = this.options.time;\n            return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);\n        }\n        _tickFormatFunction(t, e, s, n) {\n            const o = this.options, r = o.time.displayFormats, a = this._unit, l = this._majorUnit, c = a && r[a], h = l && r[l], d = s[e], u = l && h && d && d.major, f = this._adapter.format(t, n || (u ? h : c)), p = o.ticks.callback;\n            return p ? G(p, [\n                f,\n                e,\n                s\n            ], this) : f;\n        }\n        generateTickLabels(t) {\n            let e, s, n;\n            for(e = 0, s = t.length; e < s; ++e)n = t[e], n.label = this._tickFormatFunction(n.value, e, t);\n        }\n        getDecimalForValue(t) {\n            return t === null ? NaN : (t - this.min) / (this.max - this.min);\n        }\n        getPixelForValue(t) {\n            const e = this._offsets, s = this.getDecimalForValue(t);\n            return this.getPixelForDecimal((e.start + s) * e.factor);\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;\n            return this.min + s * (this.max - this.min);\n        }\n        _getLabelSize(t) {\n            const e = this.options.ticks, s = this.ctx.measureText(t).width, n = Jt(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(n), r = Math.sin(n), a = this._resolveTickFontOptions(0).size;\n            return {\n                w: s * o + a * r,\n                h: s * r + a * o\n            };\n        }\n        _getLabelCapacity(t) {\n            const e = this.options.time, s = e.displayFormats, n = s[e.unit] || s.millisecond, o = this._tickFormatFunction(t, 0, Cp(this, [\n                t\n            ], this._majorUnit), n), r = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;\n            return a > 0 ? a : 1;\n        }\n        getDataTimestamps() {\n            let t = this._cache.data || [], e, s;\n            if (t.length) return t;\n            const n = this.getMatchingVisibleMetas();\n            if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);\n            for(e = 0, s = n.length; e < s; ++e)t = t.concat(n[e].controller.getAllParsedValues(this));\n            return this._cache.data = this.normalize(t);\n        }\n        getLabelTimestamps() {\n            const t = this._cache.labels || [];\n            let e, s;\n            if (t.length) return t;\n            const n = this.getLabels();\n            for(e = 0, s = n.length; e < s; ++e)t.push(yp(this, n[e]));\n            return this._cache.labels = this._normalized ? t : this.normalize(t);\n        }\n        normalize(t) {\n            return hu(t.sort(qw));\n        }\n    }\n    ms.id = \"time\", ms.defaults = {\n        bounds: \"data\",\n        adapters: {},\n        time: {\n            parser: !1,\n            unit: !1,\n            round: !1,\n            isoWeekday: !1,\n            minUnit: \"millisecond\",\n            displayFormats: {}\n        },\n        ticks: {\n            source: \"auto\",\n            major: {\n                enabled: !1\n            }\n        }\n    };\n    function dr(i, t, e) {\n        let s = 0, n = i.length - 1, o, r, a, l;\n        e ? (t >= i[s].pos && t <= i[n].pos && ({ lo: s, hi: n } = we(i, \"pos\", t)), { pos: o, time: a } = i[s], { pos: r, time: l } = i[n]) : (t >= i[s].time && t <= i[n].time && ({ lo: s, hi: n } = we(i, \"time\", t)), { time: o, pos: a } = i[s], { time: r, pos: l } = i[n]);\n        const c = r - o;\n        return c ? a + (l - a) * (t - o) / c : a;\n    }\n    class ur extends ms {\n        constructor(t){\n            super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n        }\n        initOffsets() {\n            const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n            this._minPos = dr(e, this.min), this._tableRange = dr(e, this.max) - this._minPos, super.initOffsets(t);\n        }\n        buildLookupTable(t) {\n            const { min: e, max: s } = this, n = [], o = [];\n            let r, a, l, c, h;\n            for(r = 0, a = t.length; r < a; ++r)c = t[r], c >= e && c <= s && n.push(c);\n            if (n.length < 2) return [\n                {\n                    time: e,\n                    pos: 0\n                },\n                {\n                    time: s,\n                    pos: 1\n                }\n            ];\n            for(r = 0, a = n.length; r < a; ++r)h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({\n                time: c,\n                pos: r / (a - 1)\n            });\n            return o;\n        }\n        _getTimestampsForTable() {\n            let t = this._cache.all || [];\n            if (t.length) return t;\n            const e = this.getDataTimestamps(), s = this.getLabelTimestamps();\n            return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;\n        }\n        getDecimalForValue(t) {\n            return (dr(this._table, t) - this._minPos) / this._tableRange;\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;\n            return dr(this._table, s * this._tableRange + this._minPos, !0);\n        }\n    }\n    ur.id = \"timeseries\", ur.defaults = ms.defaults;\n    var Tp = Object.freeze({\n        __proto__: null,\n        CategoryScale: Tn,\n        LinearScale: lr,\n        LogarithmicScale: cr,\n        RadialLinearScale: gs,\n        TimeScale: ms,\n        TimeSeriesScale: ur\n    });\n    const tk = Object.freeze(Object.defineProperty({\n        __proto__: null,\n        Animation: Zu,\n        Animations: ol,\n        ArcElement: fs,\n        BarController: cn,\n        BarElement: _s,\n        BasePlatform: ul,\n        BasicPlatform: Cf,\n        BubbleController: hn,\n        CategoryScale: Tn,\n        Chart: gl,\n        DatasetController: zt,\n        Decimation: Gf,\n        DomPlatform: Sf,\n        DoughnutController: ki,\n        Element: jt,\n        Filler: sp,\n        Interaction: mf,\n        Legend: rp,\n        LineController: dn,\n        LineElement: Se,\n        LinearScale: lr,\n        LogarithmicScale: cr,\n        PieController: Zo,\n        PointElement: ps,\n        PolarAreaController: un,\n        RadarController: fn,\n        RadialLinearScale: gs,\n        Scale: Ze,\n        ScatterController: gn,\n        SubTitle: lp,\n        Ticks: pn,\n        TimeScale: ms,\n        TimeSeriesScale: ur,\n        Title: ap,\n        Tooltip: pp,\n        _adapters: _f,\n        _detectPlatform: Of,\n        animator: be,\n        controllers: pf,\n        defaults: B,\n        elements: Kf,\n        layouts: dt,\n        plugins: _p,\n        registerables: [\n            pf,\n            Kf,\n            _p,\n            Tp\n        ],\n        registry: te,\n        scales: Tp\n    }, Symbol.toStringTag, {\n        value: \"Module\"\n    })); /*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */ \n    var Ap = function() {\n        if (typeof window < \"u\") {\n            if (window.devicePixelRatio) return window.devicePixelRatio;\n            var i = window.screen;\n            if (i) return (i.deviceXDPI || 1) / (i.logicalXDPI || 1);\n        }\n        return 1;\n    }(), An = {\n        toTextLines: function(i) {\n            var t = [], e;\n            for(i = [].concat(i); i.length;)e = i.pop(), typeof e == \"string\" ? t.unshift.apply(t, e.split(`\n`)) : Array.isArray(e) ? i.push.apply(i, e) : N(i) || t.unshift(\"\" + e);\n            return t;\n        },\n        textSize: function(i, t, e) {\n            var s = [].concat(t), n = s.length, o = i.font, r = 0, a;\n            for(i.font = e.string, a = 0; a < n; ++a)r = Math.max(i.measureText(s[a]).width, r);\n            return i.font = o, {\n                height: n * e.lineHeight,\n                width: r\n            };\n        },\n        bound: function(i, t, e) {\n            return Math.max(i, Math.min(t, e));\n        },\n        arrayDiff: function(i, t) {\n            var e = i.slice(), s = [], n, o, r, a;\n            for(n = 0, r = t.length; n < r; ++n)a = t[n], o = e.indexOf(a), o === -1 ? s.push([\n                a,\n                1\n            ]) : e.splice(o, 1);\n            for(n = 0, r = e.length; n < r; ++n)s.push([\n                e[n],\n                -1\n            ]);\n            return s;\n        },\n        rasterize: function(i) {\n            return Math.round(i * Ap) / Ap;\n        }\n    };\n    function kl(i, t) {\n        var e = t.x, s = t.y;\n        if (e === null) return {\n            x: 0,\n            y: -1\n        };\n        if (s === null) return {\n            x: 1,\n            y: 0\n        };\n        var n = i.x - e, o = i.y - s, r = Math.sqrt(n * n + o * o);\n        return {\n            x: r ? n / r : 0,\n            y: r ? o / r : -1\n        };\n    }\n    function ek(i, t, e, s, n) {\n        switch(n){\n            case \"center\":\n                e = s = 0;\n                break;\n            case \"bottom\":\n                e = 0, s = 1;\n                break;\n            case \"right\":\n                e = 1, s = 0;\n                break;\n            case \"left\":\n                e = -1, s = 0;\n                break;\n            case \"top\":\n                e = 0, s = -1;\n                break;\n            case \"start\":\n                e = -e, s = -s;\n                break;\n            case \"end\":\n                break;\n            default:\n                n *= Math.PI / 180, e = Math.cos(n), s = Math.sin(n);\n                break;\n        }\n        return {\n            x: i,\n            y: t,\n            vx: e,\n            vy: s\n        };\n    }\n    var ik = 0, wp = 1, kp = 2, Sp = 4, Op = 8;\n    function fr(i, t, e) {\n        var s = ik;\n        return i < e.left ? s |= wp : i > e.right && (s |= kp), t < e.top ? s |= Op : t > e.bottom && (s |= Sp), s;\n    }\n    function sk(i, t) {\n        for(var e = i.x0, s = i.y0, n = i.x1, o = i.y1, r = fr(e, s, t), a = fr(n, o, t), l, c, h; !(!(r | a) || r & a);)l = r || a, l & Op ? (c = e + (n - e) * (t.top - s) / (o - s), h = t.top) : l & Sp ? (c = e + (n - e) * (t.bottom - s) / (o - s), h = t.bottom) : l & kp ? (h = s + (o - s) * (t.right - e) / (n - e), c = t.right) : l & wp && (h = s + (o - s) * (t.left - e) / (n - e), c = t.left), l === r ? (e = c, s = h, r = fr(e, s, t)) : (n = c, o = h, a = fr(n, o, t));\n        return {\n            x0: e,\n            x1: n,\n            y0: s,\n            y1: o\n        };\n    }\n    function pr(i, t) {\n        var e = t.anchor, s = i, n, o;\n        return t.clamp && (s = sk(s, t.area)), e === \"start\" ? (n = s.x0, o = s.y0) : e === \"end\" ? (n = s.x1, o = s.y1) : (n = (s.x0 + s.x1) / 2, o = (s.y0 + s.y1) / 2), ek(n, o, i.vx, i.vy, t.align);\n    }\n    var _r = {\n        arc: function(i, t) {\n            var e = (i.startAngle + i.endAngle) / 2, s = Math.cos(e), n = Math.sin(e), o = i.innerRadius, r = i.outerRadius;\n            return pr({\n                x0: i.x + s * o,\n                y0: i.y + n * o,\n                x1: i.x + s * r,\n                y1: i.y + n * r,\n                vx: s,\n                vy: n\n            }, t);\n        },\n        point: function(i, t) {\n            var e = kl(i, t.origin), s = e.x * i.options.radius, n = e.y * i.options.radius;\n            return pr({\n                x0: i.x - s,\n                y0: i.y - n,\n                x1: i.x + s,\n                y1: i.y + n,\n                vx: e.x,\n                vy: e.y\n            }, t);\n        },\n        bar: function(i, t) {\n            var e = kl(i, t.origin), s = i.x, n = i.y, o = 0, r = 0;\n            return i.horizontal ? (s = Math.min(i.x, i.base), o = Math.abs(i.base - i.x)) : (n = Math.min(i.y, i.base), r = Math.abs(i.base - i.y)), pr({\n                x0: s,\n                y0: n + r,\n                x1: s + o,\n                y1: n,\n                vx: e.x,\n                vy: e.y\n            }, t);\n        },\n        fallback: function(i, t) {\n            var e = kl(i, t.origin);\n            return pr({\n                x0: i.x,\n                y0: i.y,\n                x1: i.x + (i.width || 0),\n                y1: i.y + (i.height || 0),\n                vx: e.x,\n                vy: e.y\n            }, t);\n        }\n    }, De = An.rasterize;\n    function nk(i) {\n        var t = i.borderWidth || 0, e = i.padding, s = i.size.height, n = i.size.width, o = -n / 2, r = -s / 2;\n        return {\n            frame: {\n                x: o - e.left - t,\n                y: r - e.top - t,\n                w: n + e.width + t * 2,\n                h: s + e.height + t * 2\n            },\n            text: {\n                x: o,\n                y: r,\n                w: n,\n                h: s\n            }\n        };\n    }\n    function ok(i, t) {\n        var e = t.chart.getDatasetMeta(t.datasetIndex).vScale;\n        if (!e) return null;\n        if (e.xCenter !== void 0 && e.yCenter !== void 0) return {\n            x: e.xCenter,\n            y: e.yCenter\n        };\n        var s = e.getBasePixel();\n        return i.horizontal ? {\n            x: s,\n            y: null\n        } : {\n            x: null,\n            y: s\n        };\n    }\n    function rk(i) {\n        return i instanceof fs ? _r.arc : i instanceof ps ? _r.point : i instanceof _s ? _r.bar : _r.fallback;\n    }\n    function ak(i, t, e, s, n, o) {\n        var r = Math.PI / 2;\n        if (o) {\n            var a = Math.min(o, n / 2, s / 2), l = t + a, c = e + a, h = t + s - a, d = e + n - a;\n            i.moveTo(t, c), l < h && c < d ? (i.arc(l, c, a, -Math.PI, -r), i.arc(h, c, a, -r, 0), i.arc(h, d, a, 0, r), i.arc(l, d, a, r, Math.PI)) : l < h ? (i.moveTo(l, e), i.arc(h, c, a, -r, r), i.arc(l, c, a, r, Math.PI + r)) : c < d ? (i.arc(l, c, a, -Math.PI, 0), i.arc(l, d, a, 0, Math.PI)) : i.arc(l, c, a, -Math.PI, Math.PI), i.closePath(), i.moveTo(t, e);\n        } else i.rect(t, e, s, n);\n    }\n    function lk(i, t, e) {\n        var s = e.backgroundColor, n = e.borderColor, o = e.borderWidth;\n        !s && (!n || !o) || (i.beginPath(), ak(i, De(t.x) + o / 2, De(t.y) + o / 2, De(t.w) - o, De(t.h) - o, e.borderRadius), i.closePath(), s && (i.fillStyle = s, i.fill()), n && o && (i.strokeStyle = n, i.lineWidth = o, i.lineJoin = \"miter\", i.stroke()));\n    }\n    function ck(i, t, e) {\n        var s = e.lineHeight, n = i.w, o = i.x, r = i.y + s / 2;\n        return t === \"center\" ? o += n / 2 : (t === \"end\" || t === \"right\") && (o += n), {\n            h: s,\n            w: n,\n            x: o,\n            y: r\n        };\n    }\n    function hk(i, t, e) {\n        var s = i.shadowBlur, n = e.stroked, o = De(e.x), r = De(e.y), a = De(e.w);\n        n && i.strokeText(t, o, r, a), e.filled && (s && n && (i.shadowBlur = 0), i.fillText(t, o, r, a), s && n && (i.shadowBlur = s));\n    }\n    function dk(i, t, e, s) {\n        var n = s.textAlign, o = s.color, r = !!o, a = s.font, l = t.length, c = s.textStrokeColor, h = s.textStrokeWidth, d = c && h, u;\n        if (!(!l || !r && !d)) for(e = ck(e, n, a), i.font = a.string, i.textAlign = n, i.textBaseline = \"middle\", i.shadowBlur = s.textShadowBlur, i.shadowColor = s.textShadowColor, r && (i.fillStyle = o), d && (i.lineJoin = \"round\", i.lineWidth = h, i.strokeStyle = c), u = 0, l = t.length; u < l; ++u)hk(i, t[u], {\n            stroked: d,\n            filled: r,\n            w: e.w,\n            x: e.x,\n            y: e.y + e.h * u\n        });\n    }\n    var Dp = function(i, t, e, s) {\n        var n = this;\n        n._config = i, n._index = s, n._model = null, n._rects = null, n._ctx = t, n._el = e;\n    };\n    ge(Dp.prototype, {\n        _modelize: function(i, t, e, s) {\n            var n = this, o = n._index, r = lt(tt([\n                e.font,\n                {}\n            ], s, o)), a = tt([\n                e.color,\n                B.color\n            ], s, o);\n            return {\n                align: tt([\n                    e.align,\n                    \"center\"\n                ], s, o),\n                anchor: tt([\n                    e.anchor,\n                    \"center\"\n                ], s, o),\n                area: s.chart.chartArea,\n                backgroundColor: tt([\n                    e.backgroundColor,\n                    null\n                ], s, o),\n                borderColor: tt([\n                    e.borderColor,\n                    null\n                ], s, o),\n                borderRadius: tt([\n                    e.borderRadius,\n                    0\n                ], s, o),\n                borderWidth: tt([\n                    e.borderWidth,\n                    0\n                ], s, o),\n                clamp: tt([\n                    e.clamp,\n                    !1\n                ], s, o),\n                clip: tt([\n                    e.clip,\n                    !1\n                ], s, o),\n                color: a,\n                display: i,\n                font: r,\n                lines: t,\n                offset: tt([\n                    e.offset,\n                    4\n                ], s, o),\n                opacity: tt([\n                    e.opacity,\n                    1\n                ], s, o),\n                origin: ok(n._el, s),\n                padding: ht(tt([\n                    e.padding,\n                    4\n                ], s, o)),\n                positioner: rk(n._el),\n                rotation: tt([\n                    e.rotation,\n                    0\n                ], s, o) * (Math.PI / 180),\n                size: An.textSize(n._ctx, t, r),\n                textAlign: tt([\n                    e.textAlign,\n                    \"start\"\n                ], s, o),\n                textShadowBlur: tt([\n                    e.textShadowBlur,\n                    0\n                ], s, o),\n                textShadowColor: tt([\n                    e.textShadowColor,\n                    a\n                ], s, o),\n                textStrokeColor: tt([\n                    e.textStrokeColor,\n                    a\n                ], s, o),\n                textStrokeWidth: tt([\n                    e.textStrokeWidth,\n                    0\n                ], s, o)\n            };\n        },\n        update: function(i) {\n            var t = this, e = null, s = null, n = t._index, o = t._config, r, a, l, c = tt([\n                o.display,\n                !0\n            ], i, n);\n            c && (r = i.dataset.data[n], a = R(G(o.formatter, [\n                r,\n                i\n            ]), r), l = N(a) ? [] : An.toTextLines(a), l.length && (e = t._modelize(c, l, o, i), s = nk(e))), t._model = e, t._rects = s;\n        },\n        geometry: function() {\n            return this._rects ? this._rects.frame : {};\n        },\n        rotation: function() {\n            return this._model ? this._model.rotation : 0;\n        },\n        visible: function() {\n            return this._model && this._model.opacity;\n        },\n        model: function() {\n            return this._model;\n        },\n        draw: function(i, t) {\n            var e = this, s = i.ctx, n = e._model, o = e._rects, r;\n            this.visible() && (s.save(), n.clip && (r = n.area, s.beginPath(), s.rect(r.left, r.top, r.right - r.left, r.bottom - r.top), s.clip()), s.globalAlpha = An.bound(0, n.opacity, 1), s.translate(De(t.x), De(t.y)), s.rotate(n.rotation), lk(s, o.frame, n), dk(s, n.lines, o.text, n), s.restore());\n        }\n    });\n    var uk = Number.MIN_SAFE_INTEGER || -9007199254740991, fk = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    function wn(i, t, e) {\n        var s = Math.cos(e), n = Math.sin(e), o = t.x, r = t.y;\n        return {\n            x: o + s * (i.x - o) - n * (i.y - r),\n            y: r + n * (i.x - o) + s * (i.y - r)\n        };\n    }\n    function Mp(i, t) {\n        var e = fk, s = uk, n = t.origin, o, r, a, l, c;\n        for(o = 0; o < i.length; ++o)r = i[o], a = r.x - n.x, l = r.y - n.y, c = t.vx * a + t.vy * l, e = Math.min(e, c), s = Math.max(s, c);\n        return {\n            min: e,\n            max: s\n        };\n    }\n    function gr(i, t) {\n        var e = t.x - i.x, s = t.y - i.y, n = Math.sqrt(e * e + s * s);\n        return {\n            vx: (t.x - i.x) / n,\n            vy: (t.y - i.y) / n,\n            origin: i,\n            ln: n\n        };\n    }\n    var Ip = function() {\n        this._rotation = 0, this._rect = {\n            x: 0,\n            y: 0,\n            w: 0,\n            h: 0\n        };\n    };\n    ge(Ip.prototype, {\n        center: function() {\n            var i = this._rect;\n            return {\n                x: i.x + i.w / 2,\n                y: i.y + i.h / 2\n            };\n        },\n        update: function(i, t, e) {\n            this._rotation = e, this._rect = {\n                x: t.x + i.x,\n                y: t.y + i.y,\n                w: t.w,\n                h: t.h\n            };\n        },\n        contains: function(i) {\n            var t = this, e = 1, s = t._rect;\n            return i = wn(i, t.center(), -t._rotation), !(i.x < s.x - e || i.y < s.y - e || i.x > s.x + s.w + e * 2 || i.y > s.y + s.h + e * 2);\n        },\n        intersects: function(i) {\n            var t = this._points(), e = i._points(), s = [\n                gr(t[0], t[1]),\n                gr(t[0], t[3])\n            ], n, o, r;\n            for(this._rotation !== i._rotation && s.push(gr(e[0], e[1]), gr(e[0], e[3])), n = 0; n < s.length; ++n)if (o = Mp(t, s[n]), r = Mp(e, s[n]), o.max < r.min || r.max < o.min) return !1;\n            return !0;\n        },\n        _points: function() {\n            var i = this, t = i._rect, e = i._rotation, s = i.center();\n            return [\n                wn({\n                    x: t.x,\n                    y: t.y\n                }, s, e),\n                wn({\n                    x: t.x + t.w,\n                    y: t.y\n                }, s, e),\n                wn({\n                    x: t.x + t.w,\n                    y: t.y + t.h\n                }, s, e),\n                wn({\n                    x: t.x,\n                    y: t.y + t.h\n                }, s, e)\n            ];\n        }\n    });\n    function Lp(i, t, e) {\n        var s = t.positioner(i, t), n = s.vx, o = s.vy;\n        if (!n && !o) return {\n            x: s.x,\n            y: s.y\n        };\n        var r = e.w, a = e.h, l = t.rotation, c = Math.abs(r / 2 * Math.cos(l)) + Math.abs(a / 2 * Math.sin(l)), h = Math.abs(r / 2 * Math.sin(l)) + Math.abs(a / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(n), Math.abs(o));\n        return c *= n * d, h *= o * d, c += t.offset * n, h += t.offset * o, {\n            x: s.x + c,\n            y: s.y + h\n        };\n    }\n    function pk(i, t) {\n        var e, s, n, o;\n        for(e = i.length - 1; e >= 0; --e)for(n = i[e].$layout, s = e - 1; s >= 0 && n._visible; --s)o = i[s].$layout, o._visible && n._box.intersects(o._box) && t(n, o);\n        return i;\n    }\n    function _k(i) {\n        var t, e, s, n, o, r, a;\n        for(t = 0, e = i.length; t < e; ++t)s = i[t], n = s.$layout, n._visible && (a = new Proxy(s._el, {\n            get: (l, c)=>l.getProps([\n                    c\n                ], !0)[c]\n        }), o = s.geometry(), r = Lp(a, s.model(), o), n._box.update(r, o, s.rotation()));\n        return pk(i, function(l, c) {\n            var h = l._hidable, d = c._hidable;\n            h && d || d ? c._visible = !1 : h && (l._visible = !1);\n        });\n    }\n    var kn = {\n        prepare: function(i) {\n            var t = [], e, s, n, o, r;\n            for(e = 0, n = i.length; e < n; ++e)for(s = 0, o = i[e].length; s < o; ++s)r = i[e][s], t.push(r), r.$layout = {\n                _box: new Ip,\n                _hidable: !1,\n                _visible: !0,\n                _set: e,\n                _idx: r._index\n            };\n            return t.sort(function(a, l) {\n                var c = a.$layout, h = l.$layout;\n                return c._idx === h._idx ? h._set - c._set : h._idx - c._idx;\n            }), this.update(t), t;\n        },\n        update: function(i) {\n            var t = !1, e, s, n, o, r;\n            for(e = 0, s = i.length; e < s; ++e)n = i[e], o = n.model(), r = n.$layout, r._hidable = o && o.display === \"auto\", r._visible = n.visible(), t |= r._hidable;\n            t && _k(i);\n        },\n        lookup: function(i, t) {\n            var e, s;\n            for(e = i.length - 1; e >= 0; --e)if (s = i[e].$layout, s && s._visible && s._box.contains(t)) return i[e];\n            return null;\n        },\n        draw: function(i, t) {\n            var e, s, n, o, r, a;\n            for(e = 0, s = t.length; e < s; ++e)n = t[e], o = n.$layout, o._visible && (r = n.geometry(), a = Lp(n._el, n.model(), r), o._box.update(a, r, n.rotation()), n.draw(i, a));\n        }\n    }, gk = function(i) {\n        if (N(i)) return null;\n        var t = i, e, s, n;\n        if ($(i)) {\n            if (!N(i.label)) t = i.label;\n            else if (!N(i.r)) t = i.r;\n            else for(t = \"\", e = Object.keys(i), n = 0, s = e.length; n < s; ++n)t += (n !== 0 ? \", \" : \"\") + e[n] + \": \" + i[e[n]];\n        }\n        return \"\" + t;\n    }, mk = {\n        align: \"center\",\n        anchor: \"center\",\n        backgroundColor: null,\n        borderColor: null,\n        borderRadius: 0,\n        borderWidth: 0,\n        clamp: !1,\n        clip: !1,\n        color: void 0,\n        display: !0,\n        font: {\n            family: void 0,\n            lineHeight: 1.2,\n            size: void 0,\n            style: void 0,\n            weight: null\n        },\n        formatter: gk,\n        labels: void 0,\n        listeners: {},\n        offset: 4,\n        opacity: 1,\n        padding: {\n            top: 4,\n            right: 4,\n            bottom: 4,\n            left: 4\n        },\n        rotation: 0,\n        textAlign: \"start\",\n        textStrokeColor: void 0,\n        textStrokeWidth: 0,\n        textShadowBlur: 0,\n        textShadowColor: void 0\n    }, St = \"$datalabels\", Pp = \"$default\";\n    function bk(i, t) {\n        var e = i.datalabels, s = {}, n = [], o, r;\n        return e === !1 ? null : (e === !0 && (e = {}), t = ge({}, [\n            t,\n            e\n        ]), o = t.labels || {}, r = Object.keys(o), delete t.labels, r.length ? r.forEach(function(a) {\n            o[a] && n.push(ge({}, [\n                t,\n                o[a],\n                {\n                    _key: a\n                }\n            ]));\n        }) : n.push(t), s = n.reduce(function(a, l) {\n            return U(l.listeners || {}, function(c, h) {\n                a[h] = a[h] || {}, a[h][l._key || Pp] = c;\n            }), delete l.listeners, a;\n        }, {}), {\n            labels: n,\n            listeners: s\n        });\n    }\n    function Sl(i, t, e, s) {\n        if (t) {\n            var n = e.$context, o = e.$groups, r;\n            t[o._set] && (r = t[o._set][o._key], r && G(r, [\n                n,\n                s\n            ]) === !0 && (i[St]._dirty = !0, e.update(n)));\n        }\n    }\n    function vk(i, t, e, s, n) {\n        var o, r;\n        !e && !s || (e ? s ? e !== s && (r = o = !0) : r = !0 : o = !0, r && Sl(i, t.leave, e, n), o && Sl(i, t.enter, s, n));\n    }\n    function yk(i, t) {\n        var e = i[St], s = e._listeners, n, o;\n        if (!(!s.enter && !s.leave)) {\n            if (t.type === \"mousemove\") o = kn.lookup(e._labels, t);\n            else if (t.type !== \"mouseout\") return;\n            n = e._hovered, e._hovered = o, vk(i, s, n, o, t);\n        }\n    }\n    function xk(i, t) {\n        var e = i[St], s = e._listeners.click, n = s && kn.lookup(e._labels, t);\n        n && Sl(i, s, n, t);\n    }\n    var Ek = {\n        id: \"datalabels\",\n        defaults: mk,\n        beforeInit: function(i) {\n            i[St] = {\n                _actives: []\n            };\n        },\n        beforeUpdate: function(i) {\n            var t = i[St];\n            t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];\n        },\n        afterDatasetUpdate: function(i, t, e) {\n            var s = t.index, n = i[St], o = n._datasets[s] = [], r = i.isDatasetVisible(s), a = i.data.datasets[s], l = bk(a, e), c = t.meta.data || [], h = i.ctx, d, u, f, p, _, m, y, x;\n            for(h.save(), d = 0, f = c.length; d < f; ++d)if (y = c[d], y[St] = [], r && y && i.getDataVisibility(d) && !y.skip) for(u = 0, p = l.labels.length; u < p; ++u)_ = l.labels[u], m = _._key, x = new Dp(_, h, y, d), x.$groups = {\n                _set: s,\n                _key: m || Pp\n            }, x.$context = {\n                active: !1,\n                chart: i,\n                dataIndex: d,\n                dataset: a,\n                datasetIndex: s\n            }, x.update(x.$context), y[St].push(x), o.push(x);\n            h.restore(), ge(n._listeners, l.listeners, {\n                merger: function(E, C, T) {\n                    C[E] = C[E] || {}, C[E][t.index] = T[E], n._listened = !0;\n                }\n            });\n        },\n        afterUpdate: function(i) {\n            i[St]._labels = kn.prepare(i[St]._datasets);\n        },\n        afterDatasetsDraw: function(i) {\n            kn.draw(i, i[St]._labels);\n        },\n        beforeEvent: function(i, t) {\n            if (i[St]._listened) {\n                var e = t.event;\n                switch(e.type){\n                    case \"mousemove\":\n                    case \"mouseout\":\n                        yk(i, e);\n                        break;\n                    case \"click\":\n                        xk(i, e);\n                        break;\n                }\n            }\n        },\n        afterEvent: function(i) {\n            var t = i[St], e = t._actives, s = t._actives = i.getActiveElements(), n = An.arrayDiff(e, s), o, r, a, l, c, h, d;\n            for(o = 0, r = n.length; o < r; ++o)if (c = n[o], c[1]) for(d = c[0].element[St] || [], a = 0, l = d.length; a < l; ++a)h = d[a], h.$context.active = c[1] === 1, h.update(h.$context);\n            (t._dirty || n.length) && (kn.update(t._labels), i.render()), delete t._dirty;\n        }\n    };\n    const Ck = Object.freeze(Object.defineProperty({\n        __proto__: null,\n        default: Ek\n    }, Symbol.toStringTag, {\n        value: \"Module\"\n    }));\n    V.Alert = As, V.Animate = qn, V.Button = On, V.Carousel = ae, V.Chart = Qd, V.Chip = vi, V.ChipsInput = Ud, V.Collapse = re, V.Datepicker = Ph, V.Dropdown = $t, V.Input = Z, V.Modal = Ss, V.Offcanvas = zi, V.Popover = zn, V.Ripple = Ui, V.ScrollSpy = Is, V.Select = Lo, V.Sidenav = bi, V.Stepper = vd, V.Tab = Un, V.Timepicker = od, V.Toast = Ls, V.Tooltip = Ms, V.initTE = Ia, Object.defineProperty(V, Symbol.toStringTag, {\n        value: \"Module\"\n    });\n});\n\n//# sourceMappingURL=index.7d9b9be0.js.map\n","/*!\n* Taliwind Elements 1.0.0-beta2\n* \n* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\n* Copyright  2023 MDBootstrap.com\n* \n* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\n* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\n* \n*/\n(function(V,_t){typeof exports==\"object\"&&typeof module<\"u\"?_t(exports):typeof define==\"function\"&&define.amd?define([\"exports\"],_t):(V=typeof globalThis<\"u\"?globalThis:V||self,_t(V.te={}))})(this,function(V){\"use strict\";var Dk=Object.defineProperty;var Mk=(V,_t,P)=>_t in V?Dk(V,_t,{enumerable:!0,configurable:!0,writable:!0,value:P}):V[_t]=P;var Ee=(V,_t,P)=>(Mk(V,typeof _t!=\"symbol\"?_t+\"\":_t,P),P);const _t=(()=>{const i={};let t=1;return{set(e,s,n){typeof e[s]>\"u\"&&(e[s]={key:s,id:t},t++),i[e[s].id]=n},get(e,s){if(!e||typeof e[s]>\"u\")return null;const n=e[s];return n.key===s?i[n.id]:null},delete(e,s){if(typeof e[s]>\"u\")return;const n=e[s];n.key===s&&(delete i[n.id],delete e[s])}}})(),P={setData(i,t,e){_t.set(i,t,e)},getData(i,t){return _t.get(i,t)},removeData(i,t){_t.delete(i,t)}},Kp=1e6,Up=1e3,vr=\"transitionend\",Xp=i=>i==null?`${i}`:{}.toString.call(i).match(/\\s([a-z]+)/i)[1].toLowerCase(),se=i=>{do i+=Math.floor(Math.random()*Kp);while(document.getElementById(i));return i},Il=i=>{let t=i.getAttribute(\"data-te-target\");if(!t||t===\"#\"){let e=i.getAttribute(\"href\");if(!e||!e.includes(\"#\")&&!e.startsWith(\".\"))return null;e.includes(\"#\")&&!e.startsWith(\"#\")&&(e=`#${e.split(\"#\")[1]}`),t=e&&e!==\"#\"?e.trim():null}return t},yr=i=>{const t=Il(i);return t&&document.querySelector(t)?t:null},Ie=i=>{const t=Il(i);return t?document.querySelector(t):null},Gp=i=>{if(!i)return 0;let{transitionDuration:t,transitionDelay:e}=window.getComputedStyle(i);const s=Number.parseFloat(t),n=Number.parseFloat(e);return!s&&!n?0:(t=t.split(\",\")[0],e=e.split(\",\")[0],(Number.parseFloat(t)+Number.parseFloat(e))*Up)},Ll=i=>{i.dispatchEvent(new Event(vr))},Mi=i=>!i||typeof i!=\"object\"?!1:(typeof i.jquery<\"u\"&&(i=i[0]),typeof i.nodeType<\"u\"),Le=i=>Mi(i)?i.jquery?i[0]:i:typeof i==\"string\"&&i.length>0?document.querySelector(i):null,W=(i,t,e)=>{Object.keys(e).forEach(s=>{const n=e[s],o=t[s],r=o&&Mi(o)?\"element\":Xp(o);if(!new RegExp(n).test(r))throw new Error(`${i.toUpperCase()}: Option \"${s}\" provided type \"${r}\" but expected type \"${n}\".`)})},ne=i=>{if(!i||i.getClientRects().length===0)return!1;if(i.style&&i.parentNode&&i.parentNode.style){const t=getComputedStyle(i),e=getComputedStyle(i.parentNode);return getComputedStyle(i).getPropertyValue(\"visibility\")===\"visible\"||t.display!==\"none\"&&e.display!==\"none\"&&t.visibility!==\"hidden\"}return!1},ei=i=>!i||i.nodeType!==Node.ELEMENT_NODE||i.classList.contains(\"disabled\")?!0:typeof i.disabled<\"u\"?i.disabled:i.hasAttribute(\"disabled\")&&i.getAttribute(\"disabled\")!==\"false\",Pl=i=>{if(!document.documentElement.attachShadow)return null;if(typeof i.getRootNode==\"function\"){const t=i.getRootNode();return t instanceof ShadowRoot?t:null}return i instanceof ShadowRoot?i:i.parentNode?Pl(i.parentNode):null},Sn=()=>function(){},Ii=i=>{i.offsetHeight},Rl=()=>{const{jQuery:i}=window;return i&&!document.body.hasAttribute(\"data-te-no-jquery\")?i:null},xr=[],Nl=i=>{document.readyState===\"loading\"?(xr.length||document.addEventListener(\"DOMContentLoaded\",()=>{xr.forEach(t=>t())}),xr.push(i)):i()},st=()=>document.documentElement.dir===\"rtl\",qp=i=>Array.from(i),z=i=>document.createElement(i),ii=i=>{typeof i==\"function\"&&i()},$l=(i,t,e=!0)=>{if(!e){ii(i);return}const s=5,n=Gp(t)+s;let o=!1;const r=({target:a})=>{a===t&&(o=!0,t.removeEventListener(vr,r),ii(i))};t.addEventListener(vr,r),setTimeout(()=>{o||Ll(t)},n)},Bl=(i,t,e,s)=>{let n=i.indexOf(t);if(n===-1)return i[!e&&s?i.length-1:0];const o=i.length;return n+=e?1:-1,s&&(n=(n+o)%o),i[Math.max(0,Math.min(n,o-1))]},Zp=/[^.]*(?=\\..*)\\.|.*/,Qp=/\\..*/,Jp=/::\\d+$/,Er={};let Hl=1;const t_={mouseenter:\"mouseover\",mouseleave:\"mouseout\"},e_=/^(mouseenter|mouseleave)/i,Fl=new Set([\"click\",\"dblclick\",\"mouseup\",\"mousedown\",\"contextmenu\",\"mousewheel\",\"DOMMouseScroll\",\"mouseover\",\"mouseout\",\"mousemove\",\"selectstart\",\"selectend\",\"keydown\",\"keypress\",\"keyup\",\"orientationchange\",\"touchstart\",\"touchmove\",\"touchend\",\"touchcancel\",\"pointerdown\",\"pointermove\",\"pointerup\",\"pointerleave\",\"pointercancel\",\"gesturestart\",\"gesturechange\",\"gestureend\",\"focus\",\"blur\",\"change\",\"reset\",\"select\",\"submit\",\"focusin\",\"focusout\",\"load\",\"unload\",\"beforeunload\",\"resize\",\"move\",\"DOMContentLoaded\",\"readystatechange\",\"error\",\"abort\",\"scroll\"]);function Vl(i,t){return t&&`${t}::${Hl++}`||i.uidEvent||Hl++}function Wl(i){const t=Vl(i);return i.uidEvent=t,Er[t]=Er[t]||{},Er[t]}function i_(i,t){return function e(s){return s.delegateTarget=i,e.oneOff&&b.off(i,s.type,t),t.apply(i,[s])}}function s_(i,t,e){return function s(n){const o=i.querySelectorAll(t);for(let{target:r}=n;r&&r!==this;r=r.parentNode)for(let a=o.length;a--;\"\")if(o[a]===r)return n.delegateTarget=r,s.oneOff&&b.off(i,n.type,e),e.apply(r,[n]);return null}}function zl(i,t,e=null){const s=Object.keys(i);for(let n=0,o=s.length;n<o;n++){const r=i[s[n]];if(r.originalHandler===t&&r.delegationSelector===e)return r}return null}function jl(i,t,e){const s=typeof t==\"string\",n=s?e:t;let o=Kl(i);return Fl.has(o)||(o=i),[s,n,o]}function Yl(i,t,e,s,n){if(typeof t!=\"string\"||!i)return;if(e||(e=s,s=null),e_.test(t)){const f=p=>function(_){if(!_.relatedTarget||_.relatedTarget!==_.delegateTarget&&!_.delegateTarget.contains(_.relatedTarget))return p.call(this,_)};s?s=f(s):e=f(e)}const[o,r,a]=jl(t,e,s),l=Wl(i),c=l[a]||(l[a]={}),h=zl(c,r,o?e:null);if(h){h.oneOff=h.oneOff&&n;return}const d=Vl(r,t.replace(Zp,\"\")),u=o?s_(i,e,s):i_(i,e);u.delegationSelector=o?e:null,u.originalHandler=r,u.oneOff=n,u.uidEvent=d,c[d]=u,i.addEventListener(a,u,o)}function Cr(i,t,e,s,n){const o=zl(t[e],s,n);o&&(i.removeEventListener(e,o,!!n),delete t[e][o.uidEvent])}function n_(i,t,e,s){const n=t[e]||{};Object.keys(n).forEach(o=>{if(o.includes(s)){const r=n[o];Cr(i,t,e,r.originalHandler,r.delegationSelector)}})}function Kl(i){return i=i.replace(Qp,\"\"),t_[i]||i}const b={on(i,t,e,s){Yl(i,t,e,s,!1)},one(i,t,e,s){Yl(i,t,e,s,!0)},off(i,t,e,s){if(typeof t!=\"string\"||!i)return;const[n,o,r]=jl(t,e,s),a=r!==t,l=Wl(i),c=t.startsWith(\".\");if(typeof o<\"u\"){if(!l||!l[r])return;Cr(i,l,r,o,n?e:null);return}c&&Object.keys(l).forEach(d=>{n_(i,l,d,t.slice(1))});const h=l[r]||{};Object.keys(h).forEach(d=>{const u=d.replace(Jp,\"\");if(!a||t.includes(u)){const f=h[d];Cr(i,l,r,f.originalHandler,f.delegationSelector)}})},trigger(i,t,e){if(typeof t!=\"string\"||!i)return null;const s=Rl(),n=Kl(t),o=t!==n,r=Fl.has(n);let a,l=!0,c=!0,h=!1,d=null;return o&&s&&(a=s.Event(t,e),s(i).trigger(a),l=!a.isPropagationStopped(),c=!a.isImmediatePropagationStopped(),h=a.isDefaultPrevented()),r?(d=document.createEvent(\"HTMLEvents\"),d.initEvent(n,l,!0)):d=new CustomEvent(t,{bubbles:l,cancelable:!0}),typeof e<\"u\"&&Object.keys(e).forEach(u=>{Object.defineProperty(d,u,{get(){return e[u]}})}),h&&d.preventDefault(),c&&i.dispatchEvent(d),d.defaultPrevented&&typeof a<\"u\"&&a.preventDefault(),d}},si={on(i,t,e,s){const n=t.split(\" \");for(let o=0;o<n.length;o++)b.on(i,n[o],e,s)},off(i,t,e,s){const n=t.split(\" \");for(let o=0;o<n.length;o++)b.off(i,n[o],e,s)}},o_=\"5.1.3\";class Xt{constructor(t){t=Le(t),t&&(this._element=t,P.setData(this._element,this.constructor.DATA_KEY,this))}dispose(){P.removeData(this._element,this.constructor.DATA_KEY),b.off(this._element,this.constructor.EVENT_KEY),Object.getOwnPropertyNames(this).forEach(t=>{this[t]=null})}_queueCallback(t,e,s=!0){$l(t,e,s)}static getInstance(t){return P.getData(Le(t),this.DATA_KEY)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}static get VERSION(){return o_}static get NAME(){throw new Error('You have to implement the static method \"NAME\", for each component!')}static get DATA_KEY(){return`te.${this.NAME}`}static get EVENT_KEY(){return`.${this.DATA_KEY}`}}const r_=\"button\",a_=\"active\";class On extends Xt{static get NAME(){return r_}toggle(){this._element.setAttribute(\"aria-pressed\",this._element.classList.toggle(a_))}static jQueryInterface(t){return this.each(function(){const e=On.getOrCreateInstance(this);t===\"toggle\"&&e[t]()})}}var gt=\"top\",Ot=\"bottom\",Dt=\"right\",mt=\"left\",bs=\"auto\",Li=[gt,Ot,Dt,mt],ni=\"start\",Pi=\"end\",Ul=\"clippingParents\",Tr=\"viewport\",Ri=\"popper\",Xl=\"reference\",Ar=Li.reduce(function(i,t){return i.concat([t+\"-\"+ni,t+\"-\"+Pi])},[]),wr=[].concat(Li,[bs]).reduce(function(i,t){return i.concat([t,t+\"-\"+ni,t+\"-\"+Pi])},[]),Gl=\"beforeRead\",ql=\"read\",Zl=\"afterRead\",Ql=\"beforeMain\",Jl=\"main\",tc=\"afterMain\",ec=\"beforeWrite\",ic=\"write\",sc=\"afterWrite\",Dn=[Gl,ql,Zl,Ql,Jl,tc,ec,ic,sc];function oe(i){return i?(i.nodeName||\"\").toLowerCase():null}function Mt(i){if(i==null)return window;if(i.toString()!==\"[object Window]\"){var t=i.ownerDocument;return t&&t.defaultView||window}return i}function oi(i){var t=Mt(i).Element;return i instanceof t||i instanceof Element}function It(i){var t=Mt(i).HTMLElement;return i instanceof t||i instanceof HTMLElement}function kr(i){if(typeof ShadowRoot>\"u\")return!1;var t=Mt(i).ShadowRoot;return i instanceof t||i instanceof ShadowRoot}function l_(i){var t=i.state;Object.keys(t.elements).forEach(function(e){var s=t.styles[e]||{},n=t.attributes[e]||{},o=t.elements[e];!It(o)||!oe(o)||(Object.assign(o.style,s),Object.keys(n).forEach(function(r){var a=n[r];a===!1?o.removeAttribute(r):o.setAttribute(r,a===!0?\"\":a)}))})}function c_(i){var t=i.state,e={popper:{position:t.options.strategy,left:\"0\",top:\"0\",margin:\"0\"},arrow:{position:\"absolute\"},reference:{}};return Object.assign(t.elements.popper.style,e.popper),t.styles=e,t.elements.arrow&&Object.assign(t.elements.arrow.style,e.arrow),function(){Object.keys(t.elements).forEach(function(s){var n=t.elements[s],o=t.attributes[s]||{},r=Object.keys(t.styles.hasOwnProperty(s)?t.styles[s]:e[s]),a=r.reduce(function(l,c){return l[c]=\"\",l},{});!It(n)||!oe(n)||(Object.assign(n.style,a),Object.keys(o).forEach(function(l){n.removeAttribute(l)}))})}}const Sr={name:\"applyStyles\",enabled:!0,phase:\"write\",fn:l_,effect:c_,requires:[\"computeStyles\"]};function Gt(i){return i.split(\"-\")[0]}var ri=Math.max,Mn=Math.min,Ni=Math.round;function Or(){var i=navigator.userAgentData;return i!=null&&i.brands&&Array.isArray(i.brands)?i.brands.map(function(t){return t.brand+\"/\"+t.version}).join(\" \"):navigator.userAgent}function nc(){return!/^((?!chrome|android).)*safari/i.test(Or())}function $i(i,t,e){t===void 0&&(t=!1),e===void 0&&(e=!1);var s=i.getBoundingClientRect(),n=1,o=1;t&&It(i)&&(n=i.offsetWidth>0&&Ni(s.width)/i.offsetWidth||1,o=i.offsetHeight>0&&Ni(s.height)/i.offsetHeight||1);var r=oi(i)?Mt(i):window,a=r.visualViewport,l=!nc()&&e,c=(s.left+(l&&a?a.offsetLeft:0))/n,h=(s.top+(l&&a?a.offsetTop:0))/o,d=s.width/n,u=s.height/o;return{width:d,height:u,top:h,right:c+d,bottom:h+u,left:c,x:c,y:h}}function Dr(i){var t=$i(i),e=i.offsetWidth,s=i.offsetHeight;return Math.abs(t.width-e)<=1&&(e=t.width),Math.abs(t.height-s)<=1&&(s=t.height),{x:i.offsetLeft,y:i.offsetTop,width:e,height:s}}function oc(i,t){var e=t.getRootNode&&t.getRootNode();if(i.contains(t))return!0;if(e&&kr(e)){var s=t;do{if(s&&i.isSameNode(s))return!0;s=s.parentNode||s.host}while(s)}return!1}function qt(i){return Mt(i).getComputedStyle(i)}function h_(i){return[\"table\",\"td\",\"th\"].indexOf(oe(i))>=0}function Pe(i){return((oi(i)?i.ownerDocument:i.document)||window.document).documentElement}function In(i){return oe(i)===\"html\"?i:i.assignedSlot||i.parentNode||(kr(i)?i.host:null)||Pe(i)}function rc(i){return!It(i)||qt(i).position===\"fixed\"?null:i.offsetParent}function d_(i){var t=/firefox/i.test(Or()),e=/Trident/i.test(Or());if(e&&It(i)){var s=qt(i);if(s.position===\"fixed\")return null}var n=In(i);for(kr(n)&&(n=n.host);It(n)&&[\"html\",\"body\"].indexOf(oe(n))<0;){var o=qt(n);if(o.transform!==\"none\"||o.perspective!==\"none\"||o.contain===\"paint\"||[\"transform\",\"perspective\"].indexOf(o.willChange)!==-1||t&&o.willChange===\"filter\"||t&&o.filter&&o.filter!==\"none\")return n;n=n.parentNode}return null}function vs(i){for(var t=Mt(i),e=rc(i);e&&h_(e)&&qt(e).position===\"static\";)e=rc(e);return e&&(oe(e)===\"html\"||oe(e)===\"body\"&&qt(e).position===\"static\")?t:e||d_(i)||t}function Mr(i){return[\"top\",\"bottom\"].indexOf(i)>=0?\"x\":\"y\"}function ys(i,t,e){return ri(i,Mn(t,e))}function u_(i,t,e){var s=ys(i,t,e);return s>e?e:s}function ac(){return{top:0,right:0,bottom:0,left:0}}function lc(i){return Object.assign({},ac(),i)}function cc(i,t){return t.reduce(function(e,s){return e[s]=i,e},{})}var f_=function(t,e){return t=typeof t==\"function\"?t(Object.assign({},e.rects,{placement:e.placement})):t,lc(typeof t!=\"number\"?t:cc(t,Li))};function p_(i){var t,e=i.state,s=i.name,n=i.options,o=e.elements.arrow,r=e.modifiersData.popperOffsets,a=Gt(e.placement),l=Mr(a),c=[mt,Dt].indexOf(a)>=0,h=c?\"height\":\"width\";if(!(!o||!r)){var d=f_(n.padding,e),u=Dr(o),f=l===\"y\"?gt:mt,p=l===\"y\"?Ot:Dt,_=e.rects.reference[h]+e.rects.reference[l]-r[l]-e.rects.popper[h],m=r[l]-e.rects.reference[l],y=vs(o),x=y?l===\"y\"?y.clientHeight||0:y.clientWidth||0:0,E=_/2-m/2,C=d[f],T=x-u[h]-d[p],A=x/2-u[h]/2+E,w=ys(C,A,T),S=l;e.modifiersData[s]=(t={},t[S]=w,t.centerOffset=w-A,t)}}function __(i){var t=i.state,e=i.options,s=e.element,n=s===void 0?\"[data-popper-arrow]\":s;if(n!=null&&!(typeof n==\"string\"&&(n=t.elements.popper.querySelector(n),!n))){if({}.NODE_ENV!==\"production\"&&(It(n)||console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\"To use an SVG arrow, wrap it in an HTMLElement that will be used as\",\"the arrow.\"].join(\" \"))),!oc(t.elements.popper,n)){({}).NODE_ENV!==\"production\"&&console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\"element.\"].join(\" \"));return}t.elements.arrow=n}}const hc={name:\"arrow\",enabled:!0,phase:\"main\",fn:p_,effect:__,requires:[\"popperOffsets\"],requiresIfExists:[\"preventOverflow\"]};function Bi(i){return i.split(\"-\")[1]}var g_={top:\"auto\",right:\"auto\",bottom:\"auto\",left:\"auto\"};function m_(i,t){var e=i.x,s=i.y,n=t.devicePixelRatio||1;return{x:Ni(e*n)/n||0,y:Ni(s*n)/n||0}}function dc(i){var t,e=i.popper,s=i.popperRect,n=i.placement,o=i.variation,r=i.offsets,a=i.position,l=i.gpuAcceleration,c=i.adaptive,h=i.roundOffsets,d=i.isFixed,u=r.x,f=u===void 0?0:u,p=r.y,_=p===void 0?0:p,m=typeof h==\"function\"?h({x:f,y:_}):{x:f,y:_};f=m.x,_=m.y;var y=r.hasOwnProperty(\"x\"),x=r.hasOwnProperty(\"y\"),E=mt,C=gt,T=window;if(c){var A=vs(e),w=\"clientHeight\",S=\"clientWidth\";if(A===Mt(e)&&(A=Pe(e),qt(A).position!==\"static\"&&a===\"absolute\"&&(w=\"scrollHeight\",S=\"scrollWidth\")),A=A,n===gt||(n===mt||n===Dt)&&o===Pi){C=Ot;var k=d&&A===T&&T.visualViewport?T.visualViewport.height:A[w];_-=k-s.height,_*=l?1:-1}if(n===mt||(n===gt||n===Ot)&&o===Pi){E=Dt;var D=d&&A===T&&T.visualViewport?T.visualViewport.width:A[S];f-=D-s.width,f*=l?1:-1}}var O=Object.assign({position:a},c&&g_),M=h===!0?m_({x:f,y:_},Mt(e)):{x:f,y:_};if(f=M.x,_=M.y,l){var L;return Object.assign({},O,(L={},L[C]=x?\"0\":\"\",L[E]=y?\"0\":\"\",L.transform=(T.devicePixelRatio||1)<=1?\"translate(\"+f+\"px, \"+_+\"px)\":\"translate3d(\"+f+\"px, \"+_+\"px, 0)\",L))}return Object.assign({},O,(t={},t[C]=x?_+\"px\":\"\",t[E]=y?f+\"px\":\"\",t.transform=\"\",t))}function b_(i){var t=i.state,e=i.options,s=e.gpuAcceleration,n=s===void 0?!0:s,o=e.adaptive,r=o===void 0?!0:o,a=e.roundOffsets,l=a===void 0?!0:a;if({}.NODE_ENV!==\"production\"){var c=qt(t.elements.popper).transitionProperty||\"\";r&&[\"transform\",\"top\",\"right\",\"bottom\",\"left\"].some(function(d){return c.indexOf(d)>=0})&&console.warn([\"Popper: Detected CSS transitions on at least one of the following\",'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',`\n\n`,'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\"for smooth transitions, or remove these properties from the CSS\",\"transition declaration on the popper element if only transitioning\",\"opacity or background-color for example.\",`\n\n`,\"We recommend using the popper element as a wrapper around an inner\",\"element that can have any CSS property transitioned for animations.\"].join(\" \"))}var h={placement:Gt(t.placement),variation:Bi(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:n,isFixed:t.options.strategy===\"fixed\"};t.modifiersData.popperOffsets!=null&&(t.styles.popper=Object.assign({},t.styles.popper,dc(Object.assign({},h,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:r,roundOffsets:l})))),t.modifiersData.arrow!=null&&(t.styles.arrow=Object.assign({},t.styles.arrow,dc(Object.assign({},h,{offsets:t.modifiersData.arrow,position:\"absolute\",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{\"data-popper-placement\":t.placement})}const Ir={name:\"computeStyles\",enabled:!0,phase:\"beforeWrite\",fn:b_,data:{}};var Ln={passive:!0};function v_(i){var t=i.state,e=i.instance,s=i.options,n=s.scroll,o=n===void 0?!0:n,r=s.resize,a=r===void 0?!0:r,l=Mt(t.elements.popper),c=[].concat(t.scrollParents.reference,t.scrollParents.popper);return o&&c.forEach(function(h){h.addEventListener(\"scroll\",e.update,Ln)}),a&&l.addEventListener(\"resize\",e.update,Ln),function(){o&&c.forEach(function(h){h.removeEventListener(\"scroll\",e.update,Ln)}),a&&l.removeEventListener(\"resize\",e.update,Ln)}}const Lr={name:\"eventListeners\",enabled:!0,phase:\"write\",fn:function(){},effect:v_,data:{}};var y_={left:\"right\",right:\"left\",bottom:\"top\",top:\"bottom\"};function Pn(i){return i.replace(/left|right|bottom|top/g,function(t){return y_[t]})}var x_={start:\"end\",end:\"start\"};function uc(i){return i.replace(/start|end/g,function(t){return x_[t]})}function Pr(i){var t=Mt(i),e=t.pageXOffset,s=t.pageYOffset;return{scrollLeft:e,scrollTop:s}}function Rr(i){return $i(Pe(i)).left+Pr(i).scrollLeft}function E_(i,t){var e=Mt(i),s=Pe(i),n=e.visualViewport,o=s.clientWidth,r=s.clientHeight,a=0,l=0;if(n){o=n.width,r=n.height;var c=nc();(c||!c&&t===\"fixed\")&&(a=n.offsetLeft,l=n.offsetTop)}return{width:o,height:r,x:a+Rr(i),y:l}}function C_(i){var t,e=Pe(i),s=Pr(i),n=(t=i.ownerDocument)==null?void 0:t.body,o=ri(e.scrollWidth,e.clientWidth,n?n.scrollWidth:0,n?n.clientWidth:0),r=ri(e.scrollHeight,e.clientHeight,n?n.scrollHeight:0,n?n.clientHeight:0),a=-s.scrollLeft+Rr(i),l=-s.scrollTop;return qt(n||e).direction===\"rtl\"&&(a+=ri(e.clientWidth,n?n.clientWidth:0)-o),{width:o,height:r,x:a,y:l}}function Nr(i){var t=qt(i),e=t.overflow,s=t.overflowX,n=t.overflowY;return/auto|scroll|overlay|hidden/.test(e+n+s)}function fc(i){return[\"html\",\"body\",\"#document\"].indexOf(oe(i))>=0?i.ownerDocument.body:It(i)&&Nr(i)?i:fc(In(i))}function xs(i,t){var e;t===void 0&&(t=[]);var s=fc(i),n=s===((e=i.ownerDocument)==null?void 0:e.body),o=Mt(s),r=n?[o].concat(o.visualViewport||[],Nr(s)?s:[]):s,a=t.concat(r);return n?a:a.concat(xs(In(r)))}function $r(i){return Object.assign({},i,{left:i.x,top:i.y,right:i.x+i.width,bottom:i.y+i.height})}function T_(i,t){var e=$i(i,!1,t===\"fixed\");return e.top=e.top+i.clientTop,e.left=e.left+i.clientLeft,e.bottom=e.top+i.clientHeight,e.right=e.left+i.clientWidth,e.width=i.clientWidth,e.height=i.clientHeight,e.x=e.left,e.y=e.top,e}function pc(i,t,e){return t===Tr?$r(E_(i,e)):oi(t)?T_(t,e):$r(C_(Pe(i)))}function A_(i){var t=xs(In(i)),e=[\"absolute\",\"fixed\"].indexOf(qt(i).position)>=0,s=e&&It(i)?vs(i):i;return oi(s)?t.filter(function(n){return oi(n)&&oc(n,s)&&oe(n)!==\"body\"}):[]}function w_(i,t,e,s){var n=t===\"clippingParents\"?A_(i):[].concat(t),o=[].concat(n,[e]),r=o[0],a=o.reduce(function(l,c){var h=pc(i,c,s);return l.top=ri(h.top,l.top),l.right=Mn(h.right,l.right),l.bottom=Mn(h.bottom,l.bottom),l.left=ri(h.left,l.left),l},pc(i,r,s));return a.width=a.right-a.left,a.height=a.bottom-a.top,a.x=a.left,a.y=a.top,a}function _c(i){var t=i.reference,e=i.element,s=i.placement,n=s?Gt(s):null,o=s?Bi(s):null,r=t.x+t.width/2-e.width/2,a=t.y+t.height/2-e.height/2,l;switch(n){case gt:l={x:r,y:t.y-e.height};break;case Ot:l={x:r,y:t.y+t.height};break;case Dt:l={x:t.x+t.width,y:a};break;case mt:l={x:t.x-e.width,y:a};break;default:l={x:t.x,y:t.y}}var c=n?Mr(n):null;if(c!=null){var h=c===\"y\"?\"height\":\"width\";switch(o){case ni:l[c]=l[c]-(t[h]/2-e[h]/2);break;case Pi:l[c]=l[c]+(t[h]/2-e[h]/2);break}}return l}function Hi(i,t){t===void 0&&(t={});var e=t,s=e.placement,n=s===void 0?i.placement:s,o=e.strategy,r=o===void 0?i.strategy:o,a=e.boundary,l=a===void 0?Ul:a,c=e.rootBoundary,h=c===void 0?Tr:c,d=e.elementContext,u=d===void 0?Ri:d,f=e.altBoundary,p=f===void 0?!1:f,_=e.padding,m=_===void 0?0:_,y=lc(typeof m!=\"number\"?m:cc(m,Li)),x=u===Ri?Xl:Ri,E=i.rects.popper,C=i.elements[p?x:u],T=w_(oi(C)?C:C.contextElement||Pe(i.elements.popper),l,h,r),A=$i(i.elements.reference),w=_c({reference:A,element:E,strategy:\"absolute\",placement:n}),S=$r(Object.assign({},E,w)),k=u===Ri?S:A,D={top:T.top-k.top+y.top,bottom:k.bottom-T.bottom+y.bottom,left:T.left-k.left+y.left,right:k.right-T.right+y.right},O=i.modifiersData.offset;if(u===Ri&&O){var M=O[n];Object.keys(D).forEach(function(L){var X=[Dt,Ot].indexOf(L)>=0?1:-1,I=[gt,Ot].indexOf(L)>=0?\"y\":\"x\";D[L]+=M[I]*X})}return D}function k_(i,t){t===void 0&&(t={});var e=t,s=e.placement,n=e.boundary,o=e.rootBoundary,r=e.padding,a=e.flipVariations,l=e.allowedAutoPlacements,c=l===void 0?wr:l,h=Bi(s),d=h?a?Ar:Ar.filter(function(p){return Bi(p)===h}):Li,u=d.filter(function(p){return c.indexOf(p)>=0});u.length===0&&(u=d,{}.NODE_ENV!==\"production\"&&console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\",\"placements. Ensure the `placement` option matches the variation\",\"of the allowed placements.\",'For example, \"auto\" cannot be used to allow \"bottom-start\".','Use \"auto-start\" instead.'].join(\" \")));var f=u.reduce(function(p,_){return p[_]=Hi(i,{placement:_,boundary:n,rootBoundary:o,padding:r})[Gt(_)],p},{});return Object.keys(f).sort(function(p,_){return f[p]-f[_]})}function S_(i){if(Gt(i)===bs)return[];var t=Pn(i);return[uc(i),t,uc(t)]}function O_(i){var t=i.state,e=i.options,s=i.name;if(!t.modifiersData[s]._skip){for(var n=e.mainAxis,o=n===void 0?!0:n,r=e.altAxis,a=r===void 0?!0:r,l=e.fallbackPlacements,c=e.padding,h=e.boundary,d=e.rootBoundary,u=e.altBoundary,f=e.flipVariations,p=f===void 0?!0:f,_=e.allowedAutoPlacements,m=t.options.placement,y=Gt(m),x=y===m,E=l||(x||!p?[Pn(m)]:S_(m)),C=[m].concat(E).reduce(function(xe,Ut){return xe.concat(Gt(Ut)===bs?k_(t,{placement:Ut,boundary:h,rootBoundary:d,padding:c,flipVariations:p,allowedAutoPlacements:_}):Ut)},[]),T=t.rects.reference,A=t.rects.popper,w=new Map,S=!0,k=C[0],D=0;D<C.length;D++){var O=C[D],M=Gt(O),L=Bi(O)===ni,X=[gt,Ot].indexOf(M)>=0,I=X?\"width\":\"height\",F=Hi(t,{placement:O,boundary:h,rootBoundary:d,altBoundary:u,padding:c}),Y=X?L?Dt:mt:L?Ot:gt;T[I]>A[I]&&(Y=Pn(Y));var Yt=Pn(Y),ee=[];if(o&&ee.push(F[M]<=0),a&&ee.push(F[Y]<=0,F[Yt]<=0),ee.every(function(xe){return xe})){k=O,S=!1;break}w.set(O,ee)}if(S)for(var ie=p?3:1,ti=function(Ut){var Me=C.find(function(mr){var Oi=w.get(mr);if(Oi)return Oi.slice(0,Ut).every(function(Ol){return Ol})});if(Me)return k=Me,\"break\"},Kt=ie;Kt>0;Kt--){var ye=ti(Kt);if(ye===\"break\")break}t.placement!==k&&(t.modifiersData[s]._skip=!0,t.placement=k,t.reset=!0)}}const gc={name:\"flip\",enabled:!0,phase:\"main\",fn:O_,requiresIfExists:[\"offset\"],data:{_skip:!1}};function mc(i,t,e){return e===void 0&&(e={x:0,y:0}),{top:i.top-t.height-e.y,right:i.right-t.width+e.x,bottom:i.bottom-t.height+e.y,left:i.left-t.width-e.x}}function bc(i){return[gt,Dt,Ot,mt].some(function(t){return i[t]>=0})}function D_(i){var t=i.state,e=i.name,s=t.rects.reference,n=t.rects.popper,o=t.modifiersData.preventOverflow,r=Hi(t,{elementContext:\"reference\"}),a=Hi(t,{altBoundary:!0}),l=mc(r,s),c=mc(a,n,o),h=bc(l),d=bc(c);t.modifiersData[e]={referenceClippingOffsets:l,popperEscapeOffsets:c,isReferenceHidden:h,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{\"data-popper-reference-hidden\":h,\"data-popper-escaped\":d})}const vc={name:\"hide\",enabled:!0,phase:\"main\",requiresIfExists:[\"preventOverflow\"],fn:D_};function M_(i,t,e){var s=Gt(i),n=[mt,gt].indexOf(s)>=0?-1:1,o=typeof e==\"function\"?e(Object.assign({},t,{placement:i})):e,r=o[0],a=o[1];return r=r||0,a=(a||0)*n,[mt,Dt].indexOf(s)>=0?{x:a,y:r}:{x:r,y:a}}function I_(i){var t=i.state,e=i.options,s=i.name,n=e.offset,o=n===void 0?[0,0]:n,r=wr.reduce(function(h,d){return h[d]=M_(d,t.rects,o),h},{}),a=r[t.placement],l=a.x,c=a.y;t.modifiersData.popperOffsets!=null&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=c),t.modifiersData[s]=r}const yc={name:\"offset\",enabled:!0,phase:\"main\",requires:[\"popperOffsets\"],fn:I_};function L_(i){var t=i.state,e=i.name;t.modifiersData[e]=_c({reference:t.rects.reference,element:t.rects.popper,strategy:\"absolute\",placement:t.placement})}const Br={name:\"popperOffsets\",enabled:!0,phase:\"read\",fn:L_,data:{}};function P_(i){return i===\"x\"?\"y\":\"x\"}function R_(i){var t=i.state,e=i.options,s=i.name,n=e.mainAxis,o=n===void 0?!0:n,r=e.altAxis,a=r===void 0?!1:r,l=e.boundary,c=e.rootBoundary,h=e.altBoundary,d=e.padding,u=e.tether,f=u===void 0?!0:u,p=e.tetherOffset,_=p===void 0?0:p,m=Hi(t,{boundary:l,rootBoundary:c,padding:d,altBoundary:h}),y=Gt(t.placement),x=Bi(t.placement),E=!x,C=Mr(y),T=P_(C),A=t.modifiersData.popperOffsets,w=t.rects.reference,S=t.rects.popper,k=typeof _==\"function\"?_(Object.assign({},t.rects,{placement:t.placement})):_,D=typeof k==\"number\"?{mainAxis:k,altAxis:k}:Object.assign({mainAxis:0,altAxis:0},k),O=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,M={x:0,y:0};if(A){if(o){var L,X=C===\"y\"?gt:mt,I=C===\"y\"?Ot:Dt,F=C===\"y\"?\"height\":\"width\",Y=A[C],Yt=Y+m[X],ee=Y-m[I],ie=f?-S[F]/2:0,ti=x===ni?w[F]:S[F],Kt=x===ni?-S[F]:-w[F],ye=t.elements.arrow,xe=f&&ye?Dr(ye):{width:0,height:0},Ut=t.modifiersData[\"arrow#persistent\"]?t.modifiersData[\"arrow#persistent\"].padding:ac(),Me=Ut[X],mr=Ut[I],Oi=ys(0,w[F],xe[F]),Ol=E?w[F]/2-ie-Oi-Me-D.mainAxis:ti-Oi-Me-D.mainAxis,Tk=E?-w[F]/2+ie+Oi+mr+D.mainAxis:Kt+Oi+mr+D.mainAxis,Dl=t.elements.arrow&&vs(t.elements.arrow),Ak=Dl?C===\"y\"?Dl.clientTop||0:Dl.clientLeft||0:0,Rp=(L=O==null?void 0:O[C])!=null?L:0,wk=Y+Ol-Rp-Ak,kk=Y+Tk-Rp,Np=ys(f?Mn(Yt,wk):Yt,Y,f?ri(ee,kk):ee);A[C]=Np,M[C]=Np-Y}if(a){var $p,Sk=C===\"x\"?gt:mt,Ok=C===\"x\"?Ot:Dt,Di=A[T],br=T===\"y\"?\"height\":\"width\",Bp=Di+m[Sk],Hp=Di-m[Ok],Ml=[gt,mt].indexOf(y)!==-1,Fp=($p=O==null?void 0:O[T])!=null?$p:0,Vp=Ml?Bp:Di-w[br]-S[br]-Fp+D.altAxis,Wp=Ml?Di+w[br]+S[br]-Fp-D.altAxis:Hp,zp=f&&Ml?u_(Vp,Di,Wp):ys(f?Vp:Bp,Di,f?Wp:Hp);A[T]=zp,M[T]=zp-Di}t.modifiersData[s]=M}}const xc={name:\"preventOverflow\",enabled:!0,phase:\"main\",fn:R_,requiresIfExists:[\"offset\"]};function N_(i){return{scrollLeft:i.scrollLeft,scrollTop:i.scrollTop}}function $_(i){return i===Mt(i)||!It(i)?Pr(i):N_(i)}function B_(i){var t=i.getBoundingClientRect(),e=Ni(t.width)/i.offsetWidth||1,s=Ni(t.height)/i.offsetHeight||1;return e!==1||s!==1}function H_(i,t,e){e===void 0&&(e=!1);var s=It(t),n=It(t)&&B_(t),o=Pe(t),r=$i(i,n,e),a={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(s||!s&&!e)&&((oe(t)!==\"body\"||Nr(o))&&(a=$_(t)),It(t)?(l=$i(t,!0),l.x+=t.clientLeft,l.y+=t.clientTop):o&&(l.x=Rr(o))),{x:r.left+a.scrollLeft-l.x,y:r.top+a.scrollTop-l.y,width:r.width,height:r.height}}function F_(i){var t=new Map,e=new Set,s=[];i.forEach(function(o){t.set(o.name,o)});function n(o){e.add(o.name);var r=[].concat(o.requires||[],o.requiresIfExists||[]);r.forEach(function(a){if(!e.has(a)){var l=t.get(a);l&&n(l)}}),s.push(o)}return i.forEach(function(o){e.has(o.name)||n(o)}),s}function V_(i){var t=F_(i);return Dn.reduce(function(e,s){return e.concat(t.filter(function(n){return n.phase===s}))},[])}function W_(i){var t;return function(){return t||(t=new Promise(function(e){Promise.resolve().then(function(){t=void 0,e(i())})})),t}}function Re(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),s=1;s<t;s++)e[s-1]=arguments[s];return[].concat(e).reduce(function(n,o){return n.replace(/%s/,o)},i)}var ai='Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s',z_='Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available',Ec=[\"name\",\"enabled\",\"phase\",\"fn\",\"effect\",\"requires\",\"options\"];function j_(i){i.forEach(function(t){[].concat(Object.keys(t),Ec).filter(function(e,s,n){return n.indexOf(e)===s}).forEach(function(e){switch(e){case\"name\":typeof t.name!=\"string\"&&console.error(Re(ai,String(t.name),'\"name\"','\"string\"','\"'+String(t.name)+'\"'));break;case\"enabled\":typeof t.enabled!=\"boolean\"&&console.error(Re(ai,t.name,'\"enabled\"','\"boolean\"','\"'+String(t.enabled)+'\"'));break;case\"phase\":Dn.indexOf(t.phase)<0&&console.error(Re(ai,t.name,'\"phase\"',\"either \"+Dn.join(\", \"),'\"'+String(t.phase)+'\"'));break;case\"fn\":typeof t.fn!=\"function\"&&console.error(Re(ai,t.name,'\"fn\"','\"function\"','\"'+String(t.fn)+'\"'));break;case\"effect\":t.effect!=null&&typeof t.effect!=\"function\"&&console.error(Re(ai,t.name,'\"effect\"','\"function\"','\"'+String(t.fn)+'\"'));break;case\"requires\":t.requires!=null&&!Array.isArray(t.requires)&&console.error(Re(ai,t.name,'\"requires\"','\"array\"','\"'+String(t.requires)+'\"'));break;case\"requiresIfExists\":Array.isArray(t.requiresIfExists)||console.error(Re(ai,t.name,'\"requiresIfExists\"','\"array\"','\"'+String(t.requiresIfExists)+'\"'));break;case\"options\":case\"data\":break;default:console.error('PopperJS: an invalid property has been provided to the \"'+t.name+'\" modifier, valid properties are '+Ec.map(function(s){return'\"'+s+'\"'}).join(\", \")+'; but \"'+e+'\" was provided.')}t.requires&&t.requires.forEach(function(s){i.find(function(n){return n.name===s})==null&&console.error(Re(z_,String(t.name),s,s))})})})}function Y_(i,t){var e=new Set;return i.filter(function(s){var n=t(s);if(!e.has(n))return e.add(n),!0})}function K_(i){var t=i.reduce(function(e,s){var n=e[s.name];return e[s.name]=n?Object.assign({},n,s,{options:Object.assign({},n.options,s.options),data:Object.assign({},n.data,s.data)}):s,e},{});return Object.keys(t).map(function(e){return t[e]})}var Cc=\"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\",U_=\"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\",Tc={placement:\"bottom\",modifiers:[],strategy:\"absolute\"};function Ac(){for(var i=arguments.length,t=new Array(i),e=0;e<i;e++)t[e]=arguments[e];return!t.some(function(s){return!(s&&typeof s.getBoundingClientRect==\"function\")})}function Rn(i){i===void 0&&(i={});var t=i,e=t.defaultModifiers,s=e===void 0?[]:e,n=t.defaultOptions,o=n===void 0?Tc:n;return function(a,l,c){c===void 0&&(c=o);var h={placement:\"bottom\",orderedModifiers:[],options:Object.assign({},Tc,o),modifiersData:{},elements:{reference:a,popper:l},attributes:{},styles:{}},d=[],u=!1,f={state:h,setOptions:function(y){var x=typeof y==\"function\"?y(h.options):y;_(),h.options=Object.assign({},o,h.options,x),h.scrollParents={reference:oi(a)?xs(a):a.contextElement?xs(a.contextElement):[],popper:xs(l)};var E=V_(K_([].concat(s,h.options.modifiers)));if(h.orderedModifiers=E.filter(function(O){return O.enabled}),{}.NODE_ENV!==\"production\"){var C=Y_([].concat(E,h.options.modifiers),function(O){var M=O.name;return M});if(j_(C),Gt(h.options.placement)===bs){var T=h.orderedModifiers.find(function(O){var M=O.name;return M===\"flip\"});T||console.error(['Popper: \"auto\" placements require the \"flip\" modifier be',\"present and enabled to work.\"].join(\" \"))}var A=qt(l),w=A.marginTop,S=A.marginRight,k=A.marginBottom,D=A.marginLeft;[w,S,k,D].some(function(O){return parseFloat(O)})&&console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding',\"between the popper and its reference element or boundary.\",\"To replicate margin, use the `offset` modifier, as well as\",\"the `padding` option in the `preventOverflow` and `flip`\",\"modifiers.\"].join(\" \"))}return p(),f.update()},forceUpdate:function(){if(!u){var y=h.elements,x=y.reference,E=y.popper;if(!Ac(x,E)){({}).NODE_ENV!==\"production\"&&console.error(Cc);return}h.rects={reference:H_(x,vs(E),h.options.strategy===\"fixed\"),popper:Dr(E)},h.reset=!1,h.placement=h.options.placement,h.orderedModifiers.forEach(function(O){return h.modifiersData[O.name]=Object.assign({},O.data)});for(var C=0,T=0;T<h.orderedModifiers.length;T++){if({}.NODE_ENV!==\"production\"&&(C+=1,C>100)){console.error(U_);break}if(h.reset===!0){h.reset=!1,T=-1;continue}var A=h.orderedModifiers[T],w=A.fn,S=A.options,k=S===void 0?{}:S,D=A.name;typeof w==\"function\"&&(h=w({state:h,options:k,name:D,instance:f})||h)}}},update:W_(function(){return new Promise(function(m){f.forceUpdate(),m(h)})}),destroy:function(){_(),u=!0}};if(!Ac(a,l))return{}.NODE_ENV!==\"production\"&&console.error(Cc),f;f.setOptions(c).then(function(m){!u&&c.onFirstUpdate&&c.onFirstUpdate(m)});function p(){h.orderedModifiers.forEach(function(m){var y=m.name,x=m.options,E=x===void 0?{}:x,C=m.effect;if(typeof C==\"function\"){var T=C({state:h,name:y,instance:f,options:E}),A=function(){};d.push(T||A)}})}function _(){d.forEach(function(m){return m()}),d=[]}return f}}var X_=Rn(),G_=[Lr,Br,Ir,Sr],q_=Rn({defaultModifiers:G_}),Z_=[Lr,Br,Ir,Sr,yc,gc,xc,hc,vc],Fi=Rn({defaultModifiers:Z_});const wc=Object.freeze(Object.defineProperty({__proto__:null,afterMain:tc,afterRead:Zl,afterWrite:sc,applyStyles:Sr,arrow:hc,auto:bs,basePlacements:Li,beforeMain:Ql,beforeRead:Gl,beforeWrite:ec,bottom:Ot,clippingParents:Ul,computeStyles:Ir,createPopper:Fi,createPopperBase:X_,createPopperLite:q_,detectOverflow:Hi,end:Pi,eventListeners:Lr,flip:gc,hide:vc,left:mt,main:Jl,modifierPhases:Dn,offset:yc,placements:wr,popper:Ri,popperGenerator:Rn,popperOffsets:Br,preventOverflow:xc,read:ql,reference:Xl,right:Dt,start:ni,top:gt,variationPlacements:Ar,viewport:Tr,write:ic},Symbol.toStringTag,{value:\"Module\"}));function Hr(i){return i===\"true\"?!0:i===\"false\"?!1:i===Number(i).toString()?Number(i):i===\"\"||i===\"null\"?null:i}function Fr(i){return i.replace(/[A-Z]/g,t=>`-${t.toLowerCase()}`)}const v={setDataAttribute(i,t,e){i.setAttribute(`data-te-${Fr(t)}`,e)},removeDataAttribute(i,t){i.removeAttribute(`data-te-${Fr(t)}`)},getDataAttributes(i){if(!i)return{};const t={};return Object.keys(i.dataset).filter(e=>e.startsWith(\"te\")).forEach(e=>{if(e.startsWith(\"teClass\"))return;let s=e.replace(/^te/,\"\");s=s.charAt(0).toLowerCase()+s.slice(1,s.length),t[s]=Hr(i.dataset[e])}),t},getDataClassAttributes(i){if(!i)return{};const t={...i.dataset};return Object.keys(t).filter(e=>e.startsWith(\"teClass\")).forEach(e=>{let s=e.replace(/^teClass/,\"\");s=s.charAt(0).toLowerCase()+s.slice(1,s.length),t[s]=Hr(t[e])}),t},getDataAttribute(i,t){return Hr(i.getAttribute(`data-te-${Fr(t)}`))},offset(i){const t=i.getBoundingClientRect();return{top:t.top+document.body.scrollTop,left:t.left+document.body.scrollLeft}},position(i){return{top:i.offsetTop,left:i.offsetLeft}},style(i,t){Object.assign(i.style,t)},toggleClass(i,t){i&&Vr(t).forEach(e=>{i.classList.contains(e)?i.classList.remove(e):i.classList.add(e)})},addClass(i,t){Vr(t).forEach(e=>!i.classList.contains(e)&&i.classList.add(e))},addStyle(i,t){Object.keys(t).forEach(e=>{i.style[e]=t[e]})},removeClass(i,t){Vr(t).forEach(e=>i.classList.contains(e)&&i.classList.remove(e))},hasClass(i,t){return i.classList.contains(t)}};function Vr(i){return typeof i==\"string\"?i.split(\" \"):Array.isArray(i)?i:!1}const Q_=3,g={closest(i,t){return i.closest(t)},matches(i,t){return i.matches(t)},find(i,t=document.documentElement){return[].concat(...Element.prototype.querySelectorAll.call(t,i))},findOne(i,t=document.documentElement){return Element.prototype.querySelector.call(t,i)},children(i,t){return[].concat(...i.children).filter(s=>s.matches(t))},parents(i,t){const e=[];let s=i.parentNode;for(;s&&s.nodeType===Node.ELEMENT_NODE&&s.nodeType!==Q_;)this.matches(s,t)&&e.push(s),s=s.parentNode;return e},prev(i,t){let e=i.previousElementSibling;for(;e;){if(e.matches(t))return[e];e=e.previousElementSibling}return[]},next(i,t){let e=i.nextElementSibling;for(;e;){if(this.matches(e,t))return[e];e=e.nextElementSibling}return[]},focusableChildren(i){const t=[\"a\",\"button\",\"input\",\"textarea\",\"select\",\"details\",\"[tabindex]\",'[contenteditable=\"true\"]'].map(e=>`${e}:not([tabindex^=\"-\"])`).join(\", \");return this.find(t,i).filter(e=>!ei(e)&&ne(e))}},Wr=\"dropdown\",li=\".te.dropdown\",zr=\".data-api\",Nn=\"Escape\",kc=\"Space\",Sc=\"Tab\",jr=\"ArrowUp\",$n=\"ArrowDown\",J_=2,tg=new RegExp(`${jr}|${$n}|${Nn}`),eg=`hide${li}`,ig=`hidden${li}`,sg=`show${li}`,ng=`shown${li}`,og=`click${li}${zr}`,Oc=`keydown${li}${zr}`,rg=`keyup${li}${zr}`,Ne=\"show\",ag=\"dropup\",lg=\"dropend\",cg=\"dropstart\",hg=\"[data-te-navbar-ref]\",Bn=\"[data-te-dropdown-toggle-ref]\",Yr=\"[data-te-dropdown-menu-ref]\",dg=\"[data-te-navbar-nav-ref]\",ug=\"[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)\",fg=st()?\"top-end\":\"top-start\",pg=st()?\"top-start\":\"top-end\",_g=st()?\"bottom-end\":\"bottom-start\",gg=st()?\"bottom-start\":\"bottom-end\",mg=st()?\"left-start\":\"right-start\",bg=st()?\"right-start\":\"left-start\",vg=[{opacity:\"0\"},{opacity:\"1\"}],yg=[{opacity:\"1\"},{opacity:\"0\"}],Hn={duration:550,iterations:1,easing:\"ease\",fill:\"both\"},xg={offset:[0,2],boundary:\"clippingParents\",reference:\"toggle\",display:\"dynamic\",popperConfig:null,autoClose:!0,dropdownAnimation:\"on\"},Eg={offset:\"(array|string|function)\",boundary:\"(string|element)\",reference:\"(string|element|object)\",display:\"string\",popperConfig:\"(null|object|function)\",autoClose:\"(boolean|string)\",dropdownAnimation:\"string\"};class $t extends Xt{constructor(t,e){super(t),this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._fadeOutAnimate=null;const s=window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;this._animationCanPlay=this._config.dropdownAnimation===\"on\"&&!s,this._didInit=!1,this._init()}static get Default(){return xg}static get DefaultType(){return Eg}static get NAME(){return Wr}toggle(){return this._isShown()?this.hide():this.show()}show(){if(ei(this._element)||this._isShown(this._menu))return;const t={relatedTarget:this._element};if(b.trigger(this._element,sg,t).defaultPrevented)return;const s=$t.getParentFromElement(this._element);this._inNavbar?v.setDataAttribute(this._menu,\"popper\",\"none\"):this._createPopper(s),\"ontouchstart\"in document.documentElement&&!s.closest(dg)&&[].concat(...document.body.children).forEach(n=>b.on(n,\"mouseover\",Sn)),this._element.focus(),this._element.setAttribute(\"aria-expanded\",!0),this._menu.setAttribute(`data-te-dropdown-${Ne}`,\"\"),this._animationCanPlay&&this._menu.animate(vg,Hn),this._element.setAttribute(`data-te-dropdown-${Ne}`,\"\"),setTimeout(()=>{b.trigger(this._element,ng,t)},this._animationCanPlay?Hn.duration:0)}hide(){if(ei(this._element)||!this._isShown(this._menu))return;const t={relatedTarget:this._element};this._completeHide(t)}dispose(){this._popper&&this._popper.destroy(),super.dispose()}update(){this._inNavbar=this._detectNavbar(),this._popper&&this._popper.update()}_init(){this._didInit||(b.on(document,Oc,Bn,$t.dataApiKeydownHandler),b.on(document,Oc,Yr,$t.dataApiKeydownHandler),b.on(document,og,$t.clearMenus),b.on(document,rg,$t.clearMenus),this._didInit=!0)}_completeHide(t){this._fadeOutAnimate&&this._fadeOutAnimate.playState===\"running\"||b.trigger(this._element,eg,t).defaultPrevented||(\"ontouchstart\"in document.documentElement&&[].concat(...document.body.children).forEach(s=>b.off(s,\"mouseover\",Sn)),this._animationCanPlay&&(this._fadeOutAnimate=this._menu.animate(yg,Hn)),setTimeout(()=>{this._popper&&this._popper.destroy(),this._menu.removeAttribute(`data-te-dropdown-${Ne}`),this._element.removeAttribute(`data-te-dropdown-${Ne}`),this._element.setAttribute(\"aria-expanded\",\"false\"),v.removeDataAttribute(this._menu,\"popper\"),b.trigger(this._element,ig,t)},this._animationCanPlay?Hn.duration:0))}_getConfig(t){if(t={...this.constructor.Default,...v.getDataAttributes(this._element),...t},W(Wr,t,this.constructor.DefaultType),typeof t.reference==\"object\"&&!Mi(t.reference)&&typeof t.reference.getBoundingClientRect!=\"function\")throw new TypeError(`${Wr.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);return t}_createPopper(t){if(typeof wc>\"u\")throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");let e=this._element;this._config.reference===\"parent\"?e=t:Mi(this._config.reference)?e=Le(this._config.reference):typeof this._config.reference==\"object\"&&(e=this._config.reference);const s=this._getPopperConfig(),n=s.modifiers.find(o=>o.name===\"applyStyles\"&&o.enabled===!1);this._popper=Fi(e,this._menu,s),n&&v.setDataAttribute(this._menu,\"popper\",\"static\")}_isShown(t=this._element){return t.dataset[`teDropdown${Ne.charAt(0).toUpperCase()+Ne.slice(1)}`]===\"\"}_getMenuElement(){return g.next(this._element,Yr)[0]}_getPlacement(){const t=this._element.parentNode;if(t.dataset.teDropdownPosition===lg)return mg;if(t.dataset.teDropdownPosition===cg)return bg;const e=getComputedStyle(this._menu).getPropertyValue(\"--te-position\").trim()===\"end\";return t.dataset.teDropdownPosition===ag?e?pg:fg:e?gg:_g}_detectNavbar(){return this._element.closest(hg)!==null}_getOffset(){const{offset:t}=this._config;return typeof t==\"string\"?t.split(\",\").map(e=>Number.parseInt(e,10)):typeof t==\"function\"?e=>t(e,this._element):t}_getPopperConfig(){const t={placement:this._getPlacement(),modifiers:[{name:\"preventOverflow\",options:{boundary:this._config.boundary}},{name:\"offset\",options:{offset:this._getOffset()}}]};return this._config.display===\"static\"&&(t.modifiers=[{name:\"applyStyles\",enabled:!1}]),{...t,...typeof this._config.popperConfig==\"function\"?this._config.popperConfig(t):this._config.popperConfig}}_selectMenuItem({key:t,target:e}){const s=g.find(ug,this._menu).filter(ne);s.length&&Bl(s,e,t===$n,!s.includes(e)).focus()}static jQueryInterface(t){return this.each(function(){const e=$t.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t]()}})}static clearMenus(t){if(t&&(t.button===J_||t.type===\"keyup\"&&t.key!==Sc))return;const e=g.find(Bn);for(let s=0,n=e.length;s<n;s++){const o=$t.getInstance(e[s]);if(!o||o._config.autoClose===!1||!o._isShown())continue;const r={relatedTarget:o._element};if(t){const a=t.composedPath(),l=a.includes(o._menu);if(a.includes(o._element)||o._config.autoClose===\"inside\"&&!l||o._config.autoClose===\"outside\"&&l||o._menu.contains(t.target)&&(t.type===\"keyup\"&&t.key===Sc||/input|select|option|textarea|form/i.test(t.target.tagName)))continue;t.type===\"click\"&&(r.clickEvent=t)}o._completeHide(r)}}static getParentFromElement(t){return Ie(t)||t.parentNode}static dataApiKeydownHandler(t){if(/input|textarea/i.test(t.target.tagName)?t.key===kc||t.key!==Nn&&(t.key!==$n&&t.key!==jr||t.target.closest(Yr)):!tg.test(t.key))return;const e=this.dataset[`teDropdown${Ne.charAt(0).toUpperCase()+Ne.slice(1)}`]===\"\";if(!e&&t.key===Nn||(t.preventDefault(),t.stopPropagation(),ei(this)))return;const s=this.matches(Bn)?this:g.prev(this,Bn)[0],n=$t.getOrCreateInstance(s);if(t.key===Nn){n.hide();return}if(t.key===jr||t.key===$n){e||n.show(),n._selectMenuItem(t);return}(!e||t.key===kc)&&$t.clearMenus()}}const Kr=\"collapse\",Dc=\"te.collapse\",Fn=`.${Dc}`,Mc={toggle:!0,parent:null},Cg={toggle:\"boolean\",parent:\"(null|element)\"},Tg=`show${Fn}`,Ag=`shown${Fn}`,wg=`hide${Fn}`,kg=`hidden${Fn}`,Ur=\"data-te-collapse-show\",Ic=\"data-te-collapse-collapsed\",Vn=\"data-te-collapse-collapsing\",Sg=\"data-te-collapse-horizontal\",Vi=\"data-te-collapse-item\",Lc=`:scope [${Vi}] [${Vi}]`,Og=\"width\",Dg=\"height\",Mg=\"[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]\",Pc=\"[data-te-collapse-init]\",Ig={visible:\"!visible\",hidden:\"hidden\",baseTransition:\"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",collapsing:\"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",collapsingHorizontal:\"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"},Lg={visible:\"string\",hidden:\"string\",baseTransition:\"string\",collapsing:\"string\",collapsingHorizontal:\"string\"};class re extends Xt{constructor(t,e,s){super(t),this._isTransitioning=!1,this._config=this._getConfig(e),this._classes=this._getClasses(s),this._triggerArray=[];const n=g.find(Pc);for(let o=0,r=n.length;o<r;o++){const a=n[o],l=yr(a),c=g.find(l).filter(h=>h===this._element);l!==null&&c.length&&(this._selector=l,this._triggerArray.push(a))}this._initializeChildren(),this._config.parent||this._addAriaAndCollapsedClass(this._triggerArray,this._isShown()),this._config.toggle&&this.toggle()}static get Default(){return Mc}static get NAME(){return Kr}toggle(){this._isShown()?this.hide():this.show()}show(){if(this._isTransitioning||this._isShown())return;let t=[],e;if(this._config.parent){const h=g.find(Lc,this._config.parent);t=g.find(Mg,this._config.parent).filter(d=>!h.includes(d))}const s=g.findOne(this._selector);if(t.length){const h=t.find(d=>s!==d);if(e=h?re.getInstance(h):null,e&&e._isTransitioning)return}if(b.trigger(this._element,Tg).defaultPrevented)return;t.forEach(h=>{s!==h&&re.getOrCreateInstance(h,{toggle:!1}).hide(),e||P.setData(h,Dc,null)});const o=this._getDimension(),r=o===\"height\"?this._classes.collapsing:this._classes.collapsingHorizontal;v.removeClass(this._element,this._classes.visible),v.removeClass(this._element,this._classes.hidden),v.addClass(this._element,r),this._element.removeAttribute(Vi),this._element.setAttribute(Vn,\"\"),this._element.style[o]=0,this._addAriaAndCollapsedClass(this._triggerArray,!0),this._isTransitioning=!0;const a=()=>{this._isTransitioning=!1,v.removeClass(this._element,this._classes.hidden),v.removeClass(this._element,r),v.addClass(this._element,this._classes.visible),this._element.removeAttribute(Vn),this._element.setAttribute(Vi,\"\"),this._element.setAttribute(Ur,\"\"),this._element.style[o]=\"\",b.trigger(this._element,Ag)},c=`scroll${o[0].toUpperCase()+o.slice(1)}`;this._queueCallback(a,this._element,!0),this._element.style[o]=`${this._element[c]}px`}hide(){if(this._isTransitioning||!this._isShown()||b.trigger(this._element,wg).defaultPrevented)return;const e=this._getDimension(),s=e===\"height\"?this._classes.collapsing:this._classes.collapsingHorizontal;this._element.style[e]=`${this._element.getBoundingClientRect()[e]}px`,Ii(this._element),v.addClass(this._element,s),v.removeClass(this._element,this._classes.visible),v.removeClass(this._element,this._classes.hidden),this._element.setAttribute(Vn,\"\"),this._element.removeAttribute(Vi),this._element.removeAttribute(Ur);const n=this._triggerArray.length;for(let r=0;r<n;r++){const a=this._triggerArray[r],l=Ie(a);l&&!this._isShown(l)&&this._addAriaAndCollapsedClass([a],!1)}this._isTransitioning=!0;const o=()=>{this._isTransitioning=!1,v.removeClass(this._element,s),v.addClass(this._element,this._classes.visible),v.addClass(this._element,this._classes.hidden),this._element.removeAttribute(Vn),this._element.setAttribute(Vi,\"\"),b.trigger(this._element,kg)};this._element.style[e]=\"\",this._queueCallback(o,this._element,!0)}_isShown(t=this._element){return t.hasAttribute(Ur)}_getConfig(t){return t={...Mc,...v.getDataAttributes(this._element),...t},t.toggle=!!t.toggle,t.parent=Le(t.parent),W(Kr,t,Cg),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Ig,...e,...t},W(Kr,t,Lg),t}_getDimension(){return this._element.hasAttribute(Sg)?Og:Dg}_initializeChildren(){if(!this._config.parent)return;const t=g.find(Lc,this._config.parent);g.find(Pc,this._config.parent).filter(e=>!t.includes(e)).forEach(e=>{const s=Ie(e);s&&this._addAriaAndCollapsedClass([e],this._isShown(s))})}_addAriaAndCollapsedClass(t,e){t.length&&t.forEach(s=>{e?s.removeAttribute(Ic):s.setAttribute(`${Ic}`,\"\"),s.setAttribute(\"aria-expanded\",e)})}static jQueryInterface(t){return this.each(function(){const e={};typeof t==\"string\"&&/show|hide/.test(t)&&(e.toggle=!1);const s=re.getOrCreateInstance(this,e);if(typeof t==\"string\"){if(typeof s[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);s[t]()}})}}const Rc=\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\",Nc=\".sticky-top\";class Es{constructor(){this._element=document.body}getWidth(){const t=document.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}hide(){const t=this.getWidth();this._disableOverFlow(),this._setElementAttributes(this._element,\"paddingRight\",e=>e+t),this._setElementAttributes(Rc,\"paddingRight\",e=>e+t),this._setElementAttributes(Nc,\"marginRight\",e=>e-t)}_disableOverFlow(){this._saveInitialAttribute(this._element,\"overflow\"),this._element.style.overflow=\"hidden\"}_setElementAttributes(t,e,s){const n=this.getWidth(),o=r=>{if(r!==this._element&&window.innerWidth>r.clientWidth+n)return;this._saveInitialAttribute(r,e);const a=window.getComputedStyle(r)[e];r.style[e]=`${s(Number.parseFloat(a))}px`};this._applyManipulationCallback(t,o)}reset(){this._resetElementAttributes(this._element,\"overflow\"),this._resetElementAttributes(this._element,\"paddingRight\"),this._resetElementAttributes(Rc,\"paddingRight\"),this._resetElementAttributes(Nc,\"marginRight\")}_saveInitialAttribute(t,e){const s=t.style[e];s&&v.setDataAttribute(t,e,s)}_resetElementAttributes(t,e){const s=n=>{const o=v.getDataAttribute(n,e);typeof o>\"u\"?n.style.removeProperty(e):(v.removeDataAttribute(n,e),n.style[e]=o)};this._applyManipulationCallback(t,s)}_applyManipulationCallback(t,e){Mi(t)?e(t):g.find(t,this._element).forEach(e)}isOverflowing(){return this.getWidth()>0}}const Pg={isVisible:!0,isAnimated:!1,rootElement:\"body\",clickCallback:null,backdropClasses:null},Rg={isVisible:\"boolean\",isAnimated:\"boolean\",rootElement:\"(element|string)\",clickCallback:\"(function|null)\",backdropClasses:\"(array|null)\"},$c=\"backdrop\",Bc=`mousedown.te.${$c}`;class Xr{constructor(t){this._config=this._getConfig(t),this._isAppended=!1,this._element=null}show(t){if(!this._config.isVisible){ii(t);return}this._append(),this._config.isAnimated&&Ii(this._getElement());const e=this._config.backdropClasses||[\"opacity-50\",\"transition-all\",\"duration-300\",\"ease-in-out\",\"fixed\",\"top-0\",\"left-0\",\"z-[1040]\",\"bg-black\",\"w-screen\",\"h-screen\"];v.removeClass(this._getElement(),\"opacity-0\"),v.addClass(this._getElement(),e),this._element.setAttribute(\"data-te-backdrop-show\",\"\"),this._emulateAnimation(()=>{ii(t)})}hide(t){if(!this._config.isVisible){ii(t);return}this._element.removeAttribute(\"data-te-backdrop-show\"),this._getElement().classList.add(\"opacity-0\"),this._getElement().classList.remove(\"opacity-50\"),this._emulateAnimation(()=>{this.dispose(),ii(t)})}_getElement(){if(!this._element){const t=document.createElement(\"div\");t.className=this._config.className,this._config.isAnimated&&t.classList.add(\"opacity-50\"),this._element=t}return this._element}_getConfig(t){return t={...Pg,...typeof t==\"object\"?t:{}},t.rootElement=Le(t.rootElement),W($c,t,Rg),t}_append(){this._isAppended||(this._config.rootElement.append(this._getElement()),b.on(this._getElement(),Bc,()=>{ii(this._config.clickCallback)}),this._isAppended=!0)}dispose(){this._isAppended&&(b.off(this._element,Bc),this._element.remove(),this._isAppended=!1)}_emulateAnimation(t){$l(t,this._getElement(),this._config.isAnimated)}}class Cs{constructor(t,e={},s){this._element=t,this._toggler=s,this._event=e.event||\"blur\",this._condition=e.condition||(()=>!0),this._selector=e.selector||'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',this._onlyVisible=e.onlyVisible||!1,this._focusableElements=[],this._firstElement=null,this._lastElement=null,this.handler=n=>{this._condition(n)&&!n.shiftKey&&n.target===this._lastElement?(n.preventDefault(),this._firstElement.focus()):this._condition(n)&&n.shiftKey&&n.target===this._firstElement&&(n.preventDefault(),this._lastElement.focus())}}trap(){this._setElements(),this._init(),this._setFocusTrap()}disable(){this._focusableElements.forEach(t=>{t.removeEventListener(this._event,this.handler)}),this._toggler&&this._toggler.focus()}update(){this._setElements(),this._setFocusTrap()}_init(){const t=e=>{!this._firstElement||e.key!==\"Tab\"||this._focusableElements.includes(e.target)||(e.preventDefault(),this._firstElement.focus(),window.removeEventListener(\"keydown\",t))};window.addEventListener(\"keydown\",t)}_filterVisible(t){return t.filter(e=>{if(!ne(e))return!1;const s=g.parents(e,\"*\");for(let n=0;n<s.length;n++){const o=window.getComputedStyle(s[n]);if(o&&(o.display===\"none\"||o.visibility===\"hidden\"))return!1}return!0})}_setElements(){this._focusableElements=g.focusableChildren(this._element),this._onlyVisible&&(this._focusableElements=this._filterVisible(this._focusableElements)),this._firstElement=this._focusableElements[0],this._lastElement=this._focusableElements[this._focusableElements.length-1]}_setFocusTrap(){this._focusableElements.forEach((t,e)=>{e===this._focusableElements.length-1||e===0?t.addEventListener(this._event,this.handler):t.removeEventListener(this._event,this.handler)})}}const Wn=(i,t=\"hide\")=>{const e=`click.dismiss${i.EVENT_KEY}`,s=i.NAME;b.on(document,e,`[data-te-${s}-dismiss]`,function(n){if([\"A\",\"AREA\"].includes(this.tagName)&&n.preventDefault(),ei(this))return;const o=Ie(this)||this.closest(`.${s}`)||this.closest(`[data-te-${s}-init]`);if(!o)return;i.getOrCreateInstance(o)[t]()})},Hc=\"offcanvas\",Wi=\".te.offcanvas\",Ng=`load${Wi}.data-api`,$g=\"Escape\",Fc={backdrop:!0,keyboard:!0,scroll:!1},Bg={backdrop:\"boolean\",keyboard:\"boolean\",scroll:\"boolean\"},Vc=\"show\",Hg=\"[data-te-offcanvas-init][data-te-offcanvas-show]\",Fg=`show${Wi}`,Vg=`shown${Wi}`,Wg=`hide${Wi}`,zg=`hidden${Wi}`,jg=`keydown.dismiss${Wi}`;class zi extends Xt{constructor(t,e){super(t),this._config=this._getConfig(e),this._isShown=!1,this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._addEventListeners(),this._didInit=!1,this._init()}static get NAME(){return Hc}static get Default(){return Fc}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){if(this._isShown||b.trigger(this._element,Fg,{relatedTarget:t}).defaultPrevented)return;this._isShown=!0,this._element.style.visibility=\"visible\",this._backdrop.show(),this._config.scroll||new Es().hide(),this._element.removeAttribute(\"aria-hidden\"),this._element.setAttribute(\"aria-modal\",!0),this._element.setAttribute(\"role\",\"dialog\"),this._element.setAttribute(`data-te-offcanvas-${Vc}`,\"\");const s=()=>{this._config.scroll||this._focustrap.trap(),b.trigger(this._element,Vg,{relatedTarget:t})};this._queueCallback(s,this._element,!0)}hide(){if(!this._isShown||b.trigger(this._element,Wg).defaultPrevented)return;this._focustrap.disable(),this._element.blur(),this._isShown=!1,this._element.removeAttribute(`data-te-offcanvas-${Vc}`),this._backdrop.hide();const e=()=>{this._element.setAttribute(\"aria-hidden\",!0),this._element.removeAttribute(\"aria-modal\"),this._element.removeAttribute(\"role\"),this._element.style.visibility=\"hidden\",this._config.scroll||new Es().reset(),b.trigger(this._element,zg)};this._queueCallback(e,this._element,!0)}dispose(){this._backdrop.dispose(),this._focustrap.disable(),super.dispose()}_init(){this._didInit||(b.on(window,Ng,()=>g.find(Hg).forEach(t=>zi.getOrCreateInstance(t).show())),Wn(zi),this._didInit=!0)}_getConfig(t){return t={...Fc,...v.getDataAttributes(this._element),...typeof t==\"object\"?t:{}},W(Hc,t,Bg),t}_initializeBackDrop(){return new Xr({isVisible:this._config.backdrop,isAnimated:!0,rootElement:this._element.parentNode,clickCallback:()=>this.hide()})}_initializeFocusTrap(){return new Cs(this._element,{event:\"keydown\",condition:t=>t.key===\"Tab\"})}_addEventListeners(){b.on(this._element,jg,t=>{this._config.keyboard&&t.key===$g&&this.hide()})}static jQueryInterface(t){return this.each(function(){const e=zi.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(e[t]===void 0||t.startsWith(\"_\")||t===\"constructor\")throw new TypeError(`No method named \"${t}\"`);e[t](this)}})}}const Gr=\"alert\",Wc=\".te.alert\",Yg=`close${Wc}`,Kg=`closed${Wc}`,Ts=\"data-te-alert-show\",Ug={animation:\"boolean\",autohide:\"boolean\",delay:\"number\"},zc={animation:!0,autohide:!0,delay:1e3},Xg={fadeIn:\"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",fadeOut:\"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"},Gg={fadeIn:\"string\",fadeOut:\"string\"};class As extends Xt{constructor(t,e,s){super(t),this._element=t,this._config=this._getConfig(e),this._classes=this._getClasses(s),this._didInit=!1,this._init()}static get DefaultType(){return Ug}static get Default(){return zc}static get NAME(){return Gr}close(){if(b.trigger(this._element,Yg).defaultPrevented)return;let e=0;this._config.animation&&(e=300,v.addClass(this._element,this._classes.fadeOut)),this._element.removeAttribute(Ts),setTimeout(()=>{this._queueCallback(()=>this._destroyElement(),this._element,this._config.animation)},e)}show(){if(this._element){if(this._config.autohide&&this._setupAutohide(),!this._element.hasAttribute(Ts)&&(v.removeClass(this._element,\"hidden\"),v.addClass(this._element,\"block\"),ne(this._element))){const t=e=>{v.removeClass(this._element,\"hidden\"),v.addClass(this._element,\"block\"),b.off(e.target,\"animationend\",t)};this._element.setAttribute(Ts,\"\"),b.on(this._element,\"animationend\",t)}this._config.animation&&(v.removeClass(this._element,this._classes.fadeOut),v.addClass(this._element,this._classes.fadeIn))}}hide(){if(this._element&&this._element.hasAttribute(Ts)){this._element.removeAttribute(Ts);const t=e=>{v.addClass(this._element,\"hidden\"),v.removeClass(this._element,\"block\"),this._timeout!==null&&(clearTimeout(this._timeout),this._timeout=null),b.off(e.target,\"animationend\",t)};b.on(this._element,\"animationend\",t),v.removeClass(this._element,this._classes.fadeIn),v.addClass(this._element,this._classes.fadeOut)}}_init(){this._didInit||(Wn(As,\"close\"),this._didInit=!0)}_getConfig(t){return t={...zc,...v.getDataAttributes(this._element),...typeof t==\"object\"&&t?t:{}},W(Gr,t,this.constructor.DefaultType),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Xg,...e,...t},W(Gr,t,Gg),t}_setupAutohide(){this._timeout=setTimeout(()=>{this.hide()},this._config.delay)}_destroyElement(){this._element.remove(),b.trigger(this._element,Kg),this.dispose()}static jQueryInterface(t){return this.each(function(){const e=As.getOrCreateInstance(this);if(typeof t==\"string\"){if(e[t]===void 0||t.startsWith(\"_\")||t===\"constructor\")throw new TypeError(`No method named \"${t}\"`);e[t](this)}})}}const qr=\"carousel\",Lt=\".te.carousel\",jc=\".data-api\",qg=\"ArrowLeft\",Zg=\"ArrowRight\",Qg=500,Jg=40,Yc={interval:5e3,keyboard:!0,slide:!1,pause:\"hover\",wrap:!0,touch:!0},tm={interval:\"(number|boolean)\",keyboard:\"boolean\",slide:\"(boolean|string)\",pause:\"(string|boolean)\",wrap:\"boolean\",touch:\"boolean\"},em={pointer:\"touch-pan-y\",block:\"!block\",visible:\"data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]\",invisible:\"data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600\",slideRight:\"translate-x-full\",slideLeft:\"-translate-x-full\"},im={pointer:\"string\",block:\"string\",visible:\"string\",invisible:\"string\",slideRight:\"string\",slideLeft:\"string\"},ci=\"next\",hi=\"prev\",di=\"left\",ws=\"right\",sm={[qg]:ws,[Zg]:di},nm=`slide${Lt}`,Kc=`slid${Lt}`,om=`keydown${Lt}`,rm=`mouseenter${Lt}`,am=`mouseleave${Lt}`,lm=`touchstart${Lt}`,cm=`touchmove${Lt}`,hm=`touchend${Lt}`,dm=`pointerdown${Lt}`,um=`pointerup${Lt}`,fm=`dragstart${Lt}`,pm=`load${Lt}${jc}`,_m=`click${Lt}${jc}`,gm=\"data-te-carousel-init\",ui=\"data-te-carousel-active\",mm=\"data-te-carousel-slide\",bm=\"data-te-carousel-item-end\",Zr=\"data-te-carousel-item-start\",vm=\"data-te-carousel-item-next\",ym=\"data-te-carousel-item-prev\",xm=\"data-te-carousel-pointer-event\",Em=\"[data-te-carousel-init]\",Uc=\"[data-te-carousel-active]\",Qr=\"[data-te-carousel-item]\",ji=`${Uc}${Qr}`,Cm=`${Qr} img`,Tm=\"[data-te-carousel-item-next], [data-te-carousel-item-prev]\",Am=\"[data-te-carousel-indicators]\",wm=\"[data-te-target]\",km=\"[data-te-slide], [data-te-slide-to]\",Sm=\"touch\",Om=\"pen\";class ae extends Xt{constructor(t,e,s){super(t),this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this.touchStartX=0,this.touchDeltaX=0,this._config=this._getConfig(e),this._classes=this._getClasses(s),this._indicatorsElement=g.findOne(Am,this._element),this._touchSupported=\"ontouchstart\"in document.documentElement||navigator.maxTouchPoints>0,this._pointerEvent=!!window.PointerEvent,this._setActiveElementClass(),this._addEventListeners(),this._didInit=!1,this._init()}static get Default(){return Yc}static get NAME(){return qr}next(){this._slide(ci)}nextWhenVisible(){!document.hidden&&ne(this._element)&&this.next()}prev(){this._slide(hi)}pause(t){t||(this._isPaused=!0),g.findOne(Tm,this._element)&&(Ll(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null}cycle(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config&&this._config.interval&&!this._isPaused&&(this._updateInterval(),this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))}to(t){this._activeElement=g.findOne(ji,this._element);const e=this._getItemIndex(this._activeElement);if(t>this._items.length-1||t<0)return;if(this._isSliding){b.one(this._element,Kc,()=>this.to(t));return}if(e===t){this.pause(),this.cycle();return}const s=t>e?ci:hi;this._slide(s,this._items[t])}_init(){this._didInit||(b.on(document,_m,km,ae.dataApiClickHandler),b.on(window,pm,()=>{const t=g.find(Em);for(let e=0,s=t.length;e<s;e++)ae.carouselInterface(t[e],ae.getInstance(t[e]))}),this._didInit=!0)}_getConfig(t){return t={...Yc,...v.getDataAttributes(this._element),...typeof t==\"object\"?t:{}},W(qr,t,tm),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...em,...e,...t},W(qr,t,im),t}_applyInitialClasses(){const t=g.findOne(ji,this._element);t.classList.add(this._classes.block,...this._classes.visible.split(\" \")),this._setActiveIndicatorElement(t)}_handleSwipe(){const t=Math.abs(this.touchDeltaX);if(t<=Jg)return;const e=t/this.touchDeltaX;this.touchDeltaX=0,e&&this._slide(e>0?ws:di)}_setActiveElementClass(){this._activeElement=g.findOne(ji,this._element),v.addClass(this._activeElement,\"hidden\")}_addEventListeners(){this._config.keyboard&&b.on(this._element,om,t=>this._keydown(t)),this._config.pause===\"hover\"&&(b.on(this._element,rm,t=>this.pause(t)),b.on(this._element,am,t=>this.cycle(t))),this._config.touch&&this._touchSupported&&this._addTouchEventListeners(),this._applyInitialClasses()}_addTouchEventListeners(){const t=o=>this._pointerEvent&&(o.pointerType===Om||o.pointerType===Sm),e=o=>{t(o)?this.touchStartX=o.clientX:this._pointerEvent||(this.touchStartX=o.touches[0].clientX)},s=o=>{this.touchDeltaX=o.touches&&o.touches.length>1?0:o.touches[0].clientX-this.touchStartX},n=o=>{t(o)&&(this.touchDeltaX=o.clientX-this.touchStartX),this._handleSwipe(),this._config.pause===\"hover\"&&(this.pause(),this.touchTimeout&&clearTimeout(this.touchTimeout),this.touchTimeout=setTimeout(r=>this.cycle(r),Qg+this._config.interval))};g.find(Cm,this._element).forEach(o=>{b.on(o,fm,r=>r.preventDefault())}),this._pointerEvent?(b.on(this._element,dm,o=>e(o)),b.on(this._element,um,o=>n(o)),this._element.classList.add(this._classes.pointer),this._element.setAttribute(`${xm}`,\"\")):(b.on(this._element,lm,o=>e(o)),b.on(this._element,cm,o=>s(o)),b.on(this._element,hm,o=>n(o)))}_keydown(t){if(/input|textarea/i.test(t.target.tagName))return;const e=sm[t.key];e&&(t.preventDefault(),this._slide(e))}_getItemIndex(t){return this._items=t&&t.parentNode?g.find(Qr,t.parentNode):[],this._items.indexOf(t)}_getItemByOrder(t,e){const s=t===ci;return Bl(this._items,e,s,this._config.wrap)}_triggerSlideEvent(t,e){const s=this._getItemIndex(t),n=this._getItemIndex(g.findOne(ji,this._element));return b.trigger(this._element,nm,{relatedTarget:t,direction:e,from:n,to:s})}_setActiveIndicatorElement(t){if(this._indicatorsElement){const e=g.findOne(Uc,this._indicatorsElement);e.removeAttribute(ui),e.removeAttribute(\"aria-current\"),e.classList.remove(\"!opacity-100\");const s=g.find(wm,this._indicatorsElement);for(let n=0;n<s.length;n++)if(Number.parseInt(s[n].getAttribute(\"data-te-slide-to\"),10)===this._getItemIndex(t)){s[n].setAttribute(`${ui}`,\"\"),s[n].setAttribute(\"aria-current\",\"true\"),s[n].classList.add(\"!opacity-100\");break}}}_updateInterval(){const t=this._activeElement||g.findOne(ji,this._element);if(!t)return;const e=Number.parseInt(t.getAttribute(\"data-te-interval\"),10);e?(this._config.defaultInterval=this._config.defaultInterval||this._config.interval,this._config.interval=e):this._config.interval=this._config.defaultInterval||this._config.interval}_slide(t,e){const s=this._directionToOrder(t),n=g.findOne(ji,this._element),o=this._getItemIndex(n),r=e||this._getItemByOrder(s,n),a=this._getItemIndex(r),l=!!this._interval,c=s===ci,h=c?Zr:bm,d=c?vm:ym,u=this._orderToDirection(s),f=h===Zr?this._classes.slideLeft:this._classes.slideRight,p=h!==Zr?this._classes.slideLeft:this._classes.slideRight;if(r&&r.hasAttribute(ui)){this._isSliding=!1;return}if(this._isSliding||this._triggerSlideEvent(r,u).defaultPrevented||!n||!r)return;this._isSliding=!0,l&&this.pause(),this._setActiveIndicatorElement(r),this._activeElement=r;const m=()=>{b.trigger(this._element,Kc,{relatedTarget:r,direction:u,from:o,to:a})};if(this._element.hasAttribute(mm)){r.setAttribute(`${d}`,\"\"),r.classList.add(this._classes.block,p),Ii(r),n.setAttribute(`${h}`,\"\"),n.classList.add(f,...this._classes.invisible.split(\" \")),n.classList.remove(...this._classes.visible.split(\" \")),r.setAttribute(`${h}`,\"\"),r.classList.add(...this._classes.visible.split(\" \")),r.classList.remove(this._classes.slideRight,this._classes.slideLeft);const y=()=>{r.removeAttribute(h),r.removeAttribute(d),r.setAttribute(`${ui}`,\"\"),n.removeAttribute(ui),n.classList.remove(f,...this._classes.invisible.split(\" \"),this._classes.block),n.removeAttribute(d),n.removeAttribute(h),this._isSliding=!1,setTimeout(m,0)};this._queueCallback(y,n,!0)}else n.removeAttribute(ui),n.classList.remove(this._classes.block),r.setAttribute(`${ui}`,\"\"),r.classList.add(this._classes.block),this._isSliding=!1,m();l&&this.cycle()}_directionToOrder(t){return[ws,di].includes(t)?st()?t===di?hi:ci:t===di?ci:hi:t}_orderToDirection(t){return[ci,hi].includes(t)?st()?t===hi?di:ws:t===hi?ws:di:t}static carouselInterface(t,e){const s=ae.getOrCreateInstance(t,e);let{_config:n}=s;typeof e==\"object\"&&(n={...n,...e});const o=typeof e==\"string\"?e:n.slide;if(typeof e==\"number\")s.to(e);else if(typeof o==\"string\"){if(typeof s[o]>\"u\")throw new TypeError(`No method named \"${o}\"`);s[o]()}else n.interval&&n.carouselInit===null&&(s.pause(),s.cycle())}static jQueryInterface(t){return this.each(function(){ae.carouselInterface(this,t)})}static dataApiClickHandler(t){const e=Ie(this);if(!e||!e.hasAttribute(gm))return;const s={...v.getDataAttributes(e),...v.getDataAttributes(this)},n=this.getAttribute(\"data-te-slide-to\");n&&(s.interval=!1),ae.carouselInterface(e,s),n&&ae.getInstance(e).to(n),t.preventDefault()}}const Jr=\"modal\",Zt=\".te.modal\",Xc=\"Escape\",Gc={backdrop:!0,keyboard:!0,focus:!0},Dm={backdrop:\"(boolean|string)\",keyboard:\"boolean\",focus:\"boolean\"},Mm={show:\"transform-none\",static:\"scale-[1.02]\",staticProperties:\"transition-scale duration-300 ease-in-out\"},Im={show:\"string\",static:\"string\",staticProperties:\"string\"},Lm=`hide${Zt}`,Pm=`hidePrevented${Zt}`,Rm=`hidden${Zt}`,Nm=`show${Zt}`,$m=`shown${Zt}`,qc=`resize${Zt}`,Zc=`click.dismiss${Zt}`,Qc=`keydown.dismiss${Zt}`,Bm=`mouseup.dismiss${Zt}`,Jc=`mousedown.dismiss${Zt}`,th=\"data-te-modal-open\",eh=\"data-te-open\",ks=\"[data-te-modal-dialog-ref]\",Hm=\"[data-te-modal-body-ref]\";class Ss extends Xt{constructor(t,e,s){super(t),this._config=this._getConfig(e),this._classes=this._getClasses(s),this._dialog=g.findOne(ks,this._element),this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._isShown=!1,this._ignoreBackdropClick=!1,this._isTransitioning=!1,this._scrollBar=new Es,this._didInit=!1,this._init()}static get Default(){return Gc}static get NAME(){return Jr}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){this._isShown||this._isTransitioning||b.trigger(this._element,Nm,{relatedTarget:t}).defaultPrevented||(this._isShown=!0,this._isAnimated()&&(this._isTransitioning=!0),this._scrollBar.hide(),document.body.setAttribute(th,\"true\"),this._adjustDialog(),this._setEscapeEvent(),this._setResizeEvent(),b.on(this._dialog,Jc,()=>{b.one(this._element,Bm,s=>{s.target===this._element&&(this._ignoreBackdropClick=!0)})}),this._showElement(t),this._showBackdrop())}hide(){if(!this._isShown||this._isTransitioning||b.trigger(this._element,Lm).defaultPrevented)return;this._isShown=!1;const e=this._isAnimated();e&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),this._focustrap.disable(),g.findOne(ks,this._element).classList.remove(this._classes.show),b.off(this._element,Zc),b.off(this._dialog,Jc),this._queueCallback(()=>this._hideModal(),this._element,e),this._element.removeAttribute(eh)}dispose(){[window,this._dialog].forEach(t=>b.off(t,Zt)),this._backdrop.dispose(),this._focustrap.disable(),super.dispose()}handleUpdate(){this._adjustDialog()}_init(){this._didInit||(Wn(Ss),this._didInit=!0)}_initializeBackDrop(){return new Xr({isVisible:!!this._config.backdrop,isAnimated:this._isAnimated()})}_initializeFocusTrap(){return new Cs(this._element,{event:\"keydown\",condition:t=>t.key===\"Tab\"})}_getConfig(t){return t={...Gc,...v.getDataAttributes(this._element),...typeof t==\"object\"?t:{}},W(Jr,t,Dm),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Mm,...e,...t},W(Jr,t,Im),t}_showElement(t){const e=this._isAnimated(),s=g.findOne(Hm,this._dialog);(!this._element.parentNode||this._element.parentNode.nodeType!==Node.ELEMENT_NODE)&&document.body.append(this._element),this._element.style.display=\"block\",this._element.classList.remove(\"hidden\"),this._element.removeAttribute(\"aria-hidden\"),this._element.setAttribute(\"aria-modal\",!0),this._element.setAttribute(\"role\",\"dialog\"),this._element.setAttribute(`${eh}`,\"true\"),this._element.scrollTop=0;const n=g.findOne(ks,this._element);n.classList.add(this._classes.show),n.classList.remove(\"opacity-0\"),n.classList.add(\"opacity-100\"),s&&(s.scrollTop=0),e&&Ii(this._element);const o=()=>{this._config.focus&&this._focustrap.trap(),this._isTransitioning=!1,b.trigger(this._element,$m,{relatedTarget:t})};this._queueCallback(o,this._dialog,e)}_setEscapeEvent(){this._isShown?b.on(document,Qc,t=>{this._config.keyboard&&t.key===Xc?(t.preventDefault(),this.hide()):!this._config.keyboard&&t.key===Xc&&this._triggerBackdropTransition()}):b.off(this._element,Qc)}_setResizeEvent(){this._isShown?b.on(window,qc,()=>this._adjustDialog()):b.off(window,qc)}_hideModal(){const t=g.findOne(ks,this._element);t.classList.remove(this._classes.show),t.classList.remove(\"opacity-100\"),t.classList.add(\"opacity-0\"),setTimeout(()=>{this._element.style.display=\"none\"},300),this._element.setAttribute(\"aria-hidden\",!0),this._element.removeAttribute(\"aria-modal\"),this._element.removeAttribute(\"role\"),this._isTransitioning=!1,this._backdrop.hide(()=>{document.body.removeAttribute(th),this._resetAdjustments(),this._scrollBar.reset(),b.trigger(this._element,Rm)})}_showBackdrop(t){b.on(this._element,Zc,e=>{if(this._ignoreBackdropClick){this._ignoreBackdropClick=!1;return}e.target===e.currentTarget&&(this._config.backdrop===!0?this.hide():this._config.backdrop===\"static\"&&this._triggerBackdropTransition())}),this._backdrop.show(t)}_isAnimated(){return!!g.findOne(ks,this._element)}_triggerBackdropTransition(){if(b.trigger(this._element,Pm).defaultPrevented)return;const{classList:e,scrollHeight:s,style:n}=this._element,o=s>document.documentElement.clientHeight;!o&&n.overflowY===\"hidden\"||e.contains(this._classes.static)||(o||(n.overflowY=\"hidden\"),e.add(...this._classes.static.split(\" \")),e.add(...this._classes.staticProperties.split(\" \")),this._queueCallback(()=>{e.remove(this._classes.static),setTimeout(()=>{e.remove(...this._classes.staticProperties.split(\" \"))},300),o||this._queueCallback(()=>{n.overflowY=\"\"},this._dialog)},this._dialog),this._element.focus())}_adjustDialog(){const t=this._element.scrollHeight>document.documentElement.clientHeight,e=this._scrollBar.getWidth(),s=e>0;(!s&&t&&!st()||s&&!t&&st())&&(this._element.style.paddingLeft=`${e}px`),(s&&!t&&!st()||!s&&t&&st())&&(this._element.style.paddingRight=`${e}px`)}_resetAdjustments(){this._element.style.paddingLeft=\"\",this._element.style.paddingRight=\"\"}static jQueryInterface(t,e){return this.each(function(){const s=Ss.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof s[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);s[t](e)}})}}const Fm=new Set([\"background\",\"cite\",\"href\",\"itemtype\",\"longdesc\",\"poster\",\"src\",\"xlink:href\"]),Vm=/^aria-[\\w-]*$/i,Wm=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,zm=/^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,jm=(i,t)=>{const e=i.nodeName.toLowerCase();if(t.includes(e))return Fm.has(e)?!!(Wm.test(i.nodeValue)||zm.test(i.nodeValue)):!0;const s=t.filter(n=>n instanceof RegExp);for(let n=0,o=s.length;n<o;n++)if(s[n].test(e))return!0;return!1},Ym={\"*\":[\"class\",\"dir\",\"id\",\"lang\",\"role\",Vm],a:[\"target\",\"href\",\"title\",\"rel\"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:[\"src\",\"srcset\",\"alt\",\"title\",\"width\",\"height\"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]};function ih(i,t,e){if(!i.length)return i;if(e&&typeof e==\"function\")return e(i);const n=new window.DOMParser().parseFromString(i,\"text/html\"),o=[].concat(...n.body.querySelectorAll(\"*\"));for(let r=0,a=o.length;r<a;r++){const l=o[r],c=l.nodeName.toLowerCase();if(!Object.keys(t).includes(c)){l.remove();continue}const h=[].concat(...l.attributes),d=[].concat(t[\"*\"]||[],t[c]||[]);h.forEach(u=>{jm(u,d)||l.removeAttribute(u.nodeName)})}return n.body.innerHTML}const sh=\"tooltip\",le=\".te.tooltip\",Km=\"te-tooltip\",Um=new Set([\"sanitize\",\"allowList\",\"sanitizeFn\"]),Xm={animation:\"boolean\",template:\"string\",title:\"(string|element|function)\",trigger:\"string\",delay:\"(number|object)\",html:\"boolean\",selector:\"(string|boolean)\",placement:\"(string|function)\",offset:\"(array|string|function)\",container:\"(string|element|boolean)\",fallbackPlacements:\"array\",boundary:\"(string|element)\",customClass:\"(string|function)\",sanitize:\"boolean\",sanitizeFn:\"(null|function)\",allowList:\"object\",popperConfig:\"(null|object|function)\"},Gm={AUTO:\"auto\",TOP:\"top\",RIGHT:st()?\"left\":\"right\",BOTTOM:\"bottom\",LEFT:st()?\"right\":\"left\"},qm={animation:!0,template:'<div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\"><div data-te-tooltip-inner-ref class=\"tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div></div>',trigger:\"hover focus\",title:\"\",delay:0,html:!1,selector:!1,placement:\"top\",offset:[0,0],container:!1,fallbackPlacements:[\"top\",\"right\",\"bottom\",\"left\"],boundary:\"clippingParents\",customClass:\"\",sanitize:!0,sanitizeFn:null,allowList:Ym,popperConfig:{hide:!0}},Zm={HIDE:`hide${le}`,HIDDEN:`hidden${le}`,SHOW:`show${le}`,SHOWN:`shown${le}`,INSERTED:`inserted${le}`,CLICK:`click${le}`,FOCUSIN:`focusin${le}`,FOCUSOUT:`focusout${le}`,MOUSEENTER:`mouseenter${le}`,MOUSELEAVE:`mouseleave${le}`},Qm=\"fade\",Jm=\"modal\",ta=\"show\",Os=\"show\",ea=\"out\",nh=\".tooltip-inner\",oh=`.${Jm}`,rh=\"hide.te.modal\",Ds=\"hover\",ia=\"focus\",tb=\"click\",eb=\"manual\";let Ms=class jp extends Xt{constructor(t,e){if(typeof wc>\"u\")throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");super(t),this._isEnabled=!0,this._timeout=0,this._hoverState=\"\",this._activeTrigger={},this._popper=null,this._config=this._getConfig(e),this.tip=null,this._setListeners()}static get Default(){return qm}static get NAME(){return sh}static get Event(){return Zm}static get DefaultType(){return Xm}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}toggleEnabled(){this._isEnabled=!this._isEnabled}toggle(t){if(this._isEnabled)if(t){const e=this._initializeOnDelegatedTarget(t);e._activeTrigger.click=!e._activeTrigger.click,e._isWithActiveTrigger()?e._enter(null,e):e._leave(null,e)}else{if(this.getTipElement().classList.contains(ta)){this._leave(null,this);return}this._enter(null,this)}}dispose(){clearTimeout(this._timeout),b.off(this._element.closest(oh),rh,this._hideModalHandler),this.tip&&this.tip.remove(),this._disposePopper(),super.dispose()}show(){if(this._element.style.display===\"none\")throw new Error(\"Please use show on visible elements\");if(!(this.isWithContent()&&this._isEnabled))return;const t=b.trigger(this._element,this.constructor.Event.SHOW),e=Pl(this._element),s=e===null?this._element.ownerDocument.documentElement.contains(this._element):e.contains(this._element);if(t.defaultPrevented||!s)return;this.constructor.NAME===\"tooltip\"&&this.tip&&this.getTitle()!==this.tip.querySelector(nh).innerHTML&&(this._disposePopper(),this.tip.remove(),this.tip=null);const n=this.getTipElement(),o=se(this.constructor.NAME);n.setAttribute(\"id\",o),this._element.setAttribute(\"aria-describedby\",o),this._config.animation&&setTimeout(()=>{this.tip.classList.add(\"opacity-100\"),this.tip.classList.remove(\"opacity-0\")},100);const r=typeof this._config.placement==\"function\"?this._config.placement.call(this,n,this._element):this._config.placement,a=this._getAttachment(r);this._addAttachmentClass(a);const{container:l}=this._config;if(P.setData(n,this.constructor.DATA_KEY,this),this._element.ownerDocument.documentElement.contains(this.tip)||(l.append(n),b.trigger(this._element,this.constructor.Event.INSERTED)),this._popper?this._popper.update():this._popper=Fi(this._element,n,this._getPopperConfig(a)),n.getAttribute(\"id\").includes(\"tooltip\"))switch(r){case\"bottom\":n.classList.add(\"py-[0.4rem]\");break;case\"left\":n.classList.add(\"px-[0.4rem]\");break;case\"right\":n.classList.add(\"px-[0.4rem]\");break;default:n.classList.add(\"py-[0.4rem]\");break}const h=this._resolvePossibleFunction(this._config.customClass);h&&n.classList.add(...h.split(\" \")),\"ontouchstart\"in document.documentElement&&[].concat(...document.body.children).forEach(f=>{b.on(f,\"mouseover\",Sn)});const d=()=>{const f=this._hoverState;this._hoverState=null,b.trigger(this._element,this.constructor.Event.SHOWN),f===ea&&this._leave(null,this)},u=this.tip.classList.contains(\"transition-opacity\");this._queueCallback(d,this.tip,u)}hide(){if(!this._popper)return;const t=this.getTipElement(),e=()=>{this._isWithActiveTrigger()||(this._hoverState!==Os&&t.remove(),this._cleanTipClass(),this._element.removeAttribute(\"aria-describedby\"),b.trigger(this._element,this.constructor.Event.HIDDEN),this._disposePopper())};if(b.trigger(this._element,this.constructor.Event.HIDE).defaultPrevented)return;t.classList.add(\"opacity-0\"),t.classList.remove(\"opacity-100\"),\"ontouchstart\"in document.documentElement&&[].concat(...document.body.children).forEach(o=>b.off(o,\"mouseover\",Sn)),this._activeTrigger[tb]=!1,this._activeTrigger[ia]=!1,this._activeTrigger[Ds]=!1;const n=this.tip.classList.contains(\"opacity-0\");this._queueCallback(e,this.tip,n),this._hoverState=\"\"}update(){this._popper!==null&&this._popper.update()}isWithContent(){return!!this.getTitle()}getTipElement(){if(this.tip)return this.tip;const t=document.createElement(\"div\");t.innerHTML=this._config.template;const e=t.children[0];return this.setContent(e),e.classList.remove(Qm,ta),this.tip=e,this.tip}setContent(t){this._sanitizeAndSetContent(t,this.getTitle(),nh)}_sanitizeAndSetContent(t,e,s){const n=g.findOne(s,t);if(!e&&n){n.remove();return}this.setElementContent(n,e)}setElementContent(t,e){if(t!==null){if(Mi(e)){e=Le(e),this._config.html?e.parentNode!==t&&(t.innerHTML=\"\",t.append(e)):t.textContent=e.textContent;return}this._config.html?(this._config.sanitize&&(e=ih(e,this._config.allowList,this._config.sanitizeFn)),t.innerHTML=e):t.textContent=e}}getTitle(){const t=this._element.getAttribute(\"data-te-original-title\")||this._config.title;return this._resolvePossibleFunction(t)}updateAttachment(t){return t===\"right\"?\"end\":t===\"left\"?\"start\":t}_initializeOnDelegatedTarget(t,e){return e||this.constructor.getOrCreateInstance(t.delegateTarget,this._getDelegateConfig())}_getOffset(){const{offset:t}=this._config;return typeof t==\"string\"?t.split(\",\").map(e=>Number.parseInt(e,10)):typeof t==\"function\"?e=>t(e,this._element):t}_resolvePossibleFunction(t){return typeof t==\"function\"?t.call(this._element):t}_getPopperConfig(t){const e={placement:t,modifiers:[{name:\"flip\",options:{fallbackPlacements:this._config.fallbackPlacements}},{name:\"offset\",options:{offset:this._getOffset()}},{name:\"preventOverflow\",options:{boundary:this._config.boundary}},{name:\"arrow\",options:{element:`.${this.constructor.NAME}-arrow`}},{name:\"onChange\",enabled:!0,phase:\"afterWrite\",fn:s=>this._handlePopperPlacementChange(s)}],onFirstUpdate:s=>{s.options.placement!==s.placement&&this._handlePopperPlacementChange(s)}};return{...e,...typeof this._config.popperConfig==\"function\"?this._config.popperConfig(e):this._config.popperConfig}}_addAttachmentClass(t){this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`)}_getAttachment(t){return Gm[t.toUpperCase()]}_setListeners(){this._config.trigger.split(\" \").forEach(e=>{if(e===\"click\")b.on(this._element,this.constructor.Event.CLICK,this._config.selector,s=>this.toggle(s));else if(e!==eb){const s=e===Ds?this.constructor.Event.MOUSEENTER:this.constructor.Event.FOCUSIN,n=e===Ds?this.constructor.Event.MOUSELEAVE:this.constructor.Event.FOCUSOUT;b.on(this._element,s,this._config.selector,o=>this._enter(o)),b.on(this._element,n,this._config.selector,o=>this._leave(o))}}),this._hideModalHandler=()=>{this._element&&this.hide()},b.on(this._element.closest(oh),rh,this._hideModalHandler),this._config.selector?this._config={...this._config,trigger:\"manual\",selector:\"\"}:this._fixTitle()}_fixTitle(){const t=this._element.getAttribute(\"title\"),e=typeof this._element.getAttribute(\"data-te-original-title\");(t||e!==\"string\")&&(this._element.setAttribute(\"data-te-original-title\",t||\"\"),t&&!this._element.getAttribute(\"aria-label\")&&!this._element.textContent&&this._element.setAttribute(\"aria-label\",t),this._element.setAttribute(\"title\",\"\"))}_enter(t,e){if(e=this._initializeOnDelegatedTarget(t,e),t&&(e._activeTrigger[t.type===\"focusin\"?ia:Ds]=!0),e.getTipElement().classList.contains(ta)||e._hoverState===Os){e._hoverState=Os;return}if(clearTimeout(e._timeout),e._hoverState=Os,!e._config.delay||!e._config.delay.show){e.show();return}e._timeout=setTimeout(()=>{e._hoverState===Os&&e.show()},e._config.delay.show)}_leave(t,e){if(e=this._initializeOnDelegatedTarget(t,e),t&&(e._activeTrigger[t.type===\"focusout\"?ia:Ds]=e._element.contains(t.relatedTarget)),!e._isWithActiveTrigger()){if(clearTimeout(e._timeout),e._hoverState=ea,!e._config.delay||!e._config.delay.hide){e.hide();return}e._timeout=setTimeout(()=>{e._hoverState===ea&&e.hide()},e._config.delay.hide)}}_isWithActiveTrigger(){for(const t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1}_getConfig(t){const e=v.getDataAttributes(this._element);return Object.keys(e).forEach(s=>{Um.has(s)&&delete e[s]}),t={...this.constructor.Default,...e,...typeof t==\"object\"&&t?t:{}},t.container=t.container===!1?document.body:Le(t.container),typeof t.delay==\"number\"&&(t.delay={show:t.delay,hide:t.delay}),typeof t.title==\"number\"&&(t.title=t.title.toString()),typeof t.content==\"number\"&&(t.content=t.content.toString()),W(sh,t,this.constructor.DefaultType),t.sanitize&&(t.template=ih(t.template,t.allowList,t.sanitizeFn)),t}_getDelegateConfig(){const t={};for(const e in this._config)this.constructor.Default[e]!==this._config[e]&&(t[e]=this._config[e]);return t}_cleanTipClass(){const t=this.getTipElement(),e=new RegExp(`(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\"g\"),s=t.getAttribute(\"class\").match(e);s!==null&&s.length>0&&s.map(n=>n.trim()).forEach(n=>t.classList.remove(n))}_getBasicClassPrefix(){return Km}_handlePopperPlacementChange(t){const{state:e}=t;e&&(this.tip=e.elements.popper,this._cleanTipClass(),this._addAttachmentClass(this._getAttachment(e.placement)))}_disposePopper(){this._popper&&(this._popper.destroy(),this._popper=null)}static jQueryInterface(t){return this.each(function(){const e=jp.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t]()}})}};const ib=\"popover\",ce=\".te.popover\",sb=\"te-popover\",nb={...Ms.Default,placement:\"right\",offset:[0,8],trigger:\"click\",content:\"\",template:'<div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\"><h3 class=\"popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500\"></h3><div class=\"popover-body p-4 text-[#212529] dark:text-white\"></div></div>'},ob={...Ms.DefaultType,content:\"(string|element|function)\"},rb={HIDE:`hide${ce}`,HIDDEN:`hidden${ce}`,SHOW:`show${ce}`,SHOWN:`shown${ce}`,INSERTED:`inserted${ce}`,CLICK:`click${ce}`,FOCUSIN:`focusin${ce}`,FOCUSOUT:`focusout${ce}`,MOUSEENTER:`mouseenter${ce}`,MOUSELEAVE:`mouseleave${ce}`},ab=\".popover-header\",lb=\".popover-body\";class zn extends Ms{static get Default(){return nb}static get NAME(){return ib}static get Event(){return rb}static get DefaultType(){return ob}isWithContent(){return this.getTitle()||this._getContent()}setContent(t){this._sanitizeAndSetContent(t,this.getTitle(),ab),this._sanitizeAndSetContent(t,this._getContent(),lb)}_getContent(){return this._resolvePossibleFunction(this._config.content)}_getBasicClassPrefix(){return sb}static jQueryInterface(t){return this.each(function(){const e=zn.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t]()}})}}const sa=\"scrollspy\",jn=\".te.scrollspy\",cb=\".data-api\",ah={offset:10,method:\"auto\",target:\"\"},hb={offset:\"number\",method:\"string\",target:\"(string|element)\"},db={active:\"!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400\"},ub={active:\"string\"},fb=`activate${jn}`,pb=`scroll${jn}`,_b=`load${jn}${cb}`,na=\"data-te-nav-link-active\",lh=\"[data-te-dropdown-item-ref]\",gb='[data-te-spy=\"scroll\"]',mb=\"[data-te-nav-list-ref]\",oa=\"[data-te-nav-link-ref]\",bb=\"[data-te-nav-item-ref]\",ch=\"[data-te-list-group-item-ref]\",ra=`${oa}, ${ch}, ${lh}`,vb=\"[data-te-dropdown-ref]\",yb=\"[data-te-dropdown-toggle-ref]\",xb=\"offset\",hh=\"position\";class Is extends Xt{constructor(t,e,s){super(t),this._scrollElement=this._element.tagName===\"BODY\"?window:this._element,this._config=this._getConfig(e),this._classes=this._getClasses(s),this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,b.on(this._scrollElement,pb,()=>this._process()),this.refresh(),this._process(),this._didInit=!1,this._init()}static get Default(){return ah}static get NAME(){return sa}refresh(){const t=this._scrollElement===this._scrollElement.window?xb:hh,e=this._config.method===\"auto\"?t:this._config.method,s=e===hh?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),g.find(ra,this._config.target).map(o=>{const r=yr(o),a=r?g.findOne(r):null;if(a){const l=a.getBoundingClientRect();if(l.width||l.height)return[v[e](a).top+s,r]}return null}).filter(o=>o).sort((o,r)=>o[0]-r[0]).forEach(o=>{this._offsets.push(o[0]),this._targets.push(o[1])})}dispose(){b.off(this._scrollElement,jn),super.dispose()}_init(){this._didInit||(b.on(window,_b,()=>{g.find(gb).forEach(t=>new Is(t))}),this._didInit=!0)}_getConfig(t){return t={...ah,...v.getDataAttributes(this._element),...typeof t==\"object\"&&t?t:{}},t.target=Le(t.target)||document.documentElement,W(sa,t,hb),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...db,...e,...t},W(sa,t,ub),t}_getScrollTop(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop}_getScrollHeight(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)}_getOffsetHeight(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height}_process(){const t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),s=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),t>=s){const n=this._targets[this._targets.length-1];this._activeTarget!==n&&this._activate(n);return}if(this._activeTarget&&t<this._offsets[0]&&this._offsets[0]>0){this._activeTarget=null,this._clear();return}for(let n=this._offsets.length;n--;)this._activeTarget!==this._targets[n]&&t>=this._offsets[n]&&(typeof this._offsets[n+1]>\"u\"||t<this._offsets[n+1])&&this._activate(this._targets[n])}_activate(t){this._activeTarget=t,this._clear();const e=ra.split(\",\").map(n=>`${n}[data-te-target=\"${t}\"],${n}[href=\"${t}\"]`),s=g.findOne(e.join(\",\"),this._config.target);s.classList.add(...this._classes.active.split(\" \")),s.setAttribute(na,\"\"),s.getAttribute(lh)?g.findOne(yb,s.closest(vb)).classList.add(...this._classes.active.split(\" \")):g.parents(s,mb).forEach(n=>{g.prev(n,`${oa}, ${ch}`).forEach(o=>{o.classList.add(...this._classes.active.split(\" \")),o.setAttribute(na,\"\")}),g.prev(n,bb).forEach(o=>{g.children(o,oa).forEach(r=>r.classList.add(...this._classes.active.split(\" \")))})}),b.trigger(this._scrollElement,fb,{relatedTarget:t})}_clear(){g.find(ra,this._config.target).filter(t=>t.classList.contains(...this._classes.active.split(\" \"))).forEach(t=>{t.classList.remove(...this._classes.active.split(\" \")),t.removeAttribute(na)})}static jQueryInterface(t){return this.each(function(){const e=Is.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t]()}})}}const dh=\"tab\",Yn=\".te.tab\",Eb=`hide${Yn}`,Cb=`hidden${Yn}`,Tb=`show${Yn}`,Ab=`shown${Yn}`,wb=\"data-te-dropdown-menu-ref\",Yi=\"data-te-tab-active\",Kn=\"data-te-nav-active\",kb=\"[data-te-dropdown-ref]\",Sb=\"[data-te-nav-ref]\",uh=`[${Yi}]`,Ob=`[${Kn}]`,fh=\":scope > li > .active\",Db=\"[data-te-dropdown-toggle-ref]\",Mb=\":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]\",Ib={show:\"opacity-100\",hide:\"opacity-0\"},Lb={show:\"string\",hide:\"string\"};class Un extends Xt{constructor(t,e){super(t),this._classes=this._getClasses(e)}static get NAME(){return dh}show(){if(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&this._element.getAttribute(Kn)===\"\")return;let t;const e=Ie(this._element),s=this._element.closest(Sb),n=g.findOne(Ob,s);if(s){const l=s.nodeName===\"UL\"||s.nodeName===\"OL\"?fh:uh;t=g.find(l,s),t=t[t.length-1]}const o=t?b.trigger(t,Eb,{relatedTarget:this._element}):null;if(b.trigger(this._element,Tb,{relatedTarget:t}).defaultPrevented||o!==null&&o.defaultPrevented)return;this._activate(this._element,s,null,n,this._element);const a=()=>{b.trigger(t,Cb,{relatedTarget:this._element}),b.trigger(this._element,Ab,{relatedTarget:t})};e?this._activate(e,e.parentNode,a,n,this._element):a()}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Ib,...e,...t},W(dh,t,Lb),t}_activate(t,e,s,n,o){const a=(e&&(e.nodeName===\"UL\"||e.nodeName===\"OL\")?g.find(fh,e):g.children(e,uh))[0],l=s&&a&&a.hasAttribute(Yi),c=()=>this._transitionComplete(t,a,s,n,o);a&&l?(v.removeClass(a,this._classes.show),v.addClass(a,this._classes.hide),this._queueCallback(c,t,!0)):c()}_transitionComplete(t,e,s,n,o){if(e&&n){e.removeAttribute(Yi),n.removeAttribute(Kn);const a=g.findOne(Mb,e.parentNode);a&&a.removeAttribute(Yi),e.getAttribute(\"role\")===\"tab\"&&e.setAttribute(\"aria-selected\",!1)}t.setAttribute(Yi,\"\"),o.setAttribute(Kn,\"\"),t.getAttribute(\"role\")===\"tab\"&&t.setAttribute(\"aria-selected\",!0),Ii(t),t.classList.contains(this._classes.hide)&&(v.removeClass(t,this._classes.hide),v.addClass(t,this._classes.show));let r=t.parentNode;if(r&&r.nodeName===\"LI\"&&(r=r.parentNode),r&&r.hasAttribute(wb)){const a=t.closest(kb);a&&g.find(Db,a).forEach(l=>l.setAttribute(Yi,\"\")),t.setAttribute(\"aria-expanded\",!0)}s&&s()}static jQueryInterface(t){return this.each(function(){const e=Un.getOrCreateInstance(this);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t]()}})}}const aa=\"toast\",$e=\".te.toast\",Pb=`mouseover${$e}`,Rb=`mouseout${$e}`,Nb=`focusin${$e}`,$b=`focusout${$e}`,Bb=`hide${$e}`,Hb=`hidden${$e}`,Fb=`show${$e}`,Vb=`shown${$e}`,ph=\"data-te-toast-hide\",la=\"data-te-toast-show\",Xn=\"data-te-toast-showing\",Wb={animation:\"boolean\",autohide:\"boolean\",delay:\"number\"},_h={animation:!0,autohide:!0,delay:5e3},zb={fadeIn:\"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",fadeOut:\"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"},jb={fadeIn:\"string\",fadeOut:\"string\"};class Ls extends Xt{constructor(t,e,s){super(t),this._config=this._getConfig(e),this._classes=this._getClasses(s),this._timeout=null,this._hasMouseInteraction=!1,this._hasKeyboardInteraction=!1,this._setListeners(),this._didInit=!1,this._init()}static get DefaultType(){return Wb}static get Default(){return _h}static get NAME(){return aa}show(){if(b.trigger(this._element,Fb).defaultPrevented)return;this._clearTimeout(),this._config.animation&&(v.removeClass(this._element,this._classes.fadeOut),v.addClass(this._element,this._classes.fadeIn));const e=()=>{this._element.removeAttribute(Xn),b.trigger(this._element,Vb),this._maybeScheduleHide()};this._element.removeAttribute(ph),Ii(this._element),this._element.setAttribute(la,\"\"),this._element.setAttribute(Xn,\"\"),this._queueCallback(e,this._element,this._config.animation)}hide(){if(!this._element||this._element.dataset.teToastShow===void 0||b.trigger(this._element,Bb).defaultPrevented)return;const e=()=>{let s=0;this._config.animation&&(s=300,v.removeClass(this._element,this._classes.fadeIn),v.addClass(this._element,this._classes.fadeOut)),setTimeout(()=>{this._element.setAttribute(ph,\"\"),this._element.removeAttribute(Xn),this._element.removeAttribute(la),b.trigger(this._element,Hb)},s)};this._element.setAttribute(Xn,\"\"),this._queueCallback(e,this._element,this._config.animation)}dispose(){this._clearTimeout(),this._element.dataset.teToastShow!==void 0&&this._element.removeAttribute(la),super.dispose()}_init(){this._didInit||(Wn(Ls),this._didInit=!0)}_getConfig(t){return t={..._h,...v.getDataAttributes(this._element),...typeof t==\"object\"&&t?t:{}},W(aa,t,this.constructor.DefaultType),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...zb,...e,...t},W(aa,t,jb),t}_maybeScheduleHide(){this._config.autohide&&(this._hasMouseInteraction||this._hasKeyboardInteraction||(this._timeout=setTimeout(()=>{this.hide()},this._config.delay)))}_onInteraction(t,e){switch(t.type){case\"mouseover\":case\"mouseout\":this._hasMouseInteraction=e;break;case\"focusin\":case\"focusout\":this._hasKeyboardInteraction=e;break}if(e){this._clearTimeout();return}const s=t.relatedTarget;this._element===s||this._element.contains(s)||this._maybeScheduleHide()}_setListeners(){b.on(this._element,Pb,t=>this._onInteraction(t,!0)),b.on(this._element,Rb,t=>this._onInteraction(t,!1)),b.on(this._element,Nb,t=>this._onInteraction(t,!0)),b.on(this._element,$b,t=>this._onInteraction(t,!1))}_clearTimeout(){clearTimeout(this._timeout),this._timeout=null}static jQueryInterface(t){return this.each(function(){const e=Ls.getOrCreateInstance(this,t);if(typeof t==\"string\"){if(typeof e[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);e[t](this)}})}}(()=>{var i={454:(s,n,o)=>{o.d(n,{Z:()=>l});var r=o(645),a=o.n(r)()(function(c){return c[1]});a.push([s.id,\"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\",\"\"]);const l=a},645:s=>{s.exports=function(n){var o=[];return o.toString=function(){return this.map(function(r){var a=n(r);return r[2]?\"@media \".concat(r[2],\" {\").concat(a,\"}\"):a}).join(\"\")},o.i=function(r,a,l){typeof r==\"string\"&&(r=[[null,r,\"\"]]);var c={};if(l)for(var h=0;h<this.length;h++){var d=this[h][0];d!=null&&(c[d]=!0)}for(var u=0;u<r.length;u++){var f=[].concat(r[u]);l&&c[f[0]]||(a&&(f[2]?f[2]=\"\".concat(a,\" and \").concat(f[2]):f[2]=a),o.push(f))}},o}},810:()=>{(function(){if(typeof window<\"u\")try{var s=new window.CustomEvent(\"test\",{cancelable:!0});if(s.preventDefault(),s.defaultPrevented!==!0)throw new Error(\"Could not prevent default\")}catch{var n=function(r,a){var l,c;return(a=a||{}).bubbles=!!a.bubbles,a.cancelable=!!a.cancelable,(l=document.createEvent(\"CustomEvent\")).initCustomEvent(r,a.bubbles,a.cancelable,a.detail),c=l.preventDefault,l.preventDefault=function(){c.call(this);try{Object.defineProperty(this,\"defaultPrevented\",{get:function(){return!0}})}catch{this.defaultPrevented=!0}},l};n.prototype=window.Event.prototype,window.CustomEvent=n}})()},379:(s,n,o)=>{var r,a=function(){var E={};return function(C){if(E[C]===void 0){var T=document.querySelector(C);if(window.HTMLIFrameElement&&T instanceof window.HTMLIFrameElement)try{T=T.contentDocument.head}catch{T=null}E[C]=T}return E[C]}}(),l=[];function c(E){for(var C=-1,T=0;T<l.length;T++)if(l[T].identifier===E){C=T;break}return C}function h(E,C){for(var T={},A=[],w=0;w<E.length;w++){var S=E[w],k=C.base?S[0]+C.base:S[0],D=T[k]||0,O=\"\".concat(k,\" \").concat(D);T[k]=D+1;var M=c(O),L={css:S[1],media:S[2],sourceMap:S[3]};M!==-1?(l[M].references++,l[M].updater(L)):l.push({identifier:O,updater:x(L,C),references:1}),A.push(O)}return A}function d(E){var C=document.createElement(\"style\"),T=E.attributes||{};if(T.nonce===void 0){var A=o.nc;A&&(T.nonce=A)}if(Object.keys(T).forEach(function(S){C.setAttribute(S,T[S])}),typeof E.insert==\"function\")E.insert(C);else{var w=a(E.insert||\"head\");if(!w)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");w.appendChild(C)}return C}var u,f=(u=[],function(E,C){return u[E]=C,u.filter(Boolean).join(`\n`)});function p(E,C,T,A){var w=T?\"\":A.media?\"@media \".concat(A.media,\" {\").concat(A.css,\"}\"):A.css;if(E.styleSheet)E.styleSheet.cssText=f(C,w);else{var S=document.createTextNode(w),k=E.childNodes;k[C]&&E.removeChild(k[C]),k.length?E.insertBefore(S,k[C]):E.appendChild(S)}}function _(E,C,T){var A=T.css,w=T.media,S=T.sourceMap;if(w?E.setAttribute(\"media\",w):E.removeAttribute(\"media\"),S&&typeof btoa<\"u\"&&(A+=`\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(S)))),\" */\")),E.styleSheet)E.styleSheet.cssText=A;else{for(;E.firstChild;)E.removeChild(E.firstChild);E.appendChild(document.createTextNode(A))}}var m=null,y=0;function x(E,C){var T,A,w;if(C.singleton){var S=y++;T=m||(m=d(C)),A=p.bind(null,T,S,!1),w=p.bind(null,T,S,!0)}else T=d(C),A=_.bind(null,T,C),w=function(){(function(k){if(k.parentNode===null)return!1;k.parentNode.removeChild(k)})(T)};return A(E),function(k){if(k){if(k.css===E.css&&k.media===E.media&&k.sourceMap===E.sourceMap)return;A(E=k)}else w()}}s.exports=function(E,C){(C=C||{}).singleton||typeof C.singleton==\"boolean\"||(C.singleton=(r===void 0&&(r=!!(window&&document&&document.all&&!window.atob)),r));var T=h(E=E||[],C);return function(A){if(A=A||[],Object.prototype.toString.call(A)===\"[object Array]\"){for(var w=0;w<T.length;w++){var S=c(T[w]);l[S].references--}for(var k=h(A,C),D=0;D<T.length;D++){var O=c(T[D]);l[O].references===0&&(l[O].updater(),l.splice(O,1))}T=k}}}}},t={};function e(s){var n=t[s];if(n!==void 0)return n.exports;var o=t[s]={id:s,exports:{}};return i[s](o,o.exports,e),o.exports}e.n=s=>{var n=s&&s.__esModule?()=>s.default:()=>s;return e.d(n,{a:n}),n},e.d=(s,n)=>{for(var o in n)e.o(n,o)&&!e.o(s,o)&&Object.defineProperty(s,o,{enumerable:!0,get:n[o]})},e.o=(s,n)=>Object.prototype.hasOwnProperty.call(s,n),(()=>{var s=e(379),n=e.n(s),o=e(454);function r(l){if(!l.hasAttribute(\"autocompleted\")){l.setAttribute(\"autocompleted\",\"\");var c=new window.CustomEvent(\"onautocomplete\",{bubbles:!0,cancelable:!0,detail:null});l.dispatchEvent(c)||(l.value=\"\")}}function a(l){l.hasAttribute(\"autocompleted\")&&(l.removeAttribute(\"autocompleted\"),l.dispatchEvent(new window.CustomEvent(\"onautocomplete\",{bubbles:!0,cancelable:!1,detail:null})))}n()(o.Z,{insert:\"head\",singleton:!1}),o.Z.locals,e(810),document.addEventListener(\"animationstart\",function(l){l.animationName===\"onautofillstart\"?r(l.target):a(l.target)},!0),document.addEventListener(\"input\",function(l){l.inputType!==\"insertReplacementText\"&&\"data\"in l?a(l.target):r(l.target)},!0)})()})();const ca=\"input\",Gn=\"te.input\",gh=\"data-te-input-wrapper-init\",mh=\"data-te-input-notch-ref\",bh=\"data-te-input-notch-leading-ref\",vh=\"data-te-input-notch-middle-ref\",Yb=\"data-te-input-notch-trailing-ref\",Kb=\"data-te-input-helper-ref\",Ub=\"data-te-input-placeholder-active\",Be=\"data-te-input-state-active\",yh=\"data-te-input-focused\",xh=\"data-te-input-form-counter\",fi=`[${gh}] input`,pi=`[${gh}] textarea`,Ki=`[${mh}]`,Eh=`[${bh}]`,Ch=`[${vh}]`,Xb=`[${Kb}]`,Gb={inputFormWhite:!1},qb={inputFormWhite:\"(boolean)\"},Zb={notch:\"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",notchLeading:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0\",notchLeadingNormal:\"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",notchLeadingWhite:\"border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",notchMiddle:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent\",notchMiddleNormal:\"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",notchMiddleWhite:\"border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",notchTrailing:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0\",notchTrailingNormal:\"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",notchTrailingWhite:\"border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",counter:\"text-right leading-[1.6]\"},Qb={notch:\"string\",notchLeading:\"string\",notchLeadingNormal:\"string\",notchLeadingWhite:\"string\",notchMiddle:\"string\",notchMiddleNormal:\"string\",notchMiddleWhite:\"string\",notchTrailing:\"string\",notchTrailingNormal:\"string\",notchTrailingWhite:\"string\",counter:\"string\"};class Z{constructor(t,e,s){this._config=this._getConfig(e,t),this._element=t,this._classes=this._getClasses(s),this._label=null,this._labelWidth=0,this._labelMarginLeft=0,this._notchLeading=null,this._notchMiddle=null,this._notchTrailing=null,this._initiated=!1,this._helper=null,this._counter=!1,this._counterElement=null,this._maxLength=0,this._leadingIcon=null,this._element&&(P.setData(t,Gn,this),this.init())}static get NAME(){return ca}get input(){return g.findOne(\"input\",this._element)||g.findOne(\"textarea\",this._element)}init(){this._initiated||(this._getLabelData(),this._applyDivs(),this._applyNotch(),this._activate(),this._getHelper(),this._getCounter(),this._getEvents(),this._initiated=!0)}update(){this._getLabelData(),this._getNotchData(),this._applyNotch(),this._activate(),this._getHelper(),this._getCounter()}forceActive(){this.input.setAttribute(Be,\"\"),g.findOne(Ki,this.input.parentNode).setAttribute(Be,\"\")}forceInactive(){this.input.removeAttribute(Be),g.findOne(Ki,this.input.parentNode).removeAttribute(Be)}dispose(){this._removeBorder(),P.removeData(this._element,Gn),this._element=null}_getConfig(t,e){return t={...Gb,...v.getDataAttributes(e),...typeof t==\"object\"?t:{}},W(ca,t,qb),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Zb,...e,...t},W(ca,t,Qb),t}_getLabelData(){this._label=g.findOne(\"label\",this._element),this._label===null?this._showPlaceholder():(this._getLabelWidth(),this._getLabelPositionInInputGroup(),this._toggleDefaultDatePlaceholder())}_getHelper(){this._helper=g.findOne(Xb,this._element)}_getCounter(){this._counter=v.getDataAttribute(this.input,\"inputShowcounter\"),this._counter&&(this._maxLength=this.input.maxLength,this._showCounter())}_getEvents(){b.on(document,\"focus\",fi,Z.activate(new Z)),b.on(document,\"input\",fi,Z.activate(new Z)),b.on(document,\"blur\",fi,Z.deactivate(new Z)),b.on(document,\"focus\",pi,Z.activate(new Z)),b.on(document,\"input\",pi,Z.activate(new Z)),b.on(document,\"blur\",pi,Z.deactivate(new Z)),b.on(window,\"shown.te.modal\",t=>{g.find(fi,t.target).forEach(e=>{const s=Z.getInstance(e.parentNode);s&&s.update()}),g.find(pi,t.target).forEach(e=>{const s=Z.getInstance(e.parentNode);s&&s.update()})}),b.on(window,\"shown.te.dropdown\",t=>{const e=t.target.parentNode.querySelector(\"[data-te-dropdown-menu-ref]\");e&&(g.find(fi,e).forEach(s=>{const n=Z.getInstance(s.parentNode);n&&n.update()}),g.find(pi,e).forEach(s=>{const n=Z.getInstance(s.parentNode);n&&n.update()}))}),b.on(window,\"shown.te.tab\",t=>{let e;t.target.href?e=t.target.href.split(\"#\")[1]:e=v.getDataAttribute(t.target,\"target\").split(\"#\")[1];const s=g.findOne(`#${e}`);g.find(fi,s).forEach(n=>{const o=Z.getInstance(n.parentNode);o&&o.update()}),g.find(pi,s).forEach(n=>{const o=Z.getInstance(n.parentNode);o&&o.update()})}),b.on(window,\"reset\",t=>{g.find(fi,t.target).forEach(e=>{const s=Z.getInstance(e.parentNode);s&&s.forceInactive()}),g.find(pi,t.target).forEach(e=>{const s=Z.getInstance(e.parentNode);s&&s.forceInactive()})}),b.on(window,\"onautocomplete\",t=>{const e=Z.getInstance(t.target.parentNode);!e||!t.cancelable||e.forceActive()})}_showCounter(){if(g.find(`[${xh}]`,this._element).length>0)return;this._counterElement=document.createElement(\"div\"),v.addClass(this._counterElement,this._classes.counter),this._counterElement.setAttribute(xh,\"\");const e=this.input.value.length;this._counterElement.innerHTML=`${e} / ${this._maxLength}`,this._helper.appendChild(this._counterElement),this._bindCounter()}_bindCounter(){b.on(this.input,\"input\",()=>{const t=this.input.value.length;this._counterElement.innerHTML=`${t} / ${this._maxLength}`})}_toggleDefaultDatePlaceholder(t=this.input){if(!(t.getAttribute(\"type\")===\"date\"))return;!(document.activeElement===t)&&!t.value?t.style.opacity=0:t.style.opacity=1}_showPlaceholder(){this.input.setAttribute(Ub,\"\")}_getNotchData(){this._notchMiddle=g.findOne(Ch,this._element),this._notchLeading=g.findOne(Eh,this._element)}_getLabelWidth(){this._labelWidth=this._label.clientWidth*.8+8}_getLabelPositionInInputGroup(){if(this._labelMarginLeft=0,!this._element.hasAttribute(\"data-te-input-group-ref\"))return;const t=this.input,e=g.prev(t,\"[data-te-input-group-text-ref]\")[0];e===void 0?this._labelMarginLeft=0:this._labelMarginLeft=e.offsetWidth-1}_applyDivs(){const t=this._config.inputFormWhite?this._classes.notchLeadingWhite:this._classes.notchLeadingNormal,e=this._config.inputFormWhite?this._classes.notchMiddleWhite:this._classes.notchMiddleNormal,s=this._config.inputFormWhite?this._classes.notchTrailingWhite:this._classes.notchTrailingNormal,n=g.find(Ki,this._element),o=z(\"div\");v.addClass(o,this._classes.notch),o.setAttribute(mh,\"\"),this._notchLeading=z(\"div\"),v.addClass(this._notchLeading,`${this._classes.notchLeading} ${t}`),this._notchLeading.setAttribute(bh,\"\"),this._notchMiddle=z(\"div\"),v.addClass(this._notchMiddle,`${this._classes.notchMiddle} ${e}`),this._notchMiddle.setAttribute(vh,\"\"),this._notchTrailing=z(\"div\"),v.addClass(this._notchTrailing,`${this._classes.notchTrailing} ${s}`),this._notchTrailing.setAttribute(Yb,\"\"),!(n.length>=1)&&(o.append(this._notchLeading),o.append(this._notchMiddle),o.append(this._notchTrailing),this._element.append(o))}_applyNotch(){this._notchMiddle.style.width=`${this._labelWidth}px`,this._notchLeading.style.width=`${this._labelMarginLeft+9}px`,this._label!==null&&(this._label.style.marginLeft=`${this._labelMarginLeft}px`)}_removeBorder(){const t=g.findOne(Ki,this._element);t&&t.remove()}_activate(t){Nl(()=>{this._getElements(t);const e=t?t.target:this.input,s=g.findOne(Ki,this._element);t&&t.type===\"focus\"&&s.setAttribute(yh,\"\"),e.value!==\"\"&&(e.setAttribute(Be,\"\"),s.setAttribute(Be,\"\")),this._toggleDefaultDatePlaceholder(e)})}_getElements(t){if(t&&(this._element=t.target.parentNode,this._label=g.findOne(\"label\",this._element)),t&&this._label){const e=this._labelWidth;this._getLabelData(),e!==this._labelWidth&&(this._notchMiddle=g.findOne(Ch,t.target.parentNode),this._notchLeading=g.findOne(Eh,t.target.parentNode),this._applyNotch())}}_deactivate(t){const e=t?t.target:this.input,s=g.findOne(Ki,e.parentNode);s.removeAttribute(yh),e.value===\"\"&&(e.removeAttribute(Be),s.removeAttribute(Be)),this._toggleDefaultDatePlaceholder(e)}static activate(t){return function(e){t._activate(e)}}static deactivate(t){return function(e){t._deactivate(e)}}static jQueryInterface(t,e){return this.each(function(){let s=P.getData(this,Gn);const n=typeof t==\"object\"&&t;if(!(!s&&/dispose/.test(t))&&(s||(s=new Z(this,n)),typeof t==\"string\")){if(typeof s[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);s[t](e)}})}static getInstance(t){return P.getData(t,Gn)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const Th=\"animation\",ha=\"te.animation\",Jb={animation:\"string\",animationStart:\"string\",animationShowOnLoad:\"boolean\",onStart:\"(null|function)\",onEnd:\"(null|function)\",onHide:\"(null|function)\",onShow:\"(null|function)\",animationOnScroll:\"(string)\",animationWindowHeight:\"number\",animationOffset:\"(number|string)\",animationDelay:\"(number|string)\",animationReverse:\"boolean\",animationInterval:\"(number|string)\",animationRepeat:\"(number|boolean)\",animationReset:\"boolean\"},tv={animation:\"fade\",animationStart:\"onClick\",animationShowOnLoad:!0,onStart:null,onEnd:null,onHide:null,onShow:null,animationOnScroll:\"once\",animationWindowHeight:0,animationOffset:0,animationDelay:0,animationReverse:!1,animationInterval:0,animationRepeat:!1,animationReset:!1};class qn{constructor(t,e){this._element=t,this._animateElement=this._getAnimateElement(),this._isFirstScroll=!0,this._repeatAnimateOnScroll=!0,this._options=this._getConfig(e),this._element&&(P.setData(t,ha,this),this._init())}static get NAME(){return Th}init(){this._init()}startAnimation(){this._startAnimation()}stopAnimation(){this._clearAnimationClass()}changeAnimationType(t){this._options.animation=t}dispose(){b.off(this._element,\"mousedown\"),b.off(this._animateElement,\"animationend\"),b.off(window,\"scroll\"),b.off(this._element,\"mouseover\"),P.removeData(this._element,ha),this._element=null,this._animateElement=null,this._isFirstScroll=null,this._repeatAnimateOnScroll=null,this._options=null}_init(){switch(this._options.animationStart){case\"onHover\":this._bindHoverEvents();break;case\"onLoad\":this._startAnimation();break;case\"onScroll\":this._bindScrollEvents();break;case\"onClick\":this._bindClickEvents();break}this._bindTriggerOnEndCallback(),this._options.animationReset&&this._bindResetAnimationAfterFinish()}_getAnimateElement(){const t=v.getDataAttribute(this._element,\"animation-target\");return t?g.find(t)[0]:this._element}_getConfig(t){const e=v.getDataAttributes(this._animateElement);return t={...tv,...e,...t},W(Th,t,Jb),t}_animateOnScroll(){const t=v.offset(this._animateElement).top,e=this._animateElement.offsetHeight,s=window.innerHeight,n=t+this._options.animationOffset<=s&&t+this._options.animationOffset+e>=0,o=this._animateElement.style.visibility===\"visible\";switch(!0){case(n&&this._isFirstScroll):this._isFirstScroll=!1,this._startAnimation();break;case(!n&&this._isFirstScroll):this._isFirstScroll=!1,this._hideAnimateElement();break;case(n&&!o&&this._repeatAnimateOnScroll):this._options.animationOnScroll!==\"repeat\"&&(this._repeatAnimateOnScroll=!1),this._callback(this._options.onShow),this._showAnimateElement(),this._startAnimation();break;case(!n&&o&&this._repeatAnimateOnScroll):this._hideAnimateElement(),this._clearAnimationClass(),this._callback(this._options.onHide);break}}_addAnimatedClass(){v.addClass(this._animateElement,`animate-${this._options.animation}`)}_clearAnimationClass(){this._animateElement.classList.remove(`animate-${this._options.animation}`)}_startAnimation(){this._callback(this._options.onStart),this._addAnimatedClass(),this._options.animationRepeat&&!this._options.animationInterval&&this._setAnimationRepeat(),this._options.animationReverse&&this._setAnimationReverse(),this._options.animationDelay&&this._setAnimationDelay(),this._options.animationDuration&&this._setAnimationDuration(),this._options.animationInterval&&this._setAnimationInterval()}_setAnimationReverse(){v.style(this._animateElement,{animationIterationCount:this._options.animationRepeat===!0?\"infinite\":\"2\",animationDirection:\"alternate\"})}_setAnimationDuration(){v.style(this._animateElement,{animationDuration:`${this._options.animationDuration}ms`})}_setAnimationDelay(){v.style(this._animateElement,{animationDelay:`${this._options.animationDelay}ms`})}_setAnimationRepeat(){v.style(this._animateElement,{animationIterationCount:this._options.animationRepeat===!0?\"infinite\":this._options.animationRepeat})}_setAnimationInterval(){b.on(this._animateElement,\"click\",()=>{this._clearAnimationClass(),setTimeout(()=>{this._addAnimatedClass()},this._options.animationInterval)})}_hideAnimateElement(){v.style(this._animateElement,{visibility:\"hidden\"})}_showAnimateElement(){v.style(this._animateElement,{visibility:\"visible\"})}_bindResetAnimationAfterFinish(){b.on(this._animateElement,\"animationend\",()=>{this._clearAnimationClass()})}_bindTriggerOnEndCallback(){b.on(this._animateElement,\"animationend\",()=>{this._callback(this._options.onEnd)})}_bindScrollEvents(){this._options.animationShowOnLoad||this._animateOnScroll(),b.on(window,\"scroll\",()=>{this._animateOnScroll()})}_bindClickEvents(){b.on(this._element,\"mousedown\",()=>{this._startAnimation()})}_bindHoverEvents(){b.one(this._element,\"mouseover\",()=>{this._startAnimation()}),b.one(this._animateElement,\"animationend\",()=>{setTimeout(()=>{this._bindHoverEvents()},100)})}_callback(t){t instanceof Function&&t()}static autoInit(t){t._init()}static jQueryInterface(t){new qn(this[0],t).init()}static getInstance(t){return P.getData(t,ha)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const da=\"ripple\",Zn=\"te.ripple\",ev=\"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\",iv=[\"[data-te-ripple-init]\"],Qn=[0,0,0],sv=[{name:\"primary\",gradientColor:\"#3B71CA\"},{name:\"secondary\",gradientColor:\"#9FA6B2\"},{name:\"success\",gradientColor:\"#14A44D\"},{name:\"danger\",gradientColor:\"#DC4C64\"},{name:\"warning\",gradientColor:\"#E4A11B\"},{name:\"info\",gradientColor:\"#54B4D3\"},{name:\"light\",gradientColor:\"#fbfbfb\"},{name:\"dark\",gradientColor:\"#262626\"}],Ah=.5,nv={rippleCentered:!1,rippleColor:\"\",rippleColorDark:\"\",rippleDuration:\"500ms\",rippleRadius:0,rippleUnbound:!1},ov={rippleCentered:\"boolean\",rippleColor:\"string\",rippleColorDark:\"string\",rippleDuration:\"string\",rippleRadius:\"number\",rippleUnbound:\"boolean\"},rv={ripple:\"relative overflow-hidden inline-block align-bottom\",rippleWave:\"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",unbound:\"overflow-visible\"},av={ripple:\"string\",rippleWave:\"string\",unbound:\"string\"};class Ui{constructor(t,e,s){this._element=t,this._options=this._getConfig(e),this._classes=this._getClasses(s),this._element&&(P.setData(t,Zn,this),v.addClass(this._element,this._classes.ripple)),this._clickHandler=this._createRipple.bind(this),this._rippleTimer=null,this._isMinWidthSet=!1,this._initialClasses=null,this.init()}static get NAME(){return da}init(){this._addClickEvent(this._element)}dispose(){P.removeData(this._element,Zn),b.off(this._element,\"click\",this._clickHandler),this._element=null,this._options=null}_autoInit(t){iv.forEach(e=>{g.closest(t.target,e)&&(this._element=g.closest(t.target,e))}),this._element.style.minWidth||(v.style(this._element,{\"min-width\":getComputedStyle(this._element).width}),this._isMinWidthSet=!0),this._initialClasses=[...this._element.classList],v.addClass(this._element,this._classes.ripple),this._options=this._getConfig(),this._createRipple(t)}_addClickEvent(t){b.on(t,\"mousedown\",this._clickHandler)}_createRipple(t){this._element.className.indexOf(this._classes.ripple)<0&&v.addClass(this._element,this._classes.ripple);const{layerX:e,layerY:s}=t,n=e,o=s,r=this._element.offsetHeight,a=this._element.offsetWidth,l=this._durationToMsNumber(this._options.rippleDuration),c={offsetX:this._options.rippleCentered?r/2:n,offsetY:this._options.rippleCentered?a/2:o,height:r,width:a},h=this._getDiameter(c),d=this._options.rippleRadius||h/2,u={delay:l*Ah,duration:l-l*Ah},f={left:this._options.rippleCentered?`${a/2-d}px`:`${n-d}px`,top:this._options.rippleCentered?`${r/2-d}px`:`${o-d}px`,height:`${this._options.rippleRadius*2||h}px`,width:`${this._options.rippleRadius*2||h}px`,transitionDelay:`0s, ${u.delay}ms`,transitionDuration:`${l}ms, ${u.duration}ms`},p=z(\"div\");this._createHTMLRipple({wrapper:this._element,ripple:p,styles:f}),this._removeHTMLRipple({ripple:p,duration:l})}_createHTMLRipple({wrapper:t,ripple:e,styles:s}){Object.keys(s).forEach(n=>e.style[n]=s[n]),v.addClass(e,this._classes.rippleWave),e.setAttribute(\"data-te-ripple-ref\",\"\"),this._addColor(e,t),this._toggleUnbound(t),this._appendRipple(e,t)}_removeHTMLRipple({ripple:t,duration:e}){this._rippleTimer&&(clearTimeout(this._rippleTimer),this._rippleTimer=null),t&&setTimeout(()=>{t.classList.add(\"!opacity-0\")},10),this._rippleTimer=setTimeout(()=>{if(t&&(t.remove(),this._element)){g.find(\"[data-te-ripple-ref]\",this._element).forEach(n=>{n.remove()}),this._isMinWidthSet&&(v.style(this._element,{\"min-width\":\"\"}),this._isMinWidthSet=!1);const s=this._initialClasses?this._addedNewRippleClasses(this._classes.ripple,this._initialClasses):this._classes.ripple.split(\" \");v.removeClass(this._element,s)}},e)}_addedNewRippleClasses(t,e){return t.split(\" \").filter(s=>e.findIndex(n=>s===n)===-1)}_durationToMsNumber(t){return Number(t.replace(\"ms\",\"\").replace(\"s\",\"000\"))}_getConfig(t={}){const e=v.getDataAttributes(this._element);return t={...nv,...e,...t},W(da,t,ov),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...rv,...e,...t},W(da,t,av),t}_getDiameter({offsetX:t,offsetY:e,height:s,width:n}){const o=e<=s/2,r=t<=n/2,a=(u,f)=>Math.sqrt(u**2+f**2),l=e===s/2&&t===n/2,c={first:o===!0&&r===!1,second:o===!0&&r===!0,third:o===!1&&r===!0,fourth:o===!1&&r===!1},h={topLeft:a(t,e),topRight:a(n-t,e),bottomLeft:a(t,s-e),bottomRight:a(n-t,s-e)};let d=0;return l||c.fourth?d=h.topLeft:c.third?d=h.topRight:c.second?d=h.bottomRight:c.first&&(d=h.bottomLeft),d*2}_appendRipple(t,e){e.appendChild(t),setTimeout(()=>{v.addClass(t,\"opacity-0 scale-100\")},50)}_toggleUnbound(t){this._options.rippleUnbound===!0?v.addClass(t,this._classes.unbound):v.removeClass(t,this._classes.unbound)}_addColor(t){let e=this._options.rippleColor||\"rgb(0,0,0)\";(localStorage.theme===\"dark\"||!(\"theme\"in localStorage)&&window.matchMedia(\"(prefers-color-scheme: dark)\").matches)&&(e=this._options.rippleColorDark||this._options.rippleColor);const s=sv.find(r=>r.name===e.toLowerCase()),n=s?this._colorToRGB(s.gradientColor).join(\",\"):this._colorToRGB(e).join(\",\"),o=ev.split(\"{{color}}\").join(`${n}`);t.style.backgroundImage=`radial-gradient(circle, ${o})`}_colorToRGB(t){function e(o){return o.length<7&&(o=`#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`),[parseInt(o.substr(1,2),16),parseInt(o.substr(3,2),16),parseInt(o.substr(5,2),16)]}function s(o){const r=document.body.appendChild(document.createElement(\"fictum\")),a=\"rgb(1, 2, 3)\";return r.style.color=a,r.style.color!==a||(r.style.color=o,r.style.color===a||r.style.color===\"\")?Qn:(o=getComputedStyle(r).color,document.body.removeChild(r),o)}function n(o){return o=o.match(/[.\\d]+/g).map(r=>+Number(r)),o.length=3,o}return t.toLowerCase()===\"transparent\"?Qn:t[0]===\"#\"?e(t):(t.indexOf(\"rgb\")===-1&&(t=s(t)),t.indexOf(\"rgb\")===0?n(t):Qn)}static autoInitial(t){return function(e){t._autoInit(e)}}static jQueryInterface(t){return this.each(function(){return P.getData(this,Zn)?null:new Ui(this,t)})}static getInstance(t){return P.getData(t,Zn)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}function bt(i){return i.getDate()}function Jn(i){return i.getDay()}function ot(i){return i.getMonth()}function K(i){return i.getFullYear()}function lv(i,t,e){const s=e.startDay,n=s>0?7-s:0,r=new Date(i,t).getDay()+n;return r>=7?r-7:r}function ua(i){return cv(i).getDate()}function cv(i){return he(i.getFullYear(),i.getMonth()+1,0)}function Xi(){return new Date}function Et(i,t){return Ct(i,t*12)}function Ct(i,t){const e=he(i.getFullYear(),i.getMonth()+t,i.getDate()),s=bt(i),n=bt(e);return s!==n&&e.setDate(0),e}function Gi(i,t){return he(i.getFullYear(),i.getMonth(),i.getDate()+t)}function he(i,t,e){const s=new Date(i,t,e);return i>=0&&i<100&&s.setFullYear(s.getFullYear()-1900),s}function wh(i){const t=i.split(\"-\"),e=t[0],s=t[1],n=t[2];return he(e,s,n)}function hv(i){return!Number.isNaN(i.getTime())}function qi(i,t){return K(i)-K(t)||ot(i)-ot(t)||bt(i)-bt(t)}function _i(i,t){return i.setHours(0,0,0,0),t.setHours(0,0,0,0),i.getTime()===t.getTime()}function to(i,t){const s=K(i)-uv();return dv(s,t)}function dv(i,t){return(i%t+t)%t}function uv(i,t,e){let s=0;return e?s=K(e)-i+1:t&&(s=K(t)),s}function eo(i,t,e,s,n,o){const r=new Date;r.setHours(0,0,0,0);const a=t&&qi(i,t)<=-1,l=e&&qi(i,e)>=1,c=n&&qi(i,r)<=-1,h=o&&qi(i,r)>=1,d=s&&s(i)===!1;return a||l||d||c||h}function kh(i,t,e,s,n,o){const r=new Date,a=s&&K(s),l=s&&ot(s),c=e&&K(e),h=e&&ot(e),d=K(r),u=ot(r),f=l&&a&&(t>a||t===a&&i>l),p=h&&c&&(t<c||t===c&&i<h),_=n&&(t<d||t===d&&i<u),m=o&&(t>d||t===d&&i>u);return f||p||_||m}function fa(i,t,e,s,n){const o=t&&K(t),r=e&&K(e),a=K(new Date),l=r&&i>r,c=o&&i<o,h=s&&i<a,d=n&&i>a;return l||c||h||d}function fv(i,t,e,s,n,o,r,a){const l=new Date;return l.setHours(0,0,0,0),(i&&o&&qi(o,l)<0||i)&&(o=l),o&&Ps(t,o,e,s,n,o,r,a)}function pv(i,t,e,s,n,o,r,a){const l=new Date;return l.setHours(0,0,0,0),(i&&n&&qi(n,l)<0||i)&&(n=l),n&&Ps(t,n,e,s,n,o,r,a)}function Ps(i,t,e,s,n,o,r,a){return e===\"days\"?K(i)===K(t)&&ot(i)===ot(t):e===\"months\"?K(i)===K(t):e===\"years\"?K(t)>=a&&K(t)<=r:!1}const _v=\"data-te-datepicker-modal-container-ref\",gv=\"data-te-datepicker-dropdown-container-ref\",mv=\"data-te-dropdown-backdrop-ref\",bv=\"data-te-datepicker-date-text-ref\",Sh=\"data-te-datepicker-view-ref\",vv=\"data-te-datepicker-previous-button-ref\",yv=\"data-te-datepicker-next-button-ref\",xv=\"data-te-datepicker-ok-button-ref\",Ev=\"data-te-datepicker-cancel-button-ref\",Cv=\"data-te-datepicker-clear-button-ref\",Tv=\"data-te-datepicker-view-change-button-ref\";function Av(i,t,e,s,n,o,r,a,l,c){const h=ot(i),d=K(i),u=bt(i),f=Jn(i),p=z(\"div\"),_=`\n        ${Oh(i,h,d,t,e,s,n,o,r,a,c)}\n    `,m=`\n      ${kv(u,f,h,n,c)}\n      ${Oh(i,h,d,t,e,s,n,o,r,a,c)}\n    `;return n.inline?(v.addClass(p,c.datepickerDropdownContainer),p.setAttribute(gv,l),p.innerHTML=_):(v.addClass(p,c.modalContainer),p.setAttribute(_v,l),p.innerHTML=m),p}function wv(i){const t=z(\"div\");return v.addClass(t,i),t.setAttribute(mv,\"\"),t}function kv(i,t,e,s,n){return`\n      <div class=\"${n.datepickerHeader}\">\n        <div class=\"${n.datepickerTitle}\">\n          <span class=\"${n.datepickerTitleText}\">${s.title}</span>\n        </div>\n        <div class=\"${n.datepickerDate}\">\n          <span class=\"${n.datepickerDateText}\" ${bv} >${s.weekdaysShort[t]}, ${s.monthsShort[e]} ${i}</span>\n        </div>\n      </div>\n    `}function Oh(i,t,e,s,n,o,r,a,l,c,h){let d;return r.inline?d=`\n    <div class=\"${h.datepickerMain}\">\n      ${Mh(t,e,r,h)}\n      <div class=\"${h.datepickerView}\" ${Sh} tabindex=\"0\">\n        ${Dh(i,e,s,n,o,r,a,l,c,h)}\n      </div>\n    </div>\n  `:d=`\n    <div class=\"${h.datepickerMain}\">\n      ${Mh(t,e,r,h)}\n      <div class=\"${h.datepickerView}\" ${Sh} tabindex=\"0\">\n        ${Dh(i,e,s,n,o,r,a,l,c,h)}\n      </div>\n      ${Sv(r,h)}\n    </div>\n  `,d}function Dh(i,t,e,s,n,o,r,a,l,c){let h;return o.view===\"days\"?h=io(i,e,o,c):o.view===\"months\"?h=so(t,s,n,o,r,c):h=no(i,s,o,a,l,c),h}function Mh(i,t,e,s){return`\n    <div class=\"${s.datepickerDateControls}\">\n      <button class=\"${s.datepickerViewChangeButton}\" aria-label=\"${e.switchToMultiYearViewLabel}\" ${Tv}>\n        ${e.monthsFull[i]} ${t} ${de(e,s)}\n      </button>\n      <div class=\"${s.datepickerArrowControls}\">\n        <button class=\"${s.datepickerPreviousButton}\" aria-label=\"${e.prevMonthLabel}\" ${vv}>${e.changeMonthIconTemplate}</button>\n        <button class=\"${s.datepickerNextButton}\" aria-label=\"${e.nextMonthLabel}\" ${yv}>${e.changeMonthIconTemplate}</button>\n      </div>\n    </div>\n    `}function de(i,t){return`\n  <span class=\"${t.datepickerViewChangeIcon}\">\n  ${i.viewChangeIconTemplate}\n  </span>\n  `}function Sv(i,t){const e=`<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${i.okBtnLabel}\" ${xv}>${i.okBtnText}</button>`,s=`<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${i.cancelBtnLabel}\" ${Ev}>${i.cancelBtnText}</button>`,n=`<button class=\"${t.datepickerFooterBtn} ${t.datepickerClearBtn}\" aria-label=\"${i.clearBtnLabel}\" ${Cv}>${i.clearBtnText}</button>`;return`\n        <div class=\"${t.datepickerFooter}\">\n          \n        ${i.removeClearBtn?\"\":n}\n        ${i.removeCancelBtn?\"\":s}\n        ${i.removeOkBtn?\"\":e}\n        </div>\n      `}function io(i,t,e,s){const n=Ov(i,t,e),r=`\n      <tr>\n        ${e.weekdaysNarrow.map((l,c)=>`<th class=\"${s.datepickerDayHeading}\" scope=\"col\" aria-label=\"${e.weekdaysFull[c]}\">${l}</th>`).join(\"\")}\n      </tr>\n    `,a=n.map(l=>`\n        <tr>\n          ${l.map(c=>`\n              <td\n              class=\"${s.datepickerCell} ${s.datepickerCellSmall}\"\n              data-te-date=\"${K(c.date)}-${ot(c.date)}-${bt(c.date)}\"\n              aria-label=\"${c.date}\"\n              aria-selected=\"${c.isSelected}\"\n              ${c.isSelected?\"data-te-datepicker-cell-selected\":\"\"}\n              ${!c.currentMonth||c.disabled?\"data-te-datepicker-cell-disabled\":\"\"}\n              ${c.isToday?\"data-te-datepicker-cell-current\":\"\"}\n              >\n                <div\n                  class=\"${s.datepickerCellContent} ${s.datepickerCellContentSmall}\"\n                  style=\"${c.currentMonth?\"display: block\":\"display: none\"}\"\n                  >\n                  ${c.dayNumber}\n                  </div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\");return`\n      <table class=\"${s.datepickerTable}\">\n        <thead>\n          ${r}\n        </thead>\n        <tbody>\n         ${a}\n        </tbody>\n      </table>\n    `}function Ov(i,t,e){const s=[],n=ot(i),o=ot(Ct(i,-1)),r=ot(Ct(i,1)),a=K(i),l=lv(a,n,e),c=ua(i),h=ua(Ct(i,-1)),d=7;let u=1,f=!1;for(let p=1;p<d;p++){const _=[];if(p===1){const m=h-l+1;for(let x=m;x<=h;x++){const E=he(a,o,x);_.push({date:E,currentMonth:f,isSelected:t&&_i(E,t),isToday:_i(E,Xi()),dayNumber:bt(E)})}f=!0;const y=d-_.length;for(let x=0;x<y;x++){const E=he(a,n,u);_.push({date:E,currentMonth:f,isSelected:t&&_i(E,t),isToday:_i(E,Xi()),dayNumber:bt(E),disabled:eo(E,e.min,e.max,e.filter,e.disablePast,e.disableFuture)}),u++}}else for(let m=1;m<8;m++){u>c&&(u=1,f=!1);const y=he(a,f?n:r,u);_.push({date:y,currentMonth:f,isSelected:t&&_i(y,t),isToday:_i(y,Xi()),dayNumber:bt(y),disabled:eo(y,e.min,e.max,e.filter,e.disablePast,e.disableFuture)}),u++}s.push(_)}return s}function so(i,t,e,s,n,o){const r=Dv(s,n),a=ot(Xi()),l=K(Xi()),c=`\n      ${r.map(h=>`\n          <tr>\n            ${h.map(d=>{const u=s.monthsShort.indexOf(d);return`\n                <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"\n                ${kh(u,i,s.min,s.max,s.disablePast,s.disableFuture)?\"data-te-datepicker-cell-disabled\":\"\"}\n                \n                data-te-month=\"${u}\" data-te-year=\"${i}\" aria-label=\"${d}, ${i}\"\n                ${u===e&&i===t?\"data-te-datepicker-cell-selected\":\"\"}\n                ${u===a&&i===l?\"data-te-datepicker-cell-current\":\"\"}\" data-te-month=\"${u}\" data-te-year=\"${i}\" aria-label=\"${d}, ${i}\">\n                  <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${d}</div>\n                </td>\n              `}).join(\"\")}\n          </tr>\n        `).join(\"\")}\n    `;return`\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n         ${c}\n        </tbody>\n      </table>\n    `}function Dv(i,t){const e=[];let s=[];for(let n=0;n<i.monthsShort.length;n++)if(s.push(i.monthsShort[n]),s.length===t){const o=s;e.push(o),s=[]}return e}function no(i,t,e,s,n,o){const r=Mv(i,s,n),a=K(Xi()),l=`\n    ${r.map(c=>`\n        <tr>\n          ${c.map(h=>`\n              <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"  aria-label=\"${h}\" data-te-year=\"${h}\"\n              ${fa(h,e.min,e.max,e.disablePast,e.disableFuture)?\"data-te-datepicker-cell-disabled\":\"\"}\n              ${h===t?\"data-te-datepicker-cell-selected\":\"\"}\n              ${h===a?\"data-te-datepicker-cell-current\":\"\"}\n              >\n                <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${h}</div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\")}\n  `;return`\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n        ${l}\n        </tbody>\n      </table>\n    `}function Mv(i,t,e){const s=[],n=K(i),o=to(i,t),r=n-o;let a=[];for(let l=0;l<t;l++)if(a.push(r+l),a.length===e){const c=a;s.push(c),a=[]}return s}function Iv(i,t){return`\n    <button id=\"${i}\" type=\"button\" class=\"${t}\" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n      </svg>  \n    </button>\n  `}const Zi=37,Tt=38,Qi=39,ut=40,Ji=36,ts=35,pa=33,_a=34,Pt=13,oo=32,ro=27,Rs=9,Lv=8,Pv=46,Qt=24,ao=4,lo=4,ga=\"datepicker\",co=\"te.datepicker\",ho=`.${co}`,Rv=\".data-api\",Nv=`close${ho}`,$v=`open${ho}`,Bv=`dateChange${ho}`,uo=`click${ho}${Rv}`,Ih=\"data-te-datepicker-modal-container-ref\",Lh=\"data-te-datepicker-dropdown-container-ref\",fo=\"[data-te-datepicker-toggle-ref]\",Hv=`[${Ih}]`,Fv=`[${Lh}]`,Vv=\"[data-te-datepicker-view-change-button-ref]\",Wv=\"[data-te-datepicker-previous-button-ref]\",zv=\"[data-te-datepicker-next-button-ref]\",jv=\"[data-te-datepicker-ok-button-ref]\",Yv=\"[data-te-datepicker-cancel-button-ref]\",Kv=\"[data-te-datepicker-clear-button-ref]\",Uv=\"[data-te-datepicker-view-ref]\",Xv=\"[data-te-datepicker-toggle-button-ref]\",Gv=\"[data-te-datepicker-date-text-ref]\",qv=\"[data-te-dropdown-backdrop-ref]\",Zv=\"animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\",Qv=\"animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\",Jv=\"animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\",t0=\"animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\",e0=\"flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700\",i0=\"w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]\",s0=\"relative h-full\",n0=\"xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800\",o0=\"h-8 flex flex-col justify-end\",r0=\"text-[10px] font-normal uppercase tracking-[1.7px] text-white\",a0=\"xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end\",l0=\"text-[34px] font-normal text-white\",c0=\"outline-none px-3\",h0=\"px-3 pt-2.5 pb-0 flex justify-between text-black/[64]\",d0=\"flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\",u0=\"mt-2.5\",f0=\"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto\",p0=\"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto\",_0=\"h-14 flex absolute w-full bottom-0 justify-end items-center px-3\",g0=\"outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\",m0=\"mr-auto\",b0=\"w-10 h-10 text-center text-[12px] font-normal dark:text-white\",v0=\"text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group\",y0=\"w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8\",x0=\"w-[76px] h-[42px]\",E0=\"mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500\",C0=\"w-9 h-9 leading-9 rounded-[50%] text-[13px]\",T0=\"w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]\",A0=\"mx-auto w-[304px]\",w0=\"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\",k0=\"inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white\",S0=\"w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700\",O0={title:\"Select date\",container:\"body\",disablePast:!1,disableFuture:!1,monthsFull:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],monthsShort:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],weekdaysFull:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],weekdaysShort:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],weekdaysNarrow:[\"S\",\"M\",\"T\",\"W\",\"T\",\"F\",\"S\"],okBtnText:\"Ok\",clearBtnText:\"Clear\",cancelBtnText:\"Cancel\",okBtnLabel:\"Confirm selection\",clearBtnLabel:\"Clear selection\",cancelBtnLabel:\"Cancel selection\",nextMonthLabel:\"Next month\",prevMonthLabel:\"Previous month\",nextYearLabel:\"Next year\",prevYearLabel:\"Previous year\",changeMonthIconTemplate:`<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n  </svg>\n  `,nextMultiYearLabel:\"Next 24 years\",prevMultiYearLabel:\"Previous 24 years\",switchToMultiYearViewLabel:\"Choose year and month\",switchToMonthViewLabel:\"Choose date\",switchToDayViewLabel:\"Choose date\",startDate:null,startDay:0,format:\"dd/mm/yyyy\",view:\"days\",viewChangeIconTemplate:`<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"0\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n  </svg>\n  `,min:null,max:null,filter:null,inline:!1,toggleButton:!0,disableToggleButton:!1,disableInput:!1,animations:!0,confirmDateOnSelect:!1,removeOkBtn:!1,removeCancelBtn:!1,removeClearBtn:!1},D0={title:\"string\",container:\"string\",disablePast:\"boolean\",disableFuture:\"boolean\",monthsFull:\"array\",monthsShort:\"array\",weekdaysFull:\"array\",weekdaysShort:\"array\",weekdaysNarrow:\"array\",okBtnText:\"string\",clearBtnText:\"string\",cancelBtnText:\"string\",okBtnLabel:\"string\",clearBtnLabel:\"string\",cancelBtnLabel:\"string\",nextMonthLabel:\"string\",prevMonthLabel:\"string\",nextYearLabel:\"string\",prevYearLabel:\"string\",nextMultiYearLabel:\"string\",prevMultiYearLabel:\"string\",changeMonthIconTemplate:\"string\",switchToMultiYearViewLabel:\"string\",switchToMonthViewLabel:\"string\",switchToDayViewLabel:\"string\",startDate:\"(null|string|date)\",startDay:\"number\",format:\"string\",view:\"string\",viewChangeIconTemplate:\"string\",min:\"(null|string|date)\",max:\"(null|string|date)\",filter:\"(null|function)\",inline:\"boolean\",toggleButton:\"boolean\",disableToggleButton:\"boolean\",disableInput:\"boolean\",animations:\"boolean\",confirmDateOnSelect:\"boolean\",removeOkBtn:\"boolean\",removeCancelBtn:\"boolean\",removeClearBtn:\"boolean\"},M0={fadeIn:Zv,fadeOut:Qv,fadeInShort:Jv,fadeOutShort:t0,modalContainer:e0,datepickerBackdrop:i0,datepickerMain:s0,datepickerHeader:n0,datepickerTitle:o0,datepickerTitleText:r0,datepickerDate:a0,datepickerDateText:l0,datepickerView:c0,datepickerDateControls:h0,datepickerViewChangeButton:d0,datepickerViewChangeIcon:k0,datepickerArrowControls:u0,datepickerPreviousButton:f0,datepickerNextButton:p0,datepickerFooter:_0,datepickerFooterBtn:g0,datepickerClearBtn:m0,datepickerDayHeading:b0,datepickerCell:v0,datepickerCellSmall:y0,datepickerCellLarge:x0,datepickerCellContent:E0,datepickerCellContentSmall:C0,datepickerCellContentLarge:T0,datepickerTable:A0,datepickerToggleButton:w0,datepickerDropdownContainer:S0},I0={fadeIn:\"string\",fadeOut:\"string\",fadeInShort:\"string\",fadeOutShort:\"string\",modalContainer:\"string\",datepickerBackdrop:\"string\",datepickerMain:\"string\",datepickerHeader:\"string\",datepickerTitle:\"string\",datepickerTitleText:\"string\",datepickerDate:\"string\",datepickerDateText:\"string\",datepickerView:\"string\",datepickerDateControls:\"string\",datepickerViewChangeButton:\"string\",datepickerArrowControls:\"string\",datepickerPreviousButton:\"string\",datepickerNextButton:\"string\",datepickerFooter:\"string\",datepickerFooterBtn:\"string\",datepickerClearBtn:\"string\",datepickerDayHeading:\"string\",datepickerCell:\"string\",datepickerCellSmall:\"string\",datepickerCellLarge:\"string\",datepickerCellContent:\"string\",datepickerCellContentSmall:\"string\",datepickerCellContentLarge:\"string\",datepickerTable:\"string\",datepickerToggleButton:\"string\",datepickerDropdownContainer:\"string\"};class Ph{constructor(t,e,s){this._element=t,this._input=g.findOne(\"input\",this._element),this._options=this._getConfig(e),this._classes=this._getClasses(s),this._activeDate=new Date,this._selectedDate=null,this._selectedYear=null,this._selectedMonth=null,this._headerDate=null,this._headerYear=null,this._headerMonth=null,this._view=this._options.view,this._popper=null,this._focusTrap=null,this._isOpen=!1,this._toggleButtonId=se(\"datepicker-toggle-\"),this._animations=!window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches&&this._options.animations,this._scrollBar=new Es,this._element&&P.setData(t,co,this),this._init(),this.toggleButton&&this._options.disableToggle&&(this.toggleButton.disabled=\"true\"),this._options.disableInput&&(this._input.disabled=\"true\")}static get NAME(){return ga}get container(){return g.findOne(`[${Ih}='${this._toggleButtonId}']`)||g.findOne(`[${Lh}='${this._toggleButtonId}']`)}get options(){return this._options}get activeCell(){let t;return this._view===\"days\"&&(t=this._getActiveDayCell()),this._view===\"months\"&&(t=this._getActiveMonthCell()),this._view===\"years\"&&(t=this._getActiveYearCell()),t}get activeDay(){return bt(this._activeDate)}get activeMonth(){return ot(this._activeDate)}get activeYear(){return K(this._activeDate)}get firstYearInView(){return this.activeYear-to(this._activeDate,Qt)}get lastYearInView(){return this.firstYearInView+Qt-1}get viewChangeButton(){return g.findOne(Vv,this.container)}get previousButton(){return g.findOne(Wv,this.container)}get nextButton(){return g.findOne(zv,this.container)}get okButton(){return g.findOne(jv,this.container)}get cancelButton(){return g.findOne(Yv,this.container)}get clearButton(){return g.findOne(Kv,this.container)}get datesContainer(){return g.findOne(Uv,this.container)}get toggleButton(){return g.findOne(Xv,this._element)}update(t={}){this._options=this._getConfig({...this._options,...t})}_getConfig(t){const e=v.getDataAttributes(this._element);if(t={...O0,...e,...t},W(ga,t,D0),t.max&&typeof t.max==\"string\"&&(t.max=new Date(t.max)),t.min&&typeof t.min==\"string\"&&(t.min=new Date(t.min)),t.startDay&&t.startDay!==0){const s=this._getNewDaysOrderArray(t);t.weekdaysNarrow=s}return t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...M0,...e,...t},W(ga,t,I0),t}_getContainer(){return g.findOne(this._options.container)}_getNewDaysOrderArray(t){const e=t.startDay,s=t.weekdaysNarrow;return s.slice(e).concat(s.slice(0,e))}_init(){!this.toggleButton&&this._options.toggleButton&&(this._appendToggleButton(),(this._input.readOnly||this._input.disabled)&&(this.toggleButton.style.pointerEvents=\"none\")),this._listenToUserInput(),this._listenToToggleClick(),this._listenToToggleKeydown()}_appendToggleButton(){const t=Iv(this._toggleButtonId,this._classes.datepickerToggleButton);this._element.insertAdjacentHTML(\"beforeend\",t)}open(){if(this._input.readOnly||this._input.disabled)return;const t=b.trigger(this._element,$v);if(this._isOpen||t.defaultPrevented)return;this._setInitialDate();const e=wv(this._classes.datepickerBackdrop),s=Av(this._activeDate,this._selectedDate,this._selectedYear,this._selectedMonth,this._options,lo,Qt,ao,this._toggleButtonId,this._classes);this._options.inline?this._openDropdown(s):(this._openModal(e,s),this._scrollBar.hide()),this._animations&&(v.addClass(this.container,this._classes.fadeIn),v.addClass(e,this._classes.fadeInShort)),this._setFocusTrap(this.container),this._listenToDateSelection(),this._addControlsListeners(),this._updateControlsDisabledState(),this._listenToEscapeClick(),this._listenToKeyboardNavigation(),this._listenToDatesContainerFocus(),this._listenToDatesContainerBlur(),this._asyncFocusDatesContainer(),this._updateViewControlsAndAttributes(this._view),this._isOpen=!0,setTimeout(()=>{this._listenToOutsideClick()},0)}_openDropdown(t){this._popper=Fi(this._input,t,{placement:\"bottom-start\"}),this._getContainer().appendChild(t)}_openModal(t,e){const s=this._getContainer();s.appendChild(t),s.appendChild(e)}_setFocusTrap(t){this._focusTrap=new Cs(t,{event:\"keydown\",condition:e=>e.key===\"Tab\"}),this._focusTrap.trap()}_listenToUserInput(){b.on(this._input,\"input\",t=>{this._handleUserInput(t.target.value)})}_listenToToggleClick(){b.on(this._element,uo,fo,t=>{t.preventDefault(),this.open()})}_listenToToggleKeydown(){b.on(this._element,\"keydown\",fo,t=>{t.keyCode===Pt&&!this._isOpen&&this.open()})}_listenToDateSelection(){b.on(this.datesContainer,\"click\",t=>{this._handleDateSelection(t)})}_handleDateSelection(t){const e=t.target.nodeName===\"DIV\"?t.target.parentNode.dataset:t.target.dataset,s=t.target.nodeName===\"DIV\"?t.target.parentNode:t.target;if(e.teDate&&this._pickDay(e.teDate,s),e.teMonth&&e.teYear){const n=parseInt(e.teMonth,10),o=parseInt(e.teYear,10);this._pickMonth(n,o)}if(e.teYear&&!e.teMonth){const n=parseInt(e.teYear,10);this._pickYear(n)}this._options.inline||this._updateHeaderDate(this._activeDate,this._options.monthsShort,this._options.weekdaysShort)}_updateHeaderDate(t,e,s){const n=g.findOne(Gv,this.container),o=ot(t),r=bt(t),a=Jn(t);n.innerHTML=`${s[a]}, ${e[o]} ${r}`}_addControlsListeners(){b.on(this.nextButton,\"click\",()=>{this._view===\"days\"?this.nextMonth():this._view===\"years\"?this.nextYears():this.nextYear(),this._updateControlsDisabledState()}),b.on(this.previousButton,\"click\",()=>{this._view===\"days\"?this.previousMonth():this._view===\"years\"?this.previousYears():this.previousYear(),this._updateControlsDisabledState()}),b.on(this.viewChangeButton,\"click\",()=>{this._view===\"days\"?this._changeView(\"years\"):(this._view===\"years\"||this._view===\"months\")&&this._changeView(\"days\")}),this._options.inline||this._listenToFooterButtonsClick()}_listenToFooterButtonsClick(){b.on(this.okButton,\"click\",()=>this.handleOk()),b.on(this.cancelButton,\"click\",()=>this.handleCancel()),b.on(this.clearButton,\"click\",()=>this.handleClear())}_listenToOutsideClick(){b.on(document,uo,t=>{const e=t.target===this.container,s=this.container&&this.container.contains(t.target);!e&&!s&&this.close()})}_listenToEscapeClick(){b.on(document,\"keydown\",t=>{t.keyCode===ro&&this._isOpen&&this.close()})}_listenToKeyboardNavigation(){b.on(this.datesContainer,\"keydown\",t=>{this._handleKeydown(t)})}_listenToDatesContainerFocus(){b.on(this.datesContainer,\"focus\",()=>{this._focusActiveCell(this.activeCell)})}_listenToDatesContainerBlur(){b.on(this.datesContainer,\"blur\",()=>{this._removeCurrentFocusStyles()})}_handleKeydown(t){this._view===\"days\"&&this._handleDaysViewKeydown(t),this._view===\"months\"&&this._handleMonthsViewKeydown(t),this._view===\"years\"&&this._handleYearsViewKeydown(t)}_handleDaysViewKeydown(t){const e=this._activeDate,s=this.activeCell;switch(t.keyCode){case Zi:this._activeDate=Gi(this._activeDate,st()?1:-1);break;case Qi:this._activeDate=Gi(this._activeDate,st()?-1:1);break;case Tt:this._activeDate=Gi(this._activeDate,-7);break;case ut:this._activeDate=Gi(this._activeDate,7);break;case Ji:this._activeDate=Gi(this._activeDate,1-bt(this._activeDate));break;case ts:this._activeDate=Gi(this._activeDate,ua(this._activeDate)-bt(this._activeDate));break;case pa:this._activeDate=Ct(this._activeDate,-1);break;case _a:this._activeDate=Ct(this._activeDate,1);break;case Pt:case oo:this._selectDate(this._activeDate),this._handleDateSelection(t),t.preventDefault();return;default:return}Ps(e,this._activeDate,this._view,Qt,this._options.min,this._options.max)||this._changeView(\"days\"),this._removeHighlightFromCell(s),this._focusActiveCell(this.activeCell),t.preventDefault()}_asyncFocusDatesContainer(){setTimeout(()=>{this.datesContainer.focus()},0)}_focusActiveCell(t){t&&t.setAttribute(\"data-te-datepicker-cell-focused\",\"\")}_removeHighlightFromCell(t){t&&t.removeAttribute(\"data-te-datepicker-cell-focused\")}_getActiveDayCell(){const t=g.find(\"td\",this.datesContainer);return Array.from(t).find(s=>{const n=wh(s.dataset.teDate);return _i(n,this._activeDate)})}_handleMonthsViewKeydown(t){const e=this._activeDate,s=this.activeCell;switch(t.keyCode){case Zi:this._activeDate=Ct(this._activeDate,st()?1:-1);break;case Qi:this._activeDate=Ct(this._activeDate,st()?-1:1);break;case Tt:this._activeDate=Ct(this._activeDate,-4);break;case ut:this._activeDate=Ct(this._activeDate,4);break;case Ji:this._activeDate=Ct(this._activeDate,-this.activeMonth);break;case ts:this._activeDate=Ct(this._activeDate,11-this.activeMonth);break;case pa:this._activeDate=Et(this._activeDate,-1);break;case _a:this._activeDate=Et(this._activeDate,1);break;case Pt:case oo:this._selectMonth(this.activeMonth);return;default:return}Ps(e,this._activeDate,this._view,Qt,this._options.min,this._options.max)||this._changeView(\"months\"),this._removeHighlightFromCell(s),this._focusActiveCell(this.activeCell),t.preventDefault()}_getActiveMonthCell(){const t=g.find(\"td\",this.datesContainer);return Array.from(t).find(s=>{const n=parseInt(s.dataset.teYear,10),o=parseInt(s.dataset.teMonth,10);return n===this.activeYear&&o===this.activeMonth})}_handleYearsViewKeydown(t){const e=this._activeDate,s=this.activeCell,n=4,o=24;switch(t.keyCode){case Zi:this._activeDate=Et(this._activeDate,st()?1:-1);break;case Qi:this._activeDate=Et(this._activeDate,st()?-1:1);break;case Tt:this._activeDate=Et(this._activeDate,-n);break;case ut:this._activeDate=Et(this._activeDate,n);break;case Ji:this._activeDate=Et(this._activeDate,-to(this._activeDate,o));break;case ts:this._activeDate=Et(this._activeDate,o-to(this._activeDate,o)-1);break;case pa:this._activeDate=Et(this._activeDate,-o);break;case _a:this._activeDate=Et(this._activeDate,o);break;case Pt:case oo:this._selectYear(this.activeYear);return;default:return}Ps(e,this._activeDate,this._view,Qt,this._options.min,this._options.max)||this._changeView(\"years\"),this._removeHighlightFromCell(s),this._focusActiveCell(this.activeCell),t.preventDefault()}_getActiveYearCell(){const t=g.find(\"td\",this.datesContainer);return Array.from(t).find(s=>parseInt(s.dataset.teYear,10)===this.activeYear)}_setInitialDate(){this._input.value?this._handleUserInput(this._input.value):this._options.startDate?this._activeDate=new Date(this._options.startDate):this._activeDate=new Date}close(){const t=b.trigger(this._element,Nv);!this._isOpen||t.defaultPrevented||(this._removeDatepickerListeners(),this._animations&&v.addClass(this.container,this._classes.fadeOut),this._options.inline?this._closeDropdown():this._closeModal(),this._isOpen=!1,this._view=this._options.view,this.toggleButton?this.toggleButton.focus():this._input.focus())}_closeDropdown(){const t=g.findOne(Fv);window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches&&(t&&document.body.removeChild(t),this._popper&&this._popper.destroy()),t.addEventListener(\"animationend\",()=>{t&&document.body.removeChild(t),this._popper&&this._popper.destroy()}),this._removeFocusTrap()}_closeModal(){const t=g.findOne(qv),e=g.findOne(Hv);!e||!t||(this._animations?(v.addClass(t,this._classes.fadeOutShort),t.addEventListener(\"animationend\",()=>{this._removePicker(t,e),this._scrollBar.reset()})):(this._removePicker(t,e),this._scrollBar.reset()))}_removePicker(t,e){const s=this._getContainer();s.removeChild(t),s.removeChild(e)}_removeFocusTrap(){this._focusTrap&&(this._focusTrap.disable(),this._focusTrap=null)}_removeDatepickerListeners(){b.off(this.nextButton,\"click\"),b.off(this.previousButton,\"click\"),b.off(this.viewChangeButton,\"click\"),b.off(this.okButton,\"click\"),b.off(this.cancelButton,\"click\"),b.off(this.clearButton,\"click\"),b.off(this.datesContainer,\"click\"),b.off(this.datesContainer,\"keydown\"),b.off(this.datesContainer,\"focus\"),b.off(this.datesContainer,\"blur\"),b.off(document,uo)}dispose(){this._isOpen&&this.close(),this._removeInputAndToggleListeners();const t=g.findOne(`#${this._toggleButtonId}`);t&&this._element.removeChild(t),P.removeData(this._element,co),this._element=null,this._input=null,this._options=null,this._activeDate=null,this._selectedDate=null,this._selectedYear=null,this._selectedMonth=null,this._headerDate=null,this._headerYear=null,this._headerMonth=null,this._view=null,this._popper=null,this._focusTrap=null}_removeInputAndToggleListeners(){b.off(this._input,\"input\"),b.off(this._element,uo,fo),b.off(this._element,\"keydown\",fo)}handleOk(){this._confirmSelection(this._headerDate),this.close()}_selectDate(t,e=this.activeCell){const{min:s,max:n,filter:o,disablePast:r,disableFuture:a}=this._options;eo(t,s,n,o,r,a)||(this._removeCurrentSelectionStyles(),this._removeCurrentFocusStyles(),this._addSelectedStyles(e),this._selectedDate=t,this._selectedYear=K(t),this._selectedMonth=ot(t),this._headerDate=t,(this._options.inline||this.options.confirmDateOnSelect)&&(this._confirmSelection(t),this.close()))}_selectYear(t,e=this.activeCell){this._removeCurrentSelectionStyles(),this._removeCurrentFocusStyles(),this._addSelectedStyles(e),this._headerYear=t,this._asyncChangeView(\"months\")}_selectMonth(t,e=this.activeCell){this._removeCurrentSelectionStyles(),this._removeCurrentFocusStyles(),this._addSelectedStyles(e),this._headerMonth=t,this._asyncChangeView(\"days\")}_removeSelectedStyles(t){t&&t.removeAttribute(\"data-te-datepicker-cell-selected\")}_addSelectedStyles(t){t&&t.setAttribute(\"data-te-datepicker-cell-selected\",\"\")}_confirmSelection(t){if(t){const e=this.formatDate(t);this._input.value=e,b.trigger(this._element,Bv,{date:t}),b.trigger(this._input,\"input\")}}handleCancel(){this._selectedDate=null,this._selectedYear=null,this._selectedMonth=null,this.close()}handleClear(){this._selectedDate=null,this._selectedMonth=null,this._selectedYear=null,this._headerDate=null,this._headerMonth=null,this._headerYear=null,this._removeCurrentSelectionStyles(),this._input.value=\"\",this._setInitialDate(),this._changeView(\"days\"),this._updateHeaderDate(this._activeDate,this._options.monthsShort,this._options.weekdaysShort)}_removeCurrentSelectionStyles(){const t=g.findOne(\"[data-te-datepicker-cell-selected]\",this.container);t&&t.removeAttribute(\"data-te-datepicker-cell-selected\")}_removeCurrentFocusStyles(){const t=g.findOne(\"[data-te-datepicker-cell-focused]\",this.container);t&&t.removeAttribute(\"data-te-datepicker-cell-focused\")}formatDate(t){const e=bt(t),s=this._addLeadingZero(bt(t)),n=this._options.weekdaysShort[Jn(t)],o=this._options.weekdaysFull[Jn(t)],r=ot(t)+1,a=this._addLeadingZero(ot(t)+1),l=this._options.monthsShort[ot(t)],c=this._options.monthsFull[ot(t)],h=K(t).toString().length===2?K(t):K(t).toString().slice(2,4),d=K(t),u=this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);let f=\"\";return u.forEach(p=>{switch(p){case\"dddd\":p=p.replace(p,o);break;case\"ddd\":p=p.replace(p,n);break;case\"dd\":p=p.replace(p,s);break;case\"d\":p=p.replace(p,e);break;case\"mmmm\":p=p.replace(p,c);break;case\"mmm\":p=p.replace(p,l);break;case\"mm\":p=p.replace(p,a);break;case\"m\":p=p.replace(p,r);break;case\"yyyy\":p=p.replace(p,d);break;case\"yy\":p=p.replace(p,h);break}f+=p}),f}_addLeadingZero(t){return parseInt(t,10)<10?`0${t}`:t}_pickDay(t,e){const s=wh(t),{min:n,max:o,filter:r,disablePast:a,disableFuture:l}=this._options;eo(s,n,o,r,a,l)||(this._activeDate=s,this._selectDate(s,e))}_pickYear(t){const{min:e,max:s,disablePast:n,disableFuture:o}=this._options;if(fa(t,e,s,n,o))return;const r=he(t,this.activeMonth,this.activeDay);this._activeDate=r,this._selectedDate=r,this._selectYear(t)}_pickMonth(t,e){const{min:s,max:n,disablePast:o,disableFuture:r}=this._options;if(kh(t,e,s,n,o,r)||fa(e,s,n,o,r))return;const a=he(e,t,this.activeDay);this._activeDate=a,this._selectMonth(t)}nextMonth(){const t=Ct(this._activeDate,1),e=io(t,this._headerDate,this._options,this._classes);this._activeDate=t,this.viewChangeButton.textContent=`${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.datesContainer.innerHTML=e}previousMonth(){const t=Ct(this._activeDate,-1);this._activeDate=t;const e=io(t,this._headerDate,this._options,this._classes);this.viewChangeButton.textContent=`${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.datesContainer.innerHTML=e}nextYear(){const t=Et(this._activeDate,1);this._activeDate=t,this.viewChangeButton.textContent=`${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes);const e=so(this.activeYear,this._selectedYear,this._selectedMonth,this._options,lo,this._classes);this.datesContainer.innerHTML=e}previousYear(){const t=Et(this._activeDate,-1);this._activeDate=t,this.viewChangeButton.textContent=`${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes);const e=so(this.activeYear,this._selectedYear,this._selectedMonth,this._options,lo,this._classes);this.datesContainer.innerHTML=e}nextYears(){const t=Et(this._activeDate,24);this._activeDate=t;const e=no(t,this._selectedYear,this._options,Qt,ao,this._classes);this.viewChangeButton.textContent=`${this.firstYearInView} - ${this.lastYearInView}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.datesContainer.innerHTML=e}previousYears(){const t=Et(this._activeDate,-24);this._activeDate=t;const e=no(t,this._selectedYear,this._options,Qt,ao,this._classes);this.viewChangeButton.textContent=`${this.firstYearInView} - ${this.lastYearInView}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.datesContainer.innerHTML=e}_asyncChangeView(t){setTimeout(()=>{this._changeView(t)},0)}_changeView(t){this._view=t,this.datesContainer.blur(),t===\"days\"&&(this.datesContainer.innerHTML=io(this._activeDate,this._headerDate,this._options,this._classes)),t===\"months\"&&(this.datesContainer.innerHTML=so(this.activeYear,this._selectedYear,this._selectedMonth,this._options,lo,this._classes)),t===\"years\"&&(this.datesContainer.innerHTML=no(this._activeDate,this._selectedYear,this._options,Qt,ao,this._classes)),this.datesContainer.focus(),this._updateViewControlsAndAttributes(t),this._updateControlsDisabledState()}_updateViewControlsAndAttributes(t){t===\"days\"&&(this.viewChangeButton.textContent=`${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.viewChangeButton.setAttribute(\"aria-label\",this._options.switchToMultiYearViewLabel),this.previousButton.setAttribute(\"aria-label\",this._options.prevMonthLabel),this.nextButton.setAttribute(\"aria-label\",this._options.nextMonthLabel)),t===\"months\"&&(this.viewChangeButton.textContent=`${this.activeYear}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.viewChangeButton.setAttribute(\"aria-label\",this._options.switchToDayViewLabel),this.previousButton.setAttribute(\"aria-label\",this._options.prevYearLabel),this.nextButton.setAttribute(\"aria-label\",this._options.nextYearLabel)),t===\"years\"&&(this.viewChangeButton.textContent=`${this.firstYearInView} - ${this.lastYearInView}`,this.viewChangeButton.innerHTML+=de(this._options,this._classes),this.viewChangeButton.setAttribute(\"aria-label\",this._options.switchToMonthViewLabel),this.previousButton.setAttribute(\"aria-label\",this._options.prevMultiYearLabel),this.nextButton.setAttribute(\"aria-label\",this._options.nextMultiYearLabel))}_updateControlsDisabledState(){fv(this._options.disableFuture,this._activeDate,this._view,Qt,this._options.min,this._options.max,this.lastYearInView,this.firstYearInView)?this.nextButton.disabled=!0:this.nextButton.disabled=!1,pv(this._options.disablePast,this._activeDate,this._view,Qt,this._options.min,this._options.max,this.lastYearInView,this.firstYearInView)?this.previousButton.disabled=!0:this.previousButton.disabled=!1}_handleUserInput(t){const e=this._getDelimeters(this._options.format),s=this._parseDate(t,this._options.format,e);hv(s)?(this._activeDate=s,this._selectedDate=s,this._selectedYear=K(s),this._selectedMonth=ot(s),this._headerDate=s):(this._activeDate=new Date,this._selectedDate=null,this._selectedMonth=null,this._selectedYear=null,this._headerDate=null,this._headerMonth=null,this._headerYear=null)}_getDelimeters(t){return t.match(/[^(dmy)]{1,}/g)}_parseDate(t,e,s){let n;s[0]!==s[1]?n=s[0]+s[1]:n=s[0];const o=new RegExp(`[${n}]`),r=t.split(o),a=e.split(o),l=e.indexOf(\"mmm\")!==-1,c=[];for(let _=0;_<a.length;_++)a[_].indexOf(\"yy\")!==-1&&(c[0]={value:r[_],format:a[_]}),a[_].indexOf(\"m\")!==-1&&(c[1]={value:r[_],format:a[_]}),a[_].indexOf(\"d\")!==-1&&a[_].length<=2&&(c[2]={value:r[_],format:a[_]});let h;e.indexOf(\"mmmm\")!==-1?h=this._options.monthsFull:h=this._options.monthsShort;const d=Number(c[0].value),u=l?this.getMonthNumberByMonthName(c[1].value,h):Number(c[1].value)-1,f=Number(c[2].value);return he(d,u,f)}getMonthNumberByMonthName(t,e){return e.findIndex(s=>s===t)}static getInstance(t){return P.getData(t,co)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const L0=({format24:i,okLabel:t,cancelLabel:e,headID:s,footerID:n,bodyID:o,pickerID:r,clearLabel:a,inline:l,showClearBtn:c,amLabel:h,pmLabel:d},u)=>{const f=`<div id='${r}' class='${u.timepickerWrapper}' data-te-timepicker-wrapper>\n      <div class=\"${u.timepickerContainer}\">\n        <div class=\"${u.timepickerElements}\">\n        <div id='${s}' class='${u.timepickerHead}' style='padding-right:${i?50:10}px'>\n        <div class='${u.timepickerHeadContent}'>\n            <div class=\"${u.timepickerCurrentWrapper}\">\n              <span class=\"${u.timepickerCurrentButtonWrapper}\">\n                <button type='button' class='${u.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>\n              </span>\n              <button type='button' class='${u.timepickerDot}' disabled>:</button>\n            <span class=\"${u.timepickerCurrentButtonWrapper}\">\n              <button type='button' class='${u.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>\n            </span>\n            </div>\n            ${i?\"\":`<div class=\"${u.timepickerModeWrapper}\">\n                  <button type='button' class=\"${u.timepickerModeAm}\" tabindex=\"0\" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${h}</button>\n                  <button class=\"${u.timepickerModePm}\" tabindex=\"0\" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${d}</button>\n                </div>`}\n        </div>\n      </div>\n      ${l?\"\":`<div id='${o}' class='${u.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>\n            <div class='${u.timepickerClock}' data-te-timepicker-clock>\n              <span class='${u.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>\n              <div class='${u.timepickerHandPointer}' data-te-timepicker-hand-pointer>\n                <div class='${u.timepickerPointerCircle}' data-te-timepicker-circle></div>\n              </div>\n              ${i?'<div class=\"'+u.timepickerClockInner+'\" data-te-timepicker-clock-inner></div>':\"\"}\n            </div>\n          </div>`}\n    </div>\n    <div id='${n}' class='${u.timepickerFooterWrapper}'>\n      <div class=\"${u.timepickerFooter}\">\n        ${c?`<button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-clear tabindex=\"0\" data-te-ripple-init>${a}</button>`:\"\"}\n        <button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-cancel tabindex=\"0\" data-te-ripple-init>${e}</button>\n        <button type='button' class='${u.timepickerFooterButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n      </div>\n    </div>\n  </div>\n</div>`,p=`<div id='${r}' class='${u.timepickerInlineWrapper}' data-te-timepicker-wrapper>\n        <div class=\"${u.timepickerInlineContainer}\">\n          <div class=\"${u.timepickerInlineElements}\">\n          <div id='${s}' class='${u.timepickerInlineHead}'\n          style='padding-right:10px'>\n          <div class='${u.timepickerInlineHeadContent}'>\n              <div class=\"${u.timepickerCurrentWrapper}\">\n                <span class=\"${u.timepickerInlineHourWrapper}\" data-te-timepicker-inline-hour-icons>\n                  <span class=\"${u.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>\n                    <span class=\"${u.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                      </svg>   \n                    </span>\n                  </span>\n                  <button type='button' class='${u.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                  <span class=\"${u.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>\n                    <span class=\"${u.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                      </svg>  \n                    </span>\n                  </span>\n                </span>\n                <button type='button' class='${u.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>\n              <span class=\"${u.timepickerCurrentMinuteWrapper}\">\n                <span class=\"${u.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>\n                  <span class=\"${u.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                    </svg>\n                  </span>\n                </span>\n                <button type='button' class='${u.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                <span class=\"${u.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>\n                  <span class=\"${u.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                    </svg> \n                  </span>\n                </span>\n              </span>\n              </div>\n              ${i?\"\":`<div class=\"${u.timepickerInlineModeWrapper}\">\n                      <button type='button' class=\"${u.timepickerInlineModeAm}\" data-te-timepicker-am data-te-timepicker-hour-mode tabindex=\"0\" data-te-ripple-init>${h}</button>\n                      <button class=\"${u.timepickerInlineModePm}\" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex=\"0\" data-te-ripple-init>${d}</button>\n                      <button type='button' class='${u.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n                    </div>`}\n              ${i?`<button class='${u.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>`:\"\"}\n          </div>\n        </div>\n      </div>\n    </div>\n</div>`;return l?p:f},P0=(i,t,e)=>{const{iconSVG:s}=i;return`\n  <button id=\"${t}\" tabindex=\"0\" type=\"button\" class=\"${e.timepickerToggleButton}\" data-te-toggle=\"timepicker\" data-te-timepicker-toggle-button data-te-timepicker-icon>\n    ${s}\n  </button>\n`},po=\"data-te-timepicker-disabled\",_o=\"data-te-timepicker-active\",gi=i=>{if(i===\"\")return;let t,e,s,n;return Rh(i)?(t=i.getHours(),n=t,e=i.getMinutes(),t%=12,n===0&&t===0&&(s=\"AM\"),t=t||12,s===void 0&&(s=Number(n)>=12?\"PM\":\"AM\"),e=e<10?`0${e}`:e):([t,e,s]=j(i,!1),n=t,t%=12,n===0&&t===0&&(s=\"AM\"),t=t||12,s===void 0&&(s=Number(n)>=12?\"PM\":\"AM\")),{hours:t,minutes:e,amOrPm:s}},Rh=i=>i&&Object.prototype.toString.call(i)===\"[object Date]\"&&!Number.isNaN(i),Nh=i=>{if(i===\"\")return;let t,e;return Rh(i)?(t=i.getHours(),e=i.getMinutes()):[t,e]=j(i,!1),e=Number(e)<10?`0${Number(e)}`:e,{hours:t,minutes:e}},R0=(i,t,e)=>b.on(document,i,t,({target:s})=>{if(s.hasAttribute(_o))return;document.querySelectorAll(t).forEach(o=>{o.hasAttribute(_o)&&(v.removeClass(o,e.opacity),o.removeAttribute(_o))}),v.addClass(s,e.opacity),s.setAttribute(_o,\"\")}),$h=({clientX:i,clientY:t,touches:e},s,n=!1)=>{const{left:o,top:r}=s.getBoundingClientRect();let a={};return!n||!e?a={x:i-o,y:t-r}:n&&Object.keys(e).length>0&&(a={x:e[0].clientX-o,y:e[0].clientY-r}),a},go=()=>navigator.maxTouchPoints&&navigator.maxTouchPoints>2&&/MacIntel/.test(navigator.platform)||/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),j=(i,t=!0)=>t?i.value.replace(/:/gi,\" \").split(\" \"):i.replace(/:/gi,\" \").split(\" \"),Bh=(i,t)=>{const[e,s,n]=j(i,!1),[o,r,a]=j(t,!1);return n===\"PM\"&&a===\"AM\"||n===a&&e>o||s>r},Hh=()=>{const i=new Date,t=i.getHours(),e=i.getMinutes();return`${t}:${e<10?`0${e}`:e}`},He=(i,t,e)=>{if(!t)return i;let s=Hh();return e&&(s=`${gi(s).hours}:${gi(s).minutes} ${gi(s).amOrPm}`),(i!==\"\"&&Bh(s,i)||i===\"\")&&(i=s),i},Fe=(i,t,e)=>{if(!t)return i;let s=Hh();return e&&(s=`${gi(s).hours}:${gi(s).minutes} ${gi(s).amOrPm}`),(i!==\"\"&&!Bh(s,i)||i===\"\")&&(i=s),i},N0=({format12:i,maxTime:t,minTime:e,disablePast:s,disableFuture:n},o,r)=>{const a=j(o)[1];e=He(e,s,i),t=Fe(t,n,i);const[l,c,h]=j(t,!1),[d,u,f]=j(e,!1);if(h!==void 0||f!==void 0)return[r,a];if(!(l!==\"\"&&d===\"\"&&Number(r)>Number(l))&&!(l===\"\"&&d!==\"\"&&c===void 0&&u!==\"\"&&Number(r)<Number(d)))return[r,a]},Fh=(i,t,e,s)=>{i.forEach(n=>{t=t===\"12\"&&s?\"0\":t,(n.textContent===\"00\"||Number(n.textContent===\"12\"&&s?\"0\":n.textContent)>t)&&(v.addClass(n,e.tipsDisabled),n.setAttribute(po,\"\"))})},Vh=(i,t,e,s)=>{i.forEach(n=>{t=t===\"12\"&&s?\"0\":t,n.textContent!==\"00\"&&Number(n.textContent===\"12\"&&s?\"0\":n.textContent)<Number(t)&&(v.addClass(n,e.tipsDisabled),n.setAttribute(po,\"\"))})},Wh=(i,t,e,s)=>{if(t===\"12\"||t===\"24\")return;const n=e?12:24;return s===\"max\"?(Number(i)===n?0:Number(i))>Number(t):(Number(i)===n?0:Number(i))<Number(t)},$0=(i,t,e,s,n,o)=>{i.forEach(r=>{(Wh(s,e,o,\"max\")||Number(r.textContent)>t&&Number(s)===Number(e))&&(v.addClass(r,n.tipsDisabled),r.setAttribute(po,\"\"))})},B0=(i,t,e,s,n,o)=>{i.forEach(r=>{(Wh(s,e,o,\"min\")||Number(r.textContent)<t&&Number(s)===Number(e))&&(v.addClass(r,n.tipsDisabled),r.setAttribute(po,\"\"))})},H0=i=>i.startsWith(\"0\")?Number(i.slice(1)):Number(i),Ns=\"timepicker\",H=`data-te-${Ns}`,zh=\"[data-te-toggle]\",mo=`te.${Ns}`,ue=`.${mo}`,fe=\".data-api\",jh=`click${ue}${fe}`,bo=`keydown${ue}${fe}`,Yh=`mousedown${ue}${fe}`,Kh=`mouseup${ue}${fe}`,Uh=`mousemove${ue}${fe}`,Xh=`mouseleave${ue}${fe}`,Gh=`mouseover${ue}${fe}`,qh=`touchmove${ue}${fe}`,Zh=`touchend${ue}${fe}`,Qh=`touchstart${ue}${fe}`,F0=`[${H}-am]`,V0=`[${H}-pm]`,W0=`[${H}-format24]`,vo=`[${H}-current]`,yo=`[${H}-hour-mode]`,z0=`[${H}-toggle-button]`,ma=`${H}-cancel`,Jh=`${H}-clear`,ba=`${H}-submit`,j0=`${H}-icon`,va=`${H}-icon-up`,ya=`${H}-icon-down`,Y0=`${H}-icon-inline-hour`,K0=`${H}-icon-inline-minute`,td=`${H}-inline-hour-icons`,U0=`${H}-current-inline`,X0=\"readonly\",ed=`${H}-invalid-feedback`,xa=`${H}-is-invalid`,Ve=`${H}-disabled`,J=`${H}-active`,G0=`${H}-input`,mi=`${H}-clock`,$s=`${H}-clock-inner`,Ea=`${H}-wrapper`,id=`${H}-clock-wrapper`,xo=`${H}-hour`,Ca=`${H}-minute`,Eo=`${H}-tips-element`,ft=`${H}-tips-hours`,vt=`${H}-tips-minutes`,Rt=`${H}-tips-inner`,Co=`${H}-tips-inner-element`,sd=`${H}-middle-dot`,Ta=`${H}-hand-pointer`,Aa=`${H}-circle`,nd=`${H}-modal`,q0={appendValidationInfo:!0,bodyID:\"\",cancelLabel:\"Cancel\",clearLabel:\"Clear\",closeModalOnBackdropClick:!0,closeModalOnMinutesClick:!1,container:\"body\",defaultTime:\"\",disabled:!1,disablePast:!1,disableFuture:!1,enableValidation:!0,focusInputAfterApprove:!1,footerID:\"\",format12:!0,format24:!1,headID:\"\",increment:!1,inline:!1,invalidLabel:\"Invalid Time Format\",maxTime:\"\",minTime:\"\",modalID:\"\",okLabel:\"Ok\",overflowHidden:!0,pickerID:\"\",readOnly:!1,showClearBtn:!0,switchHoursToMinutesOnClick:!0,iconSVG:`<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n</svg>`,withIcon:!0,pmLabel:\"PM\",amLabel:\"AM\",animations:!0},Z0={appendValidationInfo:\"boolean\",bodyID:\"string\",cancelLabel:\"string\",clearLabel:\"string\",closeModalOnBackdropClick:\"boolean\",closeModalOnMinutesClick:\"boolean\",container:\"string\",disabled:\"boolean\",disablePast:\"boolean\",disableFuture:\"boolean\",enableValidation:\"boolean\",footerID:\"string\",format12:\"boolean\",format24:\"boolean\",headID:\"string\",increment:\"boolean\",inline:\"boolean\",invalidLabel:\"string\",modalID:\"string\",okLabel:\"string\",overflowHidden:\"boolean\",pickerID:\"string\",readOnly:\"boolean\",showClearBtn:\"boolean\",switchHoursToMinutesOnClick:\"boolean\",defaultTime:\"(string|date|number)\",iconSVG:\"string\",withIcon:\"boolean\",pmLabel:\"string\",amLabel:\"string\",animations:\"boolean\"},Q0={tips:\"absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent\",tipsActive:\"text-white bg-[#3b71ca] font-normal\",tipsDisabled:\"text-[#b3afaf] pointer-events-none bg-transparent\",transform:\"transition-[transform,height] ease-in-out duration-[400ms]\",modal:\"z-[1065]\",clockAnimation:\"animate-[show-up-clock_350ms_linear]\",opacity:\"!opacity-100\",timepickerWrapper:\"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed\",timepickerContainer:\"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg\",timepickerElements:\"flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",timepickerHead:\"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center\",timepickerHeadContent:\"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly\",timepickerCurrentWrapper:\"[direction:ltr] rtl:[direction:rtl]\",timepickerCurrentButtonWrapper:\"relative h-full\",timepickerCurrentButton:\"text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none \",timepickerDot:\"font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal\",timepickerModeWrapper:\"flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",timepickerModeAm:\"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",timepickerModePm:\"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",timepickerClockWrapper:\"min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500\",timepickerClock:\"relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50\",timepickerMiddleDot:\"top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute\",timepickerHandPointer:\"bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute\",timepickerPointerCircle:\"-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute\",timepickerClockInner:\"absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]\",timepickerFooterWrapper:\"rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500\",timepickerFooter:\"w-full flex justify-between\",timepickerFooterButton:\"text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none\",timepickerInlineWrapper:\"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg\",timepickerInlineContainer:\"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]\",timepickerInlineElements:\"flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",timepickerInlineHead:\"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg\",timepickerInlineHeadContent:\"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center\",timepickerInlineHourWrapper:\"relative h-full !opacity-100\",timepickerCurrentMinuteWrapper:\"relative h-full\",timepickerInlineIconUp:\"absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",timepickerInlineIconSvg:\"h-4 w-4\",timepickerInlineCurrentButton:\"font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]\",timepickerInlineIconDown:\"absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",timepickerInlineDot:\"font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]\",timepickerInlineModeWrapper:\"flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",timepickerInlineModeAm:\"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6\",timepickerInlineModePm:\"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer\",timepickerInlineSubmitButton:\"hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0\",timepickerToggleButton:\"h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white\"},J0={tips:\"string\",tipsActive:\"string\",tipsDisabled:\"string\",transform:\"string\",modal:\"string\",clockAnimation:\"string\",opacity:\"string\",timepickerWrapper:\"string\",timepickerContainer:\"string\",timepickerElements:\"string\",timepickerHead:\"string\",timepickerHeadContent:\"string\",timepickerCurrentWrapper:\"string\",timepickerCurrentButtonWrapper:\"string\",timepickerCurrentButton:\"string\",timepickerDot:\"string\",timepickerModeWrapper:\"string\",timepickerModeAm:\"string\",timepickerModePm:\"string\",timepickerClockWrapper:\"string\",timepickerClock:\"string\",timepickerMiddleDot:\"string\",timepickerHandPointer:\"string\",timepickerPointerCircle:\"string\",timepickerClockInner:\"string\",timepickerFooterWrapper:\"string\",timepickerFooterButton:\"string\",timepickerInlineWrapper:\"string\",timepickerInlineContainer:\"string\",timepickerInlineElements:\"string\",timepickerInlineHead:\"string\",timepickerInlineHeadContent:\"string\",timepickerInlineHourWrapper:\"string\",timepickerCurrentMinuteWrapper:\"string\",timepickerInlineIconUp:\"string\",timepickerInlineIconSvg:\"string\",timepickerInlineCurrentButton:\"string\",timepickerInlineIconDown:\"string\",timepickerInlineDot:\"string\",timepickerInlineModeWrapper:\"string\",timepickerInlineModeAm:\"string\",timepickerInlineModePm:\"string\",timepickerInlineSubmitButton:\"string\",timepickerToggleButton:\"string\"};class od{constructor(t,e={},s){Ee(this,\"_toggleAmPm\",t=>{t===\"PM\"?(this._isPmEnabled=!0,this._isAmEnabled=!1):t===\"AM\"&&(this._isPmEnabled=!1,this._isAmEnabled=!0)});Ee(this,\"_toggleBackgroundColorCircle\",t=>{if(this._modal.querySelector(`${t}[${J}]`)!==null){v.addStyle(this._circle,{backgroundColor:\"#1976d2\"});return}v.addStyle(this._circle,{backgroundColor:\"transparent\"})});Ee(this,\"_toggleClassActive\",(t,{textContent:e},s)=>{const n=[...t].find(o=>Number(o)===Number(e));return s.forEach(o=>{if(!o.hasAttribute(Ve)){if(o.textContent===n){v.addClass(o,this._classes.tipsActive),o.setAttribute(J,\"\");return}v.removeClass(o,this._classes.tipsActive),o.removeAttribute(J)}})});Ee(this,\"_makeMinutesDegrees\",(t,e)=>{const{increment:s}=this._options;return t<0?(e=Math.round(360+t/6)%60,t=360+Math.round(t/6)*6):(e=Math.round(t/6)%60,t=Math.round(t/6)*6),s&&(t=Math.round(t/30)*30,e=Math.round(t/6)*6/6,e===60&&(e=\"00\")),t>=360&&(t=0),{degrees:t,minute:e,addDegrees:s?30:6}});Ee(this,\"_makeHourDegrees\",(t,e,s)=>{if(t)return this._hasTargetInnerClass(t)?e<0?(s=Math.round(360+e/30)%24,e=360+e):(s=Math.round(e/30)+12,s===12&&(s=\"00\")):e<0?(s=Math.round(360+e/30)%12,e=360+e):(s=Math.round(e/30)%12,(s===0||s>12)&&(s=12)),e>=360&&(e=0),{degrees:e,hour:s,addDegrees:30}});Ee(this,\"_makeInnerHoursDegrees\",(t,e)=>(t<0?(e=Math.round(360+t/30)%24,t=360+t):(e=Math.round(t/30)+12,e===12&&(e=\"00\")),{degrees:t,hour:e,addDegrees:30}));Ee(this,\"_getAppendClock\",(t=[],e=`[${mi}]`,s)=>{let{minTime:n,maxTime:o}=this._options;const{inline:r,format12:a,disablePast:l,disableFuture:c}=this._options;n=He(n,l,a),o=Fe(o,c,a);const[h,d,u]=j(o,!1),[f,p,_]=j(n,!1);!r&&a&&this._isInvalidTimeFormat&&!this._AM.hasAttribute(J)&&(v.addClass(this._PM,this._classes.opacity),this._PM.setAttribute(J,\"\"));const m=g.findOne(e),y=360/t.length;function x(A){return A*(Math.PI/180)}if(m===null)return;const E=(m.offsetWidth-32)/2,C=(m.offsetHeight-32)/2,T=E-4;setTimeout(()=>{let A;a&&(A=g.findOne(`${yo}[${J}]`).textContent),this._handleDisablingTipsMinTime(A,_,p,f),this._handleDisablingTipsMaxTime(A,u,d,h)},0),[...t].forEach((A,w)=>{const S=x(w*y),k=z(\"span\"),D=z(\"span\");D.innerHTML=A,v.addClass(k,this._classes.tips),k.setAttribute(s,\"\");const O=k.offsetWidth,M=k.offsetHeight;return v.addStyle(k,{left:`${E+Math.sin(S)*T-O}px`,bottom:`${C+Math.cos(S)*T-M}px`}),t.includes(\"05\")&&k.setAttribute(vt,\"\"),t.includes(\"13\")?D.setAttribute(Co,\"\"):D.setAttribute(Eo,\"\"),k.appendChild(D),m.appendChild(k)})});this._element=t,this._element&&P.setData(t,mo,this),this._document=document,this._options=this._getConfig(e),this._classes=this._getClasses(s),this._currentTime=null,this._toggleButtonId=se(\"timepicker-toggle-\"),this.hoursArray=[\"12\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\"],this.innerHours=[\"00\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\"],this.minutesArray=[\"00\",\"05\",\"10\",\"15\",\"20\",\"25\",\"30\",\"35\",\"40\",\"45\",\"50\",\"55\"],this.input=g.findOne(\"input\",this._element),this.dataWithIcon=t.dataset.withIcon,this.dataToggle=t.dataset.toggle,this.customIcon=g.findOne(z0,this._element),this._checkToggleButton(),this.inputFormatShow=g.findOne(W0,this._element),this.inputFormat=this.inputFormatShow===null?\"\":Object.values(this.inputFormatShow.dataset)[0],this.elementToggle=g.findOne(zh,this._element),this.toggleElement=Object.values(t.querySelector(zh).dataset)[0],this._hour=null,this._minutes=null,this._AM=null,this._PM=null,this._wrapper=null,this._modal=null,this._hand=null,this._circle=null,this._focusTrap=null,this._popper=null,this._interval=null,this._inputValue=this._options.defaultTime!==\"\"?this._options.defaultTime:this.input.value,this._options.format24&&(this._options.format12=!1,this._currentTime=Nh(this._inputValue)),this._options.format12&&(this._options.format24=!1,this._currentTime=gi(this._inputValue)),this._options.readOnly&&this.input.setAttribute(X0,!0),this.inputFormat===\"true\"&&this.inputFormat!==\"\"&&(this._options.format12=!1,this._options.format24=!0,this._currentTime=Nh(this._inputValue)),this._animations=!window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches&&this._options.animations,this.init(),this._isHours=!0,this._isMinutes=!1,this._isInvalidTimeFormat=!1,this._isMouseMove=!1,this._isInner=!1,this._isAmEnabled=!1,this._isPmEnabled=!1,this._options.format12&&!this._options.defaultTime&&(this._isPmEnabled=!0),this._objWithDataOnChange={degrees:null},this._scrollBar=new Es}static get NAME(){return Ns}init(){const{format12:t,format24:e,enableValidation:s}=this._options;let n,o,r;if(this.input.setAttribute(G0,\"\"),this._currentTime!==void 0){const{hours:a,minutes:l,amOrPm:c}=this._currentTime;n=Number(a)<10?0:\"\",o=`${n}${Number(a)}:${l}`,r=c,t?this.input.value=`${o} ${r}`:e&&(this.input.value=`${o}`)}else n=\"\",o=\"\",r=\"\",this.input.value=\"\";this.input.value.length>0&&this.input.value!==\"\"&&(this.input.setAttribute(J,\"\"),b.trigger(this.input,\"input\")),!(this._options===null&&this._element===null)&&(s&&this._getValidate(\"keydown change blur focus\"),this._handleOpen(),this._listenToToggleKeydown())}dispose(){this._removeModal(),this._element!==null&&P.removeData(this._element,mo),setTimeout(()=>{this._element=null,this._options=null,this.input=null,this._focusTrap=null},350),b.off(this._document,\"click\",`[data-te-toggle='${this.toggleElement}']`),b.off(this._element,\"keydown\",`[data-te-toggle='${this.toggleElement}']`)}update(t={}){this._options=this._getConfig({...this._options,...t})}_checkToggleButton(){this.customIcon===null&&(this.dataWithIcon!==void 0&&(this._options.withIcon=null,this.dataWithIcon===\"true\"&&this._appendToggleButton(this._options)),this._options.withIcon&&this._appendToggleButton(this._options))}_appendToggleButton(){const t=P0(this._options,this._toggleButtonId,this._classes);this.input.insertAdjacentHTML(\"afterend\",t)}_getDomElements(){this._hour=g.findOne(`[${xo}]`),this._minutes=g.findOne(`[${Ca}]`),this._AM=g.findOne(F0),this._PM=g.findOne(V0),this._wrapper=g.findOne(`[${Ea}]`),this._modal=g.findOne(`[${nd}]`),this._hand=g.findOne(`[${Ta}]`),this._circle=g.findOne(`[${Aa}]`),this._clock=g.findOne(`[${mi}]`),this._clockInner=g.findOne(`[${$s}]`)}_handlerMaxMinHoursOptions(t,e,s,n,o,r){if(!e&&!s)return!0;const{format24:a,format12:l,disablePast:c,disableFuture:h}=this._options,{_isAmEnabled:d,_isPmEnabled:u}=this,f=r.keyCode,p=r.target.hasAttribute($s)||r.target.hasAttribute(Rt)||r.target.hasAttribute(Co);s=He(s,c,l),e=Fe(e,h,l),typeof e!=\"number\"&&(e=j(e,!1)[0]);const _=e!==\"\"?e*30:\"\",m=s!==\"\"?s*30:\"\";t<0&&(t=360+t),t=t===360?0:t;const y=()=>{const w=document.querySelectorAll(`[${Eo}]`),S=document.querySelectorAll(`[${Co}]`),k=H0(this._hour.innerText);let D,O,M;return f===Tt?O=1:f===ut&&(O=-1),k===12&&f===Tt?M=1:k===0&&f===Tt?M=13:k===0&&f===ut?M=23:k===13&&f===ut?M=0:k===1&&f===ut?M=12:M=k+O,w.forEach(L=>{Number(L.textContent)===M&&(D=L)}),S.forEach(L=>{Number(L.textContent)===M&&(D=L)}),!D.parentElement.hasAttribute(Ve)},x=()=>{const w=s!==\"\"&&s>12?(s-12)*30:\"\",S=e!==\"\"&&e>12?(e-12)*30:\"\";if(!(w&&t<w||S&&t>S||e&&e<12))return!0};if(a&&r.type!==\"keydown\"&&p)return x();if(r.type===\"keydown\")return y();const E=!o||o===\"PM\"&&u||s!==\"\"&&o===\"AM\"&&d,C=!n||n===\"PM\"&&u||e!==\"\"&&n===\"AM\"&&d,T=()=>{const w=m===360&&l?0:m;if(s){if(o===\"PM\"&&d||E&&t<w)return}else return!0;return!0},A=()=>{const w=_===360&&l?0:_;if(e){if(n===\"AM\"&&u||C&&t>w)return}else return!0;return!0};return T()&&A()}_handleKeyboard(){b.on(this._document,bo,\"\",t=>{let e,s,n;const{increment:o,maxTime:r,minTime:a,format12:l,disablePast:c,disableFuture:h}=this._options;let d=j(a,!1)[0],u=j(r,!1)[0];const f=j(a,!1)[2],p=j(r,!1)[2];d=He(d,c,l),u=Fe(u,h,l),typeof u!=\"number\"&&(u=j(u,!1)[0]);const _=g.findOne(`[${vt}]`)===null,m=g.findOne(`[${Rt}]`)!==null,y=Number(this._hand.style.transform.replace(/[^\\d-]/g,\"\")),x=g.find(`[${vt}]`,this._modal),E=g.find(`[${ft}]`,this._modal),C=g.find(`[${Rt}]`,this._modal);let T=this._makeHourDegrees(t.target,y,e).hour;const{degrees:A,addDegrees:w}=this._makeHourDegrees(t.target,y,e);let{minute:S,degrees:k}=this._makeMinutesDegrees(y,s);const D=this._makeMinutesDegrees(y,s).addDegrees;let{hour:O}=this._makeInnerHoursDegrees(y,n);if(t.keyCode===ro){const M=g.findOne(`[${ma}]`,this._modal);b.trigger(M,\"click\")}else if(_){if(m&&(t.keyCode===Qi&&(this._isInner=!1,v.addStyle(this._hand,{height:\"calc(40% + 1px)\"}),this._hour.textContent=this._setHourOrMinute(T>12?1:T),this._toggleClassActive(this.hoursArray,this._hour,E),this._toggleClassActive(this.innerHours,this._hour,C)),t.keyCode===Zi&&(this._isInner=!0,v.addStyle(this._hand,{height:\"21.5%\"}),this._hour.textContent=this._setHourOrMinute(O>=24||O===\"00\"?0:O),this._toggleClassActive(this.innerHours,this._hour,C),this._toggleClassActive(this.hoursArray,this._hour-1,E))),t.keyCode===Tt){if(!this._handlerMaxMinHoursOptions(A+30,u,d,p,f,t))return;v.addStyle(this._hand,{transform:`rotateZ(${A+w}deg)`}),this._isInner?(O+=1,O===24?O=0:(O===25||O===\"001\")&&(O=13),this._hour.textContent=this._setHourOrMinute(O),this._toggleClassActive(this.innerHours,this._hour,C)):(T+=1,this._hour.textContent=this._setHourOrMinute(T>12?1:T),this._toggleClassActive(this.hoursArray,this._hour,E))}if(t.keyCode===ut){if(!this._handlerMaxMinHoursOptions(A-30,u,d,p,f,t))return;v.addStyle(this._hand,{transform:`rotateZ(${A-w}deg)`}),this._isInner?(O-=1,O===12?O=0:O===-1&&(O=23),this._hour.textContent=this._setHourOrMinute(O),this._toggleClassActive(this.innerHours,this._hour,C)):(T-=1,this._hour.textContent=this._setHourOrMinute(T===0?12:T),this._toggleClassActive(this.hoursArray,this._hour,E))}}else t.keyCode===Tt&&(k+=D,v.addStyle(this._hand,{transform:`rotateZ(${k}deg)`}),S+=1,o&&(S+=4,S===\"0014\"&&(S=5)),this._minutes.textContent=this._setHourOrMinute(S>59?0:S),this._toggleClassActive(this.minutesArray,this._minutes,x),this._toggleBackgroundColorCircle(`[${vt}]`)),t.keyCode===ut&&(k-=D,v.addStyle(this._hand,{transform:`rotateZ(${k}deg)`}),o?S-=5:S-=1,S===-1?S=59:S===-5&&(S=55),this._minutes.textContent=this._setHourOrMinute(S),this._toggleClassActive(this.minutesArray,this._minutes,x),this._toggleBackgroundColorCircle(`[${vt}]`))})}_setActiveClassToTipsOnOpen(t,...e){if(!this._isInvalidTimeFormat)if(this._options.format24){const s=g.find(`[${ft}]`,this._modal),n=g.find(`[${Rt}]`,this._modal);this._addActiveClassToTip(s,t),this._addActiveClassToTip(n,t)}else{[...e].filter(n=>(n===\"PM\"?(v.addClass(this._PM,this._classes.opacity),this._PM.setAttribute(J,\"\")):n===\"AM\"?(v.addClass(this._AM,this._classes.opacity),this._AM.setAttribute(J,\"\")):(v.removeClass(this._AM,this._classes.opacity),v.removeClass(this._PM,this._classes.opacity),this._AM.removeAttribute(J),this._PM.removeAttribute(J)),n));const s=g.find(`[${ft}]`,this._modal);this._addActiveClassToTip(s,t)}}_setTipsAndTimesDependOnInputValue(t,e){const{inline:s,format12:n}=this._options;if(this._isInvalidTimeFormat)this._hour.textContent=\"12\",this._minutes.textContent=\"00\",s||v.addStyle(this._hand,{transform:\"rotateZ(0deg)\"}),n&&(v.addClass(this._PM,this._classes.opacity),this._PM.setAttribute(J,\"\"));else{const o=t>12?t*30-360:t*30;this._hour.textContent=t,this._minutes.textContent=e,s||(v.addStyle(this._hand,{transform:`rotateZ(${o}deg)`}),v.addStyle(this._circle,{backgroundColor:\"#1976d2\"}),(Number(t)>12||t===\"00\")&&v.addStyle(this._hand,{height:\"21.5%\"}))}}_listenToToggleKeydown(){b.on(this._element,\"keydown\",`[data-te-toggle='${this.toggleElement}']`,t=>{t.keyCode===Pt&&(t.preventDefault(),b.trigger(this.elementToggle,\"click\"))})}_handleOpen(){const t=this._getContainer();si.on(this._element,\"click\",`[data-te-toggle='${this.toggleElement}']`,e=>{if(this._options===null)return;const s=v.getDataAttribute(this.input,\"toggle\")!==null?200:0;setTimeout(()=>{v.addStyle(this.elementToggle,{pointerEvents:\"none\"}),this.elementToggle.blur();let n;j(this.input)[0]===\"\"?n=[\"12\",\"00\",\"PM\"]:n=j(this.input);const{modalID:o,inline:r,format12:a}=this._options,[l,c,h]=n,d=z(\"div\");if((Number(l)>12||l===\"00\")&&(this._isInner=!0),this.input.blur(),e.target.blur(),d.innerHTML=L0(this._options,this._classes),v.addClass(d,this._classes.modal),d.setAttribute(nd,\"\"),d.setAttribute(\"role\",\"dialog\"),d.setAttribute(\"tabIndex\",\"-1\"),d.setAttribute(\"id\",o),r?(this._popper=Fi(this.input,d,{placement:\"bottom-start\"}),t.appendChild(d)):(t.appendChild(d),this._scrollBar.hide()),this._getDomElements(),this._animations?this._toggleBackdropAnimation():v.addClass(this._wrapper,this._classes.opacity),this._setActiveClassToTipsOnOpen(l,c,h),this._appendTimes(),this._setActiveClassToTipsOnOpen(l,c,h),this._setTipsAndTimesDependOnInputValue(l,c),this.input.value===\"\"){const u=g.find(`[${ft}]`,this._modal);a&&(v.addClass(this._PM,this._classes.opacity),this._PM.setAttribute(J,\"\")),this._hour.textContent=\"12\",this._minutes.textContent=\"00\",this._addActiveClassToTip(u,Number(this._hour.textContent))}if(this._handleSwitchTimeMode(),this._handleOkButton(),this._handleClose(),r)this._handleHoverInlineBtn(),this._handleDocumentClickInline(),this._handleInlineClicks();else{this._handleSwitchHourMinute(),this._handleClockClick(),this._handleKeyboard();const u=document.querySelector(`${vo}[${J}]`);v.addClass(u,this._classes.opacity),v.addStyle(this._hour,{pointerEvents:\"none\"}),v.addStyle(this._minutes,{pointerEvents:\"\"})}this._focusTrap=new Cs(this._wrapper,{event:\"keydown\",condition:({key:u})=>u===\"Tab\"}),this._focusTrap.trap()},s)})}_handleInlineClicks(){let t,e;const s=u=>{let f=u;return f>59?f=0:f<0&&(f=59),f},n=u=>{let f=u;return this._options.format24?(f>24?f=1:f<0&&(f=23),f>23&&(f=0)):(f>12?f=1:f<1&&(f=12),f>12&&(f=1)),f},o=u=>{const f=n(u);this._hour.textContent=this._setHourOrMinute(f)},r=u=>{const f=s(u);this._minutes.textContent=this._setHourOrMinute(f)},a=()=>{t+=1,o(t)},l=()=>{e+=1,r(e)},c=()=>{t-=1,o(t)},h=()=>{e-=1,r(e)},d=u=>{clearInterval(this._interval),this._interval=setInterval(u,100)};si.on(this._modal,\"click mousedown mouseup touchstart touchend contextmenu\",`[${va}], [${ya}]`,u=>{t=Number(this._hour.textContent),e=Number(this._minutes.textContent);const{target:f,type:p}=u,_=p===\"mousedown\"||p===\"touchstart\";f.closest(`[${va}]`)?f.closest(`[${va}]`).parentNode.hasAttribute(td)?_?d(a):p===\"mouseup\"||p===\"touchend\"||p===\"contextmenu\"?clearInterval(this._interval):a():_?d(l):p===\"mouseup\"||p===\"touchend\"||p===\"contextmenu\"?clearInterval(this._interval):l():f.closest(`[${ya}]`)&&(f.closest(`[${ya}]`).parentNode.hasAttribute(td)?_?d(c):p===\"mouseup\"||p===\"touchend\"?clearInterval(this._interval):c():_?d(h):p===\"mouseup\"||p===\"touchend\"?clearInterval(this._interval):h())}),b.on(window,bo,u=>{const f=u.code,p=document.activeElement.hasAttribute(xo),_=document.activeElement.hasAttribute(Ca),m=document.activeElement===document.body;switch(t=Number(this._hour.textContent),e=Number(this._minutes.textContent),f){case\"ArrowUp\":u.preventDefault(),m||p?(this._hour.focus(),a()):_&&l();break;case\"ArrowDown\":u.preventDefault(),m||p?(this._hour.focus(),c()):_&&h();break}})}_handleClose(){b.on(this._modal,\"click\",`[${Ea}], [${ma}], [${Jh}]`,({target:t})=>{const{closeModalOnBackdropClick:e}=this._options,s=()=>{var n;v.addStyle(this.elementToggle,{pointerEvents:\"auto\"}),this._animations&&this._toggleBackdropAnimation(!0),this._removeModal(),(n=this._focusTrap)==null||n.disable(),this._focusTrap=null,this.elementToggle?this.elementToggle.focus():this.input&&this.input.focus()};if(t.hasAttribute(Jh)){this._toggleAmPm(\"PM\"),this.input.value=\"\",this.input.removeAttribute(J);let n;j(this.input)[0]===\"\"?n=[\"12\",\"00\",\"PM\"]:n=j(this.input);const[o,r,a]=n;this._setTipsAndTimesDependOnInputValue(\"12\",\"00\"),this._setActiveClassToTipsOnOpen(o,r,a),this._hour.click()}else(t.hasAttribute(ma)||t.hasAttribute(ba)||t.hasAttribute(Ea)&&e)&&s()})}showValueInput(){return this.input.value}_handleOkButton(){si.on(this._modal,\"click\",`[${ba}]`,()=>{let{maxTime:t,minTime:e}=this._options;const{format12:s,format24:n,readOnly:o,focusInputAfterApprove:r,disablePast:a,disableFuture:l}=this._options,c=this._document.querySelector(`${yo}[${J}]`),h=`${this._hour.textContent}:${this._minutes.textContent}`,d=Number(this._hour.textContent),u=d===12&&s?0:d,f=Number(this._minutes.textContent);e=He(e,a,s),t=Fe(t,l,s);let[p,_,m]=j(t,!1),[y,x,E]=j(e,!1);y=y===\"12\"&&s?\"00\":y,p=p===\"12\"&&s?\"00\":p;const C=u<Number(y),T=u>Number(p);let A=!0;c&&(A=m===c.textContent);let w=!0;c&&(w=E===c.textContent);const S=f>_&&u===Number(p),k=f<x&&u===Number(y);if(this.input.setAttribute(J,\"\"),v.addStyle(this.elementToggle,{pointerEvents:\"auto\"}),t!==\"\"){if(A&&(T||S))return;if(m===\"AM\"&&c.textContent===\"PM\")return}e!==\"\"&&(w&&(C||k)||E===\"PM\"&&c.textContent===\"AM\")||N0(this._options,this.input,this._hour.textContent)!==void 0&&(this._isInvalidTimeFormat&&this.input.removeAttribute(xa),!o&&r&&this.input.focus(),v.addStyle(this.elementToggle,{pointerEvents:\"auto\"}),n?this.input.value=h:c===null?this.input.value=`${h} PM`:this.input.value=`${h} ${c.textContent}`,this._animations&&this._toggleBackdropAnimation(!0),this._removeModal(),b.trigger(this.input,\"input.te.timepicker\"),b.trigger(this.input,\"input\"))})}_handleHoverInlineBtn(){si.on(this._modal,\"mouseover mouseleave\",`[${U0}]`,({type:t,target:e})=>{const s=g.find(`[${Y0}]`,this._modal),n=g.find(`[${K0}]`,this._modal),o=(l,c)=>l.forEach(h=>{if(c){v.addClass(h,this._classes.opacity),h.setAttribute(J,\"\");return}v.removeClass(h,this._classes.opacity),h.removeAttribute(J)}),a=e.hasAttribute(xo)?s:n;o(a,t===\"mouseover\")})}_handleDocumentClickInline(){b.on(document,jh,({target:t})=>{if(this._modal&&!this._modal.contains(t)&&!t.hasAttribute(j0)){if(clearInterval(this._interval),v.addStyle(this.elementToggle,{pointerEvents:\"auto\"}),this._removeModal(),!this._animations)return;this._toggleBackdropAnimation(!0)}})}_handleSwitchHourMinute(){R0(\"click\",vo,this._classes),b.on(this._modal,\"click\",vo,()=>{const{format24:t}=this._options,e=g.find(vo,this._modal),s=g.find(`[${vt}]`,this._modal),n=g.find(`[${ft}]`,this._modal),o=g.find(`[${Rt}]`,this._modal),r=Number(this._hour.textContent),a=Number(this._minutes.textContent),l=(c,h)=>{n.forEach(u=>u.remove()),s.forEach(u=>u.remove()),v.addClass(this._hand,this._classes.transform),setTimeout(()=>{v.removeClass(this._hand,this._classes.transform)},401),this._getAppendClock(c,`[${mi}]`,h);const d=()=>{const u=g.find(`[${ft}]`,this._modal),f=g.find(`[${vt}]`,this._modal);this._addActiveClassToTip(u,r),this._addActiveClassToTip(f,a)};if(!t)setTimeout(()=>{d()},401);else{const u=g.find(`[${Rt}]`,this._modal);setTimeout(()=>{this._addActiveClassToTip(u,r),d()},401)}};e.forEach(c=>{c.hasAttribute(J)&&(c.hasAttribute(Ca)?(v.addClass(this._hand,this._classes.transform),v.addStyle(this._hand,{transform:`rotateZ(${this._minutes.textContent*6}deg)`,height:\"calc(40% + 1px)\"}),t&&o.length>0&&o.forEach(h=>h.remove()),l(this.minutesArray,vt),this._hour.style.pointerEvents=\"\",this._minutes.style.pointerEvents=\"none\"):c.hasAttribute(xo)&&(v.addStyle(this._hand,{transform:`rotateZ(${this._hour.textContent*30}deg)`}),Number(this._hour.textContent)>12?(v.addStyle(this._hand,{transform:`rotateZ(${this._hour.textContent*30-360}deg)`,height:\"21.5%\"}),Number(this._hour.textContent)>12&&v.addStyle(this._hand,{height:\"21.5%\"})):v.addStyle(this._hand,{height:\"calc(40% + 1px)\"}),t&&this._getAppendClock(this.innerHours,`[${$s}]`,Rt),o.length>0&&o.forEach(h=>h.remove()),l(this.hoursArray,ft),v.addStyle(this._hour,{pointerEvents:\"none\"}),v.addStyle(this._minutes,{pointerEvents:\"\"})))})})}_handleDisablingTipsMaxTime(t,e,s,n){if(!this._options.maxTime&&!this._options.disableFuture)return;const o=g.find(`[${ft}]`),r=g.find(`[${Rt}]`),a=g.find(`[${vt}]`);if(!e||e===t){Fh(r,n,this._classes,this._options.format12),Fh(o,n,this._classes,this._options.format12),$0(a,s,n,this._hour.textContent,this._classes,this._options.format12);return}e===\"AM\"&&t===\"PM\"&&(o.forEach(l=>{v.addClass(l,this._classes.tipsDisabled),l.setAttribute(Ve,\"\")}),a.forEach(l=>{v.addClass(l,this._classes.tipsDisabled),l.setAttribute(Ve,\"\")}))}_handleDisablingTipsMinTime(t,e,s,n){if(!this._options.minTime&&!this._options.disablePast)return;const o=g.find(`[${ft}]`),r=g.find(`[${Rt}]`),a=g.find(`[${vt}]`);!e||e===t?(Vh(o,n,this._classes,this._options.format12),Vh(r,n,this._classes,this._options.format12),B0(a,s,n,this._hour.textContent,this._classes,this._options.format12)):e===\"PM\"&&t===\"AM\"&&(o.forEach(l=>{v.addClass(l,this._classes.tipsDisabled),l.setAttribute(Ve,\"\")}),a.forEach(l=>{v.addClass(l,this._classes.tipsDisabled),l.setAttribute(Ve,\"\")}))}_handleSwitchTimeMode(){b.on(document,\"click\",yo,({target:t})=>{let{maxTime:e,minTime:s}=this._options;const{disablePast:n,disableFuture:o,format12:r}=this._options;s=He(s,n,r),e=Fe(e,o,r);const[a,l,c]=j(e,!1),[h,d,u]=j(s,!1),f=g.find(`[${ft}]`),p=g.find(`[${vt}]`);(()=>{f.forEach(m=>{v.removeClass(m,this._classes.tipsDisabled),m.removeAttribute(Ve)}),p.forEach(m=>{v.removeClass(m,this._classes.tipsDisabled),m.removeAttribute(Ve)})})(),this._handleDisablingTipsMinTime(t.textContent,u,d,h),this._handleDisablingTipsMaxTime(t.textContent,c,l,a),this._toggleAmPm(t.textContent),t.hasAttribute(J)||(g.find(yo).forEach(y=>{y.hasAttribute(J)&&(v.removeClass(y,this._classes.opacity),y.removeAttribute(J))}),v.addClass(t,this._classes.opacity),t.setAttribute(J,\"\"))})}_handleClockClick(){let{maxTime:t,minTime:e}=this._options;const{disablePast:s,disableFuture:n,format12:o}=this._options;e=He(e,s,o),t=Fe(t,n,o);const r=j(t,!1)[2],a=j(e,!1)[2],l=j(t,!1)[0],c=j(e,!1)[0],h=g.findOne(`[${id}]`);si.on(document,`${Yh} ${Kh} ${Uh} ${Xh} ${Gh} ${Qh} ${qh} ${Zh}`,\"\",d=>{go()||d.preventDefault();const{type:u,target:f}=d,{closeModalOnMinutesClick:p,switchHoursToMinutesOnClick:_}=this._options,m=g.findOne(`[${vt}]`,this._modal)!==null,y=g.findOne(`[${ft}]`,this._modal)!==null,x=g.findOne(`[${Rt}]`,this._modal)!==null,E=g.find(`[${vt}]`,this._modal),C=$h(d,h),T=h.offsetWidth/2;let A=Math.atan2(C.y-T,C.x-T);if(go()){const D=$h(d,h,!0);A=Math.atan2(D.y-T,D.x-T)}let w=null,S=null,k=null;if(u===\"mousedown\"||u===\"mousemove\"||u===\"touchmove\"||u===\"touchstart\")(u===\"mousedown\"||u===\"touchstart\"||u===\"touchmove\")&&(this._hasTargetInnerClass(f)||f.hasAttribute(id)||f.hasAttribute(mi)||f.hasAttribute(vt)||f.hasAttribute(ft)||f.hasAttribute(Aa)||f.hasAttribute(Ta)||f.hasAttribute(sd)||f.hasAttribute(Eo))&&(this._isMouseMove=!0,go()&&d.touches&&(w=d.touches[0].clientX,S=d.touches[0].clientY,k=document.elementFromPoint(w,S)));else if(u===\"mouseup\"||u===\"touchend\"){if(this._isMouseMove=!1,this._hasTargetInnerClass(f)||f.hasAttribute(mi)||f.hasAttribute(ft)||f.hasAttribute(Aa)||f.hasAttribute(Ta)||f.hasAttribute(sd)||f.hasAttribute(Eo)){if((y||x)&&_){const D=Number(this._hour.textContent)>l||Number(this._hour.textContent)<c;if(this._options.format24&&l!==\"\"&&c!==\"\"&&D)return;if(this._options.format24&&c!==\"\"&&Number(this._hour.textContent)<c)return}b.trigger(this._minutes,\"click\")}if(m&&p){const D=g.findOne(`[${ba}]`,this._modal);b.trigger(D,\"click\")}}if(m){let D;const O=Math.trunc(A*180/Math.PI)+90,{degrees:M,minute:L}=this._makeMinutesDegrees(O,D);if(this._handlerMaxMinMinutesOptions(M,L)===void 0)return;const{degrees:X,minute:I}=this._handlerMaxMinMinutesOptions(M,L);if(this._isMouseMove){if(v.addStyle(this._hand,{transform:`rotateZ(${X}deg)`}),I===void 0)return;const F=()=>I>=10||I===\"00\"?I:`0${I}`;this._minutes.textContent=F(),this._toggleClassActive(this.minutesArray,this._minutes,E),this._toggleBackgroundColorCircle(`[${vt}]`),this._objWithDataOnChange.degreesMinutes=X,this._objWithDataOnChange.minutes=I}}if(y||x){let D,O=Math.trunc(A*180/Math.PI)+90;if(O=Math.round(O/30)*30,v.addStyle(this._circle,{backgroundColor:\"#1976d2\"}),this._makeHourDegrees(f,O,D)===void 0)return;const M=()=>{if(go()&&O&&k){const{degrees:L,hour:X}=this._makeHourDegrees(k,O,D);return this._handleMoveHand(k,X,L)}else{const{degrees:L,hour:X}=this._makeHourDegrees(f,O,D);return this._handleMoveHand(f,X,L)}};this._objWithDataOnChange.degreesHours=O,this._handlerMaxMinHoursOptions(O,l,c,r,a,d)&&M()}d.stopPropagation()})}_hasTargetInnerClass(t){return t.hasAttribute($s)||t.hasAttribute(Rt)||t.hasAttribute(Co)}_handleMoveHand(t,e,s){const n=g.find(`[${ft}]`,this._modal),o=g.find(`[${Rt}]`,this._modal);this._isMouseMove&&(this._hasTargetInnerClass(t)?v.addStyle(this._hand,{height:\"21.5%\"}):v.addStyle(this._hand,{height:\"calc(40% + 1px)\"}),v.addStyle(this._hand,{transform:`rotateZ(${s}deg)`}),this._hour.textContent=e>=10||e===\"00\"?e:`0${e}`,this._toggleClassActive(this.hoursArray,this._hour,n),this._toggleClassActive(this.innerHours,this._hour,o),this._objWithDataOnChange.hour=e>=10||e===\"00\"?e:`0${e}`)}_handlerMaxMinMinutesOptions(t,e){let{maxTime:s,minTime:n}=this._options;const{format12:o,increment:r,disablePast:a,disableFuture:l}=this._options;n=He(n,a,o),s=Fe(s,l,o);const c=j(s,!1)[1],h=j(n,!1)[1],d=j(s,!1)[0],u=j(n,!1)[0],f=u===\"12\"&&o?\"0\":u,p=d===\"12\"&&o?\"0\":d,_=j(s,!1)[2],m=j(n,!1)[2],y=c!==\"\"?c*6:\"\",x=h!==\"\"?h*6:\"\",E=Number(this._hour.textContent),C=E===12&&o?0:E;if(!_&&!m){if(s!==\"\"&&n!==\"\"){if(Number(p)===C&&t>y||Number(f)===C&&t<x)return t}else if(n!==\"\"&&C<=Number(f)){if(t<=x-6)return t}else if(s!==\"\"&&C>=Number(p)&&t>=y+6)return t}else{if(n!==\"\"){if(m===\"PM\"&&this._isAmEnabled)return;if(m===\"PM\"&&this._isPmEnabled){if(C<Number(f))return;if(C<=Number(f)&&t<=x-6)return t}else if(m===\"AM\"&&this._isAmEnabled){if(C<Number(f))return;if(C<=Number(f)&&t<=x-6)return t}}if(s!==\"\"){if(_===\"AM\"&&this._isPmEnabled)return;if(_===\"PM\"&&this._isPmEnabled){if(C>=Number(p)&&t>=y+6)return t}else if(_===\"AM\"&&this._isAmEnabled&&C>=Number(p)&&t>=y+6)return t}}return r&&(t=Math.round(t/30)*30),t<0?t=360+t:t>=360&&(t=0),{degrees:t,minute:e}}_removeModal(){this._animations?setTimeout(()=>{this._removeModalElements(),this._scrollBar.reset()},300):(this._removeModalElements(),this._scrollBar.reset()),si.off(this._document,`${jh} ${bo} ${Yh} ${Kh} ${Uh} ${Xh} ${Gh} ${Qh} ${qh} ${Zh}`),b.off(window,bo)}_removeModalElements(){this._modal&&this._modal.remove()}_toggleBackdropAnimation(t=!1){t?this._wrapper.classList.add(\"animate-[fade-out_350ms_ease-in-out]\"):(this._wrapper.classList.add(\"animate-[fade-in_350ms_ease-in-out]\"),this._options.inline||v.addClass(this._clock,this._classes.clockAnimation)),setTimeout(()=>{this._wrapper.classList.remove(\"animate-[fade-out_350ms_ease-in-out]\",\"animate-[fade-in_350ms_ease-in-out]\")},351)}_addActiveClassToTip(t,e){t.forEach(s=>{Number(s.textContent)===Number(e)&&(v.addClass(s,this._classes.tipsActive),s.setAttribute(J,\"\"))})}_setHourOrMinute(t){return t<10?`0${t}`:t}_appendTimes(){const{format24:t}=this._options;if(t){this._getAppendClock(this.hoursArray,`[${mi}]`,ft),this._getAppendClock(this.innerHours,`[${$s}]`,Rt);return}this._getAppendClock(this.hoursArray,`[${mi}]`,ft)}_getConfig(t){const e=v.getDataAttributes(this._element);return t={...q0,...e,...t},W(Ns,t,Z0),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Q0,...e,...t},W(Ns,t,J0),t}_getContainer(){return g.findOne(this._options.container)}_getValidate(t){const{invalidLabel:e,format24:s,format12:n,appendValidationInfo:o}=this._options;let r;o&&(r=z(\"div\"),r.setAttribute(ed,\"\"),r.innerHTML=e),si.on(this.input,t,({target:a})=>{if(this._options===null||this.input.value===\"\")return;const l=/^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/,c=/^([01]\\d|2[0-3])(:[0-5]\\d)$/,h=l.test(a.value);if(c.test(a.value)!==!0&&s||h!==!0&&n){o&&(this.input.setAttribute(xa,\"\"),this.input.parentNode.insertBefore(r,this.input.nextSibling)),v.addStyle(a,{marginBottom:0}),v.addStyle(r,{bottom:\"-23px\"}),this._isInvalidTimeFormat=!0;return}this.input.removeAttribute(xa),this._isInvalidTimeFormat=!1;const u=g.findOne(`[${ed}]`);u!==null&&u.remove()})}static getInstance(t){return P.getData(t,mo)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}/*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */function pe(i){return getComputedStyle(i)}function At(i,t){for(var e in t){var s=t[e];typeof s==\"number\"&&(s=s+\"px\"),i.style[e]=s}return i}function To(i){var t=document.createElement(\"div\");return t.className=i,t}var rd=typeof Element<\"u\"&&(Element.prototype.matches||Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector);function We(i,t){if(!rd)throw new Error(\"No element matching method supported\");return rd.call(i,t)}function es(i){i.remove?i.remove():i.parentNode&&i.parentNode.removeChild(i)}function ad(i,t){return Array.prototype.filter.call(i.children,function(e){return We(e,t)})}var at={main:\"ps\",rtl:\"ps__rtl\",element:{thumb:function(i){return\"ps__thumb-\"+i},rail:function(i){return\"ps__rail-\"+i},consuming:\"ps__child--consume\"},state:{focus:\"ps--focus\",clicking:\"ps--clicking\",active:function(i){return\"ps--active-\"+i},scrolling:function(i){return\"ps--scrolling-\"+i}}},ld={x:null,y:null};function cd(i,t){var e=i.element.classList,s=at.state.scrolling(t);e.contains(s)?clearTimeout(ld[t]):e.add(s)}function hd(i,t){ld[t]=setTimeout(function(){return i.isAlive&&i.element.classList.remove(at.state.scrolling(t))},i.settings.scrollingThreshold)}function ty(i,t){cd(i,t),hd(i,t)}var Bs=function(t){this.element=t,this.handlers={}},dd={isEmpty:{configurable:!0}};Bs.prototype.bind=function(t,e){typeof this.handlers[t]>\"u\"&&(this.handlers[t]=[]),this.handlers[t].push(e),this.element.addEventListener(t,e,!1)},Bs.prototype.unbind=function(t,e){var s=this;this.handlers[t]=this.handlers[t].filter(function(n){return e&&n!==e?!0:(s.element.removeEventListener(t,n,!1),!1)})},Bs.prototype.unbindAll=function(){for(var t in this.handlers)this.unbind(t)},dd.isEmpty.get=function(){var i=this;return Object.keys(this.handlers).every(function(t){return i.handlers[t].length===0})},Object.defineProperties(Bs.prototype,dd);var is=function(){this.eventElements=[]};is.prototype.eventElement=function(t){var e=this.eventElements.filter(function(s){return s.element===t})[0];return e||(e=new Bs(t),this.eventElements.push(e)),e},is.prototype.bind=function(t,e,s){this.eventElement(t).bind(e,s)},is.prototype.unbind=function(t,e,s){var n=this.eventElement(t);n.unbind(e,s),n.isEmpty&&this.eventElements.splice(this.eventElements.indexOf(n),1)},is.prototype.unbindAll=function(){this.eventElements.forEach(function(t){return t.unbindAll()}),this.eventElements=[]},is.prototype.once=function(t,e,s){var n=this.eventElement(t),o=function(r){n.unbind(e,o),s(r)};n.bind(e,o)};function Ao(i){if(typeof window.CustomEvent==\"function\")return new CustomEvent(i);var t=document.createEvent(\"CustomEvent\");return t.initCustomEvent(i,!1,!1,void 0),t}function wo(i,t,e,s,n){s===void 0&&(s=!0),n===void 0&&(n=!1);var o;if(t===\"top\")o=[\"contentHeight\",\"containerHeight\",\"scrollTop\",\"y\",\"up\",\"down\"];else if(t===\"left\")o=[\"contentWidth\",\"containerWidth\",\"scrollLeft\",\"x\",\"left\",\"right\"];else throw new Error(\"A proper axis should be provided\");ey(i,e,o,s,n)}function ey(i,t,e,s,n){var o=e[0],r=e[1],a=e[2],l=e[3],c=e[4],h=e[5];s===void 0&&(s=!0),n===void 0&&(n=!1);var d=i.element;i.reach[l]=null,d[a]<1&&(i.reach[l]=\"start\"),d[a]>i[o]-i[r]-1&&(i.reach[l]=\"end\"),t&&(d.dispatchEvent(Ao(\"ps-scroll-\"+l)),t<0?d.dispatchEvent(Ao(\"ps-scroll-\"+c)):t>0&&d.dispatchEvent(Ao(\"ps-scroll-\"+h)),s&&ty(i,l)),i.reach[l]&&(t||n)&&d.dispatchEvent(Ao(\"ps-\"+l+\"-reach-\"+i.reach[l]))}function it(i){return parseInt(i,10)||0}function iy(i){return We(i,\"input,[contenteditable]\")||We(i,\"select,[contenteditable]\")||We(i,\"textarea,[contenteditable]\")||We(i,\"button,[contenteditable]\")}function sy(i){var t=pe(i);return it(t.width)+it(t.paddingLeft)+it(t.paddingRight)+it(t.borderLeftWidth)+it(t.borderRightWidth)}var ss={isWebKit:typeof document<\"u\"&&\"WebkitAppearance\"in document.documentElement.style,supportsTouch:typeof window<\"u\"&&(\"ontouchstart\"in window||\"maxTouchPoints\"in window.navigator&&window.navigator.maxTouchPoints>0||window.DocumentTouch&&document instanceof window.DocumentTouch),supportsIePointer:typeof navigator<\"u\"&&navigator.msMaxTouchPoints,isChrome:typeof navigator<\"u\"&&/Chrome/i.test(navigator&&navigator.userAgent)};function Ce(i){var t=i.element,e=Math.floor(t.scrollTop),s=t.getBoundingClientRect();i.containerWidth=Math.round(s.width),i.containerHeight=Math.round(s.height),i.contentWidth=t.scrollWidth,i.contentHeight=t.scrollHeight,t.contains(i.scrollbarXRail)||(ad(t,at.element.rail(\"x\")).forEach(function(n){return es(n)}),t.appendChild(i.scrollbarXRail)),t.contains(i.scrollbarYRail)||(ad(t,at.element.rail(\"y\")).forEach(function(n){return es(n)}),t.appendChild(i.scrollbarYRail)),!i.settings.suppressScrollX&&i.containerWidth+i.settings.scrollXMarginOffset<i.contentWidth?(i.scrollbarXActive=!0,i.railXWidth=i.containerWidth-i.railXMarginWidth,i.railXRatio=i.containerWidth/i.railXWidth,i.scrollbarXWidth=ud(i,it(i.railXWidth*i.containerWidth/i.contentWidth)),i.scrollbarXLeft=it((i.negativeScrollAdjustment+t.scrollLeft)*(i.railXWidth-i.scrollbarXWidth)/(i.contentWidth-i.containerWidth))):i.scrollbarXActive=!1,!i.settings.suppressScrollY&&i.containerHeight+i.settings.scrollYMarginOffset<i.contentHeight?(i.scrollbarYActive=!0,i.railYHeight=i.containerHeight-i.railYMarginHeight,i.railYRatio=i.containerHeight/i.railYHeight,i.scrollbarYHeight=ud(i,it(i.railYHeight*i.containerHeight/i.contentHeight)),i.scrollbarYTop=it(e*(i.railYHeight-i.scrollbarYHeight)/(i.contentHeight-i.containerHeight))):i.scrollbarYActive=!1,i.scrollbarXLeft>=i.railXWidth-i.scrollbarXWidth&&(i.scrollbarXLeft=i.railXWidth-i.scrollbarXWidth),i.scrollbarYTop>=i.railYHeight-i.scrollbarYHeight&&(i.scrollbarYTop=i.railYHeight-i.scrollbarYHeight),ny(t,i),i.scrollbarXActive?t.classList.add(at.state.active(\"x\")):(t.classList.remove(at.state.active(\"x\")),i.scrollbarXWidth=0,i.scrollbarXLeft=0,t.scrollLeft=i.isRtl===!0?i.contentWidth:0),i.scrollbarYActive?t.classList.add(at.state.active(\"y\")):(t.classList.remove(at.state.active(\"y\")),i.scrollbarYHeight=0,i.scrollbarYTop=0,t.scrollTop=0)}function ud(i,t){return i.settings.minScrollbarLength&&(t=Math.max(t,i.settings.minScrollbarLength)),i.settings.maxScrollbarLength&&(t=Math.min(t,i.settings.maxScrollbarLength)),t}function ny(i,t){var e={width:t.railXWidth},s=Math.floor(i.scrollTop);t.isRtl?e.left=t.negativeScrollAdjustment+i.scrollLeft+t.containerWidth-t.contentWidth:e.left=i.scrollLeft,t.isScrollbarXUsingBottom?e.bottom=t.scrollbarXBottom-s:e.top=t.scrollbarXTop+s,At(t.scrollbarXRail,e);var n={top:s,height:t.railYHeight};t.isScrollbarYUsingRight?t.isRtl?n.right=t.contentWidth-(t.negativeScrollAdjustment+i.scrollLeft)-t.scrollbarYRight-t.scrollbarYOuterWidth-9:n.right=t.scrollbarYRight-i.scrollLeft:t.isRtl?n.left=t.negativeScrollAdjustment+i.scrollLeft+t.containerWidth*2-t.contentWidth-t.scrollbarYLeft-t.scrollbarYOuterWidth:n.left=t.scrollbarYLeft+i.scrollLeft,At(t.scrollbarYRail,n),At(t.scrollbarX,{left:t.scrollbarXLeft,width:t.scrollbarXWidth-t.railBorderXWidth}),At(t.scrollbarY,{top:t.scrollbarYTop,height:t.scrollbarYHeight-t.railBorderYWidth})}function oy(i){i.element,i.event.bind(i.scrollbarY,\"mousedown\",function(t){return t.stopPropagation()}),i.event.bind(i.scrollbarYRail,\"mousedown\",function(t){var e=t.pageY-window.pageYOffset-i.scrollbarYRail.getBoundingClientRect().top,s=e>i.scrollbarYTop?1:-1;i.element.scrollTop+=s*i.containerHeight,Ce(i),t.stopPropagation()}),i.event.bind(i.scrollbarX,\"mousedown\",function(t){return t.stopPropagation()}),i.event.bind(i.scrollbarXRail,\"mousedown\",function(t){var e=t.pageX-window.pageXOffset-i.scrollbarXRail.getBoundingClientRect().left,s=e>i.scrollbarXLeft?1:-1;i.element.scrollLeft+=s*i.containerWidth,Ce(i),t.stopPropagation()})}function ry(i){fd(i,[\"containerWidth\",\"contentWidth\",\"pageX\",\"railXWidth\",\"scrollbarX\",\"scrollbarXWidth\",\"scrollLeft\",\"x\",\"scrollbarXRail\"]),fd(i,[\"containerHeight\",\"contentHeight\",\"pageY\",\"railYHeight\",\"scrollbarY\",\"scrollbarYHeight\",\"scrollTop\",\"y\",\"scrollbarYRail\"])}function fd(i,t){var e=t[0],s=t[1],n=t[2],o=t[3],r=t[4],a=t[5],l=t[6],c=t[7],h=t[8],d=i.element,u=null,f=null,p=null;function _(x){x.touches&&x.touches[0]&&(x[n]=x.touches[0].pageY),d[l]=u+p*(x[n]-f),cd(i,c),Ce(i),x.stopPropagation(),x.type.startsWith(\"touch\")&&x.changedTouches.length>1&&x.preventDefault()}function m(){hd(i,c),i[h].classList.remove(at.state.clicking),i.event.unbind(i.ownerDocument,\"mousemove\",_)}function y(x,E){u=d[l],E&&x.touches&&(x[n]=x.touches[0].pageY),f=x[n],p=(i[s]-i[e])/(i[o]-i[a]),E?i.event.bind(i.ownerDocument,\"touchmove\",_):(i.event.bind(i.ownerDocument,\"mousemove\",_),i.event.once(i.ownerDocument,\"mouseup\",m),x.preventDefault()),i[h].classList.add(at.state.clicking),x.stopPropagation()}i.event.bind(i[r],\"mousedown\",function(x){y(x)}),i.event.bind(i[r],\"touchstart\",function(x){y(x,!0)})}function ay(i){var t=i.element,e=function(){return We(t,\":hover\")},s=function(){return We(i.scrollbarX,\":focus\")||We(i.scrollbarY,\":focus\")};function n(o,r){var a=Math.floor(t.scrollTop);if(o===0){if(!i.scrollbarYActive)return!1;if(a===0&&r>0||a>=i.contentHeight-i.containerHeight&&r<0)return!i.settings.wheelPropagation}var l=t.scrollLeft;if(r===0){if(!i.scrollbarXActive)return!1;if(l===0&&o<0||l>=i.contentWidth-i.containerWidth&&o>0)return!i.settings.wheelPropagation}return!0}i.event.bind(i.ownerDocument,\"keydown\",function(o){if(!(o.isDefaultPrevented&&o.isDefaultPrevented()||o.defaultPrevented)&&!(!e()&&!s())){var r=document.activeElement?document.activeElement:i.ownerDocument.activeElement;if(r){if(r.tagName===\"IFRAME\")r=r.contentDocument.activeElement;else for(;r.shadowRoot;)r=r.shadowRoot.activeElement;if(iy(r))return}var a=0,l=0;switch(o.which){case 37:o.metaKey?a=-i.contentWidth:o.altKey?a=-i.containerWidth:a=-30;break;case 38:o.metaKey?l=i.contentHeight:o.altKey?l=i.containerHeight:l=30;break;case 39:o.metaKey?a=i.contentWidth:o.altKey?a=i.containerWidth:a=30;break;case 40:o.metaKey?l=-i.contentHeight:o.altKey?l=-i.containerHeight:l=-30;break;case 32:o.shiftKey?l=i.containerHeight:l=-i.containerHeight;break;case 33:l=i.containerHeight;break;case 34:l=-i.containerHeight;break;case 36:l=i.contentHeight;break;case 35:l=-i.contentHeight;break;default:return}i.settings.suppressScrollX&&a!==0||i.settings.suppressScrollY&&l!==0||(t.scrollTop-=l,t.scrollLeft+=a,Ce(i),n(a,l)&&o.preventDefault())}})}function ly(i){var t=i.element;function e(r,a){var l=Math.floor(t.scrollTop),c=t.scrollTop===0,h=l+t.offsetHeight===t.scrollHeight,d=t.scrollLeft===0,u=t.scrollLeft+t.offsetWidth===t.scrollWidth,f;return Math.abs(a)>Math.abs(r)?f=c||h:f=d||u,f?!i.settings.wheelPropagation:!0}function s(r){var a=r.deltaX,l=-1*r.deltaY;return(typeof a>\"u\"||typeof l>\"u\")&&(a=-1*r.wheelDeltaX/6,l=r.wheelDeltaY/6),r.deltaMode&&r.deltaMode===1&&(a*=10,l*=10),a!==a&&l!==l&&(a=0,l=r.wheelDelta),r.shiftKey?[-l,-a]:[a,l]}function n(r,a,l){if(!ss.isWebKit&&t.querySelector(\"select:focus\"))return!0;if(!t.contains(r))return!1;for(var c=r;c&&c!==t;){if(c.classList.contains(at.element.consuming))return!0;var h=pe(c);if(l&&h.overflowY.match(/(scroll|auto)/)){var d=c.scrollHeight-c.clientHeight;if(d>0&&(c.scrollTop>0&&l<0||c.scrollTop<d&&l>0))return!0}if(a&&h.overflowX.match(/(scroll|auto)/)){var u=c.scrollWidth-c.clientWidth;if(u>0&&(c.scrollLeft>0&&a<0||c.scrollLeft<u&&a>0))return!0}c=c.parentNode}return!1}function o(r){var a=s(r),l=a[0],c=a[1];if(!n(r.target,l,c)){var h=!1;i.settings.useBothWheelAxes?i.scrollbarYActive&&!i.scrollbarXActive?(c?t.scrollTop-=c*i.settings.wheelSpeed:t.scrollTop+=l*i.settings.wheelSpeed,h=!0):i.scrollbarXActive&&!i.scrollbarYActive&&(l?t.scrollLeft+=l*i.settings.wheelSpeed:t.scrollLeft-=c*i.settings.wheelSpeed,h=!0):(t.scrollTop-=c*i.settings.wheelSpeed,t.scrollLeft+=l*i.settings.wheelSpeed),Ce(i),h=h||e(l,c),h&&!r.ctrlKey&&(r.stopPropagation(),r.preventDefault())}}typeof window.onwheel<\"u\"?i.event.bind(t,\"wheel\",o):typeof window.onmousewheel<\"u\"&&i.event.bind(t,\"mousewheel\",o)}function cy(i){if(!ss.supportsTouch&&!ss.supportsIePointer)return;var t=i.element;function e(p,_){var m=Math.floor(t.scrollTop),y=t.scrollLeft,x=Math.abs(p),E=Math.abs(_);if(E>x){if(_<0&&m===i.contentHeight-i.containerHeight||_>0&&m===0)return window.scrollY===0&&_>0&&ss.isChrome}else if(x>E&&(p<0&&y===i.contentWidth-i.containerWidth||p>0&&y===0))return!0;return!0}function s(p,_){t.scrollTop-=_,t.scrollLeft-=p,Ce(i)}var n={},o=0,r={},a=null;function l(p){return p.targetTouches?p.targetTouches[0]:p}function c(p){return p.pointerType&&p.pointerType===\"pen\"&&p.buttons===0?!1:!!(p.targetTouches&&p.targetTouches.length===1||p.pointerType&&p.pointerType!==\"mouse\"&&p.pointerType!==p.MSPOINTER_TYPE_MOUSE)}function h(p){if(c(p)){var _=l(p);n.pageX=_.pageX,n.pageY=_.pageY,o=new Date().getTime(),a!==null&&clearInterval(a)}}function d(p,_,m){if(!t.contains(p))return!1;for(var y=p;y&&y!==t;){if(y.classList.contains(at.element.consuming))return!0;var x=pe(y);if(m&&x.overflowY.match(/(scroll|auto)/)){var E=y.scrollHeight-y.clientHeight;if(E>0&&(y.scrollTop>0&&m<0||y.scrollTop<E&&m>0))return!0}if(_&&x.overflowX.match(/(scroll|auto)/)){var C=y.scrollWidth-y.clientWidth;if(C>0&&(y.scrollLeft>0&&_<0||y.scrollLeft<C&&_>0))return!0}y=y.parentNode}return!1}function u(p){if(c(p)){var _=l(p),m={pageX:_.pageX,pageY:_.pageY},y=m.pageX-n.pageX,x=m.pageY-n.pageY;if(d(p.target,y,x))return;s(y,x),n=m;var E=new Date().getTime(),C=E-o;C>0&&(r.x=y/C,r.y=x/C,o=E),e(y,x)&&p.preventDefault()}}function f(){i.settings.swipeEasing&&(clearInterval(a),a=setInterval(function(){if(i.isInitialized){clearInterval(a);return}if(!r.x&&!r.y){clearInterval(a);return}if(Math.abs(r.x)<.01&&Math.abs(r.y)<.01){clearInterval(a);return}if(!i.element){clearInterval(a);return}s(r.x*30,r.y*30),r.x*=.8,r.y*=.8},10))}ss.supportsTouch?(i.event.bind(t,\"touchstart\",h),i.event.bind(t,\"touchmove\",u),i.event.bind(t,\"touchend\",f)):ss.supportsIePointer&&(window.PointerEvent?(i.event.bind(t,\"pointerdown\",h),i.event.bind(t,\"pointermove\",u),i.event.bind(t,\"pointerup\",f)):window.MSPointerEvent&&(i.event.bind(t,\"MSPointerDown\",h),i.event.bind(t,\"MSPointerMove\",u),i.event.bind(t,\"MSPointerUp\",f)))}var hy=function(){return{handlers:[\"click-rail\",\"drag-thumb\",\"keyboard\",\"wheel\",\"touch\"],maxScrollbarLength:null,minScrollbarLength:null,scrollingThreshold:1e3,scrollXMarginOffset:0,scrollYMarginOffset:0,suppressScrollX:!1,suppressScrollY:!1,swipeEasing:!0,useBothWheelAxes:!1,wheelPropagation:!0,wheelSpeed:1}},dy={\"click-rail\":oy,\"drag-thumb\":ry,keyboard:ay,wheel:ly,touch:cy},Hs=function(t,e){var s=this;if(e===void 0&&(e={}),typeof t==\"string\"&&(t=document.querySelector(t)),!t||!t.nodeName)throw new Error(\"no element is specified to initialize PerfectScrollbar\");this.element=t,t.classList.add(at.main),this.settings=hy();for(var n in e)this.settings[n]=e[n];this.containerWidth=null,this.containerHeight=null,this.contentWidth=null,this.contentHeight=null;var o=function(){return t.classList.add(at.state.focus)},r=function(){return t.classList.remove(at.state.focus)};this.isRtl=pe(t).direction===\"rtl\",this.isRtl===!0&&t.classList.add(at.rtl),this.isNegativeScroll=function(){var c=t.scrollLeft,h=null;return t.scrollLeft=-1,h=t.scrollLeft<0,t.scrollLeft=c,h}(),this.negativeScrollAdjustment=this.isNegativeScroll?t.scrollWidth-t.clientWidth:0,this.event=new is,this.ownerDocument=t.ownerDocument||document,this.scrollbarXRail=To(at.element.rail(\"x\")),t.appendChild(this.scrollbarXRail),this.scrollbarX=To(at.element.thumb(\"x\")),this.scrollbarXRail.appendChild(this.scrollbarX),this.scrollbarX.setAttribute(\"tabindex\",0),this.event.bind(this.scrollbarX,\"focus\",o),this.event.bind(this.scrollbarX,\"blur\",r),this.scrollbarXActive=null,this.scrollbarXWidth=null,this.scrollbarXLeft=null;var a=pe(this.scrollbarXRail);this.scrollbarXBottom=parseInt(a.bottom,10),isNaN(this.scrollbarXBottom)?(this.isScrollbarXUsingBottom=!1,this.scrollbarXTop=it(a.top)):this.isScrollbarXUsingBottom=!0,this.railBorderXWidth=it(a.borderLeftWidth)+it(a.borderRightWidth),At(this.scrollbarXRail,{display:\"block\"}),this.railXMarginWidth=it(a.marginLeft)+it(a.marginRight),At(this.scrollbarXRail,{display:\"\"}),this.railXWidth=null,this.railXRatio=null,this.scrollbarYRail=To(at.element.rail(\"y\")),t.appendChild(this.scrollbarYRail),this.scrollbarY=To(at.element.thumb(\"y\")),this.scrollbarYRail.appendChild(this.scrollbarY),this.scrollbarY.setAttribute(\"tabindex\",0),this.event.bind(this.scrollbarY,\"focus\",o),this.event.bind(this.scrollbarY,\"blur\",r),this.scrollbarYActive=null,this.scrollbarYHeight=null,this.scrollbarYTop=null;var l=pe(this.scrollbarYRail);this.scrollbarYRight=parseInt(l.right,10),isNaN(this.scrollbarYRight)?(this.isScrollbarYUsingRight=!1,this.scrollbarYLeft=it(l.left)):this.isScrollbarYUsingRight=!0,this.scrollbarYOuterWidth=this.isRtl?sy(this.scrollbarY):null,this.railBorderYWidth=it(l.borderTopWidth)+it(l.borderBottomWidth),At(this.scrollbarYRail,{display:\"block\"}),this.railYMarginHeight=it(l.marginTop)+it(l.marginBottom),At(this.scrollbarYRail,{display:\"\"}),this.railYHeight=null,this.railYRatio=null,this.reach={x:t.scrollLeft<=0?\"start\":t.scrollLeft>=this.contentWidth-this.containerWidth?\"end\":null,y:t.scrollTop<=0?\"start\":t.scrollTop>=this.contentHeight-this.containerHeight?\"end\":null},this.isAlive=!0,this.settings.handlers.forEach(function(c){return dy[c](s)}),this.lastScrollTop=Math.floor(t.scrollTop),this.lastScrollLeft=t.scrollLeft,this.event.bind(this.element,\"scroll\",function(c){return s.onScroll(c)}),Ce(this)};Hs.prototype.update=function(){this.isAlive&&(this.negativeScrollAdjustment=this.isNegativeScroll?this.element.scrollWidth-this.element.clientWidth:0,At(this.scrollbarXRail,{display:\"block\"}),At(this.scrollbarYRail,{display:\"block\"}),this.railXMarginWidth=it(pe(this.scrollbarXRail).marginLeft)+it(pe(this.scrollbarXRail).marginRight),this.railYMarginHeight=it(pe(this.scrollbarYRail).marginTop)+it(pe(this.scrollbarYRail).marginBottom),At(this.scrollbarXRail,{display:\"none\"}),At(this.scrollbarYRail,{display:\"none\"}),Ce(this),wo(this,\"top\",0,!1,!0),wo(this,\"left\",0,!1,!0),At(this.scrollbarXRail,{display:\"\"}),At(this.scrollbarYRail,{display:\"\"}))},Hs.prototype.onScroll=function(t){this.isAlive&&(Ce(this),wo(this,\"top\",this.element.scrollTop-this.lastScrollTop),wo(this,\"left\",this.element.scrollLeft-this.lastScrollLeft),this.lastScrollTop=Math.floor(this.element.scrollTop),this.lastScrollLeft=this.element.scrollLeft)},Hs.prototype.destroy=function(){this.isAlive&&(this.event.unbindAll(),es(this.scrollbarX),es(this.scrollbarY),es(this.scrollbarXRail),es(this.scrollbarYRail),this.removePsClasses(),this.element=null,this.scrollbarX=null,this.scrollbarY=null,this.scrollbarXRail=null,this.scrollbarYRail=null,this.isAlive=!1)},Hs.prototype.removePsClasses=function(){this.element.className=this.element.className.split(\" \").filter(function(t){return!t.match(/^ps([-_].+|)$/)}).join(\" \")};const uy={threshold:10,direction:\"all\"};class fy{constructor(t,e){this._element=t,this._startPosition=null,this._options={...uy,...e}}handleTouchStart(t){this._startPosition=this._getCoordinates(t)}handleTouchMove(t){if(!this._startPosition)return;const e=this._getCoordinates(t),s={x:e.x-this._startPosition.x,y:e.y-this._startPosition.y},n=this._getDirection(s);if(this._options.direction===\"all\"){if(n.y.value<this._options.threshold&&n.x.value<this._options.threshold)return;const r=n.y.value>n.x.value?n.y.direction:n.x.direction;b.trigger(this._element,`swipe${r}`),b.trigger(this._element,\"swipe\",{direction:r}),this._startPosition=null;return}const o=this._options.direction===\"left\"||this._options===\"right\"?\"x\":\"y\";n[o].direction===this._options.direction&&n[o].value>this._options.threshold&&(b.trigger(this._element,`swipe${n[o].direction}`),this._startPosition=null)}handleTouchEnd(){this._startPosition=null}_getCoordinates(t){const[e]=t.touches;return{x:e.clientX,y:e.clientY}}_getDirection(t){return{x:{direction:t.x<0?\"left\":\"right\",value:Math.abs(t.x)},y:{direction:t.y<0?\"up\":\"down\",value:Math.abs(t.y)}}}}class py{constructor(t,e=\"swipe\",s={}){this._element=t,this._event=e,this.swipe=new fy(t,s),this._touchStartHandler=this._handleTouchStart.bind(this),this._touchMoveHandler=this._handleTouchMove.bind(this),this._touchEndHandler=this._handleTouchEnd.bind(this)}dispose(){this._element.removeEventListener(\"touchstart\",this._touchStartHandler),this._element.removeEventListener(\"touchmove\",this._touchMoveHandler),window.removeEventListener(\"touchend\",this._touchEndHandler)}init(){this._element.addEventListener(\"touchstart\",t=>this._handleTouchStart(t)),this._element.addEventListener(\"touchmove\",t=>this._handleTouchMove(t)),window.addEventListener(\"touchend\",t=>this._handleTouchEnd(t))}_handleTouchStart(t){this[this._event].handleTouchStart(t)}_handleTouchMove(t){this[this._event].handleTouchMove(t)}_handleTouchEnd(t){this[this._event].handleTouchEnd(t)}}const _y=\"group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none\",gy=\"group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\",my=\"absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none\",by=\"group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\",vy=\"absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none\",yy=(i=document)=>{[{ps:\"ps__rail-x\",te:gy},{ps:\"ps__rail-y\",te:by},{ps:\"ps__thumb-x\",te:my},{ps:\"ps__thumb-y\",te:vy}].forEach(e=>{v.addClass(g.findOne(`.${e.ps}`,i),e.te),v.removeClass(g.findOne(`.${e.ps}`,i),e.ps)}),v.addClass(i,_y),v.removeClass(i,\"ps\")},pd=\"sidenav\",ko=\"te.sidenav\",xy=\"data-te-sidenav-rotate-icon-ref\",wa=\"[data-te-sidenav-toggle-ref]\",Ey=\"[data-te-collapse-init]\",Cy='[data-te-sidenav-slim=\"true\"]',Ty='[data-te-sidenav-slim=\"false\"]',Ay=\"[data-te-sidenav-menu-ref]\",ns=\"[data-te-sidenav-collapse-ref]\",Fs=\"[data-te-sidenav-link-ref]\",wy=st()?100:-100,ky=st()?-100:100,Sy={sidenavAccordion:\"(boolean)\",sidenavBackdrop:\"(boolean)\",sidenavBackdropClass:\"(null|string)\",sidenavCloseOnEsc:\"(boolean)\",sidenavColor:\"(string)\",sidenavContent:\"(null|string)\",sidenavExpandable:\"(boolean)\",sidenavExpandOnHover:\"(boolean)\",sidenavFocusTrap:\"(boolean)\",sidenavHidden:\"(boolean)\",sidenavMode:\"(string)\",sidenavModeBreakpointOver:\"(null|string|number)\",sidenavModeBreakpointSide:\"(null|string|number)\",sidenavModeBreakpointPush:\"(null|string|number)\",sidenavBreakpointSm:\"(number)\",sidenavBreakpointMd:\"(number)\",sidenavBreakpointLg:\"(number)\",sidenavBreakpointXl:\"(number)\",sidenavBreakpoint2xl:\"(number)\",sidenavScrollContainer:\"(null|string)\",sidenavSlim:\"(boolean)\",sidenavSlimCollapsed:\"(boolean)\",sidenavSlimWidth:\"(number)\",sidenavPosition:\"(string)\",sidenavRight:\"(boolean)\",sidenavTransitionDuration:\"(number)\",sidenavWidth:\"(number)\"},Oy={sidenavAccordion:!1,sidenavBackdrop:!0,sidenavBackdropClass:null,sidenavCloseOnEsc:!0,sidenavColor:\"primary\",sidenavContent:null,sidenavExpandable:!0,sidenavExpandOnHover:!1,sidenavFocusTrap:!0,sidenavHidden:!0,sidenavMode:\"over\",sidenavModeBreakpointOver:null,sidenavModeBreakpointSide:null,sidenavModeBreakpointPush:null,sidenavBreakpointSm:640,sidenavBreakpointMd:768,sidenavBreakpointLg:1024,sidenavBreakpointXl:1280,sidenavBreakpoint2xl:1536,sidenavScrollContainer:null,sidenavSlim:!1,sidenavSlimCollapsed:!1,sidenavSlimWidth:77,sidenavPosition:\"fixed\",sidenavRight:!1,sidenavTransitionDuration:300,sidenavWidth:240};class bi{constructor(t,e={}){Ee(this,\"_addBackdropOnInit\",()=>{this._options.sidenavHidden||(this._backdrop.show(),b.off(this._element,\"transitionend\",this._addBackdropOnInit))});this._element=t,this._options=e,this._ID=se(\"\"),this._content=null,this._initialContentStyle=null,this._slimCollapsed=!1,this._activeNode=null,this._tempSlim=!1,this._backdrop=this._initializeBackDrop(),this._focusTrap=null,this._perfectScrollbar=null,this._touch=null,this._setModeFromBreakpoints(),this.escHandler=s=>{s.keyCode===ro&&this.toggler&&ne(this.toggler)&&(this._update(!1),b.off(window,\"keydown\",this.escHandler))},this.hashHandler=()=>{this._setActiveElements()},t&&(P.setData(t,ko,this),this._setup()),this.options.sidenavBackdrop&&!this.options.sidenavHidden&&this.options.sidenavMode===\"over\"&&b.on(this._element,\"transitionend\",this._addBackdropOnInit),this._didInit=!1,this._init()}static get NAME(){return pd}get container(){if(this.options.sidenavPosition===\"fixed\")return g.findOne(\"body\");const t=e=>!e.parentNode||e.parentNode===document?e:e.parentNode.style.position===\"relative\"||e.parentNode.classList.contains(\"relative\")?e.parentNode:t(e.parentNode);return t(this._element)}get isVisible(){let t=0,e=window.innerWidth;if(this.options.sidenavPosition!==\"fixed\"){const n=this.container.getBoundingClientRect();t=n.x,e=n.x+n.width}const{x:s}=this._element.getBoundingClientRect();return this.options.sidenavRight?Math.abs(s-e)>10:Math.abs(s-t)<10}get links(){return g.find(Fs,this._element)}get navigation(){return g.find(Ay,this._element)}get options(){const t={...Oy,...v.getDataAttributes(this._element),...this._options};return W(pd,t,Sy),t}get sidenavStyle(){return{width:`${this.width}px`,height:this.options.sidenavPosition===\"fixed\"?\"100vh\":\"100%\",position:this.options.sidenavPosition,transition:`all ${this.transitionDuration} linear`}}get toggler(){return g.find(wa).find(e=>{const s=v.getDataAttribute(e,\"target\");return g.findOne(s)===this._element})}get transitionDuration(){return`${this.options.sidenavTransitionDuration/1e3}s`}get translation(){return this.options.sidenavRight?ky:wy}get width(){return this._slimCollapsed?this.options.sidenavSlimWidth:this.options.sidenavWidth}get isBackdropVisible(){return!!this._backdrop._element}changeMode(t){this._setMode(t)}dispose(){b.off(window,\"keydown\",this.escHandler),this.options.sidenavBackdrop&&this._backdrop.dispose(),b.off(window,\"hashchange\",this.hashHandler),this._touch.dispose(),P.removeData(this._element,ko),this._element=null}hide(){this._emitEvents(!1),this._update(!1),this._options.sidenavBackdrop&&this.isBackdropVisible&&this._backdrop.hide()}show(){this._emitEvents(!0),this._update(!0),this._options.sidenavBackdrop&&this._options.sidenavMode===\"over\"&&this._backdrop.show()}toggle(){this._emitEvents(!this.isVisible),this._update(!this.isVisible)}toggleSlim(){this._setSlim(!this._slimCollapsed)}update(t){this._options=t,this._setup()}getBreakpoint(t){return this._transformBreakpointValuesToObject()[t]}_init(){this._didInit||(b.on(document,\"click\",wa,bi.toggleSidenav()),this._didInit=!0)}_transformBreakpointValuesToObject(){return{sm:this.options.sidenavBreakpointSm,md:this.options.sidenavBreakpointMd,lg:this.options.sidenavBreakpointLg,xl:this.options.sidenavBreakpointXl,\"2xl\":this.options.sidenavBreakpoint2xl}}_setModeFromBreakpoints(){const t=window.innerWidth,e=this._transformBreakpointValuesToObject();if(t===void 0||!e)return;const s=typeof this.options.sidenavModeBreakpointOver==\"number\"?t-this.options.sidenavModeBreakpointOver:t-e[this.options.sidenavModeBreakpointOver],n=typeof this.options.sidenavModeBreakpointSide==\"number\"?t-this.options.sidenavModeBreakpointSide:t-e[this.options.sidenavModeBreakpointSide],o=typeof this.options.sidenavModeBreakpointPush==\"number\"?t-this.options.sidenavModeBreakpointPush:t-e[this.options.sidenavModeBreakpointPush],r=(l,c)=>l-c<0?-1:c-l<0?1:0,a=[s,n,o].filter(l=>l!=null&&l>=0).sort(r)[0];s>0&&s===a?(this._options.sidenavMode=\"over\",this._options.sidenavHidden=!0):n>0&&n===a?this._options.sidenavMode=\"side\":o>0&&o===a&&(this._options.sidenavMode=\"push\")}_collapseItems(){this.navigation.forEach(t=>{g.find(ns,t).forEach(s=>{re.getInstance(s).hide()})})}_getOffsetValue(t,{index:e,property:s,offsets:n}){const o=this._getPxValue(this._initialContentStyle[e][n[s].property]),r=t?n[s].value:0;return o+r}_getProperty(...t){return t.map((e,s)=>s===0?e:e[0].toUpperCase().concat(e.slice(1))).join(\"\")}_getPxValue(t){return t?parseFloat(t):0}_handleSwipe(t,e){e&&this._slimCollapsed&&this.options.sidenavSlim&&this.options.sidenavExpandable?this.toggleSlim():e||(this._slimCollapsed||!this.options.sidenavSlim||!this.options.sidenavExpandable?this.toggler&&ne(this.toggler)&&this.toggle():this.toggleSlim())}_isActive(t,e){return e?e===t:t.attributes.href?new URL(t,window.location.href).href===window.location.href:!1}_isAllToBeCollapsed(){return g.find(Ey,this._element).filter(s=>s.getAttribute(\"aria-expanded\")===\"true\").length===0}_isAllCollapsed(){return g.find(ns,this._element).filter(t=>ne(t)).length===0}_initializeBackDrop(){if(!this.options.sidenavBackdrop)return;const t=this.options.sidenavBackdropClass?this.options.sidenavBackdropClass.split(\" \"):this.options.sidenavPosition?[\"opacity-50\",\"transition-all\",\"duration-300\",\"ease-in-out\",this.options.sidenavPosition,\"top-0\",\"left-0\",\"z-50\",\"bg-black/10\",\"dark:bg-black-60\",\"w-full\",\"h-full\",this._element.id]:null;return new Xr({isVisible:this.options.sidenavBackdrop,isAnimated:!0,rootElement:this._element.parentNode,backdropClasses:t,clickCallback:()=>this.hide()})}_updateBackdrop(t){if(this.options.sidenavMode===\"over\"){t?this._backdrop.show():this.isBackdropVisible&&this._backdrop.hide();return}this.isBackdropVisible&&this._backdrop.hide()}_setup(){this._setupTouch(),this.options.sidenavFocusTrap&&this._setupFocusTrap(),this._setupCollapse(),this.options.sidenavSlim&&this._setupSlim(),this._setupInitialStyling(),this._setupScrolling(),this.options.sidenavContent&&this._setupContent(),this._setupActiveState(),this._setupRippleEffect(),this.options.sidenavHidden||this._updateOffsets(!0,!0),this.options.sidenavMode===\"over\"&&this._setTabindex(!0)}_setupActiveState(){this._setActiveElements(),this.links.forEach(t=>{b.on(t,\"click\",()=>this._setActiveElements(t)),b.on(t,\"keydown\",e=>{e.keyCode===Pt&&this._setActiveElements(t)})}),b.on(window,\"hashchange\",this.hashHandler)}_setupCollapse(){this.navigation.forEach((t,e)=>{g.find(ns,t).forEach((n,o)=>this._setupCollapseList({list:n,index:o,menu:t,menuIndex:e}))})}_generateCollpaseID(t,e){return`sidenav-collapse-${this._ID}-${e}-${t}`}_setupCollapseList({list:t,index:e,menu:s,menuIndex:n}){const o=this._generateCollpaseID(e,n);t.setAttribute(\"id\",o),t.setAttribute(\"data-te-collapse-item\",\"\");const[r]=g.prev(t,Fs);v.setDataAttribute(r,\"collapse-init\",\"\"),r.setAttribute(\"href\",`#${o}`),r.setAttribute(\"role\",\"button\");const a=re.getInstance(t)||new re(t,{toggle:!1,parent:this.options.sidenavAccordion?s:t});(t.dataset.teSidenavStateShow===\"\"||t.dataset.teCollapseShow===\"\")&&this._rotateArrow(r,!1),b.on(r,\"click\",l=>{this._toggleCategory(l,a,t),this._tempSlim&&this._isAllToBeCollapsed()&&(this._setSlim(!0),this._tempSlim=!1),this.options.sidenavMode===\"over\"&&this._focusTrap&&this._focusTrap.update()}),b.on(t,\"show.te.collapse\",()=>this._rotateArrow(r,!1)),b.on(t,\"hide.te.collapse\",()=>this._rotateArrow(r,!0)),b.on(t,\"shown.te.collapse\",()=>{this.options.sidenavMode===\"over\"&&this._focusTrap&&this._focusTrap.update()}),b.on(t,\"hidden.te.collapse\",()=>{this._tempSlim&&this._isAllCollapsed()&&(this._setSlim(!0),this._tempSlim=!1),this.options.sidenavMode===\"over\"&&this._focusTrap&&this._focusTrap.update()})}_setupContent(){this._content=g.find(this.options.sidenavContent),this._content.forEach(t=>{const e=[\"!p\",\"!m\",\"!px\",\"!pl\",\"!pr\",\"!mx\",\"!ml\",\"!mr\",\"!-p\",\"!-m\",\"!-px\",\"!-pl\",\"!-pr\",\"!-mx\",\"!-ml\",\"!-mr\"];[...t.classList].filter(n=>e.findIndex(o=>n.includes(o))>=0).forEach(n=>t.classList.remove(n))}),this._initialContentStyle=this._content.map(t=>{const{paddingLeft:e,paddingRight:s,marginLeft:n,marginRight:o,transition:r}=window.getComputedStyle(t);return{paddingLeft:e,paddingRight:s,marginLeft:n,marginRight:o,transition:r}})}_setupFocusTrap(){this._focusTrap=new Cs(this._element,{event:\"keydown\",condition:t=>t.keyCode===Rs,onlyVisible:!0},this.toggler)}_setupInitialStyling(){this._setColor(),v.style(this._element,this.sidenavStyle)}_setupScrolling(){let t=this._element;if(this.options.sidenavScrollContainer){t=g.findOne(this.options.sidenavScrollContainer,this._element);const s=qp(t.parentNode.children).filter(n=>n!==t).reduce((n,o)=>n+o.clientHeight,0);v.style(t,{maxHeight:`calc(100% - ${s}px)`,position:\"relative\"})}this._perfectScrollbar=new Hs(t,{suppressScrollX:!0,handlers:[\"click-rail\",\"drag-thumb\",\"wheel\",\"touch\"]}),yy(t)}_setupSlim(){this._slimCollapsed=this.options.sidenavSlimCollapsed,this._toggleSlimDisplay(this._slimCollapsed),this.options.sidenavExpandOnHover&&(this._element.addEventListener(\"mouseenter\",()=>{this._slimCollapsed&&this._setSlim(!1)}),this._element.addEventListener(\"mouseleave\",()=>{this._slimCollapsed||this._setSlim(!0)}))}_setupRippleEffect(){this.links.forEach(t=>{let e=Ui.getInstance(t),s=this.options.sidenavColor;if(e&&e._options.sidenavColor!==this.options.sidenavColor)e.dispose();else if(e)return;(localStorage.theme===\"dark\"||!(\"theme\"in localStorage)&&window.matchMedia(\"(prefers-color-scheme: dark)\").matches)&&(s=\"white\"),e=new Ui(t,{rippleColor:s})})}_setupTouch(){this._touch=new py(this._element,\"swipe\",{threshold:20}),this._touch.init(),b.on(this._element,\"swipeleft\",t=>this._handleSwipe(t,this.options.sidenavRight)),b.on(this._element,\"swiperight\",t=>this._handleSwipe(t,!this.options.sidenavRight))}_setActive(t,e){t.setAttribute(\"data-te-sidebar-state-active\",\"\"),this._activeNode&&t.removeAttribute(\"data-te-sidebar-state-active\"),this._activeNode=t;const[s]=g.parents(this._activeNode,ns);if(!s){this._setActiveCategory();return}const[n]=g.prev(s,Fs);this._setActiveCategory(n),!e&&!this._slimCollapsed&&re.getInstance(s).show()}_setActiveCategory(t){this.navigation.forEach(e=>{g.find(ns,e).forEach(n=>{const[o]=g.prev(n,Fs);o!==t?o.removeAttribute(\"data-te-sidenav-state-active\"):o.setAttribute(\"data-te-sidenav-state-active\",\"\")})})}_setActiveElements(t){this.navigation.forEach(e=>{g.find(Fs,e).filter(n=>g.next(n,ns).length===0).forEach(n=>{this._isActive(n,t)&&n!==this._activeNode&&this._setActive(n,t)})}),t&&this._updateFocus(this.isVisible)}_setColor(){const t=[\"primary\",\"secondary\",\"success\",\"info\",\"warning\",\"danger\",\"light\",\"dark\"],{sidenavColor:e}=this.options,s=t.includes(e)?e:\"primary\";t.forEach(n=>{this._element.classList.remove(`sidenav-${n}`)}),v.addClass(this._element,`sidenav-${s}`)}_setContentOffsets(t,e,s){this._content.forEach((n,o)=>{const r=this._getOffsetValue(t,{index:o,property:\"padding\",offsets:e}),a=this._getOffsetValue(t,{index:o,property:\"margin\",offsets:e}),l={};if(s||(l.transition=`all ${this.transitionDuration} linear`),l[e.padding.property]=`${r}px`,l[e.margin.property]=`${a}px`,v.style(n,l),!!t){if(s){v.style(n,{transition:this._initialContentStyle[o].transition});return}b.on(n,\"transitionend\",()=>{v.style(n,{transition:this._initialContentStyle[o].transition})})}})}_setMode(t){this.options.sidenavMode!==t&&(this._options.sidenavMode=t,this._update(this.isVisible))}_setSlim(t){const e=t?[\"collapse\",\"collapsed\"]:[\"expand\",\"expanded\"];this._triggerEvents(...e),t&&this._collapseItems(),this._slimCollapsed=t,this._toggleSlimDisplay(t),v.style(this._element,{width:`${this.width}px`}),this._updateOffsets(this.isVisible)}_setTabindex(t){this.links.forEach(e=>{e.tabIndex=t?0:-1})}_emitEvents(t){const e=t?[\"show\",\"shown\"]:[\"hide\",\"hidden\"];this._triggerEvents(...e)}_rotateArrow(t,e){const[s]=g.children(t,`[${xy}]`);s&&(e?v.removeClass(s,\"rotate-180\"):v.addClass(s,\"rotate-180\"))}_toggleCategory(t,e){t.preventDefault(),e.toggle(),this._slimCollapsed&&this.options.sidenavExpandable&&(this._tempSlim=!0,this._setSlim(!1))}_toggleSlimDisplay(t){const e=g.find(Cy,this._element),s=g.find(Ty,this._element),n=()=>{e.forEach(o=>{v.style(o,{display:this._slimCollapsed?\"unset\":\"none\"})}),s.forEach(o=>{v.style(o,{display:this._slimCollapsed?\"none\":\"unset\"})})};t?setTimeout(()=>n(),this.options.sidenavTransitionDuration):n()}async _triggerEvents(t,e){b.trigger(this._element,`${t}.te.sidenav`),e&&await setTimeout(()=>{b.trigger(this._element,`${e}.te.sidenav`)},this.options.sidenavTransitionDuration+5)}_update(t){this.toggler&&this._updateTogglerAria(t),this._updateDisplay(t),this.options.sidenavBackdrop&&this._updateBackdrop(t),this._updateOffsets(t),t&&this.options.sidenavCloseOnEsc&&this.options.sidenavMode!==\"side\"&&b.on(window,\"keydown\",this.escHandler),this.options.sidenavFocusTrap&&this._updateFocus(t)}_updateDisplay(t){const e=t?0:this.translation;v.style(this._element,{transform:`translateX(${e}%)`})}_updateFocus(t){if(this._setTabindex(t),this.options.sidenavMode===\"over\"&&this.options.sidenavFocusTrap){if(t){this._focusTrap.trap();return}this._focusTrap.disable()}this._focusTrap.disable()}_updateOffsets(t,e=!1){const[s,n]=this.options.sidenavRight?[\"right\",\"left\"]:[\"left\",\"right\"],o={property:this._getProperty(\"padding\",s),value:this.options.sidenavMode===\"over\"?0:this.width},r={property:this._getProperty(\"margin\",n),value:this.options.sidenavMode===\"push\"?-1*this.width:0};b.trigger(this._element,\"update.te.sidenav\",{margin:r,padding:o}),this._content&&(this._content.className=\"\",this._setContentOffsets(t,{padding:o,margin:r},e))}_updateTogglerAria(t){this.toggler.setAttribute(\"aria-expanded\",t)}static toggleSidenav(){return function(t){const e=g.closest(t.target,wa),s=v.getDataAttributes(e).target;g.find(s).forEach(n=>{(bi.getInstance(n)||new bi(n)).toggle()})}}static jQueryInterface(t,e){return this.each(function(){let s=P.getData(this,ko);const n=typeof t==\"object\"&&t;if(!(!s&&/dispose/.test(t))&&(s||(s=new bi(this,n)),typeof t==\"string\")){if(typeof s[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);s[t](e)}})}static getInstance(t){return P.getData(t,ko)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const ka=\"stepper\",So=\"te.stepper\",Oo=`.${So}`,Vs=`data-te-${ka}`,Ws=\"horizontal\",_e=\"vertical\",Dy={stepperType:\"string\",stepperLinear:\"boolean\",stepperNoEditable:\"boolean\",stepperActive:\"string\",stepperCompleted:\"string\",stepperInvalid:\"string\",stepperDisabled:\"string\",stepperVerticalBreakpoint:\"number\",stepperMobileBreakpoint:\"number\",stepperMobileBarBreakpoint:\"number\"},My={stepperType:Ws,stepperLinear:!1,stepperNoEditable:!1,stepperActive:\"\",stepperCompleted:\"\",stepperInvalid:\"\",stepperDisabled:\"\",stepperVerticalBreakpoint:0,stepperMobileBreakpoint:0,stepperMobileBarBreakpoint:4},_d=`mousedown${Oo}`,gd=`keydown${Oo}`,Iy=`keyup${Oo}`,md=`resize${Oo}`,ze=`[${Vs}-step-ref]`,yt=`[${Vs}-head-ref]`,bd=`[${Vs}-head-text-ref]`,Do=`[${Vs}-head-icon-ref]`,wt=`[${Vs}-content-ref]`;class vd{constructor(t,e){this._element=t,this._options=this._getConfig(e),this._elementHeight=0,this._steps=g.find(`${ze}`,this._element),this._currentView=\"\",this._activeStepIndex=0,this._verticalStepperStyles=[],this._element&&(P.setData(t,So,this),this._init())}static get NAME(){return ka}get activeStep(){return this._steps[this._activeStepIndex]}get activeStepIndex(){return this._activeStepIndex}dispose(){this._steps.forEach(t=>{b.off(t,_d),b.off(t,gd)}),b.off(window,md),P.removeData(this._element,So),this._element=null}changeStep(t){this._toggleStep(t)}nextStep(){this._toggleStep(this._activeStepIndex+1)}previousStep(){this._toggleStep(this._activeStepIndex-1)}_init(){const t=g.find(`${ze}`,this._element)[this._activeStepIndex].setAttribute(\"data-te\",\"active-step\"),e=g.find(`${bd}`,this._element),s=g.find(`${Do}`,this._element);switch(t?(this._activeStepIndex=this._steps.indexOf(t),this._toggleStepClass(this._activeStepIndex,\"add\",this._options.stepperActive),e[this._activeStepIndex].classList.add(\"font-medium\"),s[this._activeStepIndex].classList.add(\"!bg-primary-100\"),s[this._activeStepIndex].classList.add(\"!text-primary-700\")):(e[this._activeStepIndex].classList.add(\"font-medium\"),s[this._activeStepIndex].classList.add(\"!bg-primary-100\"),s[this._activeStepIndex].classList.add(\"!text-primary-700\"),this._toggleStepClass(this._activeStepIndex,\"add\",this._options.stepperActive)),this._bindMouseDown(),this._bindKeysNavigation(),this._options.stepperType){case _e:this._toggleVertical();break;default:this._toggleHorizontal();break}(this._options.stepperVerticalBreakpoint||this._options.stepperMobileBreakpoint)&&this._toggleStepperView(),this._bindResize()}_getConfig(t){const e=v.getDataAttributes(this._element);return t={...My,...e,...t},W(ka,t,Dy),t}_bindMouseDown(){this._steps.forEach(t=>{const e=g.findOne(`${yt}`,t);b.on(e,_d,s=>{const n=g.parents(s.target,`${ze}`)[0],o=this._steps.indexOf(n);s.preventDefault(),this._toggleStep(o)})})}_bindResize(){b.on(window,md,()=>{this._currentView===_e&&this._setSingleStepHeight(this.activeStep),this._currentView===Ws&&this._setHeight(this.activeStep),(this._options.stepperVerticalBreakpoint||this._options.stepperMobileBreakpoint)&&this._toggleStepperView()})}_toggleStepperView(){const t=this._options.stepperVerticalBreakpoint<window.innerWidth,e=this._options.stepperVerticalBreakpoint>window.innerWidth,s=this._options.stepperMobileBreakpoint>window.innerWidth;t&&this._currentView!==Ws&&this._toggleHorizontal(),e&&!s&&this._currentView!==_e&&(this._steps.forEach(n=>{const o=g.findOne(`${wt}`,n);this._resetStepperHeight(),this._showElement(o)}),this._toggleVertical())}_toggleStep(t){this._activeStepIndex!==t&&(this._options.stepperNoEditable&&this._toggleDisabled(),this._showElement(g.findOne(`${wt}`,this._steps[t])),this._toggleActive(t),t>this._activeStepIndex&&this._toggleCompleted(this._activeStepIndex),this._currentView===Ws?this._animateHorizontalStep(t):(this._animateVerticalStep(t),this._setSingleStepHeight(this._steps[t])),this._toggleStepTabIndex(g.findOne(`${yt}`,this.activeStep),g.findOne(`${yt}`,this._steps[t])),this._activeStepIndex=t,this._steps[this._activeStepIndex].setAttribute(\"data-te\",\"active-step\"),this._steps.forEach((e,s)=>{e[this._activeStepIndex]!==s&&e.removeAttribute(\"data-te\")}))}_resetStepperHeight(){this._element.style.height=\"\"}_setStepsHeight(){this._steps.forEach(t=>{const e=g.findOne(`${wt}`,t),s=window.getComputedStyle(e);this._verticalStepperStyles.push({paddingTop:parseFloat(s.paddingTop),paddingBottom:parseFloat(s.paddingBottom)});const n=e.scrollHeight;e.style.height=`${n}px`})}_setSingleStepHeight(t){const e=g.findOne(`${wt}`,t),s=this.activeStep===t,n=this._steps.indexOf(t);let o;s?(e.style.height=\"\",o=e.scrollHeight):o=e.scrollHeight+this._verticalStepperStyles[n].paddingTop+this._verticalStepperStyles[n].paddingBottom,e.style.height=`${o}px`}_toggleVertical(){this._currentView=_e,this._setStepsHeight(),this._hideInactiveSteps()}_toggleHorizontal(){this._currentView=Ws,this._setHeight(this.activeStep),this._hideInactiveSteps()}_toggleStepperClass(){g.findOne(\"[data-te-stepper-type]\",this._element)!==null&&this._steps.forEach(e=>{g.findOne(`${wt}`,e).classList.remove(\"!my-0\"),g.findOne(`${wt}`,e).classList.remove(\"!py-0\"),g.findOne(`${wt}`,e).classList.remove(\"!h-0\")})}_toggleStepClass(t,e,s){s&&this._steps[t].classList[e](s)}_bindKeysNavigation(){this._toggleStepTabIndex(!1,g.findOne(`${yt}`,this.activeStep)),this._steps.forEach(t=>{const e=g.findOne(`${yt}`,t);b.on(e,gd,s=>{const n=g.parents(s.currentTarget,`${ze}`)[0],o=g.next(n,`${ze}`)[0],r=g.prev(n,`${ze}`)[0],a=g.findOne(`${yt}`,n),l=g.findOne(`${yt}`,this.activeStep);let c=null,h=null;if(o&&(c=g.findOne(`${yt}`,o)),r&&(h=g.findOne(`${yt}`,r)),s.keyCode===Zi&&this._currentView!==_e&&(h?(this._toggleStepTabIndex(a,h),this._toggleOutlineStyles(a,h),h.focus()):c&&(this._toggleStepTabIndex(a,c),this._toggleOutlineStyles(a,c),c.focus())),s.keyCode===Qi&&this._currentView!==_e&&(c?(this._toggleStepTabIndex(a,c),this._toggleOutlineStyles(a,c),c.focus()):h&&(this._toggleStepTabIndex(a,h),this._toggleOutlineStyles(a,h),h.focus())),s.keyCode===ut&&this._currentView===_e&&(s.preventDefault(),c&&(this._toggleStepTabIndex(a,c),this._toggleOutlineStyles(a,c),c.focus())),s.keyCode===Tt&&this._currentView===_e&&(s.preventDefault(),h&&(this._toggleStepTabIndex(a,h),this._toggleOutlineStyles(a,h),h.focus())),s.keyCode===Ji){const d=g.findOne(`${yt}`,this._steps[0]);this._toggleStepTabIndex(a,d),this._toggleOutlineStyles(a,d),d.focus()}if(s.keyCode===ts){const d=this._steps[this._steps.length-1],u=g.findOne(`${yt}`,d);this._toggleStepTabIndex(a,u),this._toggleOutlineStyles(a,u),u.focus()}(s.keyCode===Pt||s.keyCode===oo)&&(s.preventDefault(),this.changeStep(this._steps.indexOf(n))),s.keyCode===Rs&&(this._toggleStepTabIndex(a,l),this._toggleOutlineStyles(a,!1),l.focus())}),b.on(e,Iy,s=>{const n=g.parents(s.currentTarget,`${ze}`)[0],o=g.findOne(`${yt}`,n),r=g.findOne(`${yt}`,this.activeStep);s.keyCode===Rs&&(this._toggleStepTabIndex(o,r),this._toggleOutlineStyles(!1,r),r.focus())})})}_toggleStepTabIndex(t,e){t&&t.setAttribute(\"tabIndex\",-1),e&&e.setAttribute(\"tabIndex\",0)}_toggleOutlineStyles(t,e){t&&(t.style.outline=\"\"),e&&(e.style.outline=\"revert\")}_toggleDisabled(){const t=g.find(`${yt}`,this._element),e=g.find(`${Do}`,this._element);t[this._activeStepIndex].classList.add(\"color-[#858585]\"),t[this._activeStepIndex].classList.add(\"cursor-default\"),e[this._activeStepIndex].classList.add(\"!bg-[#858585]\"),this._toggleStepClass(this._activeStepIndex,\"add\",this._options.stepperDisabled)}_toggleActive(t){const e=g.find(`${bd}`,this._element),s=g.find(`${Do}`,this._element);e[t].classList.add(\"font-medium\"),s[t].classList.add(\"!bg-primary-100\"),s[t].classList.add(\"!text-primary-700\"),s[t].classList.remove(\"!bg-success-100\"),s[t].classList.remove(\"!text-success-700\"),e[this._activeStepIndex].classList.remove(\"font-medium\"),s[this._activeStepIndex].classList.remove(\"!bg-primary-100\"),s[this._activeStepIndex].classList.remove(\"!text-primary-700\"),this._toggleStepClass(t,\"add\",this._options.stepperActive),this._toggleStepClass(this._activeStepIndex,\"remove\",this._options.stepperActive)}_toggleCompleted(t){const e=g.find(`${Do}`,this._element);e[t].classList.add(\"!bg-success-100\"),e[t].classList.add(\"!text-success-700\"),e[t].classList.remove(\"!bg-danger-100\"),e[t].classList.remove(\"!text-danger-700\"),this._toggleStepClass(t,\"add\",this._options.stepperCompleted),this._toggleStepClass(t,\"remove\",this._options.stepperInvalid)}_hideInactiveSteps(){this._steps.forEach(t=>{t.getAttribute(\"data-te\")||this._hideElement(g.findOne(`${wt}`,t))})}_setHeight(t){const e=g.findOne(`${wt}`,t),s=getComputedStyle(e),n=g.findOne(`${yt}`,t),o=getComputedStyle(n),r=e.offsetHeight+parseFloat(s.marginTop)+parseFloat(s.marginBottom),a=n.offsetHeight+parseFloat(o.marginTop)+parseFloat(o.marginBottom);this._element.style.height=`${a+r}px`}_hideElement(t){!g.parents(t,`${ze}`)[0].getAttribute(\"data-te\")&&this._currentView!==_e||(t.classList.add(\"!my-0\"),t.classList.add(\"!py-0\"),t.classList.add(\"!h-0\"))}_showElement(t){this._currentView===_e?(t.classList.remove(\"!my-0\"),t.classList.remove(\"!py-0\"),t.classList.remove(\"!h-0\")):t.style.display=\"block\"}_animateHorizontalStep(t){const e=t>this._activeStepIndex,s=g.findOne(`${wt}`,this._steps[t]),n=g.findOne(`${wt}`,this.activeStep);let o,r;this._steps.forEach((h,d)=>{const u=g.findOne(`${wt}`,h);d!==t&&d!==this._activeStepIndex&&this._hideElement(u)});const a=\"translate-x-[150%]\",l=\"-translate-x-[150%]\",c=\"translate-0\";e?(r=l,o=c,s.classList.remove(\"translate-x-[150%]\"),s.classList.remove(\"-translate-x-[150%]\")):(r=a,o=c,s.classList.remove(\"-translate-x-[150%]\"),s.classList.remove(\"translate-x-[150%]\")),n.classList.add(r),s.classList.add(o),this._setHeight(this._steps[t])}_animateVerticalStep(t){const e=g.findOne(`${wt}`,this._steps[t]),s=g.findOne(`${wt}`,this.activeStep);this._hideElement(s),this._showElement(e)}static getInstance(t){return P.getData(t,So)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const yd=\"data-te-input-state-active\",Mo=\"data-te-input-selected\",xd=\"data-te-input-multiple-active\",Ed=\"[data-te-form-check-input]\";class Cd{constructor(t,e,s,n,o,r,a,l,c,h,d){this.id=t,this.nativeOption=e,this.multiple=s,this.value=n,this.label=o,this.selected=r,this.disabled=a,this.hidden=l,this.secondaryText=c,this.groupId=h,this.icon=d,this.node=null,this.active=!1}select(){this.multiple?this._selectMultiple():this._selectSingle()}_selectSingle(){this.selected||(this.node.setAttribute(Mo,\"\"),this.node.setAttribute(\"aria-selected\",!0),this.selected=!0,this.nativeOption&&(this.nativeOption.selected=!0))}_selectMultiple(){if(!this.selected){const t=g.findOne(Ed,this.node);t.checked=!0,this.node.setAttribute(Mo,\"\"),this.node.setAttribute(\"aria-selected\",!0),this.selected=!0,this.nativeOption&&(this.nativeOption.selected=!0)}}deselect(){this.multiple?this._deselectMultiple():this._deselectSingle()}_deselectSingle(){this.selected&&(this.node.removeAttribute(Mo),this.node.setAttribute(\"aria-selected\",!1),this.selected=!1,this.nativeOption&&(this.nativeOption.selected=!1))}_deselectMultiple(){if(this.selected){const t=g.findOne(Ed,this.node);t.checked=!1,this.node.removeAttribute(Mo),this.node.setAttribute(\"aria-selected\",!1),this.selected=!1,this.nativeOption&&(this.nativeOption.selected=!1)}}setNode(t){this.node=t}setActiveStyles(){if(!this.active){if(this.multiple){this.node.setAttribute(xd,\"\");return}this.active=!0,this.node.setAttribute(yd,\"\")}}removeActiveStyles(){this.active&&(this.active=!1,this.node.removeAttribute(yd)),this.multiple&&this.node.removeAttribute(xd)}}class Ly{constructor(t=!1){this._multiple=t,this._selections=[]}select(t){this._multiple?this._selections.push(t):this._selections=[t]}deselect(t){if(this._multiple){const e=this._selections.findIndex(s=>t===s);this._selections.splice(e,1)}else this._selections=[]}clear(){this._selections=[]}get selection(){return this._selections[0]}get selections(){return this._selections}get label(){return this._selections[0]&&this.selection.label}get labels(){return this._selections.map(t=>t.label).join(\", \")}get value(){return this.selections[0]&&this.selection.value}get values(){return this._selections.map(t=>t.value)}}function Sa(i){return i.filter(t=>!t.disabled).every(t=>t.selected)}const Py=\"data-te-select-form-outline-ref\",Ry=\"data-te-select-wrapper-ref\",Ny=\"data-te-select-input-ref\",$y=\"data-te-select-clear-btn-ref\",By=\"data-te-select-dropdown-container-ref\",Hy=\"data-te-select-dropdown-ref\",Fy=\"data-te-select-options-wrapper-ref\",Vy=\"data-te-select-options-list-ref\",Wy=\"data-te-select-input-filter-ref\",Td=\"data-te-select-option-ref\",zy=\"data-te-select-option-all-ref\",jy=\"data-te-select-option-text-ref\",Yy=\"data-te-form-check-input\",Ky=\"data-te-select-option-group-ref\",Uy=\"data-te-select-option-group-label-ref\",Ad=\"data-te-select-selected\",Xy=`\n<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n</svg>\n`,Gy=i=>{i.code===\"Tab\"||i.code===\"Esc\"||i.preventDefault()};function Io(i,t,e,s,n){t.selectSize===\"default\"&&v.addClass(i,e),t.selectSize===\"sm\"&&v.addClass(i,s),t.selectSize===\"lg\"&&v.addClass(i,n)}function qy(i,t,e,s){const n=document.createElement(\"div\");n.setAttribute(\"id\",i),n.setAttribute(Ry,\"\");const o=z(\"div\");o.setAttribute(Py,\"\"),v.addClass(o,s.formOutline);const r=z(\"input\"),a=t.selectFilter?\"combobox\":\"listbox\",l=t.multiple?\"true\":\"false\",c=t.disabled?\"true\":\"false\";r.setAttribute(Ny,\"\"),v.addClass(r,s.selectInput),Io(r,t,s.selectInputSizeDefault,s.selectInputSizeSm,s.selectInputSizeLg),t.selectFormWhite&&v.addClass(r,s.selectInputWhite),r.setAttribute(\"type\",\"text\"),r.setAttribute(\"role\",a),r.setAttribute(\"aria-multiselectable\",l),r.setAttribute(\"aria-disabled\",c),r.setAttribute(\"aria-haspopup\",\"true\"),r.setAttribute(\"aria-expanded\",!1),t.tabIndex&&r.setAttribute(\"tabIndex\",t.tabIndex),t.disabled&&r.setAttribute(\"disabled\",\"\"),t.selectPlaceholder!==\"\"&&r.setAttribute(\"placeholder\",t.selectPlaceholder),t.selectValidation?(v.addStyle(r,{\"pointer-events\":\"none\",\"caret-color\":\"transparent\"}),v.addStyle(o,{cursor:\"pointer\"})):r.setAttribute(\"readonly\",\"true\"),t.selectValidation&&(r.setAttribute(\"required\",\"true\"),r.setAttribute(\"aria-required\",\"true\"),r.addEventListener(\"keydown\",Gy));const h=z(\"div\");v.addClass(h,s.selectValidationValid);const d=document.createTextNode(`${t.selectValidFeedback}`);h.appendChild(d);const u=z(\"div\");v.addClass(u,s.selectValidationInvalid);const f=document.createTextNode(`${t.selectInvalidFeedback}`);u.appendChild(f);const p=z(\"span\");p.setAttribute($y,\"\"),v.addClass(p,s.selectClearBtn),Io(p,t,s.selectClearBtnDefault,s.selectClearBtnSm,s.selectClearBtnLg),t.selectFormWhite&&v.addClass(p,s.selectClearBtnWhite);const _=document.createTextNode(\"\");p.appendChild(_),p.setAttribute(\"tabindex\",\"0\");const m=z(\"span\");return v.addClass(m,s.selectArrow),Io(m,t,s.selectArrowDefault,s.selectArrowSm,s.selectArrowLg),t.selectFormWhite&&v.addClass(m,s.selectArrowWhite),m.innerHTML=Xy,o.appendChild(r),e&&(v.addClass(e,s.selectLabel),Io(e,t,s.selectLabelSizeDefault,s.selectLabelSizeSm,s.selectLabelSizeLg),t.selectFormWhite&&v.addClass(e,s.selectLabelWhite),o.appendChild(e)),t.selectValidation&&(o.appendChild(h),o.appendChild(u)),t.selectClearButton&&o.appendChild(p),o.appendChild(m),n.appendChild(o),n}function wd(i,t,e,s,n,o,r,a){const l=document.createElement(\"div\");l.setAttribute(By,\"\"),v.addClass(l,a.selectDropdownContainer),l.setAttribute(\"id\",`${i}`),l.style.width=`${e}px`;const c=document.createElement(\"div\");c.setAttribute(\"tabindex\",0),c.setAttribute(Hy,\"\"),v.addClass(c,a.dropdown);const h=z(\"div\");h.setAttribute(Fy,\"\"),v.addClass(h,a.optionsWrapper),v.addClass(h,a.optionsWrapperScrollbar),h.style.maxHeight=`${s}px`;const d=kd(o,n,t,a);return h.appendChild(d),t.selectFilter&&c.appendChild(Zy(t.selectSearchPlaceholder,a)),c.appendChild(h),r&&c.appendChild(r),l.appendChild(c),l}function kd(i,t,e,s){const n=z(\"div\");n.setAttribute(Vy,\"\"),v.addClass(n,s.optionsList);let o;return e.multiple?o=Jy(i,t,e,s):o=Qy(i,e,s),o.forEach(r=>{n.appendChild(r)}),n}function Zy(i,t){const e=z(\"div\");v.addClass(e,t.inputGroup);const s=z(\"input\");return s.setAttribute(Wy,\"\"),v.addClass(s,t.selectFilterInput),s.placeholder=i,s.setAttribute(\"role\",\"searchbox\"),s.setAttribute(\"type\",\"text\"),e.appendChild(s),e}function Qy(i,t,e){return Sd(i,t,e)}function Jy(i,t,e,s){let n=null;e.selectAll&&(n=tx(t,i,e,s));const o=Sd(i,e,s);return n?[n,...o]:o}function Sd(i,t,e){const s=[];return i.forEach(n=>{if(Object.prototype.hasOwnProperty.call(n,\"options\")){const r=nx(n,t,e);s.push(r)}else s.push(Od(n,t,e))}),s}function tx(i,t,e,s){const n=Sa(t),o=z(\"div\");return o.setAttribute(Td,\"\"),v.addClass(o,s.selectOption),o.setAttribute(zy,\"\"),v.addStyle(o,{height:`${e.selectOptionHeight}px`}),o.setAttribute(\"role\",\"option\"),o.setAttribute(\"aria-selected\",n),n&&o.setAttribute(Ad,\"\"),o.appendChild(Dd(i,e,s)),i.setNode(o),o}function Od(i,t,e){if(i.node)return i.node;const s=z(\"div\");return s.setAttribute(Td,\"\"),v.addClass(s,e.selectOption),v.addStyle(s,{height:`${t.selectOptionHeight}px`}),v.setDataAttribute(s,\"id\",i.id),s.setAttribute(\"role\",\"option\"),s.setAttribute(\"aria-selected\",i.selected),s.setAttribute(\"aria-disabled\",i.disabled),i.selected&&s.setAttribute(Ad,\"\"),i.disabled&&s.setAttribute(\"data-te-select-option-disabled\",!0),i.hidden&&v.addClass(s,\"hidden\"),s.appendChild(Dd(i,t,e)),i.icon&&s.appendChild(sx(i,e)),i.setNode(s),s}function Dd(i,t,e){const s=z(\"span\");s.setAttribute(jy,\"\"),v.addClass(s,e.selectOptionText);const n=document.createTextNode(i.label);return t.multiple&&s.appendChild(ix(i,e)),s.appendChild(n),(i.secondaryText||typeof i.secondaryText==\"number\")&&s.appendChild(ex(i.secondaryText,e)),s}function ex(i,t){const e=z(\"span\");v.addClass(e,t.selectOptionSecondaryText);const s=document.createTextNode(i);return e.appendChild(s),e}function ix(i,t){const e=z(\"input\");e.setAttribute(\"type\",\"checkbox\"),v.addClass(e,t.formCheckInput),e.setAttribute(Yy,\"\");const s=z(\"label\");return i.selected&&e.setAttribute(\"checked\",!0),i.disabled&&e.setAttribute(\"disabled\",!0),e.appendChild(s),e}function sx(i,t){const e=z(\"span\"),s=z(\"img\");return v.addClass(s,t.selectOptionIcon),s.src=i.icon,e.appendChild(s),e}function nx(i,t,e){const s=z(\"div\");s.setAttribute(Ky,\"\"),v.addClass(s,e.selectOptionGroup),s.setAttribute(\"role\",\"group\"),s.setAttribute(\"id\",i.id),i.hidden&&v.addClass(s,\"hidden\");const n=z(\"label\");return n.setAttribute(Uy,\"\"),v.addClass(n,e.selectOptionGroupLabel),v.addStyle(n,{height:`${t.selectOptionHeight}px`}),n.setAttribute(\"for\",i.id),n.textContent=i.label,s.appendChild(n),i.options.forEach(o=>{s.appendChild(Od(o,t,e))}),s}function ox(i,t){const e=z(\"div\");return e.innerHTML=i,v.addClass(e,t.selectLabel),v.addClass(e,t.selectFakeValue),e}const Oa=\"select\",zs=\"te.select\",js=`.${zs}`,rx=`close${js}`,ax=`open${js}`,Md=`optionSelect${js}`,Id=`optionDeselect${js}`,lx=`valueChange${js}`,cx=\"change\",Ld=\"data-te-select-init\",Pd=\"data-te-select-no-results-ref\",Rd=\"data-te-select-open\",xt=\"data-te-input-state-active\",je=\"data-te-input-focused\",Da=\"data-te-input-disabled\",hx=\"data-te-select-option-group-label-ref\",dx=\"data-te-select-option-all-ref\",Ys=\"data-te-select-selected\",ux=\"[data-te-select-label-ref]\",Nd=\"[data-te-select-input-ref]\",fx=\"[data-te-select-input-filter-ref]\",px=\"[data-te-select-dropdown-ref]\",_x=\"[data-te-select-options-wrapper-ref]\",$d=\"[data-te-select-options-list-ref]\",gx=\"[data-te-select-option-ref]\",mx=\"[data-te-select-clear-btn-ref]\",bx=\"[data-te-select-custom-content-ref]\",vx=`[${Pd}]`,Bd=\"[data-te-select-form-outline-ref]\",yx=\"[data-te-select-toggle]\",Ma=\"[data-te-input-notch-ref]\",xx=200,Ex={selectAutoSelect:!1,selectContainer:\"body\",selectClearButton:!1,disabled:!1,selectDisplayedLabels:5,selectFormWhite:!1,multiple:!1,selectOptionsSelectedLabel:\"options selected\",selectOptionHeight:38,selectAll:!0,selectAllLabel:\"Select all\",selectSearchPlaceholder:\"Search...\",selectSize:\"default\",selectVisibleOptions:5,selectFilter:!1,selectFilterDebounce:300,selectNoResultText:\"No results\",selectValidation:!1,selectValidFeedback:\"Valid\",selectInvalidFeedback:\"Invalid\",selectPlaceholder:\"\"},Cx={selectAutoSelect:\"boolean\",selectContainer:\"string\",selectClearButton:\"boolean\",disabled:\"boolean\",selectDisplayedLabels:\"number\",selectFormWhite:\"boolean\",multiple:\"boolean\",selectOptionsSelectedLabel:\"string\",selectOptionHeight:\"number\",selectAll:\"boolean\",selectAllLabel:\"string\",selectSearchPlaceholder:\"string\",selectSize:\"string\",selectVisibleOptions:\"number\",selectFilter:\"boolean\",selectFilterDebounce:\"number\",selectNoResultText:\"string\",selectValidation:\"boolean\",selectValidFeedback:\"string\",selectInvalidFeedback:\"string\",selectPlaceholder:\"string\"},Tx={dropdown:\"relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700\",formCheckInput:\"relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent\",formOutline:\"relative\",initialized:\"hidden\",inputGroup:\"flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200\",noResult:\"flex items-center px-4\",optionsList:\"list-none m-0 p-0\",optionsWrapper:\"overflow-y-auto\",optionsWrapperScrollbar:\"[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded\",selectArrow:\"absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5\",selectArrowWhite:\"text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white\",selectArrowDefault:\"top-2\",selectArrowLg:\"top-[13px]\",selectArrowSm:\"top-1\",selectClearBtn:\"absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200\",selectClearBtnWhite:\"!text-gray-50\",selectClearBtnDefault:\"top-2 text-base\",selectClearBtnLg:\"top-[11px] text-base\",selectClearBtnSm:\"top-1 text-[0.8rem]\",selectDropdownContainer:\"z-[1070]\",selectFakeValue:\"transform-none hidden data-[te-input-state-active]:block\",selectFilterInput:\"relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200\",selectInput:\"peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600\",selectInputWhite:\"!text-gray-50\",selectInputSizeDefault:\"py-[0.32rem] px-3 leading-[1.6]\",selectInputSizeLg:\"py-[0.32rem] px-3 leading-[2.15]\",selectInputSizeSm:\"py-[0.33rem] px-3 text-xs leading-[1.5]\",selectLabel:\"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary\",selectLabelWhite:\"!text-gray-50\",selectLabelSizeDefault:\"pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]\",selectLabelSizeLg:\"pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]\",selectLabelSizeSm:\"pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]\",selectOption:\"flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30\",selectOptionGroup:\"group/opt\",selectOptionGroupLabel:\"flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300\",selectOptionIcon:\"w-7 h-7 rounded-full\",selectOptionSecondaryText:\"block text-[0.8rem] text-gray-500 dark:text-gray-300\",selectOptionText:\"group\",selectValidationValid:\"hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block\",selectValidationInvalid:\"hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block\"},Ax={dropdown:\"string\",formCheckInput:\"string\",formOutline:\"string\",initialized:\"string\",inputGroup:\"string\",noResult:\"string\",optionsList:\"string\",optionsWrapper:\"string\",optionsWrapperScrollbar:\"string\",selectArrow:\"string\",selectArrowDefault:\"string\",selectArrowLg:\"string\",selectArrowSm:\"string\",selectClearBtn:\"string\",selectClearBtnDefault:\"string\",selectClearBtnLg:\"string\",selectClearBtnSm:\"string\",selectDropdownContainer:\"string\",selectFakeValue:\"string\",selectFilterInput:\"string\",selectInput:\"string\",selectInputSizeDefault:\"string\",selectInputSizeLg:\"string\",selectInputSizeSm:\"string\",selectLabel:\"string\",selectLabelSizeDefault:\"string\",selectLabelSizeLg:\"string\",selectLabelSizeSm:\"string\",selectOption:\"string\",selectOptionGroup:\"string\",selectOptionGroupLabel:\"string\",selectOptionIcon:\"string\",selectOptionSecondaryText:\"string\",selectOptionText:\"string\"};class Lo{constructor(t,e,s){this._element=t,this._config=this._getConfig(e),this._classes=this._getClasses(s),this._optionsToRender=this._getOptionsToRender(t),this._plainOptions=this._getPlainOptions(this._optionsToRender),this._filteredOptionsList=null,this._selectionModel=new Ly(this.multiple),this._activeOptionIndex=-1,this._activeOption=null,this._wrapperId=se(\"select-wrapper-\"),this._dropdownContainerId=se(\"select-dropdown-container-\"),this._selectAllId=se(\"select-all-\"),this._debounceTimeoutId=null,this._dropdownHeight=this._config.selectOptionHeight*this._config.selectVisibleOptions,this._popper=null,this._input=null,this._label=g.next(this._element,ux)[0],this._notch=null,this._fakeValue=null,this._isFakeValueActive=!1,this._customContent=g.next(t,bx)[0],this._toggleButton=null,this._elementToggle=null,this._wrapper=null,this._inputEl=null,this._dropdownContainer=null,this._container=null,this._selectAllOption=null,this._init(),this._mutationObserver=null,this._isOpen=!1,this._addMutationObserver(),this._element&&P.setData(t,zs,this)}static get NAME(){return Oa}get filterInput(){return g.findOne(fx,this._dropdownContainer)}get dropdown(){return g.findOne(px,this._dropdownContainer)}get optionsList(){return g.findOne($d,this._dropdownContainer)}get optionsWrapper(){return g.findOne(_x,this._dropdownContainer)}get clearButton(){return g.findOne(mx,this._wrapper)}get options(){return this._filteredOptionsList?this._filteredOptionsList:this._plainOptions}get value(){return this.multiple?this._selectionModel.values:this._selectionModel.value}get multiple(){return this._config.multiple}get hasSelectAll(){return this.multiple&&this._config.selectAll}get hasSelection(){return this._selectionModel.selection||this._selectionModel.selections.length>0}_getConfig(t){const e=v.getDataAttributes(this._element);return t={...Ex,...e,...t},this._element.hasAttribute(\"multiple\")&&(t.multiple=!0),this._element.hasAttribute(\"disabled\")&&(t.disabled=!0),this._element.tabIndex&&(t.tabIndex=this._element.getAttribute(\"tabIndex\")),W(Oa,t,Cx),t}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Tx,...e,...t},W(Oa,t,Ax),t}_getOptionsToRender(t){const e=[];return t.childNodes.forEach(n=>{if(n.nodeName===\"OPTGROUP\"){const o={id:se(\"group-\"),label:n.label,disabled:n.hasAttribute(\"disabled\"),hidden:n.hasAttribute(\"hidden\"),options:[]};n.childNodes.forEach(a=>{a.nodeName===\"OPTION\"&&o.options.push(this._createOptionObject(a,o))}),e.push(o)}else n.nodeName===\"OPTION\"&&e.push(this._createOptionObject(n))}),e}_getPlainOptions(t){if(!g.findOne(\"optgroup\",this._element))return t;const s=[];return t.forEach(n=>{Object.prototype.hasOwnProperty.call(n,\"options\")?n.options.forEach(r=>{s.push(r)}):s.push(n)}),s}_createOptionObject(t,e={}){const s=se(\"option-\"),n=e.id?e.id:null,o=e.disabled?e.disabled:!1,r=t.selected||t.hasAttribute(Ys),a=t.hasAttribute(\"disabled\")||o,l=t.hasAttribute(\"hidden\")||e&&e.hidden,c=this.multiple,h=t.value,d=t.label,u=v.getDataAttribute(t,\"selectSecondaryText\"),f=v.getDataAttribute(t,\"select-icon\");return new Cd(s,t,c,h,d,r,a,l,u,n,f)}_getNavigationOptions(){const t=this.options.filter(e=>!e.hidden);return this.hasSelectAll?[this._selectAllOption,...t]:t}_init(){this._renderMaterialWrapper(),this._wrapper=g.findOne(`#${this._wrapperId}`),this._input=g.findOne(Nd,this._wrapper),this._config.disabled&&this._input.setAttribute(Da,\"\");const t=this._config.selectContainer;t===\"body\"?this._container=document.body:this._container=g.findOne(t),this._initOutlineInput(),this._setDefaultSelections(),this._updateInputValue(),this._appendFakeValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility(),this._bindComponentEvents(),this.hasSelectAll&&(this._selectAllOption=this._createSelectAllOption()),this._dropdownContainer=wd(this._dropdownContainerId,this._config,this._input.offsetWidth,this._dropdownHeight,this._selectAllOption,this._optionsToRender,this._customContent,this._classes),this._setFirstActiveOption(),this._listenToFocusChange()}_renderMaterialWrapper(){const t=qy(this._wrapperId,this._config,this._label,this._classes);this._element.parentNode.insertBefore(t,this._element),v.addClass(this._element,this._classes.initialized),t.appendChild(this._element)}_initOutlineInput(){const t=g.findOne(Bd,this._wrapper);new Z(t,{inputFormWhite:this._config.selectFormWhite}).init(),this._notch=g.findOne(Ma,this._wrapper)}_bindComponentEvents(){this._listenToComponentKeydown(),this._listenToWrapperClick(),this._listenToClearBtnClick(),this._listenToClearBtnKeydown()}_setDefaultSelections(){this.options.forEach(t=>{t.selected&&this._selectionModel.select(t)})}_listenToComponentKeydown(){b.on(this._wrapper,\"keydown\",this._handleKeydown.bind(this))}_handleKeydown(t){this._isOpen&&!this._config.selectFilter?this._handleOpenKeydown(t):this._handleClosedKeydown(t)}_handleOpenKeydown(t){const e=t.keyCode,s=e===ro||e===Tt&&t.altKey||e===Rs;if(e===Rs&&this._config.selectAutoSelect&&!this.multiple&&this._handleAutoSelection(this._activeOption),s){this.close(),this._input.focus();return}switch(e){case ut:this._setNextOptionActive(),this._scrollToOption(this._activeOption);break;case Tt:this._setPreviousOptionActive(),this._scrollToOption(this._activeOption);break;case Ji:this._setFirstOptionActive(),this._scrollToOption(this._activeOption);break;case ts:this._setLastOptionActive(),this._scrollToOption(this._activeOption);break;case Pt:t.preventDefault(),this._activeOption&&(this.hasSelectAll&&this._activeOptionIndex===0?this._handleSelectAll():this._handleSelection(this._activeOption));return;default:return}t.preventDefault()}_handleClosedKeydown(t){const e=t.keyCode;if(e===Pt&&t.preventDefault(),(e===Pt||e===ut&&t.altKey||e===ut&&this.multiple)&&this.open(),this.multiple)switch(e){case ut:this.open();break;case Tt:this.open();break;default:return}else switch(e){case ut:this._setNextOptionActive(),this._handleSelection(this._activeOption);break;case Tt:this._setPreviousOptionActive(),this._handleSelection(this._activeOption);break;case Ji:this._setFirstOptionActive(),this._handleSelection(this._activeOption);break;case ts:this._setLastOptionActive(),this._handleSelection(this._activeOption);break;default:return}t.preventDefault()}_scrollToOption(t){if(!t)return;let e;const s=this.options.filter(h=>!h.hidden);this.hasSelectAll?e=s.indexOf(t)+1:e=s.indexOf(t);const n=this._getNumberOfGroupsBeforeOption(e),o=e+n,r=this.optionsWrapper,a=r.offsetHeight,l=this._config.selectOptionHeight,c=r.scrollTop;if(e>-1){const h=o*l,d=h+l>c+a;h<c?r.scrollTop=h:d?r.scrollTop=h-a+l:r.scrollTop=c}}_getNumberOfGroupsBeforeOption(t){const e=this.options.filter(r=>!r.hidden),s=this._optionsToRender.filter(r=>!r.hidden),n=this.hasSelectAll?t-1:t;let o=0;for(let r=0;r<=n;r++)e[r].groupId&&s[o]&&s[o].id&&e[r].groupId===s[o].id&&o++;return o}_setNextOptionActive(){let t=this._activeOptionIndex+1;const e=this._getNavigationOptions();if(e[t]){for(;e[t].disabled;)if(t+=1,!e[t])return;this._updateActiveOption(e[t],t)}}_setPreviousOptionActive(){let t=this._activeOptionIndex-1;const e=this._getNavigationOptions();if(e[t]){for(;e[t].disabled;)if(t-=1,!e[t])return;this._updateActiveOption(e[t],t)}}_setFirstOptionActive(){const e=this._getNavigationOptions();this._updateActiveOption(e[0],0)}_setLastOptionActive(){const t=this._getNavigationOptions(),e=t.length-1;this._updateActiveOption(t[e],e)}_updateActiveOption(t,e){const s=this._activeOption;s&&s.removeActiveStyles(),t.setActiveStyles(),this._activeOptionIndex=e,this._activeOption=t}_listenToWrapperClick(){b.on(this._wrapper,\"click\",()=>{this.toggle()})}_listenToClearBtnClick(){b.on(this.clearButton,\"click\",t=>{t.preventDefault(),t.stopPropagation(),this._handleClear()})}_listenToClearBtnKeydown(){b.on(this.clearButton,\"keydown\",t=>{t.keyCode===Pt&&(this._handleClear(),t.preventDefault(),t.stopPropagation())})}_handleClear(){if(this.multiple)this._selectionModel.clear(),this._deselectAllOptions(this.options),this.hasSelectAll&&this._updateSelectAllState();else{const t=this._selectionModel.selection;this._selectionModel.clear(),t.deselect()}this._updateInputValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility(),this._emitValueChangeEvent(null),this._emitNativeChangeEvent()}_listenToOptionsClick(){b.on(this.optionsWrapper,\"click\",t=>{if(t.target.hasAttribute(hx))return;const s=t.target.nodeName===\"DIV\"?t.target:g.closest(t.target,gx);if(s.hasAttribute(dx)){this._handleSelectAll();return}const o=s.dataset.teId,r=this.options.find(a=>a.id===o);r&&!r.disabled&&this._handleSelection(r)})}_handleSelectAll(){this._selectAllOption.selected?(this._deselectAllOptions(this.options),this._selectAllOption.deselect()):(this._selectAllOptions(this.options),this._selectAllOption.select()),this._updateInputValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility(),this._emitValueChangeEvent(this.value),this._emitNativeChangeEvent()}_selectAllOptions(t){t.forEach(e=>{!e.selected&&!e.disabled&&(this._selectionModel.select(e),e.select())})}_deselectAllOptions(t){t.forEach(e=>{e.selected&&!e.disabled&&(this._selectionModel.deselect(e),e.deselect())})}_handleSelection(t){this.multiple?(this._handleMultiSelection(t),this.hasSelectAll&&this._updateSelectAllState()):this._handleSingleSelection(t),this._updateInputValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility()}_handleAutoSelection(t){this._singleOptionSelect(t),this._updateInputValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility()}_handleSingleSelection(t){this._singleOptionSelect(t),this.close(),this._input.focus()}_singleOptionSelect(t){const e=this._selectionModel.selections[0];e&&e!==t&&(this._selectionModel.deselect(e),e.deselect(),e.node.setAttribute(Ys,!1),b.trigger(this._element,Id,{value:e.value})),(!e||e&&t!==e)&&(this._selectionModel.select(t),t.select(),t.node.setAttribute(Ys,!0),b.trigger(this._element,Md,{value:t.value}),this._emitValueChangeEvent(this.value),this._emitNativeChangeEvent())}_handleMultiSelection(t){t.selected?(this._selectionModel.deselect(t),t.deselect(),t.node.setAttribute(Ys,!1),b.trigger(this._element,Id,{value:t.value})):(this._selectionModel.select(t),t.select(),t.node.setAttribute(Ys,!0),b.trigger(this._element,Md,{value:t.value})),this._emitValueChangeEvent(this.value),this._emitNativeChangeEvent()}_emitValueChangeEvent(t){b.trigger(this._element,lx,{value:t})}_emitNativeChangeEvent(){b.trigger(this._element,cx)}_updateInputValue(){const t=this.multiple?this._selectionModel.labels:this._selectionModel.label;let e;this.multiple&&this._config.selectDisplayedLabels!==-1&&this._selectionModel.selections.length>this._config.selectDisplayedLabels?e=`${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}`:e=t,!this.multiple&&!this._isSelectionValid(this._selectionModel.selection)?this._input.value=\"\":this._isLabelEmpty(this._selectionModel.selection)?this._input.value=\" \":e?this._input.value=e:this.multiple||!this._optionsToRender[0]?this._input.value=\"\":this._input.value=this._optionsToRender[0].label}_isSelectionValid(t){return!(t&&(t.disabled||t.value===\"\"))}_isLabelEmpty(t){return!!(t&&t.label===\"\")}_appendFakeValue(){if(!this._selectionModel.selection||this._selectionModel._multiple)return;const t=this._selectionModel.selection.label;this._fakeValue=ox(t,this._classes),g.findOne(Bd,this._wrapper).appendChild(this._fakeValue)}_updateLabelPosition(){const t=this._element.hasAttribute(Ld),e=this._input.value!==\"\";this._label&&(t&&(e||this._isOpen||this._isFakeValueActive)?(this._label.setAttribute(xt,\"\"),this._notch.setAttribute(xt,\"\")):(this._label.removeAttribute(xt),this._notch.removeAttribute(xt,\"\")))}_updateLabelPositionWhileClosing(){this._label&&(this._input.value!==\"\"||this._isFakeValueActive?(this._label.setAttribute(xt,\"\"),this._notch.setAttribute(xt,\"\")):(this._label.removeAttribute(xt),this._notch.removeAttribute(xt)))}_updateFakeLabelPosition(){this._fakeValue&&(this._input.value===\"\"&&this._fakeValue.innerHTML!==\"\"?(this._isFakeValueActive=!0,this._fakeValue.setAttribute(xt,\"\")):(this._isFakeValueActive=!1,this._fakeValue.removeAttribute(xt)))}_updateClearButtonVisibility(){if(!this.clearButton)return;this._selectionModel.selection||this._selectionModel.selections.length>0?v.addStyle(this.clearButton,{display:\"block\"}):v.addStyle(this.clearButton,{display:\"none\"})}_updateSelectAllState(){const t=this._selectAllOption.selected,e=Sa(this.options);!e&&t?this._selectAllOption.deselect():e&&!t&&this._selectAllOption.select()}toggle(){this._isOpen?this.close():this.open()}open(){const t=this._config.disabled,e=b.trigger(this._element,ax);this._isOpen||t||e.defaultPrevented||(this._openDropdown(),this._updateDropdownWidth(),this._setFirstActiveOption(),this._scrollToOption(this._activeOption),this._config.selectFilter&&(setTimeout(()=>{this.filterInput.focus()},0),this._listenToSelectSearch(),this._listenToDropdownKeydown()),this._listenToOptionsClick(),this._listenToOutsideClick(),this._listenToWindowResize(),this._isOpen=!0,this._updateLabelPosition(),this._setInputActiveStyles())}_openDropdown(){this._popper=Fi(this._input,this._dropdownContainer,{placement:\"bottom-start\",modifiers:[{name:\"offset\",options:{offset:[0,1]}}]}),this._container.appendChild(this._dropdownContainer),setTimeout(()=>{this.dropdown.setAttribute(Rd,\"\")},0)}_updateDropdownWidth(){const t=this._input.offsetWidth;v.addStyle(this._dropdownContainer,{width:`${t}px`})}_setFirstActiveOption(){const t=this._getNavigationOptions(),e=this._activeOption;e&&e.removeActiveStyles();const s=this.multiple?this._selectionModel.selections[0]:this._selectionModel.selection;s?(this._activeOption=s,s.setActiveStyles(),this._activeOptionIndex=t.findIndex(n=>n===s)):(this._activeOption=null,this._activeOptionIndex=-1)}_setInputActiveStyles(){this._input.setAttribute(je,\"\"),g.findOne(Ma,this._wrapper).setAttribute(je,\"\")}_listenToWindowResize(){b.on(window,\"resize\",this._handleWindowResize.bind(this))}_handleWindowResize(){this._dropdownContainer&&this._updateDropdownWidth()}_listenToSelectSearch(){this.filterInput.addEventListener(\"input\",t=>{const e=t.target.value,s=this._config.selectFilterDebounce;this._debounceFilter(e,s)})}_debounceFilter(t,e){this._debounceTimeoutId&&clearTimeout(this._debounceTimeoutId),this._debounceTimeoutId=setTimeout(()=>{this._filterOptions(t)},e)}_filterOptions(t){const e=[];this._optionsToRender.forEach(o=>{const r=Object.prototype.hasOwnProperty.call(o,\"options\"),a=!r&&o.label.toLowerCase().includes(t.toLowerCase()),l={};r&&(l.label=o.label,l.options=this._filter(t,o.options),l.options.length>0&&e.push(l)),a&&e.push(o)});const s=this._config.selectNoResultText!==\"\",n=e.length!==0;if(n)this._updateOptionsListTemplate(e),this._popper.forceUpdate(),this._filteredOptionsList=this._getPlainOptions(e),this.hasSelectAll&&this._updateSelectAllState(),this._setFirstActiveOption();else if(!n&&s){const o=this._getNoResultTemplate();this.optionsWrapper.innerHTML=o}}_updateOptionsListTemplate(t){const e=g.findOne($d,this._dropdownContainer)||g.findOne(vx,this._dropdownContainer),s=kd(t,this._selectAllOption,this._config,this._classes);this.optionsWrapper.removeChild(e),this.optionsWrapper.appendChild(s)}_getNoResultTemplate(){return`<div class=\"${this._classes.noResult}\" ${Pd} style=\"height: ${this._config.selectOptionHeight}px\">${this._config.selectNoResultText}</div>`}_filter(t,e){const s=t.toLowerCase();return e.filter(n=>n.label.toLowerCase().includes(s))}_listenToDropdownKeydown(){b.on(this.dropdown,\"keydown\",this._handleOpenKeydown.bind(this))}_listenToOutsideClick(){this._outsideClick=this._handleOutSideClick.bind(this),b.on(document,\"click\",this._outsideClick)}_listenToFocusChange(t=!0){if(t===!1){b.remove(this._input,\"focus\",()=>this._notch.setAttribute(je,\"\")),b.remove(this._input,\"blur\",()=>this._notch.removeAttribute(je));return}b.on(this._input,\"focus\",()=>this._notch.setAttribute(je,\"\")),b.on(this._input,\"blur\",()=>this._notch.removeAttribute(je))}_handleOutSideClick(t){const e=this._wrapper&&this._wrapper.contains(t.target),s=t.target===this._dropdownContainer,n=this._dropdownContainer&&this._dropdownContainer.contains(t.target);let o;this._toggleButton||(this._elementToggle=g.find(yx)),this._elementToggle&&this._elementToggle.forEach(r=>{const a=v.getDataAttribute(r,\"select-toggle\");(a===this._element.id||this._element.classList.contains(a))&&(this._toggleButton=r,o=this._toggleButton.contains(t.target))}),!e&&!s&&!n&&!o&&this.close()}close(){const t=b.trigger(this._element,rx);!this._isOpen||t.defaultPrevented||(this._config.selectFilter&&this.hasSelectAll&&(this._resetFilterState(),this._updateOptionsListTemplate(this._optionsToRender),this._config.multiple&&this._updateSelectAllState()),this._removeDropdownEvents(),this.dropdown.removeAttribute(Rd),setTimeout(()=>{this._input.removeAttribute(je),this._input.blur(),g.findOne(Ma,this._wrapper).removeAttribute(je),this._label&&!this.hasSelection&&(this._label.removeAttribute(xt),this._notch.setAttribute(xt,\"\"),this._input.removeAttribute(xt),this._notch.removeAttribute(xt)),this._updateLabelPositionWhileClosing()},0),setTimeout(()=>{this._container&&this._dropdownContainer.parentNode===this._container&&this._container.removeChild(this._dropdownContainer),this._popper.destroy(),this._isOpen=!1,b.off(this.dropdown,\"transitionend\")},xx))}_resetFilterState(){this.filterInput.value=\"\",this._filteredOptionsList=null}_removeDropdownEvents(){b.off(document,\"click\",this._outsideClick),this._config.selectFilter&&b.off(this.dropdown,\"keydown\"),b.off(this.optionsWrapper,\"click\")}_addMutationObserver(){this._mutationObserver=new MutationObserver(()=>{this._wrapper&&(this._updateSelections(),this._updateDisabledState())}),this._observeMutationObserver()}_updateSelections(){this._optionsToRender=this._getOptionsToRender(this._element),this._plainOptions=this._getPlainOptions(this._optionsToRender),this._selectionModel.clear(),this._setDefaultSelections(),this._updateInputValue(),this._updateFakeLabelPosition(),this._updateLabelPosition(),this._updateClearButtonVisibility(),this.hasSelectAll&&this._updateSelectAllState();const t=this._config.filter&&this.filterInput&&this.filterInput.value;this._isOpen&&!t?(this._updateOptionsListTemplate(this._optionsToRender),this._setFirstActiveOption()):this._isOpen&&t?(this._filterOptions(this.filterInput.value),this._setFirstActiveOption()):this._dropdownContainer=wd(this._dropdownContainerId,this._config,this._input.offsetWidth,this._dropdownHeight,this._selectAllOption,this._optionsToRender,this._customContent,this._classes)}_updateDisabledState(){const t=g.findOne(Nd,this._wrapper);this._element.hasAttribute(\"disabled\")?(this._config.disabled=!0,t.setAttribute(\"disabled\",\"\"),t.setAttribute(Da,\"\")):(this._config.disabled=!1,t.removeAttribute(\"disabled\"),t.removeAttribute(Da))}_observeMutationObserver(){this._mutationObserver&&this._mutationObserver.observe(this._element,{attributes:!0,childList:!0,characterData:!0,subtree:!0})}_disconnectMutationObserver(){this.mutationObserver&&(this._mutationObserver.disconnect(),this._mutationObserver=null)}_createSelectAllOption(){const t=this._selectAllId,e=null,s=!0,n=\"select-all\",o=this._config.selectAllLabel,r=Sa(this.options),a=!1,l=!1,c=null,h=null,d=null;return new Cd(t,e,s,n,o,r,a,l,c,h,d)}dispose(){this._removeComponentEvents(),this._destroyMaterialSelect(),this._listenToFocusChange(!1),P.removeData(this._element,zs)}_removeComponentEvents(){b.off(this.input,\"click\"),b.off(this.wrapper,this._handleKeydown.bind(this)),b.off(this.clearButton,\"click\"),b.off(this.clearButton,\"keydown\"),b.off(window,\"resize\",this._handleWindowResize.bind(this))}_destroyMaterialSelect(){this._isOpen&&this.close(),this._destroyMaterialTemplate()}_destroyMaterialTemplate(){const t=this._wrapper.parentNode,e=g.find(\"label\",this._wrapper);t.appendChild(this._element),e.forEach(s=>{t.appendChild(s)}),e.forEach(s=>{s.removeAttribute(xt)}),v.removeClass(this._element,this._classes.initialized),this._element.removeActiveStyles(Ld),t.removeChild(this._wrapper)}setValue(t){this.options.filter(s=>s.selected).forEach(s=>s.nativeOption.selected=!1),Array.isArray(t)?t.forEach(s=>{this._selectByValue(s)}):this._selectByValue(t),this._updateSelections()}_selectByValue(t){const e=this.options.find(s=>s.value===t);return e?(e.nativeOption.selected=!0,!0):!1}static jQueryInterface(t,e){return this.each(function(){let s=P.getData(this,zs);const n=typeof t==\"object\"&&t;if(!(!s&&/dispose/.test(t))&&(s||(s=new Lo(this,n)),typeof t==\"string\")){if(typeof s[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);s[t](e)}})}static getInstance(t){return P.getData(t,zs)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const wx=i=>{Nl(()=>{const t=Rl();if(t){const e=i.NAME,s=t.fn[e];t.fn[e]=i.jQueryInterface,t.fn[e].Constructor=i,t.fn[e].noConflict=()=>(t.fn[e]=s,i.jQueryInterface)}})},kx=(i,t)=>{b.on(document,`click.te.${i.NAME}`,t,function(e){e.preventDefault(),i.getOrCreateInstance(this).toggle()})},Sx=(i,t)=>{b.on(document,`click.te.${i.NAME}.data-api`,t,function(e){if([\"A\",\"AREA\"].includes(this.tagName)&&e.preventDefault(),ei(this))return;i.getOrCreateInstance(this).show()})},Ox=(i,t)=>{b.on(document,`click.te.${i.NAME}.data-api`,t,function(e){const s=Ie(this);if([\"A\",\"AREA\"].includes(this.tagName)&&e.preventDefault(),ei(this))return;b.one(s,i.EVENT_HIDDEN,()=>{ne(this)&&this.focus()});const n=g.findOne(i.OPEN_SELECTOR);n&&n!==s&&i.getInstance(n).hide(),i.getOrCreateInstance(s).toggle(this)})},Dx=(i,t)=>{b.on(document,`click.te.${i.NAME}`,t,e=>{e.preventDefault();const s=e.target.closest(t);i.getOrCreateInstance(s).toggle()})},Mx=(i,t)=>{b.on(document,`click.te.${i.NAME}`,t,function(e){const s=Ie(this);[\"A\",\"AREA\"].includes(this.tagName)&&e.preventDefault(),b.one(s,i.EVENT_SHOW,r=>{r.defaultPrevented||b.one(s,i.EVENT_HIDDEN,()=>{ne(this)&&this.focus()})});const n=g.findOne(`[${i.OPEN_SELECTOR}=\"true\"]`);n&&i.getInstance(n).hide(),i.getOrCreateInstance(s).toggle(this)})},Ix=(i,t)=>{b.one(document,\"mousedown\",t,i.autoInitial(new i))},Lx=(i,t)=>{b.on(document,`click.te.${i.NAME}.data-api`,t,function(e){(e.target.tagName===\"A\"||e.delegateTarget&&e.delegateTarget.tagName===\"A\")&&e.preventDefault();const s=yr(this);g.find(s).forEach(o=>{i.getOrCreateInstance(o,{toggle:!1}).toggle()})})},Ye={plugins:{legend:{labels:{color:\"rgb(102,102,102)\"}}}},Po={line:{options:{...Ye,elements:{line:{backgroundColor:\"rgba(59, 112, 202, 0.0)\",borderColor:\"rgb(59, 112, 202)\",borderWidth:2,tension:0},point:{borderColor:\"rgb(59, 112, 202)\",backgroundColor:\"rgb(59, 112, 202)\"}},responsive:!0,legend:{display:!0},tooltips:{intersect:!1,mode:\"index\"},datasets:{borderColor:\"red\"},scales:{x:{stacked:!0,grid:{display:!1},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}},y:{stacked:!1,grid:{borderDash:[2],drawBorder:!1,zeroLineColor:\"rgba(0,0,0,0)\",zeroLineBorderDash:[2],zeroLineBorderDashOffset:[2]},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}}}}},bar:{options:{...Ye,backgroundColor:\"rgb(59, 112, 202)\",borderWidth:0,responsive:!0,legend:{display:!0},tooltips:{intersect:!1,mode:\"index\"},scales:{x:{stacked:!0,grid:{display:!1},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}},y:{stacked:!0,grid:{borderDash:[2],drawBorder:!1,zeroLineColor:\"rgba(0,0,0,0)\",zeroLineBorderDash:[2],zeroLineBorderDashOffset:[2]},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}}}}},pie:{options:{...Ye,elements:{arc:{backgroundColor:\"rgb(59, 112, 202)\"}},responsive:!0,legend:{display:!0}}},doughnut:{options:{...Ye,elements:{arc:{backgroundColor:\"rgb(59, 112, 202)\"}},responsive:!0,legend:{display:!0}}},polarArea:{options:{...Ye,elements:{arc:{backgroundColor:\"rgba(59, 112, 202, 0.5)\"}},responsive:!0,legend:{display:!0}}},radar:{options:{...Ye,elements:{line:{backgroundColor:\"rgba(59, 112, 202, 0.5)\",borderColor:\"rgb(59, 112, 202)\",borderWidth:2},point:{borderColor:\"rgb(59, 112, 202)\",backgroundColor:\"rgb(59, 112, 202)\"}},responsive:!0,legend:{display:!0}}},scatter:{options:{...Ye,elements:{line:{backgroundColor:\"rgba(59, 112, 202, 0.5)\",borderColor:\"rgb(59, 112, 202)\",borderWidth:2,tension:0},point:{borderColor:\"rgb(59, 112, 202)\",backgroundColor:\"rgba(59, 112, 202, 0.5)\"}},responsive:!0,legend:{display:!0},tooltips:{intersect:!1,mode:\"index\"},datasets:{borderColor:\"red\"},scales:{x:{stacked:!0,grid:{display:!1},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}},y:{stacked:!1,grid:{borderDash:[2],drawBorder:!1,zeroLineColor:\"rgba(0,0,0,0)\",zeroLineBorderDash:[2],zeroLineBorderDashOffset:[2]},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}}}}},bubble:{options:{...Ye,elements:{point:{borderColor:\"rgb(59, 112, 202)\",backgroundColor:\"rgba(59, 112, 202, 0.5)\"}},responsive:!0,legend:{display:!0},scales:{x:{grid:{display:!1},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}},y:{grid:{borderDash:[2],drawBorder:!1,zeroLineColor:\"rgba(0,0,0,0)\",zeroLineBorderDash:[2],zeroLineBorderDashOffset:[2]},ticks:{fontColor:\"rgba(0,0,0, 0.5)\"}}}}}},Ks={alert:{name:\"Alert\",selector:\"[data-te-alert-init]\",isToggler:!1},animation:{name:\"Animate\",selector:\"[data-te-animation-init]\",isToggler:!1},carousel:{name:\"Carousel\",selector:\"[data-te-carousel-init]\",isToggler:!1},chips:{name:\"ChipsInput\",selector:\"[data-te-chips-init]\",isToggler:!1},chip:{name:\"Chip\",selector:\"[data-te-chip-init]\",isToggler:!1},datepicker:{name:\"Datepicker\",selector:\"[data-te-datepicker-init]\",isToggler:!1},input:{name:\"Input\",selector:\"[data-te-input-wrapper-init]\",isToggler:!1},scrollspy:{name:\"ScrollSpy\",selector:\"[data-te-spy='scroll']\",isToggler:!1},select:{name:\"Select\",selector:\"[data-te-select-init]\",isToggler:!1},sidenav:{name:\"Sidenav\",selector:\"[data-te-sidenav-init]\",isToggler:!1},stepper:{name:\"Stepper\",selector:\"[data-te-stepper-init]\",isToggler:!1},timepicker:{name:\"Timepicker\",selector:\"[data-te-timepicker-init]\",isToggler:!1},toast:{name:\"Toast\",selector:\"[data-te-toast-init]\",isToggler:!1},chart:{name:\"Chart\",selector:\"[data-te-chart]\",isToggler:!1,advanced:(i,t)=>{const e=o=>o[0]===\"{\"&&o[o.length-1]===\"}\"||o[0]===\"[\"&&o[o.length-1]===\"]\",s=o=>typeof o!=\"string\"?o:e(o)?JSON.parse(o.replace(/'/g,'\"')):o,n=o=>{const r={};return Object.keys(o).forEach(a=>{if(a.match(/dataset.*/)){const l=a.slice(7,8).toLowerCase().concat(a.slice(8));r[l]=s(o[a])}}),r};g.find(t).forEach(o=>{if(v.getDataAttribute(o,\"chart\")!==\"bubble\"&&v.getDataAttribute(o,\"chart\")!==\"scatter\"){const r=v.getDataAttributes(o),a={data:{datasets:[n(r)]}};return r.chart&&(a.type=r.chart),r.labels&&(a.data.labels=JSON.parse(r.labels.replace(/'/g,'\"'))),new i(o,{...a,...Po[a.type]})}return null})}},button:{name:\"Button\",selector:\"[data-te-toggle='button']\",isToggler:!0,callback:Dx},collapse:{name:\"Collapse\",selector:\"[data-te-collapse-init]\",isToggler:!0,callback:Lx},dropdown:{name:\"Dropdown\",selector:\"[data-te-dropdown-toggle-ref]\",isToggler:!0,callback:kx},modal:{name:\"Modal\",selector:\"[data-te-toggle='modal']\",isToggler:!0,callback:Mx},ripple:{name:\"Ripple\",selector:\"[data-te-ripple-init]\",isToggler:!0,callback:Ix},offcanvas:{name:\"Offcanvas\",selector:\"[data-te-offcanvas-toggle]\",isToggler:!0,callback:Ox},tab:{name:\"Tab\",selector:\"[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']\",isToggler:!0,callback:Sx}},Px=i=>Ks[i.NAME]||null,Rx=i=>{if(!i||[].includes(i.NAME))return;[].push(i.NAME);const t=Px(i),e=(t==null?void 0:t.isToggler)||!1;if(wx(i),t!=null&&t.advanced){t==null||t.advanced(i,t==null?void 0:t.selector);return}if(e){t==null||t.callback(i,t==null?void 0:t.selector);return}g.find(t==null?void 0:t.selector).forEach(s=>{let n=i.getInstance(s);n||(n=new i(s))})},Nx=i=>{i.forEach(t=>Rx(t))},Ia=(i,t=!1)=>{const e=Object.keys(Ks).map(s=>{if(!!document.body.querySelector(Ks[s].selector)){const o=i[Ks[s].name];return!o&&![].includes(s)&&t&&console.warn(`Please import ${Ks[s].name} from \"tw-elements\" package and add it to a object parameter inside \"initTE\" function`),o}});Nx(e)},$x=({inputID:i,labelText:t},e)=>(Ia({Input:Z},!1),`<div data-te-chips-input-wrapper data-te-input-wrapper-init class=\"${e.chipsInputWrapper}\">\n      <input\n          type=\"text\"\n          class=\"${e.chipsInput}\"\n          id=\"${i}\"\n          placeholder=\"Example label\" />\n        <label\n          for=\"${i}\"\n          class=\"${e.chipsLabel}\"\n          >${t}\n        </label>\n\n        <div data-te-input-notch-ref class=\"${e.chipsNotchesWrapper}\">\n        <div class=\"${e.chipsNotchesLeading}\" data-te-input-notch-leading-ref style=\"width: 9px;\"></div>\n        <div class=\"${e.chipsNotchesMiddle}\" data-te-input-notch-middle-ref style=\"width: 87.2px;\"></div>\n        <div class=\"${e.chipsNotchesTrailing}\" data-te-input-notch-trailing-ref></div>\n      </div>\n    </div>`),Bx=({text:i,iconSVG:t},e)=>`<div data-te-chip-init data-te-ripple-init class=\"${e.chipElement}\">\n    <span data-te-chip-text>${i}</span> \n      <span data-te-chip-close class=\"${e.chipCloseIcon}\">\n        ${t}\n      </span>\n  </div>`,Ro=\"chip\",Hx=`te.${Ro}`,Hd=\"data-te-chip-close\",La=`[${Hd}]`,Fx=\"delete.te.chips\",Vx=\"select.te.chip\",Wx='<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-3 h-3\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" /></svg>',zx={text:\"string\",closeIcon:\"boolean\",img:\"object\",iconSVG:\"string\"},jx={text:\"\",closeIcon:!1,img:{path:\"\",alt:\"\"},iconSVG:Wx},Yx={icon:\"float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out\",chipElement:\"flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded\",chipCloseIcon:\"w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out\"},Kx={icon:\"string\",chipElement:\"string\",chipCloseIcon:\"string\"};class vi{constructor(t,e={},s){this._element=t,this._options=this._getConfig(e),this._classes=this._getClasses(s)}static get NAME(){return Ro}init(){this._appendCloseIcon(),this._handleDelete(),this._handleTextChip(),this._handleClickOnChip()}dispose(){this._element=null,this._options=null,b.off(this._element,\"click\")}appendChip(){const{text:t,closeIcon:e,iconSVG:s}=this._options;return Bx({text:t,closeIcon:e,iconSVG:s},this._classes)}_appendCloseIcon(t=this._element){if(!(g.find(La,this._element).length>0)&&this._options.closeIcon){const e=z(\"span\");e.classList=this._classes.icon,e.setAttribute(Hd),e.innerHTML=this._options.iconSVG,t.insertAdjacentElement(\"beforeend\",e)}}_handleClickOnChip(){b.on(this._element,\"click\",t=>{const{textContent:e}=t.target,s={};s.tag=e.trim(),b.trigger(Vx,{event:t,obj:s})})}_handleDelete(){g.find(La,this._element).length!==0&&b.on(this._element,\"click\",La,()=>{b.trigger(this._element,Fx),this._element.remove()})}_handleTextChip(){this._element.innerText===\"\"&&(this._element.innerText=this._options.text)}_getConfig(t){const e={...jx,...v.getDataAttributes(this._element),...t};return W(Ro,e,zx),e}_getClasses(t){const e=v.getDataClassAttributes(this._element);return t={...Yx,...e,...t},W(Ro,t,Kx),t}static getInstance(t){return P.getData(t,Hx)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}}const Us=\"chips\",Xs=`data-te-${Us}`,Fd=`te.${Us}`,Ux=`${Xs}-init`,Bt=`${Xs}-active`,Vd=`${Xs}-initial`,Wd=`${Xs}-placeholder`,Xx=`${Xs}-input-wrapper`,Pa=\"data-te-chip-init\",zd=\"data-te-chip-close\",jd=\"data-te-chip-text\",Gx=`[${Bt}]`,Ra=`[${Pa}]`,qx=`${Ra}${Gx}`,Na=`[${zd}]`,Zx=`[${Xx}]`,Qx=`[${jd}]`,Jx=`[${Wd}]`,tE=\"data-te-input-notch-leading-ref\",eE=\"data-te-input-notch-middle-ref\",iE=`[${tE}]`,sE=`[${eE}]`,os=\"data-te-input-state-active\",$a=\"[data-te-input-notch-ref]\",nE=\"add.te.chips\",oE=\"arrowDown.te.chips\",rE=\"arrowLeft.te.chips\",aE=\"arrowRight.te.chips\",lE=\"arrowUp.te.chips\",Yd=\"delete.te.chips\",Kd=\"select.te.chips\",cE={inputID:\"string\",parentSelector:\"string\",initialValues:\"array\",editable:\"boolean\",labelText:\"string\"},hE={inputID:se(\"chips-input-\"),parentSelector:\"\",initialValues:[{tag:\"init1\"},{tag:\"init2\"}],editable:!1,labelText:\"Example label\"},dE={opacity:\"opacity-0\",inputWrapperPadding:\"p-[5px]\",transition:\"transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",contentEditable:\"outline-none !border-[3px] !border-solid !border-[#b2b3b4]\",chipsInputWrapper:\"relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",chipsInput:\"peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0\",chipsLabel:\"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200\",chipsNotchesWrapper:\"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",chipsNotchesLeading:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",chipsNotchesMiddle:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",chipsNotchesTrailing:\"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\"},uE={opacity:\"string\",inputWrapperPadding:\"string\",transition:\"string\",contentEditable:\"string\",chipsInputWrapper:\"string\",chipsInput:\"string\",chipsLabel:\"string\",chipsNotchesWrapper:\"string\",chipsNotchesLeading:\"string\",chipsNotchesMiddle:\"string\",chipsNotchesTrailing:\"string\"};class Ud extends vi{constructor(e,s={},n){super(e,s);Ee(this,\"_handleBlurInput\",({target:e})=>{e.value.length>0&&this._handleCreateChip(e,e.value),this.allChips.length>0?(e.setAttribute(Bt,\"\"),this.input.setAttribute(os,\"\"),g.findOne($a,this.input.parentNode).setAttribute(os,\"\"),this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \"))):(e.removeAttribute(Bt),this.input.removeAttribute(os),g.findOne($a,this.input.parentNode).removeAttribute(os),this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \"))),this.allChips.forEach(s=>s.removeAttribute(Bt))});this._element=e,this._label=null,this._labelWidth=0,this._labelMarginLeft=0,this._notchLeading=null,this._notchMiddle=null,this._element&&P.setData(e,Fd,this),this._options=this._getConfig(s),this._classes=this._getClasses(n),this.numberClicks=0,this.init()}static get NAME(){return Us}get activeChip(){return g.findOne(qx,this._element)}get input(){return g.findOne(\"input\",this._element)}get allChips(){return g.find(Ra,this._element)}get chipsInputWrapper(){return g.findOne(Zx,this._element)}init(){this._setChipsClass(),this._appendInputToElement(Wd),this._handleInitialValue(),this._handleInputText(),this._handleKeyboard(),this._handleChipsOnSelect(),this._handleEditable(),this._handleChipsFocus(),this._handleClicksOnChips(),this._getLabelData(),this._getLabelWidth(),this._getNotchData(),this._applyNotch()}dispose(){this._element=null,this._options=null}_getNotchData(){this._notchMiddle=g.findOne(sE,this._element),this._notchLeading=g.findOne(iE,this._element)}_getLabelData(){this._label=g.findOne(\"label\",this._element)}_getLabelWidth(){this._labelWidth=this._label.clientWidth*.8+8}_applyNotch(){this._notchMiddle.style.width=`${this._labelWidth}px`,this._notchLeading.style.width=`${this._labelMarginLeft+9}px`,this._label!==null&&(this._label.style.marginLeft=`${this._labelMarginLeft}px`)}_setChipsClass(){this._element.setAttribute(Ux,\"\")}_handleDeleteEvents(e){const[s]=this.allChips.slice(-1);if(this.activeChip===null)s.remove(),this._handleEvents(e,Yd);else{const n=this.allChips.findIndex(a=>a===this.activeChip),o=this._handleActiveChipAfterRemove(n),r=[];if(this.activeChip===null)return;this.activeChip.remove(),this._handleEvents(e,Yd),this.numberClicks=n,o.setAttribute(Bt,\"\"),this.allChips.forEach(a=>{a.hasAttribute(Bt)&&(r.push(a),r.length>1&&this.allChips.forEach(l=>l.remove()))})}}_handleUpEvents(e){this.numberClicks+=1,this.numberClicks===this.allChips.length+1&&(this.numberClicks=0),this._handleRightKeyboardArrow(this.numberClicks),this._handleEvents(e,aE),this._handleEvents(e,lE)}_handleDownEvents(e){this.numberClicks-=1,this.numberClicks<=0&&(this.numberClicks=this.allChips.length),this._handleLeftKeyboardArrow(this.numberClicks),this._handleEvents(e,rE),this._handleEvents(e,oE)}_keyboardEvents(e){const{target:s,keyCode:n,ctrlKey:o}=e;s.value.length>0||this.allChips.length===0||(n===Lv||n===Pv?this._handleDeleteEvents(e):n===Qi||n===Tt?this._handleUpEvents(e):n===Zi||n===ut?this._handleDownEvents(e):n===65&&o&&this._handleAddActiveClass())}_handleKeyboard(){b.on(this.input,\"keydown\",e=>this._keyboardEvents(e))}_handleEditable(){const{editable:e}=this._options;e&&this.allChips.forEach(s=>{b.on(s,\"dblclick\",n=>{const o=g.findOne(Na,s);s.classList.add(...this._classes.contentEditable.split(\" \")),s.contentEditable=!0,s.focus(),setTimeout(()=>{v.addStyle(o,{display:\"none\"})},200),o.classList.add(...this._classes.opacity.split(\" \")),n.target.textContent,b.trigger(s,Kd,{event:n,allChips:this.allChips})}),b.on(document,\"click\",({target:n})=>{const o=g.findOne(Na,s),r=g.findOne(Qx,s),a=n===s,l=s&&s.contains(n);!a&&!l&&(s.contentEditable=!1,s.classList.remove(...this._classes.contentEditable.split(\" \")),r.textContent!==\"\"&&setTimeout(()=>{v.addStyle(o,{display:\"block\"}),o.classList.remove(...this._classes.opacity.split(\" \"))},160)),r.textContent===\"\"&&(setTimeout(()=>{s.classList.add(...this._classes.opacity.split(\" \"))},200),setTimeout(()=>{s.remove()},300))})})}_handleRemoveActiveClass(){this.allChips.forEach(e=>e.removeAttribute(Bt))}_handleAddActiveClass(){this.allChips.forEach(e=>e.setAttribute(Bt,\"\"))}_handleRightKeyboardArrow(e){this._handleRemoveActiveClass(),e===0&&(e=1),this._handleAddActiveClassWithKebyboard(e)}_handleLeftKeyboardArrow(e){this._handleRemoveActiveClass(),this._handleAddActiveClassWithKebyboard(e)}_handleActiveChipAfterRemove(e){const s=e===0?1:e-1;return this.allChips[s]}_handleClicksOnChips(){b.on(this._element,\"click\",()=>{this.allChips.length===0&&(this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \")),this.input.removeAttribute(Bt))})}_handleTextContent(){const e=[];return this.allChips.forEach(s=>e.push({tag:s.textContent.trim()})),e}_handleEvents(e,s){const n=this._handleTextContent(),o=this.allChips.filter(r=>r.hasAttribute(Bt)&&r);b.trigger(this._element,s,{event:e,allChips:this.allChips,arrOfObjects:n,active:o,activeObj:{tag:o.length<=0?\"\":o[0].textContent.trim()}})}_handleChipsFocus(){b.on(this._element,\"click\",({target:{attributes:e}})=>{const s=[...e];s.includes(Pa)||s.includes(zd)||s.includes(jd)||this.input.focus()})}_handleInitialValue(){if(this._appendInputToElement(Vd),this._element.hasAttribute(Vd)){const{initialValues:e}=this._options;e.forEach(({tag:s})=>this._handleCreateChip(this.input,s)),g.findOne($a,this.input.parentNode).setAttribute(os,\"\"),this.input.setAttribute(Bt,\"\"),this.input.setAttribute(os,\"\")}this.allChips.length>0&&(this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \")),this.chipsInputWrapper.classList.add(...this._classes.transition.split(\" \")))}_handleKeysInputToElement(e){const{keyCode:s,target:n}=e;if(n.hasAttribute(Pa)){const o=g.findOne(Na,n);s===Pt&&(n.contentEditable=!1,n.classList.remove(...this._classes.contentEditable.split(\" \")),n.textContent!==\"\"?setTimeout(()=>{v.addStyle(o,{display:\"block\"}),o.classList.remove(...this._classes.opacity.split(\" \"))},160):n.textContent===\"\"&&(setTimeout(()=>{n.classList.add(...this._classes.opacity.split(\" \"))},200),setTimeout(()=>{n.remove()},300)));return}if(s===Pt){if(n.value===\"\")return;this._handleCreateChip(n,n.value),this._handleRemoveActiveClass(),this.numberClicks=this.allChips.length+1,this._handleEvents(e,nE)}this.allChips.length>0?(this.chipsInputWrapper.classList.add(...this._classes.inputWrapperPadding.split(\" \")),this.chipsInputWrapper.classList.add(...this._classes.transition.split(\" \"))):this.chipsInputWrapper.classList.remove(...this._classes.inputWrapperPadding.split(\" \"))}_handleInputText(){const e=g.findOne(Jx,this._element);b.on(this._element,\"keyup\",e,s=>this._handleKeysInputToElement(s)),b.on(this.input,\"blur\",s=>this._handleBlurInput(s))}_appendInputToElement(e){if(!this._element.hasAttribute(e))return;const s=$x(this._options,this._classes);this._element.insertAdjacentHTML(\"beforeend\",s)}_handleCreateChip(e,s){const n=z(\"div\"),o=vi.getInstance(n),r=new vi(o,{text:s},this._classes);this._options.parentSelector!==\"\"?document.querySelector(this._options.parentSelector).insertAdjacentHTML(\"beforeend\",r.appendChip()):e.insertAdjacentHTML(\"beforebegin\",r.appendChip()),e.value=\"\",g.find(Ra).forEach(a=>{let l=vi.getInstance(a);return l||(l=new vi(a,{},this._classes)),l.init()}),this._handleEditable()}_handleChipsOnSelect(){this.allChips.forEach(e=>{b.on(this._element,\"click\",s=>{b.trigger(e,Kd,{event:s,allChips:this.allChips})})})}_handleAddActiveClassWithKebyboard(e){let s;this.allChips[e-1]===void 0?s=this.allChips[e-2]:s=this.allChips[e-1],s.setAttribute(Bt)}_getConfig(e){const s={...hE,...v.getDataAttributes(this._element),...e};return W(Us,s,cE),s}_getClasses(e){const s=v.getDataClassAttributes(this._element);return e={...dE,...s,...e},W(Us,e,uE),e}static getInstance(e){return P.getData(e,Fd)}static getOrCreateInstance(e,s={}){return this.getInstance(e)||new this(e,typeof s==\"object\"?s:null)}}var fE=function(t){return pE(t)&&!_E(t)};function pE(i){return!!i&&typeof i==\"object\"}function _E(i){var t=Object.prototype.toString.call(i);return t===\"[object RegExp]\"||t===\"[object Date]\"||bE(i)}var gE=typeof Symbol==\"function\"&&Symbol.for,mE=gE?Symbol.for(\"react.element\"):60103;function bE(i){return i.$$typeof===mE}function vE(i){return Array.isArray(i)?[]:{}}function Gs(i,t){return t.clone!==!1&&t.isMergeableObject(i)?rs(vE(i),i,t):i}function yE(i,t,e){return i.concat(t).map(function(s){return Gs(s,e)})}function xE(i,t){if(!t.customMerge)return rs;var e=t.customMerge(i);return typeof e==\"function\"?e:rs}function EE(i){return Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(i).filter(function(t){return Object.propertyIsEnumerable.call(i,t)}):[]}function Xd(i){return Object.keys(i).concat(EE(i))}function Gd(i,t){try{return t in i}catch{return!1}}function CE(i,t){return Gd(i,t)&&!(Object.hasOwnProperty.call(i,t)&&Object.propertyIsEnumerable.call(i,t))}function TE(i,t,e){var s={};return e.isMergeableObject(i)&&Xd(i).forEach(function(n){s[n]=Gs(i[n],e)}),Xd(t).forEach(function(n){CE(i,n)||(Gd(i,n)&&e.isMergeableObject(t[n])?s[n]=xE(n,e)(i[n],t[n],e):s[n]=Gs(t[n],e))}),s}function rs(i,t,e){e=e||{},e.arrayMerge=e.arrayMerge||yE,e.isMergeableObject=e.isMergeableObject||fE,e.cloneUnlessOtherwiseSpecified=Gs;var s=Array.isArray(t),n=Array.isArray(i),o=s===n;return o?s?e.arrayMerge(i,t,e):TE(i,t,e):Gs(t,e)}rs.all=function(t,e){if(!Array.isArray(t))throw new Error(\"first argument should be an array\");return t.reduce(function(s,n){return rs(s,n,e)},{})};var AE=rs,Ba=AE;const qd=\"chart\",No=\"te.chart\",wE=\"chart\",Zd=(i,t,e)=>{const s=(n,o,r)=>{const a=n.slice();return o.forEach((l,c)=>{typeof a[c]>\"u\"?a[c]=r.cloneUnlessOtherwiseSpecified(l,r):r.isMergeableObject(l)?a[c]=Ba(n[c],l,r):n.indexOf(l)===-1&&a.push(l)}),a};return Ba(e[t],i,{arrayMerge:s})},kE={darkTicksColor:\"#fff\",darkLabelColor:\"#fff\",darkGridLinesColor:\"#555\",darkmodeOff:\"undefined\",darkBgColor:\"#262626\",options:null},SE={darkTicksColor:\"string\",darkLabelColor:\"string\",darkGridLinesColor:\"string\",darkmodeOff:\"(string|null)\",darkBgColor:\"string\",options:\"(object|null)\"};let Qd=class Yp{constructor(t,e,s={},n={}){this._waitForCharts(t,e,s,n)}async _getChartjs(){const{Chart:t,ArcElement:e,LineElement:s,BarElement:n,PointElement:o,BarController:r,BubbleController:a,DoughnutController:l,LineController:c,PieController:h,PolarAreaController:d,RadarController:u,ScatterController:f,CategoryScale:p,LinearScale:_,LogarithmicScale:m,RadialLinearScale:y,TimeScale:x,TimeSeriesScale:E,Decimation:C,Filler:T,Legend:A,Title:w,Tooltip:S,SubTitle:k}=await Promise.resolve().then(()=>tk);return t.register(e,s,n,o,r,a,l,c,h,d,u,f,p,_,m,y,x,E,C,T,A,w,S,k),t}async _getChartDataLabels(){const{ChartDataLabels:t}=await Promise.resolve().then(()=>Ck);return t}async _waitForCharts(t,e,s={},n={}){this._Chartjs=await this._getChartjs(),this._ChartDataLabels=await this._getChartDataLabels(),this._element=t,this._data=e,this._options=s,this._type=e.type,this._canvas=null,this._chart=null,this._darkOptions=this._getDarkConfig(n),this._darkModeClassContainer=document.querySelector(\"html\"),this._prevConfig=null,this._observer=null,this._element&&(P.setData(t,No,this),v.addClass(this._element,wE),this._chartConstructor()),this._darkOptions.darkmodeOff!==null&&(this._handleMode(this.systemColorMode),this._observer=new MutationObserver(this._observerCallback.bind(this)),this._observer.observe(this._darkModeClassContainer,{attributes:!0}))}static get NAME(){return qd}get systemColorMode(){return localStorage.theme||(this._darkModeClassContainer.classList.contains(\"dark\")?\"dark\":\"light\")}dispose(){this._observer.disconnect(),P.removeData(this._element,No),this._element=null}update(t,e){t&&(this._data={...this._data,...t},this._chart.data=this._data),this._prevConfig=this._chart.options,this._options={...this._options,...e},this._chart.options=Ba(this._chart.options,this._options),this._chart.update()}_getDarkConfig(t){let e={};const s=v.getDataAttributes(this._element);Object.keys(s).forEach(c=>c.startsWith(\"dark\")&&(e[c]=s[c])),e={...kE,...e};const n={y:{ticks:{color:e.darkTicksColor},grid:{color:e.darkGridLinesColor}},x:{ticks:{color:e.darkTicksColor},grid:{color:e.darkGridLinesColor}}},o={r:{ticks:{color:e.darkTicksColor,backdropColor:e.darkBgColor},grid:{color:e.darkGridLinesColor},pointLabels:{color:e.darkTicksColor}}},l={scales:[\"pie\",\"doughnut\",\"polarArea\",\"radar\"].includes(this._type)?[\"polarArea\",\"radar\"].includes(this._type)?o:{}:n,plugins:{legend:{labels:{color:e.darkLabelColor}}}};return t={...e,options:{...l},...t},W(qd,t,SE),t}_chartConstructor(){if(this._data){this._createCanvas();const t=Zd(this._options,this._type,Po),e=[];t.dataLabelsPlugin&&e.push(this._ChartDataLabels),this._chart=new this._Chartjs(this._canvas,{...this._data,...t,plugins:e})}}_createCanvas(){this._canvas||(this._element.nodeName===\"CANVAS\"?this._canvas=this._element:(this._canvas=z(\"canvas\"),this._element.appendChild(this._canvas)))}_handleMode(t){t===\"dark\"?(this._changeDatasetBorderColor(),this.update(null,this._darkOptions.options)):(this._changeDatasetBorderColor(!1),this._prevConfig&&this.update(null,this._prevConfig))}_observerCallback(t){for(const e of t)e.type===\"attributes\"&&this._handleMode(this.systemColorMode)}_changeDatasetBorderColor(t=!0){[...this._data.data.datasets].forEach(e=>[\"pie\",\"doughnut\",\"polarArea\"].includes(this._type)&&(e.borderColor=t?this._darkOptions.darkBgColor:\"#fff\"))}static jQueryInterface(t,e,s){return this.each(function(){let n=P.getData(this,No);if(!(!n&&/dispose/.test(t))){if(!n){const o=e?Zd(e,s,Po):Po[s];n=new Yp(this,{...t,...o})}if(typeof t==\"string\"){if(typeof n[t]>\"u\")throw new TypeError(`No method named \"${t}\"`);n[t](e,s)}}})}static getInstance(t){return P.getData(t,No)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,typeof e==\"object\"?e:null)}};Ia({Animate:qn,Alert:As,Button:On,ChipsInput:Ud,Chip:vi,Dropdown:$t,Carousel:ae,Collapse:re,Offcanvas:zi,Modal:Ss,Popover:zn,ScrollSpy:Is,Select:Lo,Tab:Un,Toast:Ls,Tooltip:Ms,Ripple:Ui,Datepicker:Ph,Timepicker:od,Sidenav:bi,Stepper:vd,Input:Z,Chart:Qd});/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */function Te(){}const OE=function(){let i=0;return function(){return i++}}();function N(i){return i===null||typeof i>\"u\"}function Q(i){if(Array.isArray&&Array.isArray(i))return!0;const t=Object.prototype.toString.call(i);return t.slice(0,7)===\"[object\"&&t.slice(-6)===\"Array]\"}function $(i){return i!==null&&Object.prototype.toString.call(i)===\"[object Object]\"}const rt=i=>(typeof i==\"number\"||i instanceof Number)&&isFinite(+i);function Ht(i,t){return rt(i)?i:t}function R(i,t){return typeof i>\"u\"?t:i}const DE=(i,t)=>typeof i==\"string\"&&i.endsWith(\"%\")?parseFloat(i)/100:i/t,Jd=(i,t)=>typeof i==\"string\"&&i.endsWith(\"%\")?parseFloat(i)/100*t:+i;function G(i,t,e){if(i&&typeof i.call==\"function\")return i.apply(e,t)}function U(i,t,e,s){let n,o,r;if(Q(i))if(o=i.length,s)for(n=o-1;n>=0;n--)t.call(e,i[n],n);else for(n=0;n<o;n++)t.call(e,i[n],n);else if($(i))for(r=Object.keys(i),o=r.length,n=0;n<o;n++)t.call(e,i[r[n]],r[n])}function $o(i,t){let e,s,n,o;if(!i||!t||i.length!==t.length)return!1;for(e=0,s=i.length;e<s;++e)if(n=i[e],o=t[e],n.datasetIndex!==o.datasetIndex||n.index!==o.index)return!1;return!0}function Bo(i){if(Q(i))return i.map(Bo);if($(i)){const t=Object.create(null),e=Object.keys(i),s=e.length;let n=0;for(;n<s;++n)t[e[n]]=Bo(i[e[n]]);return t}return i}function tu(i){return[\"__proto__\",\"prototype\",\"constructor\"].indexOf(i)===-1}function ME(i,t,e,s){if(!tu(i))return;const n=t[i],o=e[i];$(n)&&$(o)?ge(n,o,s):t[i]=Bo(o)}function ge(i,t,e){const s=Q(t)?t:[t],n=s.length;if(!$(i))return i;e=e||{};const o=e.merger||ME;for(let r=0;r<n;++r){if(t=s[r],!$(t))continue;const a=Object.keys(t);for(let l=0,c=a.length;l<c;++l)o(a[l],i,t,e)}return i}function qs(i,t){return ge(i,t,{merger:IE})}function IE(i,t,e){if(!tu(i))return;const s=t[i],n=e[i];$(s)&&$(n)?qs(s,n):Object.prototype.hasOwnProperty.call(t,i)||(t[i]=Bo(n))}const eu={\"\":i=>i,x:i=>i.x,y:i=>i.y};function Ke(i,t){return(eu[t]||(eu[t]=LE(t)))(i)}function LE(i){const t=PE(i);return e=>{for(const s of t){if(s===\"\")break;e=e&&e[s]}return e}}function PE(i){const t=i.split(\".\"),e=[];let s=\"\";for(const n of t)s+=n,s.endsWith(\"\\\\\")?s=s.slice(0,-1)+\".\":(e.push(s),s=\"\");return e}function Ha(i){return i.charAt(0).toUpperCase()+i.slice(1)}const Ft=i=>typeof i<\"u\",Ue=i=>typeof i==\"function\",iu=(i,t)=>{if(i.size!==t.size)return!1;for(const e of i)if(!t.has(e))return!1;return!0};function RE(i){return i.type===\"mouseup\"||i.type===\"click\"||i.type===\"contextmenu\"}const et=Math.PI,q=2*et,NE=q+et,Ho=Number.POSITIVE_INFINITY,$E=et/180,nt=et/2,Zs=et/4,su=et*2/3,Vt=Math.log10,me=Math.sign;function nu(i){const t=Math.round(i);i=Qs(i,t,i/1e3)?t:i;const e=Math.pow(10,Math.floor(Vt(i))),s=i/e;return(s<=1?1:s<=2?2:s<=5?5:10)*e}function BE(i){const t=[],e=Math.sqrt(i);let s;for(s=1;s<e;s++)i%s===0&&(t.push(s),t.push(i/s));return e===(e|0)&&t.push(e),t.sort((n,o)=>n-o).pop(),t}function as(i){return!isNaN(parseFloat(i))&&isFinite(i)}function Qs(i,t,e){return Math.abs(i-t)<e}function HE(i,t){const e=Math.round(i);return e-t<=i&&e+t>=i}function ou(i,t,e){let s,n,o;for(s=0,n=i.length;s<n;s++)o=i[s][e],isNaN(o)||(t.min=Math.min(t.min,o),t.max=Math.max(t.max,o))}function Jt(i){return i*(et/180)}function Fa(i){return i*(180/et)}function ru(i){if(!rt(i))return;let t=1,e=0;for(;Math.round(i*t)/t!==i;)t*=10,e++;return e}function au(i,t){const e=t.x-i.x,s=t.y-i.y,n=Math.sqrt(e*e+s*s);let o=Math.atan2(s,e);return o<-.5*et&&(o+=q),{angle:o,distance:n}}function Va(i,t){return Math.sqrt(Math.pow(t.x-i.x,2)+Math.pow(t.y-i.y,2))}function FE(i,t){return(i-t+NE)%q-et}function Nt(i){return(i%q+q)%q}function Js(i,t,e,s){const n=Nt(i),o=Nt(t),r=Nt(e),a=Nt(o-n),l=Nt(r-n),c=Nt(n-o),h=Nt(n-r);return n===o||n===r||s&&o===r||a>l&&c<h}function ct(i,t,e){return Math.max(t,Math.min(e,i))}function VE(i){return ct(i,-32768,32767)}function Ae(i,t,e,s=1e-6){return i>=Math.min(t,e)-s&&i<=Math.max(t,e)+s}function Wa(i,t,e){e=e||(r=>i[r]<t);let s=i.length-1,n=0,o;for(;s-n>1;)o=n+s>>1,e(o)?n=o:s=o;return{lo:n,hi:s}}const we=(i,t,e,s)=>Wa(i,e,s?n=>i[n][t]<=e:n=>i[n][t]<e),WE=(i,t,e)=>Wa(i,e,s=>i[s][t]>=e);function zE(i,t,e){let s=0,n=i.length;for(;s<n&&i[s]<t;)s++;for(;n>s&&i[n-1]>e;)n--;return s>0||n<i.length?i.slice(s,n):i}const lu=[\"push\",\"pop\",\"shift\",\"splice\",\"unshift\"];function jE(i,t){if(i._chartjs){i._chartjs.listeners.push(t);return}Object.defineProperty(i,\"_chartjs\",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),lu.forEach(e=>{const s=\"_onData\"+Ha(e),n=i[e];Object.defineProperty(i,e,{configurable:!0,enumerable:!1,value(...o){const r=n.apply(this,o);return i._chartjs.listeners.forEach(a=>{typeof a[s]==\"function\"&&a[s](...o)}),r}})})}function cu(i,t){const e=i._chartjs;if(!e)return;const s=e.listeners,n=s.indexOf(t);n!==-1&&s.splice(n,1),!(s.length>0)&&(lu.forEach(o=>{delete i[o]}),delete i._chartjs)}function hu(i){const t=new Set;let e,s;for(e=0,s=i.length;e<s;++e)t.add(i[e]);return t.size===s?i:Array.from(t)}const du=function(){return typeof window>\"u\"?function(i){return i()}:window.requestAnimationFrame}();function uu(i,t,e){const s=e||(r=>Array.prototype.slice.call(r));let n=!1,o=[];return function(...r){o=s(r),n||(n=!0,du.call(window,()=>{n=!1,i.apply(t,o)}))}}function YE(i,t){let e;return function(...s){return t?(clearTimeout(e),e=setTimeout(i,t,s)):i.apply(this,s),t}}const za=i=>i===\"start\"?\"left\":i===\"end\"?\"right\":\"center\",pt=(i,t,e)=>i===\"start\"?t:i===\"end\"?e:(t+e)/2,KE=(i,t,e,s)=>i===(s?\"left\":\"right\")?e:i===\"center\"?(t+e)/2:t;function fu(i,t,e){const s=t.length;let n=0,o=s;if(i._sorted){const{iScale:r,_parsed:a}=i,l=r.axis,{min:c,max:h,minDefined:d,maxDefined:u}=r.getUserBounds();d&&(n=ct(Math.min(we(a,r.axis,c).lo,e?s:we(t,l,r.getPixelForValue(c)).lo),0,s-1)),u?o=ct(Math.max(we(a,r.axis,h,!0).hi+1,e?0:we(t,l,r.getPixelForValue(h),!0).hi+1),n,s)-n:o=s-n}return{start:n,count:o}}function pu(i){const{xScale:t,yScale:e,_scaleRanges:s}=i,n={xmin:t.min,xmax:t.max,ymin:e.min,ymax:e.max};if(!s)return i._scaleRanges=n,!0;const o=s.xmin!==t.min||s.xmax!==t.max||s.ymin!==e.min||s.ymax!==e.max;return Object.assign(s,n),o}const Fo=i=>i===0||i===1,_u=(i,t,e)=>-(Math.pow(2,10*(i-=1))*Math.sin((i-t)*q/e)),gu=(i,t,e)=>Math.pow(2,-10*i)*Math.sin((i-t)*q/e)+1,tn={linear:i=>i,easeInQuad:i=>i*i,easeOutQuad:i=>-i*(i-2),easeInOutQuad:i=>(i/=.5)<1?.5*i*i:-.5*(--i*(i-2)-1),easeInCubic:i=>i*i*i,easeOutCubic:i=>(i-=1)*i*i+1,easeInOutCubic:i=>(i/=.5)<1?.5*i*i*i:.5*((i-=2)*i*i+2),easeInQuart:i=>i*i*i*i,easeOutQuart:i=>-((i-=1)*i*i*i-1),easeInOutQuart:i=>(i/=.5)<1?.5*i*i*i*i:-.5*((i-=2)*i*i*i-2),easeInQuint:i=>i*i*i*i*i,easeOutQuint:i=>(i-=1)*i*i*i*i+1,easeInOutQuint:i=>(i/=.5)<1?.5*i*i*i*i*i:.5*((i-=2)*i*i*i*i+2),easeInSine:i=>-Math.cos(i*nt)+1,easeOutSine:i=>Math.sin(i*nt),easeInOutSine:i=>-.5*(Math.cos(et*i)-1),easeInExpo:i=>i===0?0:Math.pow(2,10*(i-1)),easeOutExpo:i=>i===1?1:-Math.pow(2,-10*i)+1,easeInOutExpo:i=>Fo(i)?i:i<.5?.5*Math.pow(2,10*(i*2-1)):.5*(-Math.pow(2,-10*(i*2-1))+2),easeInCirc:i=>i>=1?i:-(Math.sqrt(1-i*i)-1),easeOutCirc:i=>Math.sqrt(1-(i-=1)*i),easeInOutCirc:i=>(i/=.5)<1?-.5*(Math.sqrt(1-i*i)-1):.5*(Math.sqrt(1-(i-=2)*i)+1),easeInElastic:i=>Fo(i)?i:_u(i,.075,.3),easeOutElastic:i=>Fo(i)?i:gu(i,.075,.3),easeInOutElastic(i){return Fo(i)?i:i<.5?.5*_u(i*2,.1125,.45):.5+.5*gu(i*2-1,.1125,.45)},easeInBack(i){return i*i*((1.70158+1)*i-1.70158)},easeOutBack(i){return(i-=1)*i*((1.70158+1)*i+1.70158)+1},easeInOutBack(i){let t=1.70158;return(i/=.5)<1?.5*(i*i*(((t*=1.525)+1)*i-t)):.5*((i-=2)*i*(((t*=1.525)+1)*i+t)+2)},easeInBounce:i=>1-tn.easeOutBounce(1-i),easeOutBounce(i){return i<1/2.75?7.5625*i*i:i<2/2.75?7.5625*(i-=1.5/2.75)*i+.75:i<2.5/2.75?7.5625*(i-=2.25/2.75)*i+.9375:7.5625*(i-=2.625/2.75)*i+.984375},easeInOutBounce:i=>i<.5?tn.easeInBounce(i*2)*.5:tn.easeOutBounce(i*2-1)*.5+.5};/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */function en(i){return i+.5|0}const Xe=(i,t,e)=>Math.max(Math.min(i,e),t);function sn(i){return Xe(en(i*2.55),0,255)}function Ge(i){return Xe(en(i*255),0,255)}function ke(i){return Xe(en(i/2.55)/100,0,1)}function mu(i){return Xe(en(i*100),0,100)}const Wt={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},ja=[...\"0123456789ABCDEF\"],UE=i=>ja[i&15],XE=i=>ja[(i&240)>>4]+ja[i&15],Vo=i=>(i&240)>>4===(i&15),GE=i=>Vo(i.r)&&Vo(i.g)&&Vo(i.b)&&Vo(i.a);function qE(i){var t=i.length,e;return i[0]===\"#\"&&(t===4||t===5?e={r:255&Wt[i[1]]*17,g:255&Wt[i[2]]*17,b:255&Wt[i[3]]*17,a:t===5?Wt[i[4]]*17:255}:(t===7||t===9)&&(e={r:Wt[i[1]]<<4|Wt[i[2]],g:Wt[i[3]]<<4|Wt[i[4]],b:Wt[i[5]]<<4|Wt[i[6]],a:t===9?Wt[i[7]]<<4|Wt[i[8]]:255})),e}const ZE=(i,t)=>i<255?t(i):\"\";function QE(i){var t=GE(i)?UE:XE;return i?\"#\"+t(i.r)+t(i.g)+t(i.b)+ZE(i.a,t):void 0}const JE=/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function bu(i,t,e){const s=t*Math.min(e,1-e),n=(o,r=(o+i/30)%12)=>e-s*Math.max(Math.min(r-3,9-r,1),-1);return[n(0),n(8),n(4)]}function tC(i,t,e){const s=(n,o=(n+i/60)%6)=>e-e*t*Math.max(Math.min(o,4-o,1),0);return[s(5),s(3),s(1)]}function eC(i,t,e){const s=bu(i,1,.5);let n;for(t+e>1&&(n=1/(t+e),t*=n,e*=n),n=0;n<3;n++)s[n]*=1-t-e,s[n]+=t;return s}function iC(i,t,e,s,n){return i===n?(t-e)/s+(t<e?6:0):t===n?(e-i)/s+2:(i-t)/s+4}function Ya(i){const e=i.r/255,s=i.g/255,n=i.b/255,o=Math.max(e,s,n),r=Math.min(e,s,n),a=(o+r)/2;let l,c,h;return o!==r&&(h=o-r,c=a>.5?h/(2-o-r):h/(o+r),l=iC(e,s,n,h,o),l=l*60+.5),[l|0,c||0,a]}function Ka(i,t,e,s){return(Array.isArray(t)?i(t[0],t[1],t[2]):i(t,e,s)).map(Ge)}function Ua(i,t,e){return Ka(bu,i,t,e)}function sC(i,t,e){return Ka(eC,i,t,e)}function nC(i,t,e){return Ka(tC,i,t,e)}function vu(i){return(i%360+360)%360}function oC(i){const t=JE.exec(i);let e=255,s;if(!t)return;t[5]!==s&&(e=t[6]?sn(+t[5]):Ge(+t[5]));const n=vu(+t[2]),o=+t[3]/100,r=+t[4]/100;return t[1]===\"hwb\"?s=sC(n,o,r):t[1]===\"hsv\"?s=nC(n,o,r):s=Ua(n,o,r),{r:s[0],g:s[1],b:s[2],a:e}}function rC(i,t){var e=Ya(i);e[0]=vu(e[0]+t),e=Ua(e),i.r=e[0],i.g=e[1],i.b=e[2]}function aC(i){if(!i)return;const t=Ya(i),e=t[0],s=mu(t[1]),n=mu(t[2]);return i.a<255?`hsla(${e}, ${s}%, ${n}%, ${ke(i.a)})`:`hsl(${e}, ${s}%, ${n}%)`}const yu={x:\"dark\",Z:\"light\",Y:\"re\",X:\"blu\",W:\"gr\",V:\"medium\",U:\"slate\",A:\"ee\",T:\"ol\",S:\"or\",B:\"ra\",C:\"lateg\",D:\"ights\",R:\"in\",Q:\"turquois\",E:\"hi\",P:\"ro\",O:\"al\",N:\"le\",M:\"de\",L:\"yello\",F:\"en\",K:\"ch\",G:\"arks\",H:\"ea\",I:\"ightg\",J:\"wh\"},xu={OiceXe:\"f0f8ff\",antiquewEte:\"faebd7\",aqua:\"ffff\",aquamarRe:\"7fffd4\",azuY:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"0\",blanKedOmond:\"ffebcd\",Xe:\"ff\",XeviTet:\"8a2be2\",bPwn:\"a52a2a\",burlywood:\"deb887\",caMtXe:\"5f9ea0\",KartYuse:\"7fff00\",KocTate:\"d2691e\",cSO:\"ff7f50\",cSnflowerXe:\"6495ed\",cSnsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"ffff\",xXe:\"8b\",xcyan:\"8b8b\",xgTMnPd:\"b8860b\",xWay:\"a9a9a9\",xgYF:\"6400\",xgYy:\"a9a9a9\",xkhaki:\"bdb76b\",xmagFta:\"8b008b\",xTivegYF:\"556b2f\",xSange:\"ff8c00\",xScEd:\"9932cc\",xYd:\"8b0000\",xsOmon:\"e9967a\",xsHgYF:\"8fbc8f\",xUXe:\"483d8b\",xUWay:\"2f4f4f\",xUgYy:\"2f4f4f\",xQe:\"ced1\",xviTet:\"9400d3\",dAppRk:\"ff1493\",dApskyXe:\"bfff\",dimWay:\"696969\",dimgYy:\"696969\",dodgerXe:\"1e90ff\",fiYbrick:\"b22222\",flSOwEte:\"fffaf0\",foYstWAn:\"228b22\",fuKsia:\"ff00ff\",gaRsbSo:\"dcdcdc\",ghostwEte:\"f8f8ff\",gTd:\"ffd700\",gTMnPd:\"daa520\",Way:\"808080\",gYF:\"8000\",gYFLw:\"adff2f\",gYy:\"808080\",honeyMw:\"f0fff0\",hotpRk:\"ff69b4\",RdianYd:\"cd5c5c\",Rdigo:\"4b0082\",ivSy:\"fffff0\",khaki:\"f0e68c\",lavFMr:\"e6e6fa\",lavFMrXsh:\"fff0f5\",lawngYF:\"7cfc00\",NmoncEffon:\"fffacd\",ZXe:\"add8e6\",ZcSO:\"f08080\",Zcyan:\"e0ffff\",ZgTMnPdLw:\"fafad2\",ZWay:\"d3d3d3\",ZgYF:\"90ee90\",ZgYy:\"d3d3d3\",ZpRk:\"ffb6c1\",ZsOmon:\"ffa07a\",ZsHgYF:\"20b2aa\",ZskyXe:\"87cefa\",ZUWay:\"778899\",ZUgYy:\"778899\",ZstAlXe:\"b0c4de\",ZLw:\"ffffe0\",lime:\"ff00\",limegYF:\"32cd32\",lRF:\"faf0e6\",magFta:\"ff00ff\",maPon:\"800000\",VaquamarRe:\"66cdaa\",VXe:\"cd\",VScEd:\"ba55d3\",VpurpN:\"9370db\",VsHgYF:\"3cb371\",VUXe:\"7b68ee\",VsprRggYF:\"fa9a\",VQe:\"48d1cc\",VviTetYd:\"c71585\",midnightXe:\"191970\",mRtcYam:\"f5fffa\",mistyPse:\"ffe4e1\",moccasR:\"ffe4b5\",navajowEte:\"ffdead\",navy:\"80\",Tdlace:\"fdf5e6\",Tive:\"808000\",TivedBb:\"6b8e23\",Sange:\"ffa500\",SangeYd:\"ff4500\",ScEd:\"da70d6\",pOegTMnPd:\"eee8aa\",pOegYF:\"98fb98\",pOeQe:\"afeeee\",pOeviTetYd:\"db7093\",papayawEp:\"ffefd5\",pHKpuff:\"ffdab9\",peru:\"cd853f\",pRk:\"ffc0cb\",plum:\"dda0dd\",powMrXe:\"b0e0e6\",purpN:\"800080\",YbeccapurpN:\"663399\",Yd:\"ff0000\",Psybrown:\"bc8f8f\",PyOXe:\"4169e1\",saddNbPwn:\"8b4513\",sOmon:\"fa8072\",sandybPwn:\"f4a460\",sHgYF:\"2e8b57\",sHshell:\"fff5ee\",siFna:\"a0522d\",silver:\"c0c0c0\",skyXe:\"87ceeb\",UXe:\"6a5acd\",UWay:\"708090\",UgYy:\"708090\",snow:\"fffafa\",sprRggYF:\"ff7f\",stAlXe:\"4682b4\",tan:\"d2b48c\",teO:\"8080\",tEstN:\"d8bfd8\",tomato:\"ff6347\",Qe:\"40e0d0\",viTet:\"ee82ee\",JHt:\"f5deb3\",wEte:\"ffffff\",wEtesmoke:\"f5f5f5\",Lw:\"ffff00\",LwgYF:\"9acd32\"};function lC(){const i={},t=Object.keys(xu),e=Object.keys(yu);let s,n,o,r,a;for(s=0;s<t.length;s++){for(r=a=t[s],n=0;n<e.length;n++)o=e[n],a=a.replace(o,yu[o]);o=parseInt(xu[r],16),i[a]=[o>>16&255,o>>8&255,o&255]}return i}let Wo;function cC(i){Wo||(Wo=lC(),Wo.transparent=[0,0,0,0]);const t=Wo[i.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:t.length===4?t[3]:255}}const hC=/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function dC(i){const t=hC.exec(i);let e=255,s,n,o;if(t){if(t[7]!==s){const r=+t[7];e=t[8]?sn(r):Xe(r*255,0,255)}return s=+t[1],n=+t[3],o=+t[5],s=255&(t[2]?sn(s):Xe(s,0,255)),n=255&(t[4]?sn(n):Xe(n,0,255)),o=255&(t[6]?sn(o):Xe(o,0,255)),{r:s,g:n,b:o,a:e}}}function uC(i){return i&&(i.a<255?`rgba(${i.r}, ${i.g}, ${i.b}, ${ke(i.a)})`:`rgb(${i.r}, ${i.g}, ${i.b})`)}const Xa=i=>i<=.0031308?i*12.92:Math.pow(i,1/2.4)*1.055-.055,ls=i=>i<=.04045?i/12.92:Math.pow((i+.055)/1.055,2.4);function fC(i,t,e){const s=ls(ke(i.r)),n=ls(ke(i.g)),o=ls(ke(i.b));return{r:Ge(Xa(s+e*(ls(ke(t.r))-s))),g:Ge(Xa(n+e*(ls(ke(t.g))-n))),b:Ge(Xa(o+e*(ls(ke(t.b))-o))),a:i.a+e*(t.a-i.a)}}function zo(i,t,e){if(i){let s=Ya(i);s[t]=Math.max(0,Math.min(s[t]+s[t]*e,t===0?360:1)),s=Ua(s),i.r=s[0],i.g=s[1],i.b=s[2]}}function Eu(i,t){return i&&Object.assign(t||{},i)}function Cu(i){var t={r:0,g:0,b:0,a:255};return Array.isArray(i)?i.length>=3&&(t={r:i[0],g:i[1],b:i[2],a:255},i.length>3&&(t.a=Ge(i[3]))):(t=Eu(i,{r:0,g:0,b:0,a:1}),t.a=Ge(t.a)),t}function pC(i){return i.charAt(0)===\"r\"?dC(i):oC(i)}class jo{constructor(t){if(t instanceof jo)return t;const e=typeof t;let s;e===\"object\"?s=Cu(t):e===\"string\"&&(s=qE(t)||cC(t)||pC(t)),this._rgb=s,this._valid=!!s}get valid(){return this._valid}get rgb(){var t=Eu(this._rgb);return t&&(t.a=ke(t.a)),t}set rgb(t){this._rgb=Cu(t)}rgbString(){return this._valid?uC(this._rgb):void 0}hexString(){return this._valid?QE(this._rgb):void 0}hslString(){return this._valid?aC(this._rgb):void 0}mix(t,e){if(t){const s=this.rgb,n=t.rgb;let o;const r=e===o?.5:e,a=2*r-1,l=s.a-n.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;o=1-c,s.r=255&c*s.r+o*n.r+.5,s.g=255&c*s.g+o*n.g+.5,s.b=255&c*s.b+o*n.b+.5,s.a=r*s.a+(1-r)*n.a,this.rgb=s}return this}interpolate(t,e){return t&&(this._rgb=fC(this._rgb,t._rgb,e)),this}clone(){return new jo(this.rgb)}alpha(t){return this._rgb.a=Ge(t),this}clearer(t){const e=this._rgb;return e.a*=1-t,this}greyscale(){const t=this._rgb,e=en(t.r*.3+t.g*.59+t.b*.11);return t.r=t.g=t.b=e,this}opaquer(t){const e=this._rgb;return e.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return zo(this._rgb,2,t),this}darken(t){return zo(this._rgb,2,-t),this}saturate(t){return zo(this._rgb,1,t),this}desaturate(t){return zo(this._rgb,1,-t),this}rotate(t){return rC(this._rgb,t),this}}function Tu(i){return new jo(i)}function Au(i){if(i&&typeof i==\"object\"){const t=i.toString();return t===\"[object CanvasPattern]\"||t===\"[object CanvasGradient]\"}return!1}function wu(i){return Au(i)?i:Tu(i)}function Ga(i){return Au(i)?i:Tu(i).saturate(.5).darken(.1).hexString()}const yi=Object.create(null),qa=Object.create(null);function nn(i,t){if(!t)return i;const e=t.split(\".\");for(let s=0,n=e.length;s<n;++s){const o=e[s];i=i[o]||(i[o]=Object.create(null))}return i}function Za(i,t,e){return typeof t==\"string\"?ge(nn(i,t),e):ge(nn(i,\"\"),t)}class _C{constructor(t){this.animation=void 0,this.backgroundColor=\"rgba(0,0,0,0.1)\",this.borderColor=\"rgba(0,0,0,0.1)\",this.color=\"#666\",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=[\"mousemove\",\"mouseout\",\"click\",\"touchstart\",\"touchmove\"],this.font={family:\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",size:12,style:\"normal\",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,s)=>Ga(s.backgroundColor),this.hoverBorderColor=(e,s)=>Ga(s.borderColor),this.hoverColor=(e,s)=>Ga(s.color),this.indexAxis=\"x\",this.interaction={mode:\"nearest\",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t)}set(t,e){return Za(this,t,e)}get(t){return nn(this,t)}describe(t,e){return Za(qa,t,e)}override(t,e){return Za(yi,t,e)}route(t,e,s,n){const o=nn(this,t),r=nn(this,s),a=\"_\"+e;Object.defineProperties(o,{[a]:{value:o[e],writable:!0},[e]:{enumerable:!0,get(){const l=this[a],c=r[n];return $(l)?Object.assign({},c,l):R(l,c)},set(l){this[a]=l}}})}}var B=new _C({_scriptable:i=>!i.startsWith(\"on\"),_indexable:i=>i!==\"events\",hover:{_fallback:\"interaction\"},interaction:{_scriptable:!1,_indexable:!1}});function gC(i){return!i||N(i.size)||N(i.family)?null:(i.style?i.style+\" \":\"\")+(i.weight?i.weight+\" \":\"\")+i.size+\"px \"+i.family}function Yo(i,t,e,s,n){let o=t[n];return o||(o=t[n]=i.measureText(n).width,e.push(n)),o>s&&(s=o),s}function mC(i,t,e,s){s=s||{};let n=s.data=s.data||{},o=s.garbageCollect=s.garbageCollect||[];s.font!==t&&(n=s.data={},o=s.garbageCollect=[],s.font=t),i.save(),i.font=t;let r=0;const a=e.length;let l,c,h,d,u;for(l=0;l<a;l++)if(d=e[l],d!=null&&Q(d)!==!0)r=Yo(i,n,o,r,d);else if(Q(d))for(c=0,h=d.length;c<h;c++)u=d[c],u!=null&&!Q(u)&&(r=Yo(i,n,o,r,u));i.restore();const f=o.length/2;if(f>e.length){for(l=0;l<f;l++)delete n[o[l]];o.splice(0,f)}return r}function xi(i,t,e){const s=i.currentDevicePixelRatio,n=e!==0?Math.max(e/2,.5):0;return Math.round((t-n)*s)/s+n}function ku(i,t){t=t||i.getContext(\"2d\"),t.save(),t.resetTransform(),t.clearRect(0,0,i.width,i.height),t.restore()}function Qa(i,t,e,s){Su(i,t,e,s,null)}function Su(i,t,e,s,n){let o,r,a,l,c,h;const d=t.pointStyle,u=t.rotation,f=t.radius;let p=(u||0)*$E;if(d&&typeof d==\"object\"&&(o=d.toString(),o===\"[object HTMLImageElement]\"||o===\"[object HTMLCanvasElement]\")){i.save(),i.translate(e,s),i.rotate(p),i.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),i.restore();return}if(!(isNaN(f)||f<=0)){switch(i.beginPath(),d){default:n?i.ellipse(e,s,n/2,f,0,0,q):i.arc(e,s,f,0,q),i.closePath();break;case\"triangle\":i.moveTo(e+Math.sin(p)*f,s-Math.cos(p)*f),p+=su,i.lineTo(e+Math.sin(p)*f,s-Math.cos(p)*f),p+=su,i.lineTo(e+Math.sin(p)*f,s-Math.cos(p)*f),i.closePath();break;case\"rectRounded\":c=f*.516,l=f-c,r=Math.cos(p+Zs)*l,a=Math.sin(p+Zs)*l,i.arc(e-r,s-a,c,p-et,p-nt),i.arc(e+a,s-r,c,p-nt,p),i.arc(e+r,s+a,c,p,p+nt),i.arc(e-a,s+r,c,p+nt,p+et),i.closePath();break;case\"rect\":if(!u){l=Math.SQRT1_2*f,h=n?n/2:l,i.rect(e-h,s-l,2*h,2*l);break}p+=Zs;case\"rectRot\":r=Math.cos(p)*f,a=Math.sin(p)*f,i.moveTo(e-r,s-a),i.lineTo(e+a,s-r),i.lineTo(e+r,s+a),i.lineTo(e-a,s+r),i.closePath();break;case\"crossRot\":p+=Zs;case\"cross\":r=Math.cos(p)*f,a=Math.sin(p)*f,i.moveTo(e-r,s-a),i.lineTo(e+r,s+a),i.moveTo(e+a,s-r),i.lineTo(e-a,s+r);break;case\"star\":r=Math.cos(p)*f,a=Math.sin(p)*f,i.moveTo(e-r,s-a),i.lineTo(e+r,s+a),i.moveTo(e+a,s-r),i.lineTo(e-a,s+r),p+=Zs,r=Math.cos(p)*f,a=Math.sin(p)*f,i.moveTo(e-r,s-a),i.lineTo(e+r,s+a),i.moveTo(e+a,s-r),i.lineTo(e-a,s+r);break;case\"line\":r=n?n/2:Math.cos(p)*f,a=Math.sin(p)*f,i.moveTo(e-r,s-a),i.lineTo(e+r,s+a);break;case\"dash\":i.moveTo(e,s),i.lineTo(e+Math.cos(p)*f,s+Math.sin(p)*f);break}i.fill(),t.borderWidth>0&&i.stroke()}}function on(i,t,e){return e=e||.5,!t||i&&i.x>t.left-e&&i.x<t.right+e&&i.y>t.top-e&&i.y<t.bottom+e}function Ko(i,t){i.save(),i.beginPath(),i.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),i.clip()}function Uo(i){i.restore()}function bC(i,t,e,s,n){if(!t)return i.lineTo(e.x,e.y);if(n===\"middle\"){const o=(t.x+e.x)/2;i.lineTo(o,t.y),i.lineTo(o,e.y)}else n===\"after\"!=!!s?i.lineTo(t.x,e.y):i.lineTo(e.x,t.y);i.lineTo(e.x,e.y)}function vC(i,t,e,s){if(!t)return i.lineTo(e.x,e.y);i.bezierCurveTo(s?t.cp1x:t.cp2x,s?t.cp1y:t.cp2y,s?e.cp2x:e.cp1x,s?e.cp2y:e.cp1y,e.x,e.y)}function Ei(i,t,e,s,n,o={}){const r=Q(t)?t:[t],a=o.strokeWidth>0&&o.strokeColor!==\"\";let l,c;for(i.save(),i.font=n.string,yC(i,o),l=0;l<r.length;++l)c=r[l],a&&(o.strokeColor&&(i.strokeStyle=o.strokeColor),N(o.strokeWidth)||(i.lineWidth=o.strokeWidth),i.strokeText(c,e,s,o.maxWidth)),i.fillText(c,e,s,o.maxWidth),xC(i,e,s,c,o),s+=n.lineHeight;i.restore()}function yC(i,t){t.translation&&i.translate(t.translation[0],t.translation[1]),N(t.rotation)||i.rotate(t.rotation),t.color&&(i.fillStyle=t.color),t.textAlign&&(i.textAlign=t.textAlign),t.textBaseline&&(i.textBaseline=t.textBaseline)}function xC(i,t,e,s,n){if(n.strikethrough||n.underline){const o=i.measureText(s),r=t-o.actualBoundingBoxLeft,a=t+o.actualBoundingBoxRight,l=e-o.actualBoundingBoxAscent,c=e+o.actualBoundingBoxDescent,h=n.strikethrough?(l+c)/2:c;i.strokeStyle=i.fillStyle,i.beginPath(),i.lineWidth=n.decorationWidth||2,i.moveTo(r,h),i.lineTo(a,h),i.stroke()}}function rn(i,t){const{x:e,y:s,w:n,h:o,radius:r}=t;i.arc(e+r.topLeft,s+r.topLeft,r.topLeft,-nt,et,!0),i.lineTo(e,s+o-r.bottomLeft),i.arc(e+r.bottomLeft,s+o-r.bottomLeft,r.bottomLeft,et,nt,!0),i.lineTo(e+n-r.bottomRight,s+o),i.arc(e+n-r.bottomRight,s+o-r.bottomRight,r.bottomRight,nt,0,!0),i.lineTo(e+n,s+r.topRight),i.arc(e+n-r.topRight,s+r.topRight,r.topRight,0,-nt,!0),i.lineTo(e+r.topLeft,s)}const EC=new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/),CC=new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);function TC(i,t){const e=(\"\"+i).match(EC);if(!e||e[1]===\"normal\")return t*1.2;switch(i=+e[2],e[3]){case\"px\":return i;case\"%\":i/=100;break}return t*i}const AC=i=>+i||0;function Ja(i,t){const e={},s=$(t),n=s?Object.keys(t):t,o=$(i)?s?r=>R(i[r],i[t[r]]):r=>i[r]:()=>i;for(const r of n)e[r]=AC(o(r));return e}function Ou(i){return Ja(i,{top:\"y\",right:\"x\",bottom:\"y\",left:\"x\"})}function Ci(i){return Ja(i,[\"topLeft\",\"topRight\",\"bottomLeft\",\"bottomRight\"])}function ht(i){const t=Ou(i);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function lt(i,t){i=i||{},t=t||B.font;let e=R(i.size,t.size);typeof e==\"string\"&&(e=parseInt(e,10));let s=R(i.style,t.style);s&&!(\"\"+s).match(CC)&&(console.warn('Invalid font style specified: \"'+s+'\"'),s=\"\");const n={family:R(i.family,t.family),lineHeight:TC(R(i.lineHeight,t.lineHeight),e),size:e,style:s,weight:R(i.weight,t.weight),string:\"\"};return n.string=gC(n),n}function tt(i,t,e,s){let n=!0,o,r,a;for(o=0,r=i.length;o<r;++o)if(a=i[o],a!==void 0&&(t!==void 0&&typeof a==\"function\"&&(a=a(t),n=!1),e!==void 0&&Q(a)&&(a=a[e%a.length],n=!1),a!==void 0))return s&&!n&&(s.cacheable=!1),a}function wC(i,t,e){const{min:s,max:n}=i,o=Jd(t,(n-s)/2),r=(a,l)=>e&&a===0?0:a+l;return{min:r(s,-Math.abs(o)),max:r(n,o)}}function qe(i,t){return Object.assign(Object.create(i),t)}function tl(i,t=[\"\"],e=i,s,n=()=>i[0]){Ft(s)||(s=Pu(\"_fallback\",i));const o={[Symbol.toStringTag]:\"Object\",_cacheable:!0,_scopes:i,_rootScopes:e,_fallback:s,_getTarget:n,override:r=>tl([r,...i],t,e,s)};return new Proxy(o,{deleteProperty(r,a){return delete r[a],delete r._keys,delete i[0][a],!0},get(r,a){return Mu(r,a,()=>PC(a,t,i,r))},getOwnPropertyDescriptor(r,a){return Reflect.getOwnPropertyDescriptor(r._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(i[0])},has(r,a){return Ru(r).includes(a)},ownKeys(r){return Ru(r)},set(r,a,l){const c=r._storage||(r._storage=n());return r[a]=c[a]=l,delete r._keys,!0}})}function cs(i,t,e,s){const n={_cacheable:!1,_proxy:i,_context:t,_subProxy:e,_stack:new Set,_descriptors:Du(i,s),setContext:o=>cs(i,o,e,s),override:o=>cs(i.override(o),t,e,s)};return new Proxy(n,{deleteProperty(o,r){return delete o[r],delete i[r],!0},get(o,r,a){return Mu(o,r,()=>SC(o,r,a))},getOwnPropertyDescriptor(o,r){return o._descriptors.allKeys?Reflect.has(i,r)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(i,r)},getPrototypeOf(){return Reflect.getPrototypeOf(i)},has(o,r){return Reflect.has(i,r)},ownKeys(){return Reflect.ownKeys(i)},set(o,r,a){return i[r]=a,delete o[r],!0}})}function Du(i,t={scriptable:!0,indexable:!0}){const{_scriptable:e=t.scriptable,_indexable:s=t.indexable,_allKeys:n=t.allKeys}=i;return{allKeys:n,scriptable:e,indexable:s,isScriptable:Ue(e)?e:()=>e,isIndexable:Ue(s)?s:()=>s}}const kC=(i,t)=>i?i+Ha(t):t,el=(i,t)=>$(t)&&i!==\"adapters\"&&(Object.getPrototypeOf(t)===null||t.constructor===Object);function Mu(i,t,e){if(Object.prototype.hasOwnProperty.call(i,t))return i[t];const s=e();return i[t]=s,s}function SC(i,t,e){const{_proxy:s,_context:n,_subProxy:o,_descriptors:r}=i;let a=s[t];return Ue(a)&&r.isScriptable(t)&&(a=OC(t,a,i,e)),Q(a)&&a.length&&(a=DC(t,a,i,r.isIndexable)),el(t,a)&&(a=cs(a,n,o&&o[t],r)),a}function OC(i,t,e,s){const{_proxy:n,_context:o,_subProxy:r,_stack:a}=e;if(a.has(i))throw new Error(\"Recursion detected: \"+Array.from(a).join(\"->\")+\"->\"+i);return a.add(i),t=t(o,r||s),a.delete(i),el(i,t)&&(t=il(n._scopes,n,i,t)),t}function DC(i,t,e,s){const{_proxy:n,_context:o,_subProxy:r,_descriptors:a}=e;if(Ft(o.index)&&s(i))t=t[o.index%t.length];else if($(t[0])){const l=t,c=n._scopes.filter(h=>h!==l);t=[];for(const h of l){const d=il(c,n,i,h);t.push(cs(d,o,r&&r[i],a))}}return t}function Iu(i,t,e){return Ue(i)?i(t,e):i}const MC=(i,t)=>i===!0?t:typeof i==\"string\"?Ke(t,i):void 0;function IC(i,t,e,s,n){for(const o of t){const r=MC(e,o);if(r){i.add(r);const a=Iu(r._fallback,e,n);if(Ft(a)&&a!==e&&a!==s)return a}else if(r===!1&&Ft(s)&&e!==s)return null}return!1}function il(i,t,e,s){const n=t._rootScopes,o=Iu(t._fallback,e,s),r=[...i,...n],a=new Set;a.add(s);let l=Lu(a,r,e,o||e,s);return l===null||Ft(o)&&o!==e&&(l=Lu(a,r,o,l,s),l===null)?!1:tl(Array.from(a),[\"\"],n,o,()=>LC(t,e,s))}function Lu(i,t,e,s,n){for(;e;)e=IC(i,t,e,s,n);return e}function LC(i,t,e){const s=i._getTarget();t in s||(s[t]={});const n=s[t];return Q(n)&&$(e)?e:n}function PC(i,t,e,s){let n;for(const o of t)if(n=Pu(kC(o,i),e),Ft(n))return el(i,n)?il(e,s,i,n):n}function Pu(i,t){for(const e of t){if(!e)continue;const s=e[i];if(Ft(s))return s}}function Ru(i){let t=i._keys;return t||(t=i._keys=RC(i._scopes)),t}function RC(i){const t=new Set;for(const e of i)for(const s of Object.keys(e).filter(n=>!n.startsWith(\"_\")))t.add(s);return Array.from(t)}function Nu(i,t,e,s){const{iScale:n}=i,{key:o=\"r\"}=this._parsing,r=new Array(s);let a,l,c,h;for(a=0,l=s;a<l;++a)c=a+e,h=t[c],r[a]={r:n.parse(Ke(h,o),c)};return r}const NC=Number.EPSILON||1e-14,hs=(i,t)=>t<i.length&&!i[t].skip&&i[t],$u=i=>i===\"x\"?\"y\":\"x\";function $C(i,t,e,s){const n=i.skip?t:i,o=t,r=e.skip?t:e,a=Va(o,n),l=Va(r,o);let c=a/(a+l),h=l/(a+l);c=isNaN(c)?0:c,h=isNaN(h)?0:h;const d=s*c,u=s*h;return{previous:{x:o.x-d*(r.x-n.x),y:o.y-d*(r.y-n.y)},next:{x:o.x+u*(r.x-n.x),y:o.y+u*(r.y-n.y)}}}function BC(i,t,e){const s=i.length;let n,o,r,a,l,c=hs(i,0);for(let h=0;h<s-1;++h)if(l=c,c=hs(i,h+1),!(!l||!c)){if(Qs(t[h],0,NC)){e[h]=e[h+1]=0;continue}n=e[h]/t[h],o=e[h+1]/t[h],a=Math.pow(n,2)+Math.pow(o,2),!(a<=9)&&(r=3/Math.sqrt(a),e[h]=n*r*t[h],e[h+1]=o*r*t[h])}}function HC(i,t,e=\"x\"){const s=$u(e),n=i.length;let o,r,a,l=hs(i,0);for(let c=0;c<n;++c){if(r=a,a=l,l=hs(i,c+1),!a)continue;const h=a[e],d=a[s];r&&(o=(h-r[e])/3,a[`cp1${e}`]=h-o,a[`cp1${s}`]=d-o*t[c]),l&&(o=(l[e]-h)/3,a[`cp2${e}`]=h+o,a[`cp2${s}`]=d+o*t[c])}}function FC(i,t=\"x\"){const e=$u(t),s=i.length,n=Array(s).fill(0),o=Array(s);let r,a,l,c=hs(i,0);for(r=0;r<s;++r)if(a=l,l=c,c=hs(i,r+1),!!l){if(c){const h=c[t]-l[t];n[r]=h!==0?(c[e]-l[e])/h:0}o[r]=a?c?me(n[r-1])!==me(n[r])?0:(n[r-1]+n[r])/2:n[r-1]:n[r]}BC(i,n,o),HC(i,o,t)}function Xo(i,t,e){return Math.max(Math.min(i,e),t)}function VC(i,t){let e,s,n,o,r,a=on(i[0],t);for(e=0,s=i.length;e<s;++e)r=o,o=a,a=e<s-1&&on(i[e+1],t),o&&(n=i[e],r&&(n.cp1x=Xo(n.cp1x,t.left,t.right),n.cp1y=Xo(n.cp1y,t.top,t.bottom)),a&&(n.cp2x=Xo(n.cp2x,t.left,t.right),n.cp2y=Xo(n.cp2y,t.top,t.bottom)))}function WC(i,t,e,s,n){let o,r,a,l;if(t.spanGaps&&(i=i.filter(c=>!c.skip)),t.cubicInterpolationMode===\"monotone\")FC(i,n);else{let c=s?i[i.length-1]:i[0];for(o=0,r=i.length;o<r;++o)a=i[o],l=$C(c,a,i[Math.min(o+1,r-(s?0:1))%r],t.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}t.capBezierPoints&&VC(i,e)}function Bu(){return typeof window<\"u\"&&typeof document<\"u\"}function sl(i){let t=i.parentNode;return t&&t.toString()===\"[object ShadowRoot]\"&&(t=t.host),t}function Go(i,t,e){let s;return typeof i==\"string\"?(s=parseInt(i,10),i.indexOf(\"%\")!==-1&&(s=s/100*t.parentNode[e])):s=i,s}const qo=i=>window.getComputedStyle(i,null);function zC(i,t){return qo(i).getPropertyValue(t)}const jC=[\"top\",\"right\",\"bottom\",\"left\"];function Ti(i,t,e){const s={};e=e?\"-\"+e:\"\";for(let n=0;n<4;n++){const o=jC[n];s[o]=parseFloat(i[t+\"-\"+o+e])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const YC=(i,t,e)=>(i>0||t>0)&&(!e||!e.shadowRoot);function KC(i,t){const e=i.touches,s=e&&e.length?e[0]:i,{offsetX:n,offsetY:o}=s;let r=!1,a,l;if(YC(n,o,i.target))a=n,l=o;else{const c=t.getBoundingClientRect();a=s.clientX-c.left,l=s.clientY-c.top,r=!0}return{x:a,y:l,box:r}}function Ai(i,t){if(\"native\"in i)return i;const{canvas:e,currentDevicePixelRatio:s}=t,n=qo(e),o=n.boxSizing===\"border-box\",r=Ti(n,\"padding\"),a=Ti(n,\"border\",\"width\"),{x:l,y:c,box:h}=KC(i,e),d=r.left+(h&&a.left),u=r.top+(h&&a.top);let{width:f,height:p}=t;return o&&(f-=r.width+a.width,p-=r.height+a.height),{x:Math.round((l-d)/f*e.width/s),y:Math.round((c-u)/p*e.height/s)}}function UC(i,t,e){let s,n;if(t===void 0||e===void 0){const o=sl(i);if(!o)t=i.clientWidth,e=i.clientHeight;else{const r=o.getBoundingClientRect(),a=qo(o),l=Ti(a,\"border\",\"width\"),c=Ti(a,\"padding\");t=r.width-c.width-l.width,e=r.height-c.height-l.height,s=Go(a.maxWidth,o,\"clientWidth\"),n=Go(a.maxHeight,o,\"clientHeight\")}}return{width:t,height:e,maxWidth:s||Ho,maxHeight:n||Ho}}const nl=i=>Math.round(i*10)/10;function XC(i,t,e,s){const n=qo(i),o=Ti(n,\"margin\"),r=Go(n.maxWidth,i,\"clientWidth\")||Ho,a=Go(n.maxHeight,i,\"clientHeight\")||Ho,l=UC(i,t,e);let{width:c,height:h}=l;if(n.boxSizing===\"content-box\"){const d=Ti(n,\"border\",\"width\"),u=Ti(n,\"padding\");c-=u.width+d.width,h-=u.height+d.height}return c=Math.max(0,c-o.width),h=Math.max(0,s?Math.floor(c/s):h-o.height),c=nl(Math.min(c,r,l.maxWidth)),h=nl(Math.min(h,a,l.maxHeight)),c&&!h&&(h=nl(c/2)),{width:c,height:h}}function Hu(i,t,e){const s=t||1,n=Math.floor(i.height*s),o=Math.floor(i.width*s);i.height=n/s,i.width=o/s;const r=i.canvas;return r.style&&(e||!r.style.height&&!r.style.width)&&(r.style.height=`${i.height}px`,r.style.width=`${i.width}px`),i.currentDevicePixelRatio!==s||r.height!==n||r.width!==o?(i.currentDevicePixelRatio=s,r.height=n,r.width=o,i.ctx.setTransform(s,0,0,s,0,0),!0):!1}const GC=function(){let i=!1;try{const t={get passive(){return i=!0,!1}};window.addEventListener(\"test\",null,t),window.removeEventListener(\"test\",null,t)}catch{}return i}();function Fu(i,t){const e=zC(i,t),s=e&&e.match(/^(\\d+)(\\.\\d+)?px$/);return s?+s[1]:void 0}function wi(i,t,e,s){return{x:i.x+e*(t.x-i.x),y:i.y+e*(t.y-i.y)}}function qC(i,t,e,s){return{x:i.x+e*(t.x-i.x),y:s===\"middle\"?e<.5?i.y:t.y:s===\"after\"?e<1?i.y:t.y:e>0?t.y:i.y}}function ZC(i,t,e,s){const n={x:i.cp2x,y:i.cp2y},o={x:t.cp1x,y:t.cp1y},r=wi(i,n,e),a=wi(n,o,e),l=wi(o,t,e),c=wi(r,a,e),h=wi(a,l,e);return wi(c,h,e)}const Vu=new Map;function QC(i,t){t=t||{};const e=i+JSON.stringify(t);let s=Vu.get(e);return s||(s=new Intl.NumberFormat(i,t),Vu.set(e,s)),s}function an(i,t,e){return QC(t,e).format(i)}const JC=function(i,t){return{x(e){return i+i+t-e},setWidth(e){t=e},textAlign(e){return e===\"center\"?e:e===\"right\"?\"left\":\"right\"},xPlus(e,s){return e-s},leftForLtr(e,s){return e-s}}},tT=function(){return{x(i){return i},setWidth(i){},textAlign(i){return i},xPlus(i,t){return i+t},leftForLtr(i,t){return i}}};function ds(i,t,e){return i?JC(t,e):tT()}function Wu(i,t){let e,s;(t===\"ltr\"||t===\"rtl\")&&(e=i.canvas.style,s=[e.getPropertyValue(\"direction\"),e.getPropertyPriority(\"direction\")],e.setProperty(\"direction\",t,\"important\"),i.prevTextDirection=s)}function zu(i,t){t!==void 0&&(delete i.prevTextDirection,i.canvas.style.setProperty(\"direction\",t[0],t[1]))}function ju(i){return i===\"angle\"?{between:Js,compare:FE,normalize:Nt}:{between:Ae,compare:(t,e)=>t-e,normalize:t=>t}}function Yu({start:i,end:t,count:e,loop:s,style:n}){return{start:i%e,end:t%e,loop:s&&(t-i+1)%e===0,style:n}}function eT(i,t,e){const{property:s,start:n,end:o}=e,{between:r,normalize:a}=ju(s),l=t.length;let{start:c,end:h,loop:d}=i,u,f;if(d){for(c+=l,h+=l,u=0,f=l;u<f&&r(a(t[c%l][s]),n,o);++u)c--,h--;c%=l,h%=l}return h<c&&(h+=l),{start:c,end:h,loop:d,style:i.style}}function Ku(i,t,e){if(!e)return[i];const{property:s,start:n,end:o}=e,r=t.length,{compare:a,between:l,normalize:c}=ju(s),{start:h,end:d,loop:u,style:f}=eT(i,t,e),p=[];let _=!1,m=null,y,x,E;const C=()=>l(n,E,y)&&a(n,E)!==0,T=()=>a(o,y)===0||l(o,E,y),A=()=>_||C(),w=()=>!_||T();for(let S=h,k=h;S<=d;++S)x=t[S%r],!x.skip&&(y=c(x[s]),y!==E&&(_=l(y,n,o),m===null&&A()&&(m=a(y,n)===0?S:k),m!==null&&w()&&(p.push(Yu({start:m,end:S,loop:u,count:r,style:f})),m=null),k=S,E=y));return m!==null&&p.push(Yu({start:m,end:d,loop:u,count:r,style:f})),p}function Uu(i,t){const e=[],s=i.segments;for(let n=0;n<s.length;n++){const o=Ku(s[n],i.points,t);o.length&&e.push(...o)}return e}function iT(i,t,e,s){let n=0,o=t-1;if(e&&!s)for(;n<t&&!i[n].skip;)n++;for(;n<t&&i[n].skip;)n++;for(n%=t,e&&(o+=n);o>n&&i[o%t].skip;)o--;return o%=t,{start:n,end:o}}function sT(i,t,e,s){const n=i.length,o=[];let r=t,a=i[t],l;for(l=t+1;l<=e;++l){const c=i[l%n];c.skip||c.stop?a.skip||(s=!1,o.push({start:t%n,end:(l-1)%n,loop:s}),t=r=c.stop?l:null):(r=l,a.skip&&(t=l)),a=c}return r!==null&&o.push({start:t%n,end:r%n,loop:s}),o}function nT(i,t){const e=i.points,s=i.options.spanGaps,n=e.length;if(!n)return[];const o=!!i._loop,{start:r,end:a}=iT(e,n,o,s);if(s===!0)return Xu(i,[{start:r,end:a,loop:o}],e,t);const l=a<r?a+n:a,c=!!i._fullLoop&&r===0&&a===n-1;return Xu(i,sT(e,r,l,c),e,t)}function Xu(i,t,e,s){return!s||!s.setContext||!e?t:oT(i,t,e,s)}function oT(i,t,e,s){const n=i._chart.getContext(),o=Gu(i.options),{_datasetIndex:r,options:{spanGaps:a}}=i,l=e.length,c=[];let h=o,d=t[0].start,u=d;function f(p,_,m,y){const x=a?-1:1;if(p!==_){for(p+=l;e[p%l].skip;)p-=x;for(;e[_%l].skip;)_+=x;p%l!==_%l&&(c.push({start:p%l,end:_%l,loop:m,style:y}),h=y,d=_%l)}}for(const p of t){d=a?d:p.start;let _=e[d%l],m;for(u=d+1;u<=p.end;u++){const y=e[u%l];m=Gu(s.setContext(qe(n,{type:\"segment\",p0:_,p1:y,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:r}))),rT(m,h)&&f(d,u-1,p.loop,h),_=y,h=m}d<u-1&&f(d,u-1,p.loop,h)}return c}function Gu(i){return{backgroundColor:i.backgroundColor,borderCapStyle:i.borderCapStyle,borderDash:i.borderDash,borderDashOffset:i.borderDashOffset,borderJoinStyle:i.borderJoinStyle,borderWidth:i.borderWidth,borderColor:i.borderColor}}function rT(i,t){return t&&JSON.stringify(i)!==JSON.stringify(t)}/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */class aT{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,s,n){const o=e.listeners[n],r=e.duration;o.forEach(a=>a({chart:t,initial:e.initial,numSteps:r,currentStep:Math.min(s-e.start,r)}))}_refresh(){this._request||(this._running=!0,this._request=du.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let e=0;this._charts.forEach((s,n)=>{if(!s.running||!s.items.length)return;const o=s.items;let r=o.length-1,a=!1,l;for(;r>=0;--r)l=o[r],l._active?(l._total>s.duration&&(s.duration=l._total),l.tick(t),a=!0):(o[r]=o[o.length-1],o.pop());a&&(n.draw(),this._notify(n,s,t,\"progress\")),o.length||(s.running=!1,this._notify(n,s,t,\"complete\"),s.initial=!1),e+=o.length}),this._lastDate=t,e===0&&(this._running=!1)}_getAnims(t){const e=this._charts;let s=e.get(t);return s||(s={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,s)),s}listen(t,e,s){this._getAnims(t).listeners[e].push(s)}add(t,e){!e||!e.length||this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((s,n)=>Math.max(s,n._duration),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!(!e||!e.running||!e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const s=e.items;let n=s.length-1;for(;n>=0;--n)s[n].cancel();e.items=[],this._notify(t,e,Date.now(),\"complete\")}remove(t){return this._charts.delete(t)}}var be=new aT;const qu=\"transparent\",lT={boolean(i,t,e){return e>.5?t:i},color(i,t,e){const s=wu(i||qu),n=s.valid&&wu(t||qu);return n&&n.valid?n.mix(s,e).hexString():t},number(i,t,e){return i+(t-i)*e}};class Zu{constructor(t,e,s,n){const o=e[s];n=tt([t.to,n,o,t.from]);const r=tt([t.from,o,n]);this._active=!0,this._fn=t.fn||lT[t.type||typeof r],this._easing=tn[t.easing]||tn.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=s,this._from=r,this._to=n,this._promises=void 0}active(){return this._active}update(t,e,s){if(this._active){this._notify(!1);const n=this._target[this._prop],o=s-this._start,r=this._duration-o;this._start=s,this._duration=Math.floor(Math.max(r,t.duration)),this._total+=o,this._loop=!!t.loop,this._to=tt([t.to,e,n,t.from]),this._from=tt([t.from,n,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,s=this._duration,n=this._prop,o=this._from,r=this._loop,a=this._to;let l;if(this._active=o!==a&&(r||e<s),!this._active){this._target[n]=a,this._notify(!0);return}if(e<0){this._target[n]=o;return}l=e/s%2,l=r&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[n]=this._fn(o,a,l)}wait(){const t=this._promises||(this._promises=[]);return new Promise((e,s)=>{t.push({res:e,rej:s})})}_notify(t){const e=t?\"res\":\"rej\",s=this._promises||[];for(let n=0;n<s.length;n++)s[n][e]()}}const cT=[\"x\",\"y\",\"borderWidth\",\"radius\",\"tension\"],hT=[\"color\",\"borderColor\",\"backgroundColor\"];B.set(\"animation\",{delay:void 0,duration:1e3,easing:\"easeOutQuart\",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});const dT=Object.keys(B.animation);B.describe(\"animation\",{_fallback:!1,_indexable:!1,_scriptable:i=>i!==\"onProgress\"&&i!==\"onComplete\"&&i!==\"fn\"}),B.set(\"animations\",{colors:{type:\"color\",properties:hT},numbers:{type:\"number\",properties:cT}}),B.describe(\"animations\",{_fallback:\"animation\"}),B.set(\"transitions\",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:\"transparent\"},visible:{type:\"boolean\",duration:0}}},hide:{animations:{colors:{to:\"transparent\"},visible:{type:\"boolean\",easing:\"linear\",fn:i=>i|0}}}});class ol{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!$(t))return;const e=this._properties;Object.getOwnPropertyNames(t).forEach(s=>{const n=t[s];if(!$(n))return;const o={};for(const r of dT)o[r]=n[r];(Q(n.properties)&&n.properties||[s]).forEach(r=>{(r===s||!e.has(r))&&e.set(r,o)})})}_animateOptions(t,e){const s=e.options,n=fT(t,s);if(!n)return[];const o=this._createAnimations(n,s);return s.$shared&&uT(t.options.$animations,s).then(()=>{t.options=s},()=>{}),o}_createAnimations(t,e){const s=this._properties,n=[],o=t.$animations||(t.$animations={}),r=Object.keys(e),a=Date.now();let l;for(l=r.length-1;l>=0;--l){const c=r[l];if(c.charAt(0)===\"$\")continue;if(c===\"options\"){n.push(...this._animateOptions(t,e));continue}const h=e[c];let d=o[c];const u=s.get(c);if(d)if(u&&d.active()){d.update(u,h,a);continue}else d.cancel();if(!u||!u.duration){t[c]=h;continue}o[c]=d=new Zu(u,t,c,h),n.push(d)}return n}update(t,e){if(this._properties.size===0){Object.assign(t,e);return}const s=this._createAnimations(t,e);if(s.length)return be.add(this._chart,s),!0}}function uT(i,t){const e=[],s=Object.keys(t);for(let n=0;n<s.length;n++){const o=i[s[n]];o&&o.active()&&e.push(o.wait())}return Promise.all(e)}function fT(i,t){if(!t)return;let e=i.options;if(!e){i.options=t;return}return e.$shared&&(i.options=e=Object.assign({},e,{$shared:!1,$animations:{}})),e}function Qu(i,t){const e=i&&i.options||{},s=e.reverse,n=e.min===void 0?t:0,o=e.max===void 0?t:0;return{start:s?o:n,end:s?n:o}}function pT(i,t,e){if(e===!1)return!1;const s=Qu(i,e),n=Qu(t,e);return{top:n.end,right:s.end,bottom:n.start,left:s.start}}function _T(i){let t,e,s,n;return $(i)?(t=i.top,e=i.right,s=i.bottom,n=i.left):t=e=s=n=i,{top:t,right:e,bottom:s,left:n,disabled:i===!1}}function Ju(i,t){const e=[],s=i._getSortedDatasetMetas(t);let n,o;for(n=0,o=s.length;n<o;++n)e.push(s[n].index);return e}function tf(i,t,e,s={}){const n=i.keys,o=s.mode===\"single\";let r,a,l,c;if(t!==null){for(r=0,a=n.length;r<a;++r){if(l=+n[r],l===e){if(s.all)continue;break}c=i.values[l],rt(c)&&(o||t===0||me(t)===me(c))&&(t+=c)}return t}}function gT(i){const t=Object.keys(i),e=new Array(t.length);let s,n,o;for(s=0,n=t.length;s<n;++s)o=t[s],e[s]={x:o,y:i[o]};return e}function ef(i,t){const e=i&&i.options.stacked;return e||e===void 0&&t.stack!==void 0}function mT(i,t,e){return`${i.id}.${t.id}.${e.stack||e.type}`}function bT(i){const{min:t,max:e,minDefined:s,maxDefined:n}=i.getUserBounds();return{min:s?t:Number.NEGATIVE_INFINITY,max:n?e:Number.POSITIVE_INFINITY}}function vT(i,t,e){const s=i[t]||(i[t]={});return s[e]||(s[e]={})}function sf(i,t,e,s){for(const n of t.getMatchingVisibleMetas(s).reverse()){const o=i[n.index];if(e&&o>0||!e&&o<0)return n.index}return null}function nf(i,t){const{chart:e,_cachedMeta:s}=i,n=e._stacks||(e._stacks={}),{iScale:o,vScale:r,index:a}=s,l=o.axis,c=r.axis,h=mT(o,r,s),d=t.length;let u;for(let f=0;f<d;++f){const p=t[f],{[l]:_,[c]:m}=p,y=p._stacks||(p._stacks={});u=y[c]=vT(n,h,_),u[a]=m,u._top=sf(u,r,!0,s.type),u._bottom=sf(u,r,!1,s.type)}}function rl(i,t){const e=i.scales;return Object.keys(e).filter(s=>e[s].axis===t).shift()}function yT(i,t){return qe(i,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:\"default\",type:\"dataset\"})}function xT(i,t,e){return qe(i,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:e,index:t,mode:\"default\",type:\"data\"})}function ln(i,t){const e=i.controller.index,s=i.vScale&&i.vScale.axis;if(s){t=t||i._parsed;for(const n of t){const o=n._stacks;if(!o||o[s]===void 0||o[s][e]===void 0)return;delete o[s][e]}}}const al=i=>i===\"reset\"||i===\"none\",of=(i,t)=>t?i:Object.assign({},i),ET=(i,t,e)=>i&&!t.hidden&&t._stacked&&{keys:Ju(e,!0),values:null};class zt{constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=ef(t.vScale,t),this.addElements()}updateIndex(t){this.index!==t&&ln(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,s=this.getDataset(),n=(d,u,f,p)=>d===\"x\"?u:d===\"r\"?p:f,o=e.xAxisID=R(s.xAxisID,rl(t,\"x\")),r=e.yAxisID=R(s.yAxisID,rl(t,\"y\")),a=e.rAxisID=R(s.rAxisID,rl(t,\"r\")),l=e.indexAxis,c=e.iAxisID=n(l,o,r,a),h=e.vAxisID=n(l,r,o,a);e.xScale=this.getScaleForId(o),e.yScale=this.getScaleForId(r),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(c),e.vScale=this.getScaleForId(h)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update(\"reset\")}_destroy(){const t=this._cachedMeta;this._data&&cu(this._data,this),t._stacked&&ln(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),s=this._data;if($(e))this._data=gT(e);else if(s!==e){if(s){cu(s,this);const n=this._cachedMeta;ln(n),n._parsed=[]}e&&Object.isExtensible(e)&&jE(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,s=this.getDataset();let n=!1;this._dataCheck();const o=e._stacked;e._stacked=ef(e.vScale,e),e.stack!==s.stack&&(n=!0,ln(e),e.stack=s.stack),this._resyncElements(t),(n||o!==e._stacked)&&nf(this,e._parsed)}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),s=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(s,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:s,_data:n}=this,{iScale:o,_stacked:r}=s,a=o.axis;let l=t===0&&e===n.length?!0:s._sorted,c=t>0&&s._parsed[t-1],h,d,u;if(this._parsing===!1)s._parsed=n,s._sorted=!0,u=n;else{Q(n[t])?u=this.parseArrayData(s,n,t,e):$(n[t])?u=this.parseObjectData(s,n,t,e):u=this.parsePrimitiveData(s,n,t,e);const f=()=>d[a]===null||c&&d[a]<c[a];for(h=0;h<e;++h)s._parsed[h+t]=d=u[h],l&&(f()&&(l=!1),c=d);s._sorted=l}r&&nf(this,u)}parsePrimitiveData(t,e,s,n){const{iScale:o,vScale:r}=t,a=o.axis,l=r.axis,c=o.getLabels(),h=o===r,d=new Array(n);let u,f,p;for(u=0,f=n;u<f;++u)p=u+s,d[u]={[a]:h||o.parse(c[p],p),[l]:r.parse(e[p],p)};return d}parseArrayData(t,e,s,n){const{xScale:o,yScale:r}=t,a=new Array(n);let l,c,h,d;for(l=0,c=n;l<c;++l)h=l+s,d=e[h],a[l]={x:o.parse(d[0],h),y:r.parse(d[1],h)};return a}parseObjectData(t,e,s,n){const{xScale:o,yScale:r}=t,{xAxisKey:a=\"x\",yAxisKey:l=\"y\"}=this._parsing,c=new Array(n);let h,d,u,f;for(h=0,d=n;h<d;++h)u=h+s,f=e[u],c[h]={x:o.parse(Ke(f,a),u),y:r.parse(Ke(f,l),u)};return c}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,s){const n=this.chart,o=this._cachedMeta,r=e[t.axis],a={keys:Ju(n,!0),values:e._stacks[t.axis]};return tf(a,r,o.index,{mode:s})}updateRangeFromParsed(t,e,s,n){const o=s[e.axis];let r=o===null?NaN:o;const a=n&&s._stacks[e.axis];n&&a&&(n.values=a,r=tf(n,o,this._cachedMeta.index)),t.min=Math.min(t.min,r),t.max=Math.max(t.max,r)}getMinMax(t,e){const s=this._cachedMeta,n=s._parsed,o=s._sorted&&t===s.iScale,r=n.length,a=this._getOtherScale(t),l=ET(e,s,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:h,max:d}=bT(a);let u,f;function p(){f=n[u];const _=f[a.axis];return!rt(f[t.axis])||h>_||d<_}for(u=0;u<r&&!(!p()&&(this.updateRangeFromParsed(c,t,f,l),o));++u);if(o){for(u=r-1;u>=0;--u)if(!p()){this.updateRangeFromParsed(c,t,f,l);break}}return c}getAllParsedValues(t){const e=this._cachedMeta._parsed,s=[];let n,o,r;for(n=0,o=e.length;n<o;++n)r=e[n][t.axis],rt(r)&&s.push(r);return s}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,s=e.iScale,n=e.vScale,o=this.getParsed(t);return{label:s?\"\"+s.getLabelForValue(o[s.axis]):\"\",value:n?\"\"+n.getLabelForValue(o[n.axis]):\"\"}}_update(t){const e=this._cachedMeta;this.update(t||\"default\"),e._clip=_T(R(this.options.clip,pT(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,s=this._cachedMeta,n=s.data||[],o=e.chartArea,r=[],a=this._drawStart||0,l=this._drawCount||n.length-a,c=this.options.drawActiveElementsOnTop;let h;for(s.dataset&&s.dataset.draw(t,o,a,l),h=a;h<a+l;++h){const d=n[h];d.hidden||(d.active&&c?r.push(d):d.draw(t,o))}for(h=0;h<r.length;++h)r[h].draw(t,o)}getStyle(t,e){const s=e?\"active\":\"default\";return t===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(s):this.resolveDataElementOptions(t||0,s)}getContext(t,e,s){const n=this.getDataset();let o;if(t>=0&&t<this._cachedMeta.data.length){const r=this._cachedMeta.data[t];o=r.$context||(r.$context=xT(this.getContext(),t,r)),o.parsed=this.getParsed(t),o.raw=n.data[t],o.index=o.dataIndex=t}else o=this.$context||(this.$context=yT(this.chart.getContext(),this.index)),o.dataset=n,o.index=o.datasetIndex=this.index;return o.active=!!e,o.mode=s,o}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e=\"default\",s){const n=e===\"active\",o=this._cachedDataOpts,r=t+\"-\"+e,a=o[r],l=this.enableOptionSharing&&Ft(s);if(a)return of(a,l);const c=this.chart.config,h=c.datasetElementScopeKeys(this._type,t),d=n?[`${t}Hover`,\"hover\",t,\"\"]:[t,\"\"],u=c.getOptionScopes(this.getDataset(),h),f=Object.keys(B.elements[t]),p=()=>this.getContext(s,n),_=c.resolveNamedOptions(u,f,p,d);return _.$shared&&(_.$shared=l,o[r]=Object.freeze(of(_,l))),_}_resolveAnimations(t,e,s){const n=this.chart,o=this._cachedDataOpts,r=`animation-${e}`,a=o[r];if(a)return a;let l;if(n.options.animation!==!1){const h=this.chart.config,d=h.datasetAnimationScopeKeys(this._type,e),u=h.getOptionScopes(this.getDataset(),d);l=h.createResolver(u,this.getContext(t,s,e))}const c=new ol(n,l&&l.animations);return l&&l._cacheable&&(o[r]=Object.freeze(c)),c}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||al(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const s=this.resolveDataElementOptions(t,e),n=this._sharedOptions,o=this.getSharedOptions(s),r=this.includeOptions(e,o)||o!==n;return this.updateSharedOptions(o,e,s),{sharedOptions:o,includeOptions:r}}updateElement(t,e,s,n){al(n)?Object.assign(t,s):this._resolveAnimations(e,n).update(t,s)}updateSharedOptions(t,e,s){t&&!al(e)&&this._resolveAnimations(void 0,e).update(t,s)}_setStyle(t,e,s,n){t.active=n;const o=this.getStyle(e,n);this._resolveAnimations(e,s,n).update(t,{options:!n&&this.getSharedOptions(o)||o})}removeHoverStyle(t,e,s){this._setStyle(t,s,\"active\",!1)}setHoverStyle(t,e,s){this._setStyle(t,s,\"active\",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!0)}_resyncElements(t){const e=this._data,s=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const n=s.length,o=e.length,r=Math.min(o,n);r&&this.parse(0,r),o>n?this._insertElements(n,o-n,t):o<n&&this._removeElements(o,n-o)}_insertElements(t,e,s=!0){const n=this._cachedMeta,o=n.data,r=t+e;let a;const l=c=>{for(c.length+=e,a=c.length-1;a>=r;a--)c[a]=c[a-e]};for(l(o),a=t;a<r;++a)o[a]=new this.dataElementType;this._parsing&&l(n._parsed),this.parse(t,e),s&&this.updateElements(o,t,e,\"reset\")}updateElements(t,e,s,n){}_removeElements(t,e){const s=this._cachedMeta;if(this._parsing){const n=s._parsed.splice(t,e);s._stacked&&ln(s,n)}s.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,s,n]=t;this[e](s,n)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync([\"_insertElements\",this.getDataset().data.length-t,t])}_onDataPop(){this._sync([\"_removeElements\",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync([\"_removeElements\",0,1])}_onDataSplice(t,e){e&&this._sync([\"_removeElements\",t,e]);const s=arguments.length-2;s&&this._sync([\"_insertElements\",t,s])}_onDataUnshift(){this._sync([\"_insertElements\",0,arguments.length])}}zt.defaults={},zt.prototype.datasetElementType=null,zt.prototype.dataElementType=null;function CT(i,t){if(!i._cache.$bar){const e=i.getMatchingVisibleMetas(t);let s=[];for(let n=0,o=e.length;n<o;n++)s=s.concat(e[n].controller.getAllParsedValues(i));i._cache.$bar=hu(s.sort((n,o)=>n-o))}return i._cache.$bar}function TT(i){const t=i.iScale,e=CT(t,i.type);let s=t._length,n,o,r,a;const l=()=>{r===32767||r===-32768||(Ft(a)&&(s=Math.min(s,Math.abs(r-a)||s)),a=r)};for(n=0,o=e.length;n<o;++n)r=t.getPixelForValue(e[n]),l();for(a=void 0,n=0,o=t.ticks.length;n<o;++n)r=t.getPixelForTick(n),l();return s}function AT(i,t,e,s){const n=e.barThickness;let o,r;return N(n)?(o=t.min*e.categoryPercentage,r=e.barPercentage):(o=n*s,r=1),{chunk:o/s,ratio:r,start:t.pixels[i]-o/2}}function wT(i,t,e,s){const n=t.pixels,o=n[i];let r=i>0?n[i-1]:null,a=i<n.length-1?n[i+1]:null;const l=e.categoryPercentage;r===null&&(r=o-(a===null?t.end-t.start:a-o)),a===null&&(a=o+o-r);const c=o-(o-Math.min(r,a))/2*l;return{chunk:Math.abs(a-r)/2*l/s,ratio:e.barPercentage,start:c}}function kT(i,t,e,s){const n=e.parse(i[0],s),o=e.parse(i[1],s),r=Math.min(n,o),a=Math.max(n,o);let l=r,c=a;Math.abs(r)>Math.abs(a)&&(l=a,c=r),t[e.axis]=c,t._custom={barStart:l,barEnd:c,start:n,end:o,min:r,max:a}}function rf(i,t,e,s){return Q(i)?kT(i,t,e,s):t[e.axis]=e.parse(i,s),t}function af(i,t,e,s){const n=i.iScale,o=i.vScale,r=n.getLabels(),a=n===o,l=[];let c,h,d,u;for(c=e,h=e+s;c<h;++c)u=t[c],d={},d[n.axis]=a||n.parse(r[c],c),l.push(rf(u,d,o,c));return l}function ll(i){return i&&i.barStart!==void 0&&i.barEnd!==void 0}function ST(i,t,e){return i!==0?me(i):(t.isHorizontal()?1:-1)*(t.min>=e?1:-1)}function OT(i){let t,e,s,n,o;return i.horizontal?(t=i.base>i.x,e=\"left\",s=\"right\"):(t=i.base<i.y,e=\"bottom\",s=\"top\"),t?(n=\"end\",o=\"start\"):(n=\"start\",o=\"end\"),{start:e,end:s,reverse:t,top:n,bottom:o}}function DT(i,t,e,s){let n=t.borderSkipped;const o={};if(!n){i.borderSkipped=o;return}if(n===!0){i.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:r,end:a,reverse:l,top:c,bottom:h}=OT(i);n===\"middle\"&&e&&(i.enableBorderRadius=!0,(e._top||0)===s?n=c:(e._bottom||0)===s?n=h:(o[lf(h,r,a,l)]=!0,n=c)),o[lf(n,r,a,l)]=!0,i.borderSkipped=o}function lf(i,t,e,s){return s?(i=MT(i,t,e),i=cf(i,e,t)):i=cf(i,t,e),i}function MT(i,t,e){return i===t?e:i===e?t:i}function cf(i,t,e){return i===\"start\"?t:i===\"end\"?e:i}function IT(i,{inflateAmount:t},e){i.inflateAmount=t===\"auto\"?e===1?.33:0:t}class cn extends zt{parsePrimitiveData(t,e,s,n){return af(t,e,s,n)}parseArrayData(t,e,s,n){return af(t,e,s,n)}parseObjectData(t,e,s,n){const{iScale:o,vScale:r}=t,{xAxisKey:a=\"x\",yAxisKey:l=\"y\"}=this._parsing,c=o.axis===\"x\"?a:l,h=r.axis===\"x\"?a:l,d=[];let u,f,p,_;for(u=s,f=s+n;u<f;++u)_=e[u],p={},p[o.axis]=o.parse(Ke(_,c),u),d.push(rf(Ke(_,h),p,r,u));return d}updateRangeFromParsed(t,e,s,n){super.updateRangeFromParsed(t,e,s,n);const o=s._custom;o&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,o.min),t.max=Math.max(t.max,o.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:s,vScale:n}=e,o=this.getParsed(t),r=o._custom,a=ll(r)?\"[\"+r.start+\", \"+r.end+\"]\":\"\"+n.getLabelForValue(o[n.axis]);return{label:\"\"+s.getLabelForValue(o[s.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const t=this._cachedMeta;t.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,s,n){const o=n===\"reset\",{index:r,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),h=this._getRuler(),{sharedOptions:d,includeOptions:u}=this._getSharedOptions(e,n);for(let f=e;f<e+s;f++){const p=this.getParsed(f),_=o||N(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),m=this._calculateBarIndexPixels(f,h),y=(p._stacks||{})[a.axis],x={horizontal:c,base:_.base,enableBorderRadius:!y||ll(p._custom)||r===y._top||r===y._bottom,x:c?_.head:m.center,y:c?m.center:_.head,height:c?m.size:Math.abs(_.size),width:c?Math.abs(_.size):m.size};u&&(x.options=d||this.resolveDataElementOptions(f,t[f].active?\"active\":n));const E=x.options||t[f].options;DT(x,E,y,r),IT(x,E,h.ratio),this.updateElement(t[f],f,x,n)}}_getStacks(t,e){const{iScale:s}=this._cachedMeta,n=s.getMatchingVisibleMetas(this._type).filter(l=>l.controller.options.grouped),o=s.options.stacked,r=[],a=l=>{const c=l.controller.getParsed(e),h=c&&c[l.vScale.axis];if(N(h)||isNaN(h))return!0};for(const l of n)if(!(e!==void 0&&a(l))&&((o===!1||r.indexOf(l.stack)===-1||o===void 0&&l.stack===void 0)&&r.push(l.stack),l.index===t))break;return r.length||r.push(void 0),r}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,s){const n=this._getStacks(t,s),o=e!==void 0?n.indexOf(e):-1;return o===-1?n.length-1:o}_getRuler(){const t=this.options,e=this._cachedMeta,s=e.iScale,n=[];let o,r;for(o=0,r=e.data.length;o<r;++o)n.push(s.getPixelForValue(this.getParsed(o)[s.axis],o));const a=t.barThickness;return{min:a||TT(e),pixels:n,start:s._startPixel,end:s._endPixel,stackCount:this._getStackCount(),scale:s,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:s},options:{base:n,minBarLength:o}}=this,r=n||0,a=this.getParsed(t),l=a._custom,c=ll(l);let h=a[e.axis],d=0,u=s?this.applyStack(e,a,s):h,f,p;u!==h&&(d=u-h,u=h),c&&(h=l.barStart,u=l.barEnd-l.barStart,h!==0&&me(h)!==me(l.barEnd)&&(d=0),d+=h);const _=!N(n)&&!c?n:d;let m=e.getPixelForValue(_);if(this.chart.getDataVisibility(t)?f=e.getPixelForValue(d+u):f=m,p=f-m,Math.abs(p)<o){p=ST(p,e,r)*o,h===r&&(m-=p/2);const y=e.getPixelForDecimal(0),x=e.getPixelForDecimal(1),E=Math.min(y,x),C=Math.max(y,x);m=Math.max(Math.min(m,C),E),f=m+p}if(m===e.getPixelForValue(r)){const y=me(p)*e.getLineWidthForValue(r)/2;m+=y,p-=y}return{size:p,base:m,head:f,center:f+p/2}}_calculateBarIndexPixels(t,e){const s=e.scale,n=this.options,o=n.skipNull,r=R(n.maxBarThickness,1/0);let a,l;if(e.grouped){const c=o?this._getStackCount(t):e.stackCount,h=n.barThickness===\"flex\"?wT(t,e,n,c):AT(t,e,n,c),d=this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);a=h.start+h.chunk*d+h.chunk/2,l=Math.min(r,h.chunk*h.ratio)}else a=s.getPixelForValue(this.getParsed(t)[s.axis],t),l=Math.min(r,e.min*e.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const t=this._cachedMeta,e=t.vScale,s=t.data,n=s.length;let o=0;for(;o<n;++o)this.getParsed(o)[e.axis]!==null&&s[o].draw(this._ctx)}}cn.id=\"bar\",cn.defaults={datasetElementType:!1,dataElementType:\"bar\",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"base\",\"width\",\"height\"]}}},cn.overrides={scales:{_index_:{type:\"category\",offset:!0,grid:{offset:!0}},_value_:{type:\"linear\",beginAtZero:!0}}};class hn extends zt{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,s,n){const o=super.parsePrimitiveData(t,e,s,n);for(let r=0;r<o.length;r++)o[r]._custom=this.resolveDataElementOptions(r+s).radius;return o}parseArrayData(t,e,s,n){const o=super.parseArrayData(t,e,s,n);for(let r=0;r<o.length;r++){const a=e[s+r];o[r]._custom=R(a[2],this.resolveDataElementOptions(r+s).radius)}return o}parseObjectData(t,e,s,n){const o=super.parseObjectData(t,e,s,n);for(let r=0;r<o.length;r++){const a=e[s+r];o[r]._custom=R(a&&a.r&&+a.r,this.resolveDataElementOptions(r+s).radius)}return o}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let s=t.length-1;s>=0;--s)e=Math.max(e,t[s].size(this.resolveDataElementOptions(s))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,{xScale:s,yScale:n}=e,o=this.getParsed(t),r=s.getLabelForValue(o.x),a=n.getLabelForValue(o.y),l=o._custom;return{label:e.label,value:\"(\"+r+\", \"+a+(l?\", \"+l:\"\")+\")\"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,s,n){const o=n===\"reset\",{iScale:r,vScale:a}=this._cachedMeta,{sharedOptions:l,includeOptions:c}=this._getSharedOptions(e,n),h=r.axis,d=a.axis;for(let u=e;u<e+s;u++){const f=t[u],p=!o&&this.getParsed(u),_={},m=_[h]=o?r.getPixelForDecimal(.5):r.getPixelForValue(p[h]),y=_[d]=o?a.getBasePixel():a.getPixelForValue(p[d]);_.skip=isNaN(m)||isNaN(y),c&&(_.options=l||this.resolveDataElementOptions(u,f.active?\"active\":n),o&&(_.options.radius=0)),this.updateElement(f,u,_,n)}}resolveDataElementOptions(t,e){const s=this.getParsed(t);let n=super.resolveDataElementOptions(t,e);n.$shared&&(n=Object.assign({},n,{$shared:!1}));const o=n.radius;return e!==\"active\"&&(n.radius=0),n.radius+=R(s&&s._custom,o),n}}hn.id=\"bubble\",hn.defaults={datasetElementType:!1,dataElementType:\"point\",animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"borderWidth\",\"radius\"]}}},hn.overrides={scales:{x:{type:\"linear\"},y:{type:\"linear\"}},plugins:{tooltip:{callbacks:{title(){return\"\"}}}}};function LT(i,t,e){let s=1,n=1,o=0,r=0;if(t<q){const a=i,l=a+t,c=Math.cos(a),h=Math.sin(a),d=Math.cos(l),u=Math.sin(l),f=(E,C,T)=>Js(E,a,l,!0)?1:Math.max(C,C*e,T,T*e),p=(E,C,T)=>Js(E,a,l,!0)?-1:Math.min(C,C*e,T,T*e),_=f(0,c,d),m=f(nt,h,u),y=p(et,c,d),x=p(et+nt,h,u);s=(_-y)/2,n=(m-x)/2,o=-(_+y)/2,r=-(m+x)/2}return{ratioX:s,ratioY:n,offsetX:o,offsetY:r}}class ki extends zt{constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const s=this.getDataset().data,n=this._cachedMeta;if(this._parsing===!1)n._parsed=s;else{let o=l=>+s[l];if($(s[t])){const{key:l=\"value\"}=this._parsing;o=c=>+Ke(s[c],l)}let r,a;for(r=t,a=t+e;r<a;++r)n._parsed[r]=o(r)}}_getRotation(){return Jt(this.options.rotation-90)}_getCircumference(){return Jt(this.options.circumference)}_getRotationExtents(){let t=q,e=-q;for(let s=0;s<this.chart.data.datasets.length;++s)if(this.chart.isDatasetVisible(s)){const n=this.chart.getDatasetMeta(s).controller,o=n._getRotation(),r=n._getCircumference();t=Math.min(t,o),e=Math.max(e,o+r)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:s}=e,n=this._cachedMeta,o=n.data,r=this.getMaxBorderWidth()+this.getMaxOffset(o)+this.options.spacing,a=Math.max((Math.min(s.width,s.height)-r)/2,0),l=Math.min(DE(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:h,rotation:d}=this._getRotationExtents(),{ratioX:u,ratioY:f,offsetX:p,offsetY:_}=LT(d,h,l),m=(s.width-r)/u,y=(s.height-r)/f,x=Math.max(Math.min(m,y)/2,0),E=Jd(this.options.radius,x),C=Math.max(E*l,0),T=(E-C)/this._getVisibleDatasetWeightTotal();this.offsetX=p*E,this.offsetY=_*E,n.total=this.calculateTotal(),this.outerRadius=E-T*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-T*c,0),this.updateElements(o,0,o.length,t)}_circumference(t,e){const s=this.options,n=this._cachedMeta,o=this._getCircumference();return e&&s.animation.animateRotate||!this.chart.getDataVisibility(t)||n._parsed[t]===null||n.data[t].hidden?0:this.calculateCircumference(n._parsed[t]*o/q)}updateElements(t,e,s,n){const o=n===\"reset\",r=this.chart,a=r.chartArea,c=r.options.animation,h=(a.left+a.right)/2,d=(a.top+a.bottom)/2,u=o&&c.animateScale,f=u?0:this.innerRadius,p=u?0:this.outerRadius,{sharedOptions:_,includeOptions:m}=this._getSharedOptions(e,n);let y=this._getRotation(),x;for(x=0;x<e;++x)y+=this._circumference(x,o);for(x=e;x<e+s;++x){const E=this._circumference(x,o),C=t[x],T={x:h+this.offsetX,y:d+this.offsetY,startAngle:y,endAngle:y+E,circumference:E,outerRadius:p,innerRadius:f};m&&(T.options=_||this.resolveDataElementOptions(x,C.active?\"active\":n)),y+=E,this.updateElement(C,x,T,n)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let s=0,n;for(n=0;n<e.length;n++){const o=t._parsed[n];o!==null&&!isNaN(o)&&this.chart.getDataVisibility(n)&&!e[n].hidden&&(s+=Math.abs(o))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?q*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,s=this.chart,n=s.data.labels||[],o=an(e._parsed[t],s.options.locale);return{label:n[t]||\"\",value:o}}getMaxBorderWidth(t){let e=0;const s=this.chart;let n,o,r,a,l;if(!t){for(n=0,o=s.data.datasets.length;n<o;++n)if(s.isDatasetVisible(n)){r=s.getDatasetMeta(n),t=r.data,a=r.controller;break}}if(!t)return 0;for(n=0,o=t.length;n<o;++n)l=a.resolveDataElementOptions(n),l.borderAlign!==\"inner\"&&(e=Math.max(e,l.borderWidth||0,l.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let s=0,n=t.length;s<n;++s){const o=this.resolveDataElementOptions(s);e=Math.max(e,o.offset||0,o.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let s=0;s<t;++s)this.chart.isDatasetVisible(s)&&(e+=this._getRingWeight(s));return e}_getRingWeight(t){return Math.max(R(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}ki.id=\"doughnut\",ki.defaults={datasetElementType:!1,dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:\"number\",properties:[\"circumference\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"startAngle\",\"x\",\"y\",\"offset\",\"borderWidth\",\"spacing\"]}},cutout:\"50%\",rotation:0,circumference:360,radius:\"100%\",spacing:0,indexAxis:\"r\"},ki.descriptors={_scriptable:i=>i!==\"spacing\",_indexable:i=>i!==\"spacing\"},ki.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(i){const t=i.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:e}}=i.legend.options;return t.labels.map((s,n)=>{const r=i.getDatasetMeta(0).controller.getStyle(n);return{text:s,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,pointStyle:e,hidden:!i.getDataVisibility(n),index:n}})}return[]}},onClick(i,t,e){e.chart.toggleDataVisibility(t.index),e.chart.update()}},tooltip:{callbacks:{title(){return\"\"},label(i){let t=i.label;const e=\": \"+i.formattedValue;return Q(t)?(t=t.slice(),t[0]+=e):t+=e,t}}}}};class dn extends zt{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:s,data:n=[],_dataset:o}=e,r=this.chart._animationsDisabled;let{start:a,count:l}=fu(e,n,r);this._drawStart=a,this._drawCount=l,pu(e)&&(a=0,l=n.length),s._chart=this.chart,s._datasetIndex=this.index,s._decimated=!!o._decimated,s.points=n;const c=this.resolveDatasetElementOptions(t);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(s,void 0,{animated:!r,options:c},t),this.updateElements(n,a,l,t)}updateElements(t,e,s,n){const o=n===\"reset\",{iScale:r,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:h,includeOptions:d}=this._getSharedOptions(e,n),u=r.axis,f=a.axis,{spanGaps:p,segment:_}=this.options,m=as(p)?p:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||o||n===\"none\";let x=e>0&&this.getParsed(e-1);for(let E=e;E<e+s;++E){const C=t[E],T=this.getParsed(E),A=y?C:{},w=N(T[f]),S=A[u]=r.getPixelForValue(T[u],E),k=A[f]=o||w?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,T,l):T[f],E);A.skip=isNaN(S)||isNaN(k)||w,A.stop=E>0&&Math.abs(T[u]-x[u])>m,_&&(A.parsed=T,A.raw=c.data[E]),d&&(A.options=h||this.resolveDataElementOptions(E,C.active?\"active\":n)),y||this.updateElement(C,E,A,n),x=T}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,s=e.options&&e.options.borderWidth||0,n=t.data||[];if(!n.length)return s;const o=n[0].size(this.resolveDataElementOptions(0)),r=n[n.length-1].size(this.resolveDataElementOptions(n.length-1));return Math.max(s,o,r)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}dn.id=\"line\",dn.defaults={datasetElementType:\"line\",dataElementType:\"point\",showLine:!0,spanGaps:!1},dn.overrides={scales:{_index_:{type:\"category\"},_value_:{type:\"linear\"}}};class un extends zt{constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,s=this.chart,n=s.data.labels||[],o=an(e._parsed[t].r,s.options.locale);return{label:n[t]||\"\",value:o}}parseObjectData(t,e,s,n){return Nu.bind(this)(t,e,s,n)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach((s,n)=>{const o=this.getParsed(n).r;!isNaN(o)&&this.chart.getDataVisibility(n)&&(o<e.min&&(e.min=o),o>e.max&&(e.max=o))}),e}_updateRadius(){const t=this.chart,e=t.chartArea,s=t.options,n=Math.min(e.right-e.left,e.bottom-e.top),o=Math.max(n/2,0),r=Math.max(s.cutoutPercentage?o/100*s.cutoutPercentage:1,0),a=(o-r)/t.getVisibleDatasetCount();this.outerRadius=o-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(t,e,s,n){const o=n===\"reset\",r=this.chart,l=r.options.animation,c=this._cachedMeta.rScale,h=c.xCenter,d=c.yCenter,u=c.getIndexAngle(0)-.5*et;let f=u,p;const _=360/this.countVisibleElements();for(p=0;p<e;++p)f+=this._computeAngle(p,n,_);for(p=e;p<e+s;p++){const m=t[p];let y=f,x=f+this._computeAngle(p,n,_),E=r.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;f=x,o&&(l.animateScale&&(E=0),l.animateRotate&&(y=x=u));const C={x:h,y:d,innerRadius:0,outerRadius:E,startAngle:y,endAngle:x,options:this.resolveDataElementOptions(p,m.active?\"active\":n)};this.updateElement(m,p,C,n)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach((s,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&e++}),e}_computeAngle(t,e,s){return this.chart.getDataVisibility(t)?Jt(this.resolveDataElementOptions(t,e).angle||s):0}}un.id=\"polarArea\",un.defaults={dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"]}},indexAxis:\"r\",startAngle:0},un.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(i){const t=i.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:e}}=i.legend.options;return t.labels.map((s,n)=>{const r=i.getDatasetMeta(0).controller.getStyle(n);return{text:s,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,pointStyle:e,hidden:!i.getDataVisibility(n),index:n}})}return[]}},onClick(i,t,e){e.chart.toggleDataVisibility(t.index),e.chart.update()}},tooltip:{callbacks:{title(){return\"\"},label(i){return i.chart.data.labels[i.dataIndex]+\": \"+i.formattedValue}}}},scales:{r:{type:\"radialLinear\",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};class Zo extends ki{}Zo.id=\"pie\",Zo.defaults={cutout:0,rotation:0,circumference:360,radius:\"100%\"};class fn extends zt{getLabelAndValue(t){const e=this._cachedMeta.vScale,s=this.getParsed(t);return{label:e.getLabels()[t],value:\"\"+e.getLabelForValue(s[e.axis])}}parseObjectData(t,e,s,n){return Nu.bind(this)(t,e,s,n)}update(t){const e=this._cachedMeta,s=e.dataset,n=e.data||[],o=e.iScale.getLabels();if(s.points=n,t!==\"resize\"){const r=this.resolveDatasetElementOptions(t);this.options.showLine||(r.borderWidth=0);const a={_loop:!0,_fullLoop:o.length===n.length,options:r};this.updateElement(s,void 0,a,t)}this.updateElements(n,0,n.length,t)}updateElements(t,e,s,n){const o=this._cachedMeta.rScale,r=n===\"reset\";for(let a=e;a<e+s;a++){const l=t[a],c=this.resolveDataElementOptions(a,l.active?\"active\":n),h=o.getPointPositionForValue(a,this.getParsed(a).r),d=r?o.xCenter:h.x,u=r?o.yCenter:h.y,f={x:d,y:u,angle:h.angle,skip:isNaN(d)||isNaN(u),options:c};this.updateElement(l,a,f,n)}}}fn.id=\"radar\",fn.defaults={datasetElementType:\"line\",dataElementType:\"point\",indexAxis:\"r\",showLine:!0,elements:{line:{fill:\"start\"}}},fn.overrides={aspectRatio:1,scales:{r:{type:\"radialLinear\"}}};let jt=class{constructor(){this.x=void 0,this.y=void 0,this.active=!1,this.options=void 0,this.$animations=void 0}tooltipPosition(t){const{x:e,y:s}=this.getProps([\"x\",\"y\"],t);return{x:e,y:s}}hasValue(){return as(this.x)&&as(this.y)}getProps(t,e){const s=this.$animations;if(!e||!s)return this;const n={};return t.forEach(o=>{n[o]=s[o]&&s[o].active()?s[o]._to:this[o]}),n}};jt.defaults={},jt.defaultRoutes=void 0;const hf={values(i){return Q(i)?i:\"\"+i},numeric(i,t,e){if(i===0)return\"0\";const s=this.chart.options.locale;let n,o=i;if(e.length>1){const c=Math.max(Math.abs(e[0].value),Math.abs(e[e.length-1].value));(c<1e-4||c>1e15)&&(n=\"scientific\"),o=PT(i,e)}const r=Vt(Math.abs(o)),a=Math.max(Math.min(-1*Math.floor(r),20),0),l={notation:n,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),an(i,s,l)},logarithmic(i,t,e){if(i===0)return\"0\";const s=i/Math.pow(10,Math.floor(Vt(i)));return s===1||s===2||s===5?hf.numeric.call(this,i,t,e):\"\"}};function PT(i,t){let e=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(e)>=1&&i!==Math.floor(i)&&(e=i-Math.floor(i)),e}var pn={formatters:hf};B.set(\"scale\",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:\"ticks\",grace:0,grid:{display:!0,lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(i,t)=>t.lineWidth,tickColor:(i,t)=>t.color,offset:!1,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:!1,text:\"\",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:\"\",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:pn.formatters.values,minor:{},major:{},align:\"center\",crossAlign:\"near\",showLabelBackdrop:!1,backdropColor:\"rgba(255, 255, 255, 0.75)\",backdropPadding:2}}),B.route(\"scale.ticks\",\"color\",\"\",\"color\"),B.route(\"scale.grid\",\"color\",\"\",\"borderColor\"),B.route(\"scale.grid\",\"borderColor\",\"\",\"borderColor\"),B.route(\"scale.title\",\"color\",\"\",\"color\"),B.describe(\"scale\",{_fallback:!1,_scriptable:i=>!i.startsWith(\"before\")&&!i.startsWith(\"after\")&&i!==\"callback\"&&i!==\"parser\",_indexable:i=>i!==\"borderDash\"&&i!==\"tickBorderDash\"}),B.describe(\"scales\",{_fallback:\"scale\"}),B.describe(\"scale.ticks\",{_scriptable:i=>i!==\"backdropPadding\"&&i!==\"callback\",_indexable:i=>i!==\"backdropPadding\"});function RT(i,t){const e=i.options.ticks,s=e.maxTicksLimit||NT(i),n=e.major.enabled?BT(t):[],o=n.length,r=n[0],a=n[o-1],l=[];if(o>s)return HT(t,l,n,o/s),l;const c=$T(n,t,s);if(o>0){let h,d;const u=o>1?Math.round((a-r)/(o-1)):null;for(Qo(t,l,c,N(u)?0:r-u,r),h=0,d=o-1;h<d;h++)Qo(t,l,c,n[h],n[h+1]);return Qo(t,l,c,a,N(u)?t.length:a+u),l}return Qo(t,l,c),l}function NT(i){const t=i.options.offset,e=i._tickSize(),s=i._length/e+(t?0:1),n=i._maxLength/e;return Math.floor(Math.min(s,n))}function $T(i,t,e){const s=FT(i),n=t.length/e;if(!s)return Math.max(n,1);const o=BE(s);for(let r=0,a=o.length-1;r<a;r++){const l=o[r];if(l>n)return l}return Math.max(n,1)}function BT(i){const t=[];let e,s;for(e=0,s=i.length;e<s;e++)i[e].major&&t.push(e);return t}function HT(i,t,e,s){let n=0,o=e[0],r;for(s=Math.ceil(s),r=0;r<i.length;r++)r===o&&(t.push(i[r]),n++,o=e[n*s])}function Qo(i,t,e,s,n){const o=R(s,0),r=Math.min(R(n,i.length),i.length);let a=0,l,c,h;for(e=Math.ceil(e),n&&(l=n-s,e=l/Math.floor(l/e)),h=o;h<0;)a++,h=Math.round(o+a*e);for(c=Math.max(o,0);c<r;c++)c===h&&(t.push(i[c]),a++,h=Math.round(o+a*e))}function FT(i){const t=i.length;let e,s;if(t<2)return!1;for(s=i[0],e=1;e<t;++e)if(i[e]-i[e-1]!==s)return!1;return s}const VT=i=>i===\"left\"?\"right\":i===\"right\"?\"left\":i,df=(i,t,e)=>t===\"top\"||t===\"left\"?i[t]+e:i[t]-e;function uf(i,t){const e=[],s=i.length/t,n=i.length;let o=0;for(;o<n;o+=s)e.push(i[Math.floor(o)]);return e}function WT(i,t,e){const s=i.ticks.length,n=Math.min(t,s-1),o=i._startPixel,r=i._endPixel,a=1e-6;let l=i.getPixelForTick(n),c;if(!(e&&(s===1?c=Math.max(l-o,r-l):t===0?c=(i.getPixelForTick(1)-l)/2:c=(l-i.getPixelForTick(n-1))/2,l+=n<t?c:-c,l<o-a||l>r+a)))return l}function zT(i,t){U(i,e=>{const s=e.gc,n=s.length/2;let o;if(n>t){for(o=0;o<n;++o)delete e.data[s[o]];s.splice(0,n)}})}function _n(i){return i.drawTicks?i.tickLength:0}function ff(i,t){if(!i.display)return 0;const e=lt(i.font,t),s=ht(i.padding);return(Q(i.text)?i.text.length:1)*e.lineHeight+s.height}function jT(i,t){return qe(i,{scale:t,type:\"scale\"})}function YT(i,t,e){return qe(i,{tick:e,index:t,type:\"tick\"})}function KT(i,t,e){let s=za(i);return(e&&t!==\"right\"||!e&&t===\"right\")&&(s=VT(s)),s}function UT(i,t,e,s){const{top:n,left:o,bottom:r,right:a,chart:l}=i,{chartArea:c,scales:h}=l;let d=0,u,f,p;const _=r-n,m=a-o;if(i.isHorizontal()){if(f=pt(s,o,a),$(e)){const y=Object.keys(e)[0],x=e[y];p=h[y].getPixelForValue(x)+_-t}else e===\"center\"?p=(c.bottom+c.top)/2+_-t:p=df(i,e,t);u=a-o}else{if($(e)){const y=Object.keys(e)[0],x=e[y];f=h[y].getPixelForValue(x)-m+t}else e===\"center\"?f=(c.left+c.right)/2-m+t:f=df(i,e,t);p=pt(s,r,n),d=e===\"left\"?-nt:nt}return{titleX:f,titleY:p,maxWidth:u,rotation:d}}class Ze extends jt{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:s,_suggestedMax:n}=this;return t=Ht(t,Number.POSITIVE_INFINITY),e=Ht(e,Number.NEGATIVE_INFINITY),s=Ht(s,Number.POSITIVE_INFINITY),n=Ht(n,Number.NEGATIVE_INFINITY),{min:Ht(t,s),max:Ht(e,n),minDefined:rt(t),maxDefined:rt(e)}}getMinMax(t){let{min:e,max:s,minDefined:n,maxDefined:o}=this.getUserBounds(),r;if(n&&o)return{min:e,max:s};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)r=a[l].controller.getMinMax(this,t),n||(e=Math.min(e,r.min)),o||(s=Math.max(s,r.max));return e=o&&e>s?s:e,s=n&&e>s?e:s,{min:Ht(e,Ht(s,e)),max:Ht(s,Ht(e,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){G(this.options.beforeUpdate,[this])}update(t,e,s){const{beginAtZero:n,grace:o,ticks:r}=this.options,a=r.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=s=Object.assign({left:0,right:0,top:0,bottom:0},s),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+s.left+s.right:this.height+s.top+s.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=wC(this,o,n),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?uf(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),r.display&&(r.autoSkip||r.source===\"auto\")&&(this.ticks=RT(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t=this.options.reverse,e,s;this.isHorizontal()?(e=this.left,s=this.right):(e=this.top,s=this.bottom,t=!t),this._startPixel=e,this._endPixel=s,this._reversePixels=t,this._length=s-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){G(this.options.afterUpdate,[this])}beforeSetDimensions(){G(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){G(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),G(this.options[t],[this])}beforeDataLimits(){this._callHooks(\"beforeDataLimits\")}determineDataLimits(){}afterDataLimits(){this._callHooks(\"afterDataLimits\")}beforeBuildTicks(){this._callHooks(\"beforeBuildTicks\")}buildTicks(){return[]}afterBuildTicks(){this._callHooks(\"afterBuildTicks\")}beforeTickToLabelConversion(){G(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let s,n,o;for(s=0,n=t.length;s<n;s++)o=t[s],o.label=G(e.callback,[o.value,s,t],this)}afterTickToLabelConversion(){G(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){G(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,s=this.ticks.length,n=e.minRotation||0,o=e.maxRotation;let r=n,a,l,c;if(!this._isVisible()||!e.display||n>=o||s<=1||!this.isHorizontal()){this.labelRotation=n;return}const h=this._getLabelSizes(),d=h.widest.width,u=h.highest.height,f=ct(this.chart.width-d,0,this.maxWidth);a=t.offset?this.maxWidth/s:f/(s-1),d+6>a&&(a=f/(s-(t.offset?.5:1)),l=this.maxHeight-_n(t.grid)-e.padding-ff(t.title,this.chart.options.font),c=Math.sqrt(d*d+u*u),r=Fa(Math.min(Math.asin(ct((h.highest.height+6)/a,-1,1)),Math.asin(ct(l/c,-1,1))-Math.asin(ct(u/c,-1,1)))),r=Math.max(n,Math.min(o,r))),this.labelRotation=r}afterCalculateLabelRotation(){G(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){G(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:s,title:n,grid:o}}=this,r=this._isVisible(),a=this.isHorizontal();if(r){const l=ff(n,e.options.font);if(a?(t.width=this.maxWidth,t.height=_n(o)+l):(t.height=this.maxHeight,t.width=_n(o)+l),s.display&&this.ticks.length){const{first:c,last:h,widest:d,highest:u}=this._getLabelSizes(),f=s.padding*2,p=Jt(this.labelRotation),_=Math.cos(p),m=Math.sin(p);if(a){const y=s.mirror?0:m*d.width+_*u.height;t.height=Math.min(this.maxHeight,t.height+y+f)}else{const y=s.mirror?0:_*d.width+m*u.height;t.width=Math.min(this.maxWidth,t.width+y+f)}this._calculatePadding(c,h,m,_)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,s,n){const{ticks:{align:o,padding:r},position:a}=this.options,l=this.labelRotation!==0,c=a!==\"top\"&&this.axis===\"x\";if(this.isHorizontal()){const h=this.getPixelForTick(0)-this.left,d=this.right-this.getPixelForTick(this.ticks.length-1);let u=0,f=0;l?c?(u=n*t.width,f=s*e.height):(u=s*t.height,f=n*e.width):o===\"start\"?f=e.width:o===\"end\"?u=t.width:o!==\"inner\"&&(u=t.width/2,f=e.width/2),this.paddingLeft=Math.max((u-h+r)*this.width/(this.width-h),0),this.paddingRight=Math.max((f-d+r)*this.width/(this.width-d),0)}else{let h=e.height/2,d=t.height/2;o===\"start\"?(h=0,d=t.height):o===\"end\"&&(h=e.height,d=0),this.paddingTop=h+r,this.paddingBottom=d+r}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){G(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return e===\"top\"||e===\"bottom\"||t===\"x\"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion(),this.generateTickLabels(t);let e,s;for(e=0,s=t.length;e<s;e++)N(t[e].label)&&(t.splice(e,1),s--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let s=this.ticks;e<s.length&&(s=uf(s,e)),this._labelSizes=t=this._computeLabelSizes(s,s.length)}return t}_computeLabelSizes(t,e){const{ctx:s,_longestTextCache:n}=this,o=[],r=[];let a=0,l=0,c,h,d,u,f,p,_,m,y,x,E;for(c=0;c<e;++c){if(u=t[c].label,f=this._resolveTickFontOptions(c),s.font=p=f.string,_=n[p]=n[p]||{data:{},gc:[]},m=f.lineHeight,y=x=0,!N(u)&&!Q(u))y=Yo(s,_.data,_.gc,y,u),x=m;else if(Q(u))for(h=0,d=u.length;h<d;++h)E=u[h],!N(E)&&!Q(E)&&(y=Yo(s,_.data,_.gc,y,E),x+=m);o.push(y),r.push(x),a=Math.max(y,a),l=Math.max(x,l)}zT(n,e);const C=o.indexOf(a),T=r.indexOf(l),A=w=>({width:o[w]||0,height:r[w]||0});return{first:A(0),last:A(e-1),widest:A(C),highest:A(T),widths:o,heights:r}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return VE(this._alignToPixels?xi(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const s=e[t];return s.$context||(s.$context=YT(this.getContext(),t,s))}return this.$context||(this.$context=jT(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=Jt(this.labelRotation),s=Math.abs(Math.cos(e)),n=Math.abs(Math.sin(e)),o=this._getLabelSizes(),r=t.autoSkipPadding||0,a=o?o.widest.width+r:0,l=o?o.highest.height+r:0;return this.isHorizontal()?l*s>a*n?a/s:l/n:l*n<a*s?l/s:a/n}_isVisible(){const t=this.options.display;return t!==\"auto\"?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,s=this.chart,n=this.options,{grid:o,position:r}=n,a=o.offset,l=this.isHorizontal(),h=this.ticks.length+(a?1:0),d=_n(o),u=[],f=o.setContext(this.getContext()),p=f.drawBorder?f.borderWidth:0,_=p/2,m=function(I){return xi(s,I,p)};let y,x,E,C,T,A,w,S,k,D,O,M;if(r===\"top\")y=m(this.bottom),A=this.bottom-d,S=y-_,D=m(t.top)+_,M=t.bottom;else if(r===\"bottom\")y=m(this.top),D=t.top,M=m(t.bottom)-_,A=y+_,S=this.top+d;else if(r===\"left\")y=m(this.right),T=this.right-d,w=y-_,k=m(t.left)+_,O=t.right;else if(r===\"right\")y=m(this.left),k=t.left,O=m(t.right)-_,T=y+_,w=this.left+d;else if(e===\"x\"){if(r===\"center\")y=m((t.top+t.bottom)/2+.5);else if($(r)){const I=Object.keys(r)[0],F=r[I];y=m(this.chart.scales[I].getPixelForValue(F))}D=t.top,M=t.bottom,A=y+_,S=A+d}else if(e===\"y\"){if(r===\"center\")y=m((t.left+t.right)/2);else if($(r)){const I=Object.keys(r)[0],F=r[I];y=m(this.chart.scales[I].getPixelForValue(F))}T=y-_,w=T-d,k=t.left,O=t.right}const L=R(n.ticks.maxTicksLimit,h),X=Math.max(1,Math.ceil(h/L));for(x=0;x<h;x+=X){const I=o.setContext(this.getContext(x)),F=I.lineWidth,Y=I.color,Yt=I.borderDash||[],ee=I.borderDashOffset,ie=I.tickWidth,ti=I.tickColor,Kt=I.tickBorderDash||[],ye=I.tickBorderDashOffset;E=WT(this,x,a),E!==void 0&&(C=xi(s,E,F),l?T=w=k=O=C:A=S=D=M=C,u.push({tx1:T,ty1:A,tx2:w,ty2:S,x1:k,y1:D,x2:O,y2:M,width:F,color:Y,borderDash:Yt,borderDashOffset:ee,tickWidth:ie,tickColor:ti,tickBorderDash:Kt,tickBorderDashOffset:ye}))}return this._ticksLength=h,this._borderValue=y,u}_computeLabelItems(t){const e=this.axis,s=this.options,{position:n,ticks:o}=s,r=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:h,mirror:d}=o,u=_n(s.grid),f=u+h,p=d?-h:f,_=-Jt(this.labelRotation),m=[];let y,x,E,C,T,A,w,S,k,D,O,M,L=\"middle\";if(n===\"top\")A=this.bottom-p,w=this._getXAxisLabelAlignment();else if(n===\"bottom\")A=this.top+p,w=this._getXAxisLabelAlignment();else if(n===\"left\"){const I=this._getYAxisLabelAlignment(u);w=I.textAlign,T=I.x}else if(n===\"right\"){const I=this._getYAxisLabelAlignment(u);w=I.textAlign,T=I.x}else if(e===\"x\"){if(n===\"center\")A=(t.top+t.bottom)/2+f;else if($(n)){const I=Object.keys(n)[0],F=n[I];A=this.chart.scales[I].getPixelForValue(F)+f}w=this._getXAxisLabelAlignment()}else if(e===\"y\"){if(n===\"center\")T=(t.left+t.right)/2-f;else if($(n)){const I=Object.keys(n)[0],F=n[I];T=this.chart.scales[I].getPixelForValue(F)}w=this._getYAxisLabelAlignment(u).textAlign}e===\"y\"&&(l===\"start\"?L=\"top\":l===\"end\"&&(L=\"bottom\"));const X=this._getLabelSizes();for(y=0,x=a.length;y<x;++y){E=a[y],C=E.label;const I=o.setContext(this.getContext(y));S=this.getPixelForTick(y)+o.labelOffset,k=this._resolveTickFontOptions(y),D=k.lineHeight,O=Q(C)?C.length:1;const F=O/2,Y=I.color,Yt=I.textStrokeColor,ee=I.textStrokeWidth;let ie=w;r?(T=S,w===\"inner\"&&(y===x-1?ie=this.options.reverse?\"left\":\"right\":y===0?ie=this.options.reverse?\"right\":\"left\":ie=\"center\"),n===\"top\"?c===\"near\"||_!==0?M=-O*D+D/2:c===\"center\"?M=-X.highest.height/2-F*D+D:M=-X.highest.height+D/2:c===\"near\"||_!==0?M=D/2:c===\"center\"?M=X.highest.height/2-F*D:M=X.highest.height-O*D,d&&(M*=-1)):(A=S,M=(1-O)*D/2);let ti;if(I.showLabelBackdrop){const Kt=ht(I.backdropPadding),ye=X.heights[y],xe=X.widths[y];let Ut=A+M-Kt.top,Me=T-Kt.left;switch(L){case\"middle\":Ut-=ye/2;break;case\"bottom\":Ut-=ye;break}switch(w){case\"center\":Me-=xe/2;break;case\"right\":Me-=xe;break}ti={left:Me,top:Ut,width:xe+Kt.width,height:ye+Kt.height,color:I.backdropColor}}m.push({rotation:_,label:C,font:k,color:Y,strokeColor:Yt,strokeWidth:ee,textOffset:M,textAlign:ie,textBaseline:L,translation:[T,A],backdrop:ti})}return m}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-Jt(this.labelRotation))return t===\"top\"?\"left\":\"right\";let n=\"center\";return e.align===\"start\"?n=\"left\":e.align===\"end\"?n=\"right\":e.align===\"inner\"&&(n=\"inner\"),n}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:s,mirror:n,padding:o}}=this.options,r=this._getLabelSizes(),a=t+o,l=r.widest.width;let c,h;return e===\"left\"?n?(h=this.right+o,s===\"near\"?c=\"left\":s===\"center\"?(c=\"center\",h+=l/2):(c=\"right\",h+=l)):(h=this.right-a,s===\"near\"?c=\"right\":s===\"center\"?(c=\"center\",h-=l/2):(c=\"left\",h=this.left)):e===\"right\"?n?(h=this.left+o,s===\"near\"?c=\"right\":s===\"center\"?(c=\"center\",h-=l/2):(c=\"left\",h-=l)):(h=this.left+a,s===\"near\"?c=\"left\":s===\"center\"?(c=\"center\",h+=l/2):(c=\"right\",h=this.right)):c=\"right\",{textAlign:c,x:h}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;if(e===\"left\"||e===\"right\")return{top:0,left:this.left,bottom:t.height,right:this.right};if(e===\"top\"||e===\"bottom\")return{top:this.top,left:0,bottom:this.bottom,right:t.width}}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:s,top:n,width:o,height:r}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(s,n,o,r),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const n=this.ticks.findIndex(o=>o.value===t);return n>=0?e.setContext(this.getContext(n)).lineWidth:0}drawGrid(t){const e=this.options.grid,s=this.ctx,n=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let o,r;const a=(l,c,h)=>{!h.width||!h.color||(s.save(),s.lineWidth=h.width,s.strokeStyle=h.color,s.setLineDash(h.borderDash||[]),s.lineDashOffset=h.borderDashOffset,s.beginPath(),s.moveTo(l.x,l.y),s.lineTo(c.x,c.y),s.stroke(),s.restore())};if(e.display)for(o=0,r=n.length;o<r;++o){const l=n[o];e.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),e.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{grid:s}}=this,n=s.setContext(this.getContext()),o=s.drawBorder?n.borderWidth:0;if(!o)return;const r=s.setContext(this.getContext(0)).lineWidth,a=this._borderValue;let l,c,h,d;this.isHorizontal()?(l=xi(t,this.left,o)-o/2,c=xi(t,this.right,r)+r/2,h=d=a):(h=xi(t,this.top,o)-o/2,d=xi(t,this.bottom,r)+r/2,l=c=a),e.save(),e.lineWidth=n.borderWidth,e.strokeStyle=n.borderColor,e.beginPath(),e.moveTo(l,h),e.lineTo(c,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const s=this.ctx,n=this._computeLabelArea();n&&Ko(s,n);const o=this._labelItems||(this._labelItems=this._computeLabelItems(t));let r,a;for(r=0,a=o.length;r<a;++r){const l=o[r],c=l.font,h=l.label;l.backdrop&&(s.fillStyle=l.backdrop.color,s.fillRect(l.backdrop.left,l.backdrop.top,l.backdrop.width,l.backdrop.height));let d=l.textOffset;Ei(s,h,0,d,c,l)}n&&Uo(s)}drawTitle(){const{ctx:t,options:{position:e,title:s,reverse:n}}=this;if(!s.display)return;const o=lt(s.font),r=ht(s.padding),a=s.align;let l=o.lineHeight/2;e===\"bottom\"||e===\"center\"||$(e)?(l+=r.bottom,Q(s.text)&&(l+=o.lineHeight*(s.text.length-1))):l+=r.top;const{titleX:c,titleY:h,maxWidth:d,rotation:u}=UT(this,l,e,a);Ei(t,s.text,0,0,o,{color:s.color,maxWidth:d,rotation:u,textAlign:KT(a,e,n),textBaseline:\"middle\",translation:[c,h]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,s=R(t.grid&&t.grid.z,-1);return!this._isVisible()||this.draw!==Ze.prototype.draw?[{z:e,draw:n=>{this.draw(n)}}]:[{z:s,draw:n=>{this.drawBackground(),this.drawGrid(n),this.drawTitle()}},{z:s+1,draw:()=>{this.drawBorder()}},{z:e,draw:n=>{this.drawLabels(n)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),s=this.axis+\"AxisID\",n=[];let o,r;for(o=0,r=e.length;o<r;++o){const a=e[o];a[s]===this.id&&(!t||a.type===t)&&n.push(a)}return n}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return lt(e.font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Jo{constructor(t,e,s){this.type=t,this.scope=e,this.override=s,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let s;qT(e)&&(s=this.register(e));const n=this.items,o=t.id,r=this.scope+\".\"+o;if(!o)throw new Error(\"class does not have id: \"+t);return o in n||(n[o]=t,XT(t,r,s),this.override&&B.override(t.id,t.overrides)),r}get(t){return this.items[t]}unregister(t){const e=this.items,s=t.id,n=this.scope;s in e&&delete e[s],n&&s in B[n]&&(delete B[n][s],this.override&&delete yi[s])}}function XT(i,t,e){const s=ge(Object.create(null),[e?B.get(e):{},B.get(t),i.defaults]);B.set(t,s),i.defaultRoutes&&GT(t,i.defaultRoutes),i.descriptors&&B.describe(t,i.descriptors)}function GT(i,t){Object.keys(t).forEach(e=>{const s=e.split(\".\"),n=s.pop(),o=[i].concat(s).join(\".\"),r=t[e].split(\".\"),a=r.pop(),l=r.join(\".\");B.route(o,n,l,a)})}function qT(i){return\"id\"in i&&\"defaults\"in i}class ZT{constructor(){this.controllers=new Jo(zt,\"datasets\",!0),this.elements=new Jo(jt,\"elements\"),this.plugins=new Jo(Object,\"plugins\"),this.scales=new Jo(Ze,\"scales\"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each(\"register\",t)}remove(...t){this._each(\"unregister\",t)}addControllers(...t){this._each(\"register\",t,this.controllers)}addElements(...t){this._each(\"register\",t,this.elements)}addPlugins(...t){this._each(\"register\",t,this.plugins)}addScales(...t){this._each(\"register\",t,this.scales)}getController(t){return this._get(t,this.controllers,\"controller\")}getElement(t){return this._get(t,this.elements,\"element\")}getPlugin(t){return this._get(t,this.plugins,\"plugin\")}getScale(t){return this._get(t,this.scales,\"scale\")}removeControllers(...t){this._each(\"unregister\",t,this.controllers)}removeElements(...t){this._each(\"unregister\",t,this.elements)}removePlugins(...t){this._each(\"unregister\",t,this.plugins)}removeScales(...t){this._each(\"unregister\",t,this.scales)}_each(t,e,s){[...e].forEach(n=>{const o=s||this._getRegistryForType(n);s||o.isForType(n)||o===this.plugins&&n.id?this._exec(t,o,n):U(n,r=>{const a=s||this._getRegistryForType(r);this._exec(t,a,r)})})}_exec(t,e,s){const n=Ha(t);G(s[\"before\"+n],[],s),e[t](s),G(s[\"after\"+n],[],s)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const s=this._typedRegistries[e];if(s.isForType(t))return s}return this.plugins}_get(t,e,s){const n=e.get(t);if(n===void 0)throw new Error('\"'+t+'\" is not a registered '+s+\".\");return n}}var te=new ZT;class gn extends zt{update(t){const e=this._cachedMeta,{data:s=[]}=e,n=this.chart._animationsDisabled;let{start:o,count:r}=fu(e,s,n);if(this._drawStart=o,this._drawCount=r,pu(e)&&(o=0,r=s.length),this.options.showLine){const{dataset:a,_dataset:l}=e;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=s;const c=this.resolveDatasetElementOptions(t);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!n,options:c},t)}this.updateElements(s,o,r,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=te.getElement(\"line\")),super.addElements()}updateElements(t,e,s,n){const o=n===\"reset\",{iScale:r,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,h=this.resolveDataElementOptions(e,n),d=this.getSharedOptions(h),u=this.includeOptions(n,d),f=r.axis,p=a.axis,{spanGaps:_,segment:m}=this.options,y=as(_)?_:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||o||n===\"none\";let E=e>0&&this.getParsed(e-1);for(let C=e;C<e+s;++C){const T=t[C],A=this.getParsed(C),w=x?T:{},S=N(A[p]),k=w[f]=r.getPixelForValue(A[f],C),D=w[p]=o||S?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,A,l):A[p],C);w.skip=isNaN(k)||isNaN(D)||S,w.stop=C>0&&Math.abs(A[f]-E[f])>y,m&&(w.parsed=A,w.raw=c.data[C]),u&&(w.options=d||this.resolveDataElementOptions(C,T.active?\"active\":n)),x||this.updateElement(T,C,w,n),E=A}this.updateSharedOptions(d,n,h)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let a=0;for(let l=e.length-1;l>=0;--l)a=Math.max(a,e[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const s=t.dataset,n=s.options&&s.options.borderWidth||0;if(!e.length)return n;const o=e[0].size(this.resolveDataElementOptions(0)),r=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(n,o,r)/2}}gn.id=\"scatter\",gn.defaults={datasetElementType:!1,dataElementType:\"point\",showLine:!1,fill:!1},gn.overrides={interaction:{mode:\"point\"},plugins:{tooltip:{callbacks:{title(){return\"\"},label(i){return\"(\"+i.label+\", \"+i.formattedValue+\")\"}}}},scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};var pf=Object.freeze({__proto__:null,BarController:cn,BubbleController:hn,DoughnutController:ki,LineController:dn,PolarAreaController:un,PieController:Zo,RadarController:fn,ScatterController:gn});function Si(){throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\")}class cl{constructor(t){this.options=t||{}}init(t){}formats(){return Si()}parse(t,e){return Si()}format(t,e){return Si()}add(t,e,s){return Si()}diff(t,e,s){return Si()}startOf(t,e,s){return Si()}endOf(t,e){return Si()}}cl.override=function(i){Object.assign(cl.prototype,i)};var _f={_date:cl};function QT(i,t,e,s){const{controller:n,data:o,_sorted:r}=i,a=n._cachedMeta.iScale;if(a&&t===a.axis&&t!==\"r\"&&r&&o.length){const l=a._reversePixels?WE:we;if(s){if(n._sharedOptions){const c=o[0],h=typeof c.getRange==\"function\"&&c.getRange(t);if(h){const d=l(o,t,e-h),u=l(o,t,e+h);return{lo:d.lo,hi:u.hi}}}}else return l(o,t,e)}return{lo:0,hi:o.length-1}}function mn(i,t,e,s,n){const o=i.getSortedVisibleDatasetMetas(),r=e[t];for(let a=0,l=o.length;a<l;++a){const{index:c,data:h}=o[a],{lo:d,hi:u}=QT(o[a],t,r,n);for(let f=d;f<=u;++f){const p=h[f];p.skip||s(p,c,f)}}}function JT(i){const t=i.indexOf(\"x\")!==-1,e=i.indexOf(\"y\")!==-1;return function(s,n){const o=t?Math.abs(s.x-n.x):0,r=e?Math.abs(s.y-n.y):0;return Math.sqrt(Math.pow(o,2)+Math.pow(r,2))}}function hl(i,t,e,s,n){const o=[];return!n&&!i.isPointInArea(t)||mn(i,e,t,function(a,l,c){!n&&!on(a,i.chartArea,0)||a.inRange(t.x,t.y,s)&&o.push({element:a,datasetIndex:l,index:c})},!0),o}function tA(i,t,e,s){let n=[];function o(r,a,l){const{startAngle:c,endAngle:h}=r.getProps([\"startAngle\",\"endAngle\"],s),{angle:d}=au(r,{x:t.x,y:t.y});Js(d,c,h)&&n.push({element:r,datasetIndex:a,index:l})}return mn(i,e,t,o),n}function eA(i,t,e,s,n,o){let r=[];const a=JT(e);let l=Number.POSITIVE_INFINITY;function c(h,d,u){const f=h.inRange(t.x,t.y,n);if(s&&!f)return;const p=h.getCenterPoint(n);if(!(!!o||i.isPointInArea(p))&&!f)return;const m=a(t,p);m<l?(r=[{element:h,datasetIndex:d,index:u}],l=m):m===l&&r.push({element:h,datasetIndex:d,index:u})}return mn(i,e,t,c),r}function dl(i,t,e,s,n,o){return!o&&!i.isPointInArea(t)?[]:e===\"r\"&&!s?tA(i,t,e,n):eA(i,t,e,s,n,o)}function gf(i,t,e,s,n){const o=[],r=e===\"x\"?\"inXRange\":\"inYRange\";let a=!1;return mn(i,e,t,(l,c,h)=>{l[r](t[e],n)&&(o.push({element:l,datasetIndex:c,index:h}),a=a||l.inRange(t.x,t.y,n))}),s&&!a?[]:o}var mf={evaluateInteractionItems:mn,modes:{index(i,t,e,s){const n=Ai(t,i),o=e.axis||\"x\",r=e.includeInvisible||!1,a=e.intersect?hl(i,n,o,s,r):dl(i,n,o,!1,s,r),l=[];return a.length?(i.getSortedVisibleDatasetMetas().forEach(c=>{const h=a[0].index,d=c.data[h];d&&!d.skip&&l.push({element:d,datasetIndex:c.index,index:h})}),l):[]},dataset(i,t,e,s){const n=Ai(t,i),o=e.axis||\"xy\",r=e.includeInvisible||!1;let a=e.intersect?hl(i,n,o,s,r):dl(i,n,o,!1,s,r);if(a.length>0){const l=a[0].datasetIndex,c=i.getDatasetMeta(l).data;a=[];for(let h=0;h<c.length;++h)a.push({element:c[h],datasetIndex:l,index:h})}return a},point(i,t,e,s){const n=Ai(t,i),o=e.axis||\"xy\",r=e.includeInvisible||!1;return hl(i,n,o,s,r)},nearest(i,t,e,s){const n=Ai(t,i),o=e.axis||\"xy\",r=e.includeInvisible||!1;return dl(i,n,o,e.intersect,s,r)},x(i,t,e,s){const n=Ai(t,i);return gf(i,n,\"x\",e.intersect,s)},y(i,t,e,s){const n=Ai(t,i);return gf(i,n,\"y\",e.intersect,s)}}};const bf=[\"left\",\"top\",\"right\",\"bottom\"];function bn(i,t){return i.filter(e=>e.pos===t)}function vf(i,t){return i.filter(e=>bf.indexOf(e.pos)===-1&&e.box.axis===t)}function vn(i,t){return i.sort((e,s)=>{const n=t?s:e,o=t?e:s;return n.weight===o.weight?n.index-o.index:n.weight-o.weight})}function iA(i){const t=[];let e,s,n,o,r,a;for(e=0,s=(i||[]).length;e<s;++e)n=i[e],{position:o,options:{stack:r,stackWeight:a=1}}=n,t.push({index:e,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:r&&o+r,stackWeight:a});return t}function sA(i){const t={};for(const e of i){const{stack:s,pos:n,stackWeight:o}=e;if(!s||!bf.includes(n))continue;const r=t[s]||(t[s]={count:0,placed:0,weight:0,size:0});r.count++,r.weight+=o}return t}function nA(i,t){const e=sA(i),{vBoxMaxWidth:s,hBoxMaxHeight:n}=t;let o,r,a;for(o=0,r=i.length;o<r;++o){a=i[o];const{fullSize:l}=a.box,c=e[a.stack],h=c&&a.stackWeight/c.weight;a.horizontal?(a.width=h?h*s:l&&t.availableWidth,a.height=n):(a.width=s,a.height=h?h*n:l&&t.availableHeight)}return e}function oA(i){const t=iA(i),e=vn(t.filter(c=>c.box.fullSize),!0),s=vn(bn(t,\"left\"),!0),n=vn(bn(t,\"right\")),o=vn(bn(t,\"top\"),!0),r=vn(bn(t,\"bottom\")),a=vf(t,\"x\"),l=vf(t,\"y\");return{fullSize:e,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(r).concat(a),chartArea:bn(t,\"chartArea\"),vertical:s.concat(n).concat(l),horizontal:o.concat(r).concat(a)}}function yf(i,t,e,s){return Math.max(i[e],t[e])+Math.max(i[s],t[s])}function xf(i,t){i.top=Math.max(i.top,t.top),i.left=Math.max(i.left,t.left),i.bottom=Math.max(i.bottom,t.bottom),i.right=Math.max(i.right,t.right)}function rA(i,t,e,s){const{pos:n,box:o}=e,r=i.maxPadding;if(!$(n)){e.size&&(i[n]-=e.size);const d=s[e.stack]||{size:0,count:1};d.size=Math.max(d.size,e.horizontal?o.height:o.width),e.size=d.size/d.count,i[n]+=e.size}o.getPadding&&xf(r,o.getPadding());const a=Math.max(0,t.outerWidth-yf(r,i,\"left\",\"right\")),l=Math.max(0,t.outerHeight-yf(r,i,\"top\",\"bottom\")),c=a!==i.w,h=l!==i.h;return i.w=a,i.h=l,e.horizontal?{same:c,other:h}:{same:h,other:c}}function aA(i){const t=i.maxPadding;function e(s){const n=Math.max(t[s]-i[s],0);return i[s]+=n,n}i.y+=e(\"top\"),i.x+=e(\"left\"),e(\"right\"),e(\"bottom\")}function lA(i,t){const e=t.maxPadding;function s(n){const o={left:0,top:0,right:0,bottom:0};return n.forEach(r=>{o[r]=Math.max(t[r],e[r])}),o}return s(i?[\"left\",\"right\"]:[\"top\",\"bottom\"])}function yn(i,t,e,s){const n=[];let o,r,a,l,c,h;for(o=0,r=i.length,c=0;o<r;++o){a=i[o],l=a.box,l.update(a.width||t.w,a.height||t.h,lA(a.horizontal,t));const{same:d,other:u}=rA(t,e,a,s);c|=d&&n.length,h=h||u,l.fullSize||n.push(a)}return c&&yn(n,t,e,s)||h}function tr(i,t,e,s,n){i.top=e,i.left=t,i.right=t+s,i.bottom=e+n,i.width=s,i.height=n}function Ef(i,t,e,s){const n=e.padding;let{x:o,y:r}=t;for(const a of i){const l=a.box,c=s[a.stack]||{count:1,placed:0,weight:1},h=a.stackWeight/c.weight||1;if(a.horizontal){const d=t.w*h,u=c.size||l.height;Ft(c.start)&&(r=c.start),l.fullSize?tr(l,n.left,r,e.outerWidth-n.right-n.left,u):tr(l,t.left+c.placed,r,d,u),c.start=r,c.placed+=d,r=l.bottom}else{const d=t.h*h,u=c.size||l.width;Ft(c.start)&&(o=c.start),l.fullSize?tr(l,o,n.top,u,e.outerHeight-n.bottom-n.top):tr(l,o,t.top+c.placed,u,d),c.start=o,c.placed+=d,o=l.right}}t.x=o,t.y=r}B.set(\"layout\",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}});var dt={addBox(i,t){i.boxes||(i.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||\"top\",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},i.boxes.push(t)},removeBox(i,t){const e=i.boxes?i.boxes.indexOf(t):-1;e!==-1&&i.boxes.splice(e,1)},configure(i,t,e){t.fullSize=e.fullSize,t.position=e.position,t.weight=e.weight},update(i,t,e,s){if(!i)return;const n=ht(i.options.layout.padding),o=Math.max(t-n.width,0),r=Math.max(e-n.height,0),a=oA(i.boxes),l=a.vertical,c=a.horizontal;U(i.boxes,_=>{typeof _.beforeLayout==\"function\"&&_.beforeLayout()});const h=l.reduce((_,m)=>m.box.options&&m.box.options.display===!1?_:_+1,0)||1,d=Object.freeze({outerWidth:t,outerHeight:e,padding:n,availableWidth:o,availableHeight:r,vBoxMaxWidth:o/2/h,hBoxMaxHeight:r/2}),u=Object.assign({},n);xf(u,ht(s));const f=Object.assign({maxPadding:u,w:o,h:r,x:n.left,y:n.top},n),p=nA(l.concat(c),d);yn(a.fullSize,f,d,p),yn(l,f,d,p),yn(c,f,d,p)&&yn(l,f,d,p),aA(f),Ef(a.leftAndTop,f,d,p),f.x+=f.w,f.y+=f.h,Ef(a.rightAndBottom,f,d,p),i.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},U(a.chartArea,_=>{const m=_.box;Object.assign(m,i.chartArea),m.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})})}};class ul{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,s){}removeEventListener(t,e,s){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,s,n){return e=Math.max(0,e||t.width),s=s||t.height,{width:e,height:Math.max(0,n?Math.floor(e/n):s)}}isAttached(t){return!0}updateConfig(t){}}class Cf extends ul{acquireContext(t){return t&&t.getContext&&t.getContext(\"2d\")||null}updateConfig(t){t.options.animation=!1}}const er=\"$chartjs\",cA={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\",pointerenter:\"mouseenter\",pointerdown:\"mousedown\",pointermove:\"mousemove\",pointerup:\"mouseup\",pointerleave:\"mouseout\",pointerout:\"mouseout\"},Tf=i=>i===null||i===\"\";function hA(i,t){const e=i.style,s=i.getAttribute(\"height\"),n=i.getAttribute(\"width\");if(i[er]={initial:{height:s,width:n,style:{display:e.display,height:e.height,width:e.width}}},e.display=e.display||\"block\",e.boxSizing=e.boxSizing||\"border-box\",Tf(n)){const o=Fu(i,\"width\");o!==void 0&&(i.width=o)}if(Tf(s))if(i.style.height===\"\")i.height=i.width/(t||2);else{const o=Fu(i,\"height\");o!==void 0&&(i.height=o)}return i}const Af=GC?{passive:!0}:!1;function dA(i,t,e){i.addEventListener(t,e,Af)}function uA(i,t,e){i.canvas.removeEventListener(t,e,Af)}function fA(i,t){const e=cA[i.type]||i.type,{x:s,y:n}=Ai(i,t);return{type:e,chart:t,native:i,x:s!==void 0?s:null,y:n!==void 0?n:null}}function ir(i,t){for(const e of i)if(e===t||e.contains(t))return!0}function pA(i,t,e){const s=i.canvas,n=new MutationObserver(o=>{let r=!1;for(const a of o)r=r||ir(a.addedNodes,s),r=r&&!ir(a.removedNodes,s);r&&e()});return n.observe(document,{childList:!0,subtree:!0}),n}function _A(i,t,e){const s=i.canvas,n=new MutationObserver(o=>{let r=!1;for(const a of o)r=r||ir(a.removedNodes,s),r=r&&!ir(a.addedNodes,s);r&&e()});return n.observe(document,{childList:!0,subtree:!0}),n}const xn=new Map;let wf=0;function kf(){const i=window.devicePixelRatio;i!==wf&&(wf=i,xn.forEach((t,e)=>{e.currentDevicePixelRatio!==i&&t()}))}function gA(i,t){xn.size||window.addEventListener(\"resize\",kf),xn.set(i,t)}function mA(i){xn.delete(i),xn.size||window.removeEventListener(\"resize\",kf)}function bA(i,t,e){const s=i.canvas,n=s&&sl(s);if(!n)return;const o=uu((a,l)=>{const c=n.clientWidth;e(a,l),c<n.clientWidth&&e()},window),r=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,h=l.contentRect.height;c===0&&h===0||o(c,h)});return r.observe(n),gA(i,o),r}function fl(i,t,e){e&&e.disconnect(),t===\"resize\"&&mA(i)}function vA(i,t,e){const s=i.canvas,n=uu(o=>{i.ctx!==null&&e(fA(o,i))},i,o=>{const r=o[0];return[r,r.offsetX,r.offsetY]});return dA(s,t,n),n}class Sf extends ul{acquireContext(t,e){const s=t&&t.getContext&&t.getContext(\"2d\");return s&&s.canvas===t?(hA(t,e),s):null}releaseContext(t){const e=t.canvas;if(!e[er])return!1;const s=e[er].initial;[\"height\",\"width\"].forEach(o=>{const r=s[o];N(r)?e.removeAttribute(o):e.setAttribute(o,r)});const n=s.style||{};return Object.keys(n).forEach(o=>{e.style[o]=n[o]}),e.width=e.width,delete e[er],!0}addEventListener(t,e,s){this.removeEventListener(t,e);const n=t.$proxies||(t.$proxies={}),r={attach:pA,detach:_A,resize:bA}[e]||vA;n[e]=r(t,e,s)}removeEventListener(t,e){const s=t.$proxies||(t.$proxies={}),n=s[e];if(!n)return;({attach:fl,detach:fl,resize:fl}[e]||uA)(t,e,n),s[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,s,n){return XC(t,e,s,n)}isAttached(t){const e=sl(t);return!!(e&&e.isConnected)}}function Of(i){return!Bu()||typeof OffscreenCanvas<\"u\"&&i instanceof OffscreenCanvas?Cf:Sf}class yA{constructor(){this._init=[]}notify(t,e,s,n){e===\"beforeInit\"&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,\"install\"));const o=n?this._descriptors(t).filter(n):this._descriptors(t),r=this._notify(o,t,e,s);return e===\"afterDestroy\"&&(this._notify(o,t,\"stop\"),this._notify(this._init,t,\"uninstall\")),r}_notify(t,e,s,n){n=n||{};for(const o of t){const r=o.plugin,a=r[s],l=[e,n,o.options];if(G(a,l,r)===!1&&n.cancelable)return!1}return!0}invalidate(){N(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const s=t&&t.config,n=R(s.options&&s.options.plugins,{}),o=xA(s);return n===!1&&!e?[]:CA(t,o,n,e)}_notifyStateChanges(t){const e=this._oldCache||[],s=this._cache,n=(o,r)=>o.filter(a=>!r.some(l=>a.plugin.id===l.plugin.id));this._notify(n(e,s),t,\"stop\"),this._notify(n(s,e),t,\"start\")}}function xA(i){const t={},e=[],s=Object.keys(te.plugins.items);for(let o=0;o<s.length;o++)e.push(te.getPlugin(s[o]));const n=i.plugins||[];for(let o=0;o<n.length;o++){const r=n[o];e.indexOf(r)===-1&&(e.push(r),t[r.id]=!0)}return{plugins:e,localIds:t}}function EA(i,t){return!t&&i===!1?null:i===!0?{}:i}function CA(i,{plugins:t,localIds:e},s,n){const o=[],r=i.getContext();for(const a of t){const l=a.id,c=EA(s[l],n);c!==null&&o.push({plugin:a,options:TA(i.config,{plugin:a,local:e[l]},c,r)})}return o}function TA(i,{plugin:t,local:e},s,n){const o=i.pluginScopeKeys(t),r=i.getOptionScopes(s,o);return e&&t.defaults&&r.push(t.defaults),i.createResolver(r,n,[\"\"],{scriptable:!1,indexable:!1,allKeys:!0})}function pl(i,t){const e=B.datasets[i]||{};return((t.datasets||{})[i]||{}).indexAxis||t.indexAxis||e.indexAxis||\"x\"}function AA(i,t){let e=i;return i===\"_index_\"?e=t:i===\"_value_\"&&(e=t===\"x\"?\"y\":\"x\"),e}function wA(i,t){return i===t?\"_index_\":\"_value_\"}function kA(i){if(i===\"top\"||i===\"bottom\")return\"x\";if(i===\"left\"||i===\"right\")return\"y\"}function _l(i,t){return i===\"x\"||i===\"y\"?i:t.axis||kA(t.position)||i.charAt(0).toLowerCase()}function SA(i,t){const e=yi[i.type]||{scales:{}},s=t.scales||{},n=pl(i.type,t),o=Object.create(null),r=Object.create(null);return Object.keys(s).forEach(a=>{const l=s[a];if(!$(l))return console.error(`Invalid scale configuration for scale: ${a}`);if(l._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${a}`);const c=_l(a,l),h=wA(c,n),d=e.scales||{};o[c]=o[c]||a,r[a]=qs(Object.create(null),[{axis:c},l,d[c],d[h]])}),i.data.datasets.forEach(a=>{const l=a.type||i.type,c=a.indexAxis||pl(l,t),d=(yi[l]||{}).scales||{};Object.keys(d).forEach(u=>{const f=AA(u,c),p=a[f+\"AxisID\"]||o[f]||f;r[p]=r[p]||Object.create(null),qs(r[p],[{axis:f},s[p],d[u]])})}),Object.keys(r).forEach(a=>{const l=r[a];qs(l,[B.scales[l.type],B.scale])}),r}function Df(i){const t=i.options||(i.options={});t.plugins=R(t.plugins,{}),t.scales=SA(i,t)}function Mf(i){return i=i||{},i.datasets=i.datasets||[],i.labels=i.labels||[],i}function OA(i){return i=i||{},i.data=Mf(i.data),Df(i),i}const If=new Map,Lf=new Set;function sr(i,t){let e=If.get(i);return e||(e=t(),If.set(i,e),Lf.add(e)),e}const En=(i,t,e)=>{const s=Ke(t,e);s!==void 0&&i.add(s)};class DA{constructor(t){this._config=OA(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=Mf(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),Df(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return sr(t,()=>[[`datasets.${t}`,\"\"]])}datasetAnimationScopeKeys(t,e){return sr(`${t}.transition.${e}`,()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,\"\"]])}datasetElementScopeKeys(t,e){return sr(`${t}-${e}`,()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,\"\"]])}pluginScopeKeys(t){const e=t.id,s=this.type;return sr(`${s}-plugin-${e}`,()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,e){const s=this._scopeCache;let n=s.get(t);return(!n||e)&&(n=new Map,s.set(t,n)),n}getOptionScopes(t,e,s){const{options:n,type:o}=this,r=this._cachedScopes(t,s),a=r.get(e);if(a)return a;const l=new Set;e.forEach(h=>{t&&(l.add(t),h.forEach(d=>En(l,t,d))),h.forEach(d=>En(l,n,d)),h.forEach(d=>En(l,yi[o]||{},d)),h.forEach(d=>En(l,B,d)),h.forEach(d=>En(l,qa,d))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Lf.has(e)&&r.set(e,c),c}chartOptionScopes(){const{options:t,type:e}=this;return[t,yi[e]||{},B.datasets[e]||{},{type:e},B,qa]}resolveNamedOptions(t,e,s,n=[\"\"]){const o={$shared:!0},{resolver:r,subPrefixes:a}=Pf(this._resolverCache,t,n);let l=r;if(IA(r,e)){o.$shared=!1,s=Ue(s)?s():s;const c=this.createResolver(t,s,a);l=cs(r,s,c)}for(const c of e)o[c]=l[c];return o}createResolver(t,e,s=[\"\"],n){const{resolver:o}=Pf(this._resolverCache,t,s);return $(e)?cs(o,e,void 0,n):o}}function Pf(i,t,e){let s=i.get(t);s||(s=new Map,i.set(t,s));const n=e.join();let o=s.get(n);return o||(o={resolver:tl(t,e),subPrefixes:e.filter(a=>!a.toLowerCase().includes(\"hover\"))},s.set(n,o)),o}const MA=i=>$(i)&&Object.getOwnPropertyNames(i).reduce((t,e)=>t||Ue(i[e]),!1);function IA(i,t){const{isScriptable:e,isIndexable:s}=Du(i);for(const n of t){const o=e(n),r=s(n),a=(r||o)&&i[n];if(o&&(Ue(a)||MA(a))||r&&Q(a))return!0}return!1}var LA=\"3.9.1\";const PA=[\"top\",\"bottom\",\"left\",\"right\",\"chartArea\"];function Rf(i,t){return i===\"top\"||i===\"bottom\"||PA.indexOf(i)===-1&&t===\"x\"}function Nf(i,t){return function(e,s){return e[i]===s[i]?e[t]-s[t]:e[i]-s[i]}}function $f(i){const t=i.chart,e=t.options.animation;t.notifyPlugins(\"afterRender\"),G(e&&e.onComplete,[i],t)}function RA(i){const t=i.chart,e=t.options.animation;G(e&&e.onProgress,[i],t)}function Bf(i){return Bu()&&typeof i==\"string\"?i=document.getElementById(i):i&&i.length&&(i=i[0]),i&&i.canvas&&(i=i.canvas),i}const nr={},Hf=i=>{const t=Bf(i);return Object.values(nr).filter(e=>e.canvas===t).pop()};function NA(i,t,e){const s=Object.keys(i);for(const n of s){const o=+n;if(o>=t){const r=i[n];delete i[n],(e>0||o>t)&&(i[o+e]=r)}}}function $A(i,t,e,s){return!e||i.type===\"mouseout\"?null:s?t:i}class gl{constructor(t,e){const s=this.config=new DA(e),n=Bf(t),o=Hf(n);if(o)throw new Error(\"Canvas is already in use. Chart with ID '\"+o.id+\"' must be destroyed before the canvas with ID '\"+o.canvas.id+\"' can be reused.\");const r=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||Of(n)),this.platform.updateConfig(s);const a=this.platform.acquireContext(n,r.aspectRatio),l=a&&a.canvas,c=l&&l.height,h=l&&l.width;if(this.id=OE(),this.ctx=a,this.canvas=l,this.width=h,this.height=c,this._options=r,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new yA,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=YE(d=>this.update(d),r.resizeDelay||0),this._dataChanges=[],nr[this.id]=this,!a||!l){console.error(\"Failed to create chart: can't acquire context from the given item\");return}be.listen(this,\"complete\",$f),be.listen(this,\"progress\",RA),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:s,height:n,_aspectRatio:o}=this;return N(t)?e&&o?o:n?s/n:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}_initialize(){return this.notifyPlugins(\"beforeInit\"),this.options.responsive?this.resize():Hu(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins(\"afterInit\"),this}clear(){return ku(this.canvas,this.ctx),this}stop(){return be.stop(this),this}resize(t,e){be.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const s=this.options,n=this.canvas,o=s.maintainAspectRatio&&this.aspectRatio,r=this.platform.getMaximumSize(n,t,e,o),a=s.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?\"resize\":\"attach\";this.width=r.width,this.height=r.height,this._aspectRatio=this.aspectRatio,Hu(this,a,!0)&&(this.notifyPlugins(\"resize\",{size:r}),G(s.onResize,[this,r],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const e=this.options.scales||{};U(e,(s,n)=>{s.id=n})}buildOrUpdateScales(){const t=this.options,e=t.scales,s=this.scales,n=Object.keys(s).reduce((r,a)=>(r[a]=!1,r),{});let o=[];e&&(o=o.concat(Object.keys(e).map(r=>{const a=e[r],l=_l(r,a),c=l===\"r\",h=l===\"x\";return{options:a,dposition:c?\"chartArea\":h?\"bottom\":\"left\",dtype:c?\"radialLinear\":h?\"category\":\"linear\"}}))),U(o,r=>{const a=r.options,l=a.id,c=_l(l,a),h=R(a.type,r.dtype);(a.position===void 0||Rf(a.position,c)!==Rf(r.dposition))&&(a.position=r.dposition),n[l]=!0;let d=null;if(l in s&&s[l].type===h)d=s[l];else{const u=te.getScale(h);d=new u({id:l,type:h,ctx:this.ctx,chart:this}),s[d.id]=d}d.init(a,t)}),U(n,(r,a)=>{r||delete s[a]}),U(s,r=>{dt.configure(this,r,r.options),dt.addBox(this,r)})}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,s=t.length;if(t.sort((n,o)=>n.index-o.index),s>e){for(let n=e;n<s;++n)this._destroyDatasetMeta(n);t.splice(e,s-e)}this._sortedMetasets=t.slice(0).sort(Nf(\"order\",\"index\"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach((s,n)=>{e.filter(o=>o===s._dataset).length===0&&this._destroyDatasetMeta(n)})}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let s,n;for(this._removeUnreferencedMetasets(),s=0,n=e.length;s<n;s++){const o=e[s];let r=this.getDatasetMeta(s);const a=o.type||this.config.type;if(r.type&&r.type!==a&&(this._destroyDatasetMeta(s),r=this.getDatasetMeta(s)),r.type=a,r.indexAxis=o.indexAxis||pl(a,this.options),r.order=o.order||0,r.index=s,r.label=\"\"+o.label,r.visible=this.isDatasetVisible(s),r.controller)r.controller.updateIndex(s),r.controller.linkScales();else{const l=te.getController(a),{datasetElementType:c,dataElementType:h}=B.datasets[a];Object.assign(l.prototype,{dataElementType:te.getElement(h),datasetElementType:c&&te.getElement(c)}),r.controller=new l(this,s),t.push(r.controller)}}return this._updateMetasets(),t}_resetElements(){U(this.data.datasets,(t,e)=>{this.getDatasetMeta(e).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins(\"reset\")}update(t){const e=this.config;e.update();const s=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),n=this._animationsDisabled=!s.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins(\"beforeUpdate\",{mode:t,cancelable:!0})===!1)return;const o=this.buildOrUpdateControllers();this.notifyPlugins(\"beforeElementsUpdate\");let r=0;for(let c=0,h=this.data.datasets.length;c<h;c++){const{controller:d}=this.getDatasetMeta(c),u=!n&&o.indexOf(d)===-1;d.buildOrUpdateElements(u),r=Math.max(+d.getMaxOverflow(),r)}r=this._minPadding=s.layout.autoPadding?r:0,this._updateLayout(r),n||U(o,c=>{c.reset()}),this._updateDatasets(t),this.notifyPlugins(\"afterUpdate\",{mode:t}),this._layers.sort(Nf(\"z\",\"_idx\"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){U(this.scales,t=>{dt.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),s=new Set(t.events);(!iu(e,s)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:s,start:n,count:o}of e){const r=s===\"_removeElements\"?-o:o;NA(t,n,r)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,s=o=>new Set(t.filter(r=>r[0]===o).map((r,a)=>a+\",\"+r.splice(1).join(\",\"))),n=s(0);for(let o=1;o<e;o++)if(!iu(n,s(o)))return;return Array.from(n).map(o=>o.split(\",\")).map(o=>({method:o[1],start:+o[2],count:+o[3]}))}_updateLayout(t){if(this.notifyPlugins(\"beforeLayout\",{cancelable:!0})===!1)return;dt.update(this,this.width,this.height,t);const e=this.chartArea,s=e.width<=0||e.height<=0;this._layers=[],U(this.boxes,n=>{s&&n.position===\"chartArea\"||(n.configure&&n.configure(),this._layers.push(...n._layers()))},this),this._layers.forEach((n,o)=>{n._idx=o}),this.notifyPlugins(\"afterLayout\")}_updateDatasets(t){if(this.notifyPlugins(\"beforeDatasetsUpdate\",{mode:t,cancelable:!0})!==!1){for(let e=0,s=this.data.datasets.length;e<s;++e)this.getDatasetMeta(e).controller.configure();for(let e=0,s=this.data.datasets.length;e<s;++e)this._updateDataset(e,Ue(t)?t({datasetIndex:e}):t);this.notifyPlugins(\"afterDatasetsUpdate\",{mode:t})}}_updateDataset(t,e){const s=this.getDatasetMeta(t),n={meta:s,index:t,mode:e,cancelable:!0};this.notifyPlugins(\"beforeDatasetUpdate\",n)!==!1&&(s.controller._update(e),n.cancelable=!1,this.notifyPlugins(\"afterDatasetUpdate\",n))}render(){this.notifyPlugins(\"beforeRender\",{cancelable:!0})!==!1&&(be.has(this)?this.attached&&!be.running(this)&&be.start(this):(this.draw(),$f({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:s,height:n}=this._resizeBeforeDraw;this._resize(s,n),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins(\"beforeDraw\",{cancelable:!0})===!1)return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins(\"afterDraw\")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,s=[];let n,o;for(n=0,o=e.length;n<o;++n){const r=e[n];(!t||r.visible)&&s.push(r)}return s}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins(\"beforeDatasetsDraw\",{cancelable:!0})===!1)return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins(\"afterDatasetsDraw\")}_drawDataset(t){const e=this.ctx,s=t._clip,n=!s.disabled,o=this.chartArea,r={meta:t,index:t.index,cancelable:!0};this.notifyPlugins(\"beforeDatasetDraw\",r)!==!1&&(n&&Ko(e,{left:s.left===!1?0:o.left-s.left,right:s.right===!1?this.width:o.right+s.right,top:s.top===!1?0:o.top-s.top,bottom:s.bottom===!1?this.height:o.bottom+s.bottom}),t.controller.draw(),n&&Uo(e),r.cancelable=!1,this.notifyPlugins(\"afterDatasetDraw\",r))}isPointInArea(t){return on(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,s,n){const o=mf.modes[e];return typeof o==\"function\"?o(this,t,s,n):[]}getDatasetMeta(t){const e=this.data.datasets[t],s=this._metasets;let n=s.filter(o=>o&&o._dataset===e).pop();return n||(n={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},s.push(n)),n}getContext(){return this.$context||(this.$context=qe(null,{chart:this,type:\"chart\"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const s=this.getDatasetMeta(t);return typeof s.hidden==\"boolean\"?!s.hidden:!e.hidden}setDatasetVisibility(t,e){const s=this.getDatasetMeta(t);s.hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,s){const n=s?\"show\":\"hide\",o=this.getDatasetMeta(t),r=o.controller._resolveAnimations(void 0,n);Ft(e)?(o.data[e].hidden=!s,this.update()):(this.setDatasetVisibility(t,s),r.update(o,{visible:s}),this.update(a=>a.datasetIndex===t?n:void 0))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),be.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins(\"beforeDestroy\");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),ku(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),this.notifyPlugins(\"destroy\"),delete nr[this.id],this.notifyPlugins(\"afterDestroy\")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,s=(o,r)=>{e.addEventListener(this,o,r),t[o]=r},n=(o,r,a)=>{o.offsetX=r,o.offsetY=a,this._eventHandler(o)};U(this.options.events,o=>s(o,n))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,s=(l,c)=>{e.addEventListener(this,l,c),t[l]=c},n=(l,c)=>{t[l]&&(e.removeEventListener(this,l,c),delete t[l])},o=(l,c)=>{this.canvas&&this.resize(l,c)};let r;const a=()=>{n(\"attach\",a),this.attached=!0,this.resize(),s(\"resize\",o),s(\"detach\",r)};r=()=>{this.attached=!1,n(\"resize\",o),this._stop(),this._resize(0,0),s(\"attach\",a)},e.isAttached(this.canvas)?a():r()}unbindEvents(){U(this._listeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._listeners={},U(this._responsiveListeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,e,s){const n=s?\"set\":\"remove\";let o,r,a,l;for(e===\"dataset\"&&(o=this.getDatasetMeta(t[0].datasetIndex),o.controller[\"_\"+n+\"DatasetHoverStyle\"]()),a=0,l=t.length;a<l;++a){r=t[a];const c=r&&this.getDatasetMeta(r.datasetIndex).controller;c&&c[n+\"HoverStyle\"](r.element,r.datasetIndex,r.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],s=t.map(({datasetIndex:o,index:r})=>{const a=this.getDatasetMeta(o);if(!a)throw new Error(\"No dataset found at index \"+o);return{datasetIndex:o,element:a.data[r],index:r}});!$o(s,e)&&(this._active=s,this._lastEvent=null,this._updateHoverStyles(s,e))}notifyPlugins(t,e,s){return this._plugins.notify(this,t,e,s)}_updateHoverStyles(t,e,s){const n=this.options.hover,o=(l,c)=>l.filter(h=>!c.some(d=>h.datasetIndex===d.datasetIndex&&h.index===d.index)),r=o(e,t),a=s?t:o(t,e);r.length&&this.updateHoverStyle(r,n.mode,!1),a.length&&n.mode&&this.updateHoverStyle(a,n.mode,!0)}_eventHandler(t,e){const s={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},n=r=>(r.options.events||this.options.events).includes(t.native.type);if(this.notifyPlugins(\"beforeEvent\",s,n)===!1)return;const o=this._handleEvent(t,e,s.inChartArea);return s.cancelable=!1,this.notifyPlugins(\"afterEvent\",s,n),(o||s.changed)&&this.render(),this}_handleEvent(t,e,s){const{_active:n=[],options:o}=this,r=e,a=this._getActiveElements(t,n,s,r),l=RE(t),c=$A(t,this._lastEvent,s,l);s&&(this._lastEvent=null,G(o.onHover,[t,a,this],this),l&&G(o.onClick,[t,a,this],this));const h=!$o(a,n);return(h||e)&&(this._active=a,this._updateHoverStyles(a,n,e)),this._lastEvent=c,h}_getActiveElements(t,e,s,n){if(t.type===\"mouseout\")return[];if(!s)return e;const o=this.options.hover;return this.getElementsAtEventForMode(t,o.mode,o,n)}}const Ff=()=>U(gl.instances,i=>i._plugins.invalidate()),Qe=!0;Object.defineProperties(gl,{defaults:{enumerable:Qe,value:B},instances:{enumerable:Qe,value:nr},overrides:{enumerable:Qe,value:yi},registry:{enumerable:Qe,value:te},version:{enumerable:Qe,value:LA},getChart:{enumerable:Qe,value:Hf},register:{enumerable:Qe,value:(...i)=>{te.add(...i),Ff()}},unregister:{enumerable:Qe,value:(...i)=>{te.remove(...i),Ff()}}});function Vf(i,t,e){const{startAngle:s,pixelMargin:n,x:o,y:r,outerRadius:a,innerRadius:l}=t;let c=n/a;i.beginPath(),i.arc(o,r,a,s-c,e+c),l>n?(c=n/l,i.arc(o,r,l,e+c,s-c,!0)):i.arc(o,r,n,e+nt,s-nt),i.closePath(),i.clip()}function BA(i){return Ja(i,[\"outerStart\",\"outerEnd\",\"innerStart\",\"innerEnd\"])}function HA(i,t,e,s){const n=BA(i.options.borderRadius),o=(e-t)/2,r=Math.min(o,s*t/2),a=l=>{const c=(e-Math.min(o,l))*s/2;return ct(l,0,Math.min(o,c))};return{outerStart:a(n.outerStart),outerEnd:a(n.outerEnd),innerStart:ct(n.innerStart,0,r),innerEnd:ct(n.innerEnd,0,r)}}function us(i,t,e,s){return{x:e+i*Math.cos(t),y:s+i*Math.sin(t)}}function ml(i,t,e,s,n,o){const{x:r,y:a,startAngle:l,pixelMargin:c,innerRadius:h}=t,d=Math.max(t.outerRadius+s+e-c,0),u=h>0?h+s+e+c:0;let f=0;const p=n-l;if(s){const I=h>0?h-s:0,F=d>0?d-s:0,Y=(I+F)/2,Yt=Y!==0?p*Y/(Y+s):p;f=(p-Yt)/2}const _=Math.max(.001,p*d-e/et)/d,m=(p-_)/2,y=l+m+f,x=n-m-f,{outerStart:E,outerEnd:C,innerStart:T,innerEnd:A}=HA(t,u,d,x-y),w=d-E,S=d-C,k=y+E/w,D=x-C/S,O=u+T,M=u+A,L=y+T/O,X=x-A/M;if(i.beginPath(),o){if(i.arc(r,a,d,k,D),C>0){const Y=us(S,D,r,a);i.arc(Y.x,Y.y,C,D,x+nt)}const I=us(M,x,r,a);if(i.lineTo(I.x,I.y),A>0){const Y=us(M,X,r,a);i.arc(Y.x,Y.y,A,x+nt,X+Math.PI)}if(i.arc(r,a,u,x-A/u,y+T/u,!0),T>0){const Y=us(O,L,r,a);i.arc(Y.x,Y.y,T,L+Math.PI,y-nt)}const F=us(w,y,r,a);if(i.lineTo(F.x,F.y),E>0){const Y=us(w,k,r,a);i.arc(Y.x,Y.y,E,y-nt,k)}}else{i.moveTo(r,a);const I=Math.cos(k)*d+r,F=Math.sin(k)*d+a;i.lineTo(I,F);const Y=Math.cos(D)*d+r,Yt=Math.sin(D)*d+a;i.lineTo(Y,Yt)}i.closePath()}function FA(i,t,e,s,n){const{fullCircles:o,startAngle:r,circumference:a}=t;let l=t.endAngle;if(o){ml(i,t,e,s,r+q,n);for(let c=0;c<o;++c)i.fill();isNaN(a)||(l=r+a%q,a%q===0&&(l+=q))}return ml(i,t,e,s,l,n),i.fill(),l}function VA(i,t,e){const{x:s,y:n,startAngle:o,pixelMargin:r,fullCircles:a}=t,l=Math.max(t.outerRadius-r,0),c=t.innerRadius+r;let h;for(e&&Vf(i,t,o+q),i.beginPath(),i.arc(s,n,c,o+q,o,!0),h=0;h<a;++h)i.stroke();for(i.beginPath(),i.arc(s,n,l,o,o+q),h=0;h<a;++h)i.stroke()}function WA(i,t,e,s,n,o){const{options:r}=t,{borderWidth:a,borderJoinStyle:l}=r,c=r.borderAlign===\"inner\";a&&(c?(i.lineWidth=a*2,i.lineJoin=l||\"round\"):(i.lineWidth=a,i.lineJoin=l||\"bevel\"),t.fullCircles&&VA(i,t,c),c&&Vf(i,t,n),ml(i,t,e,s,n,o),i.stroke())}class fs extends jt{constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,s){const n=this.getProps([\"x\",\"y\"],s),{angle:o,distance:r}=au(n,{x:t,y:e}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:h,circumference:d}=this.getProps([\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],s),u=this.options.spacing/2,p=R(d,l-a)>=q||Js(o,a,l),_=Ae(r,c+u,h+u);return p&&_}getCenterPoint(t){const{x:e,y:s,startAngle:n,endAngle:o,innerRadius:r,outerRadius:a}=this.getProps([\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],t),{offset:l,spacing:c}=this.options,h=(n+o)/2,d=(r+a+c+l)/2;return{x:e+Math.cos(h)*d,y:s+Math.sin(h)*d}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:s}=this,n=(e.offset||0)/2,o=(e.spacing||0)/2,r=e.circular;if(this.pixelMargin=e.borderAlign===\"inner\"?.33:0,this.fullCircles=s>q?Math.floor(s/q):0,s===0||this.innerRadius<0||this.outerRadius<0)return;t.save();let a=0;if(n){a=n/2;const c=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(c)*a,Math.sin(c)*a),this.circumference>=et&&(a=n)}t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor;const l=FA(t,this,a,o,r);WA(t,this,a,o,l,r),t.restore()}}fs.id=\"arc\",fs.defaults={borderAlign:\"center\",borderColor:\"#fff\",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0},fs.defaultRoutes={backgroundColor:\"backgroundColor\"};function Wf(i,t,e=t){i.lineCap=R(e.borderCapStyle,t.borderCapStyle),i.setLineDash(R(e.borderDash,t.borderDash)),i.lineDashOffset=R(e.borderDashOffset,t.borderDashOffset),i.lineJoin=R(e.borderJoinStyle,t.borderJoinStyle),i.lineWidth=R(e.borderWidth,t.borderWidth),i.strokeStyle=R(e.borderColor,t.borderColor)}function zA(i,t,e){i.lineTo(e.x,e.y)}function jA(i){return i.stepped?bC:i.tension||i.cubicInterpolationMode===\"monotone\"?vC:zA}function zf(i,t,e={}){const s=i.length,{start:n=0,end:o=s-1}=e,{start:r,end:a}=t,l=Math.max(n,r),c=Math.min(o,a),h=n<r&&o<r||n>a&&o>a;return{count:s,start:l,loop:t.loop,ilen:c<l&&!h?s+c-l:c-l}}function YA(i,t,e,s){const{points:n,options:o}=t,{count:r,start:a,loop:l,ilen:c}=zf(n,e,s),h=jA(o);let{move:d=!0,reverse:u}=s||{},f,p,_;for(f=0;f<=c;++f)p=n[(a+(u?c-f:f))%r],!p.skip&&(d?(i.moveTo(p.x,p.y),d=!1):h(i,_,p,u,o.stepped),_=p);return l&&(p=n[(a+(u?c:0))%r],h(i,_,p,u,o.stepped)),!!l}function KA(i,t,e,s){const n=t.points,{count:o,start:r,ilen:a}=zf(n,e,s),{move:l=!0,reverse:c}=s||{};let h=0,d=0,u,f,p,_,m,y;const x=C=>(r+(c?a-C:C))%o,E=()=>{_!==m&&(i.lineTo(h,m),i.lineTo(h,_),i.lineTo(h,y))};for(l&&(f=n[x(0)],i.moveTo(f.x,f.y)),u=0;u<=a;++u){if(f=n[x(u)],f.skip)continue;const C=f.x,T=f.y,A=C|0;A===p?(T<_?_=T:T>m&&(m=T),h=(d*h+C)/++d):(E(),i.lineTo(C,T),p=A,d=0,_=m=T),y=T}E()}function bl(i){const t=i.options,e=t.borderDash&&t.borderDash.length;return!i._decimated&&!i._loop&&!t.tension&&t.cubicInterpolationMode!==\"monotone\"&&!t.stepped&&!e?KA:YA}function UA(i){return i.stepped?qC:i.tension||i.cubicInterpolationMode===\"monotone\"?ZC:wi}function XA(i,t,e,s){let n=t._path;n||(n=t._path=new Path2D,t.path(n,e,s)&&n.closePath()),Wf(i,t.options),i.stroke(n)}function GA(i,t,e,s){const{segments:n,options:o}=t,r=bl(t);for(const a of n)Wf(i,o,a.style),i.beginPath(),r(i,t,a,{start:e,end:e+s-1})&&i.closePath(),i.stroke()}const qA=typeof Path2D==\"function\";function ZA(i,t,e,s){qA&&!t.options.segment?XA(i,t,e,s):GA(i,t,e,s)}class Se extends jt{constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const s=this.options;if((s.tension||s.cubicInterpolationMode===\"monotone\")&&!s.stepped&&!this._pointsUpdated){const n=s.spanGaps?this._loop:this._fullLoop;WC(this._points,s,t,n,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=nT(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,s=t.length;return s&&e[t[s-1].end]}interpolate(t,e){const s=this.options,n=t[e],o=this.points,r=Uu(this,{property:e,start:n,end:n});if(!r.length)return;const a=[],l=UA(s);let c,h;for(c=0,h=r.length;c<h;++c){const{start:d,end:u}=r[c],f=o[d],p=o[u];if(f===p){a.push(f);continue}const _=Math.abs((n-f[e])/(p[e]-f[e])),m=l(f,p,_,s.stepped);m[e]=t[e],a.push(m)}return a.length===1?a[0]:a}pathSegment(t,e,s){return bl(this)(t,this,e,s)}path(t,e,s){const n=this.segments,o=bl(this);let r=this._loop;e=e||0,s=s||this.points.length-e;for(const a of n)r&=o(t,this,a,{start:e,end:e+s-1});return!!r}draw(t,e,s,n){const o=this.options||{};(this.points||[]).length&&o.borderWidth&&(t.save(),ZA(t,this,s,n),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}Se.id=\"line\",Se.defaults={borderCapStyle:\"butt\",borderDash:[],borderDashOffset:0,borderJoinStyle:\"miter\",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:\"default\",fill:!1,spanGaps:!1,stepped:!1,tension:0},Se.defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"},Se.descriptors={_scriptable:!0,_indexable:i=>i!==\"borderDash\"&&i!==\"fill\"};function jf(i,t,e,s){const n=i.options,{[e]:o}=i.getProps([e],s);return Math.abs(t-o)<n.radius+n.hitRadius}class ps extends jt{constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,s){const n=this.options,{x:o,y:r}=this.getProps([\"x\",\"y\"],s);return Math.pow(t-o,2)+Math.pow(e-r,2)<Math.pow(n.hitRadius+n.radius,2)}inXRange(t,e){return jf(this,t,\"x\",e)}inYRange(t,e){return jf(this,t,\"y\",e)}getCenterPoint(t){const{x:e,y:s}=this.getProps([\"x\",\"y\"],t);return{x:e,y:s}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const s=e&&t.borderWidth||0;return(e+s)*2}draw(t,e){const s=this.options;this.skip||s.radius<.1||!on(this,e,this.size(s)/2)||(t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.fillStyle=s.backgroundColor,Qa(t,s,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}ps.id=\"point\",ps.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:\"circle\",radius:3,rotation:0},ps.defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};function Yf(i,t){const{x:e,y:s,base:n,width:o,height:r}=i.getProps([\"x\",\"y\",\"base\",\"width\",\"height\"],t);let a,l,c,h,d;return i.horizontal?(d=r/2,a=Math.min(e,n),l=Math.max(e,n),c=s-d,h=s+d):(d=o/2,a=e-d,l=e+d,c=Math.min(s,n),h=Math.max(s,n)),{left:a,top:c,right:l,bottom:h}}function Je(i,t,e,s){return i?0:ct(t,e,s)}function QA(i,t,e){const s=i.options.borderWidth,n=i.borderSkipped,o=Ou(s);return{t:Je(n.top,o.top,0,e),r:Je(n.right,o.right,0,t),b:Je(n.bottom,o.bottom,0,e),l:Je(n.left,o.left,0,t)}}function JA(i,t,e){const{enableBorderRadius:s}=i.getProps([\"enableBorderRadius\"]),n=i.options.borderRadius,o=Ci(n),r=Math.min(t,e),a=i.borderSkipped,l=s||$(n);return{topLeft:Je(!l||a.top||a.left,o.topLeft,0,r),topRight:Je(!l||a.top||a.right,o.topRight,0,r),bottomLeft:Je(!l||a.bottom||a.left,o.bottomLeft,0,r),bottomRight:Je(!l||a.bottom||a.right,o.bottomRight,0,r)}}function tw(i){const t=Yf(i),e=t.right-t.left,s=t.bottom-t.top,n=QA(i,e/2,s/2),o=JA(i,e/2,s/2);return{outer:{x:t.left,y:t.top,w:e,h:s,radius:o},inner:{x:t.left+n.l,y:t.top+n.t,w:e-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,o.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,o.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,o.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,o.bottomRight-Math.max(n.b,n.r))}}}}function vl(i,t,e,s){const n=t===null,o=e===null,a=i&&!(n&&o)&&Yf(i,s);return a&&(n||Ae(t,a.left,a.right))&&(o||Ae(e,a.top,a.bottom))}function ew(i){return i.topLeft||i.topRight||i.bottomLeft||i.bottomRight}function iw(i,t){i.rect(t.x,t.y,t.w,t.h)}function yl(i,t,e={}){const s=i.x!==e.x?-t:0,n=i.y!==e.y?-t:0,o=(i.x+i.w!==e.x+e.w?t:0)-s,r=(i.y+i.h!==e.y+e.h?t:0)-n;return{x:i.x+s,y:i.y+n,w:i.w+o,h:i.h+r,radius:i.radius}}class _s extends jt{constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:s,backgroundColor:n}}=this,{inner:o,outer:r}=tw(this),a=ew(r.radius)?rn:iw;t.save(),(r.w!==o.w||r.h!==o.h)&&(t.beginPath(),a(t,yl(r,e,o)),t.clip(),a(t,yl(o,-e,r)),t.fillStyle=s,t.fill(\"evenodd\")),t.beginPath(),a(t,yl(o,e)),t.fillStyle=n,t.fill(),t.restore()}inRange(t,e,s){return vl(this,t,e,s)}inXRange(t,e){return vl(this,t,null,e)}inYRange(t,e){return vl(this,null,t,e)}getCenterPoint(t){const{x:e,y:s,base:n,horizontal:o}=this.getProps([\"x\",\"y\",\"base\",\"horizontal\"],t);return{x:o?(e+n)/2:e,y:o?s:(s+n)/2}}getRange(t){return t===\"x\"?this.width/2:this.height/2}}_s.id=\"bar\",_s.defaults={borderSkipped:\"start\",borderWidth:0,borderRadius:0,inflateAmount:\"auto\",pointStyle:void 0},_s.defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};var Kf=Object.freeze({__proto__:null,ArcElement:fs,LineElement:Se,PointElement:ps,BarElement:_s});function sw(i,t,e,s,n){const o=n.samples||s;if(o>=e)return i.slice(t,t+e);const r=[],a=(e-2)/(o-2);let l=0;const c=t+e-1;let h=t,d,u,f,p,_;for(r[l++]=i[h],d=0;d<o-2;d++){let m=0,y=0,x;const E=Math.floor((d+1)*a)+1+t,C=Math.min(Math.floor((d+2)*a)+1,e)+t,T=C-E;for(x=E;x<C;x++)m+=i[x].x,y+=i[x].y;m/=T,y/=T;const A=Math.floor(d*a)+1+t,w=Math.min(Math.floor((d+1)*a)+1,e)+t,{x:S,y:k}=i[h];for(f=p=-1,x=A;x<w;x++)p=.5*Math.abs((S-m)*(i[x].y-k)-(S-i[x].x)*(y-k)),p>f&&(f=p,u=i[x],_=x);r[l++]=u,h=_}return r[l++]=i[c],r}function nw(i,t,e,s){let n=0,o=0,r,a,l,c,h,d,u,f,p,_;const m=[],y=t+e-1,x=i[t].x,C=i[y].x-x;for(r=t;r<t+e;++r){a=i[r],l=(a.x-x)/C*s,c=a.y;const T=l|0;if(T===h)c<p?(p=c,d=r):c>_&&(_=c,u=r),n=(o*n+a.x)/++o;else{const A=r-1;if(!N(d)&&!N(u)){const w=Math.min(d,u),S=Math.max(d,u);w!==f&&w!==A&&m.push({...i[w],x:n}),S!==f&&S!==A&&m.push({...i[S],x:n})}r>0&&A!==f&&m.push(i[A]),m.push(a),h=T,o=0,p=_=c,d=u=f=r}}return m}function Uf(i){if(i._decimated){const t=i._data;delete i._decimated,delete i._data,Object.defineProperty(i,\"data\",{value:t})}}function Xf(i){i.data.datasets.forEach(t=>{Uf(t)})}function ow(i,t){const e=t.length;let s=0,n;const{iScale:o}=i,{min:r,max:a,minDefined:l,maxDefined:c}=o.getUserBounds();return l&&(s=ct(we(t,o.axis,r).lo,0,e-1)),c?n=ct(we(t,o.axis,a).hi+1,s,e)-s:n=e-s,{start:s,count:n}}var Gf={id:\"decimation\",defaults:{algorithm:\"min-max\",enabled:!1},beforeElementsUpdate:(i,t,e)=>{if(!e.enabled){Xf(i);return}const s=i.width;i.data.datasets.forEach((n,o)=>{const{_data:r,indexAxis:a}=n,l=i.getDatasetMeta(o),c=r||n.data;if(tt([a,i.options.indexAxis])===\"y\"||!l.controller.supportsDecimation)return;const h=i.scales[l.xAxisID];if(h.type!==\"linear\"&&h.type!==\"time\"||i.options.parsing)return;let{start:d,count:u}=ow(l,c);const f=e.threshold||4*s;if(u<=f){Uf(n);return}N(r)&&(n._data=c,delete n.data,Object.defineProperty(n,\"data\",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(_){this._data=_}}));let p;switch(e.algorithm){case\"lttb\":p=sw(c,d,u,s,e);break;case\"min-max\":p=nw(c,d,u,s);break;default:throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`)}n._decimated=p})},destroy(i){Xf(i)}};function rw(i,t,e){const s=i.segments,n=i.points,o=t.points,r=[];for(const a of s){let{start:l,end:c}=a;c=El(l,c,n);const h=xl(e,n[l],n[c],a.loop);if(!t.segments){r.push({source:a,target:h,start:n[l],end:n[c]});continue}const d=Uu(t,h);for(const u of d){const f=xl(e,o[u.start],o[u.end],u.loop),p=Ku(a,n,f);for(const _ of p)r.push({source:_,target:u,start:{[e]:qf(h,f,\"start\",Math.max)},end:{[e]:qf(h,f,\"end\",Math.min)}})}}return r}function xl(i,t,e,s){if(s)return;let n=t[i],o=e[i];return i===\"angle\"&&(n=Nt(n),o=Nt(o)),{property:i,start:n,end:o}}function aw(i,t){const{x:e=null,y:s=null}=i||{},n=t.points,o=[];return t.segments.forEach(({start:r,end:a})=>{a=El(r,a,n);const l=n[r],c=n[a];s!==null?(o.push({x:l.x,y:s}),o.push({x:c.x,y:s})):e!==null&&(o.push({x:e,y:l.y}),o.push({x:e,y:c.y}))}),o}function El(i,t,e){for(;t>i;t--){const s=e[t];if(!isNaN(s.x)&&!isNaN(s.y))break}return t}function qf(i,t,e,s){return i&&t?s(i[e],t[e]):i?i[e]:t?t[e]:0}function Zf(i,t){let e=[],s=!1;return Q(i)?(s=!0,e=i):e=aw(i,t),e.length?new Se({points:e,options:{tension:0},_loop:s,_fullLoop:s}):null}function Qf(i){return i&&i.fill!==!1}function lw(i,t,e){let n=i[t].fill;const o=[t];let r;if(!e)return n;for(;n!==!1&&o.indexOf(n)===-1;){if(!rt(n))return n;if(r=i[n],!r)return!1;if(r.visible)return n;o.push(n),n=r.fill}return!1}function cw(i,t,e){const s=fw(i);if($(s))return isNaN(s.value)?!1:s;let n=parseFloat(s);return rt(n)&&Math.floor(n)===n?hw(s[0],t,n,e):[\"origin\",\"start\",\"end\",\"stack\",\"shape\"].indexOf(s)>=0&&s}function hw(i,t,e,s){return(i===\"-\"||i===\"+\")&&(e=t+e),e===t||e<0||e>=s?!1:e}function dw(i,t){let e=null;return i===\"start\"?e=t.bottom:i===\"end\"?e=t.top:$(i)?e=t.getPixelForValue(i.value):t.getBasePixel&&(e=t.getBasePixel()),e}function uw(i,t,e){let s;return i===\"start\"?s=e:i===\"end\"?s=t.options.reverse?t.min:t.max:$(i)?s=i.value:s=t.getBaseValue(),s}function fw(i){const t=i.options,e=t.fill;let s=R(e&&e.target,e);return s===void 0&&(s=!!t.backgroundColor),s===!1||s===null?!1:s===!0?\"origin\":s}function pw(i){const{scale:t,index:e,line:s}=i,n=[],o=s.segments,r=s.points,a=_w(t,e);a.push(Zf({x:null,y:t.bottom},s));for(let l=0;l<o.length;l++){const c=o[l];for(let h=c.start;h<=c.end;h++)gw(n,r[h],a)}return new Se({points:n,options:{}})}function _w(i,t){const e=[],s=i.getMatchingVisibleMetas(\"line\");for(let n=0;n<s.length;n++){const o=s[n];if(o.index===t)break;o.hidden||e.unshift(o.dataset)}return e}function gw(i,t,e){const s=[];for(let n=0;n<e.length;n++){const o=e[n],{first:r,last:a,point:l}=mw(o,t,\"x\");if(!(!l||r&&a)){if(r)s.unshift(l);else if(i.push(l),!a)break}}i.push(...s)}function mw(i,t,e){const s=i.interpolate(t,e);if(!s)return{};const n=s[e],o=i.segments,r=i.points;let a=!1,l=!1;for(let c=0;c<o.length;c++){const h=o[c],d=r[h.start][e],u=r[h.end][e];if(Ae(n,d,u)){a=n===d,l=n===u;break}}return{first:a,last:l,point:s}}class Jf{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,s){const{x:n,y:o,radius:r}=this;return e=e||{start:0,end:q},t.arc(n,o,r,e.end,e.start,!0),!s.bounds}interpolate(t){const{x:e,y:s,radius:n}=this,o=t.angle;return{x:e+Math.cos(o)*n,y:s+Math.sin(o)*n,angle:o}}}function bw(i){const{chart:t,fill:e,line:s}=i;if(rt(e))return vw(t,e);if(e===\"stack\")return pw(i);if(e===\"shape\")return!0;const n=yw(i);return n instanceof Jf?n:Zf(n,s)}function vw(i,t){const e=i.getDatasetMeta(t);return e&&i.isDatasetVisible(t)?e.dataset:null}function yw(i){return(i.scale||{}).getPointPositionForValue?Ew(i):xw(i)}function xw(i){const{scale:t={},fill:e}=i,s=dw(e,t);if(rt(s)){const n=t.isHorizontal();return{x:n?s:null,y:n?null:s}}return null}function Ew(i){const{scale:t,fill:e}=i,s=t.options,n=t.getLabels().length,o=s.reverse?t.max:t.min,r=uw(e,t,o),a=[];if(s.grid.circular){const l=t.getPointPositionForValue(0,o);return new Jf({x:l.x,y:l.y,radius:t.getDistanceFromCenterForValue(r)})}for(let l=0;l<n;++l)a.push(t.getPointPositionForValue(l,r));return a}function Cl(i,t,e){const s=bw(t),{line:n,scale:o,axis:r}=t,a=n.options,l=a.fill,c=a.backgroundColor,{above:h=c,below:d=c}=l||{};s&&n.points.length&&(Ko(i,e),Cw(i,{line:n,target:s,above:h,below:d,area:e,scale:o,axis:r}),Uo(i))}function Cw(i,t){const{line:e,target:s,above:n,below:o,area:r,scale:a}=t,l=e._loop?\"angle\":t.axis;i.save(),l===\"x\"&&o!==n&&(tp(i,s,r.top),ep(i,{line:e,target:s,color:n,scale:a,property:l}),i.restore(),i.save(),tp(i,s,r.bottom)),ep(i,{line:e,target:s,color:o,scale:a,property:l}),i.restore()}function tp(i,t,e){const{segments:s,points:n}=t;let o=!0,r=!1;i.beginPath();for(const a of s){const{start:l,end:c}=a,h=n[l],d=n[El(l,c,n)];o?(i.moveTo(h.x,h.y),o=!1):(i.lineTo(h.x,e),i.lineTo(h.x,h.y)),r=!!t.pathSegment(i,a,{move:r}),r?i.closePath():i.lineTo(d.x,e)}i.lineTo(t.first().x,e),i.closePath(),i.clip()}function ep(i,t){const{line:e,target:s,property:n,color:o,scale:r}=t,a=rw(e,s,n);for(const{source:l,target:c,start:h,end:d}of a){const{style:{backgroundColor:u=o}={}}=l,f=s!==!0;i.save(),i.fillStyle=u,Tw(i,r,f&&xl(n,h,d)),i.beginPath();const p=!!e.pathSegment(i,l);let _;if(f){p?i.closePath():ip(i,s,d,n);const m=!!s.pathSegment(i,c,{move:p,reverse:!0});_=p&&m,_||ip(i,s,h,n)}i.closePath(),i.fill(_?\"evenodd\":\"nonzero\"),i.restore()}}function Tw(i,t,e){const{top:s,bottom:n}=t.chart.chartArea,{property:o,start:r,end:a}=e||{};o===\"x\"&&(i.beginPath(),i.rect(r,s,a-r,n-s),i.clip())}function ip(i,t,e,s){const n=t.interpolate(e,s);n&&i.lineTo(n.x,n.y)}var sp={id:\"filler\",afterDatasetsUpdate(i,t,e){const s=(i.data.datasets||[]).length,n=[];let o,r,a,l;for(r=0;r<s;++r)o=i.getDatasetMeta(r),a=o.dataset,l=null,a&&a.options&&a instanceof Se&&(l={visible:i.isDatasetVisible(r),index:r,fill:cw(a,r,s),chart:i,axis:o.controller.options.indexAxis,scale:o.vScale,line:a}),o.$filler=l,n.push(l);for(r=0;r<s;++r)l=n[r],!(!l||l.fill===!1)&&(l.fill=lw(n,r,e.propagate))},beforeDraw(i,t,e){const s=e.drawTime===\"beforeDraw\",n=i.getSortedVisibleDatasetMetas(),o=i.chartArea;for(let r=n.length-1;r>=0;--r){const a=n[r].$filler;a&&(a.line.updateControlPoints(o,a.axis),s&&a.fill&&Cl(i.ctx,a,o))}},beforeDatasetsDraw(i,t,e){if(e.drawTime!==\"beforeDatasetsDraw\")return;const s=i.getSortedVisibleDatasetMetas();for(let n=s.length-1;n>=0;--n){const o=s[n].$filler;Qf(o)&&Cl(i.ctx,o,i.chartArea)}},beforeDatasetDraw(i,t,e){const s=t.meta.$filler;!Qf(s)||e.drawTime!==\"beforeDatasetDraw\"||Cl(i.ctx,s,i.chartArea)},defaults:{propagate:!0,drawTime:\"beforeDatasetDraw\"}};const np=(i,t)=>{let{boxHeight:e=t,boxWidth:s=t}=i;return i.usePointStyle&&(e=Math.min(e,t),s=i.pointStyleWidth||Math.min(s,t)),{boxWidth:s,boxHeight:e,itemHeight:Math.max(t,e)}},Aw=(i,t)=>i!==null&&t!==null&&i.datasetIndex===t.datasetIndex&&i.index===t.index;class op extends jt{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,s){this.maxWidth=t,this.maxHeight=e,this._margins=s,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=G(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter(s=>t.filter(s,this.chart.data))),t.sort&&(e=e.sort((s,n)=>t.sort(s,n,this.chart.data))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const s=t.labels,n=lt(s.font),o=n.size,r=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=np(s,o);let c,h;e.font=n.string,this.isHorizontal()?(c=this.maxWidth,h=this._fitRows(r,o,a,l)+10):(h=this.maxHeight,c=this._fitCols(r,o,a,l)+10),this.width=Math.min(c,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,s,n){const{ctx:o,maxWidth:r,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],h=n+a;let d=t;o.textAlign=\"left\",o.textBaseline=\"middle\";let u=-1,f=-h;return this.legendItems.forEach((p,_)=>{const m=s+e/2+o.measureText(p.text).width;(_===0||c[c.length-1]+m+2*a>r)&&(d+=h,c[c.length-(_>0?0:1)]=0,f+=h,u++),l[_]={left:0,top:f,row:u,width:m,height:n},c[c.length-1]+=m+a}),d}_fitCols(t,e,s,n){const{ctx:o,maxHeight:r,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],h=r-t;let d=a,u=0,f=0,p=0,_=0;return this.legendItems.forEach((m,y)=>{const x=s+e/2+o.measureText(m.text).width;y>0&&f+n+2*a>h&&(d+=u+a,c.push({width:u,height:f}),p+=u+a,_++,u=f=0),l[y]={left:p,top:f,col:_,width:x,height:n},u=Math.max(u,x),f+=n+a}),d+=u,c.push({width:u,height:f}),d}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:s,labels:{padding:n},rtl:o}}=this,r=ds(o,this.left,this.width);if(this.isHorizontal()){let a=0,l=pt(s,this.left+n,this.right-this.lineWidths[a]);for(const c of e)a!==c.row&&(a=c.row,l=pt(s,this.left+n,this.right-this.lineWidths[a])),c.top+=this.top+t+n,c.left=r.leftForLtr(r.x(l),c.width),l+=c.width+n}else{let a=0,l=pt(s,this.top+t+n,this.bottom-this.columnSizes[a].height);for(const c of e)c.col!==a&&(a=c.col,l=pt(s,this.top+t+n,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+n,c.left=r.leftForLtr(r.x(c.left),c.width),l+=c.height+n}}isHorizontal(){return this.options.position===\"top\"||this.options.position===\"bottom\"}draw(){if(this.options.display){const t=this.ctx;Ko(t,this),this._draw(),Uo(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:s,ctx:n}=this,{align:o,labels:r}=t,a=B.color,l=ds(t.rtl,this.left,this.width),c=lt(r.font),{color:h,padding:d}=r,u=c.size,f=u/2;let p;this.drawTitle(),n.textAlign=l.textAlign(\"left\"),n.textBaseline=\"middle\",n.lineWidth=.5,n.font=c.string;const{boxWidth:_,boxHeight:m,itemHeight:y}=np(r,u),x=function(w,S,k){if(isNaN(_)||_<=0||isNaN(m)||m<0)return;n.save();const D=R(k.lineWidth,1);if(n.fillStyle=R(k.fillStyle,a),n.lineCap=R(k.lineCap,\"butt\"),n.lineDashOffset=R(k.lineDashOffset,0),n.lineJoin=R(k.lineJoin,\"miter\"),n.lineWidth=D,n.strokeStyle=R(k.strokeStyle,a),n.setLineDash(R(k.lineDash,[])),r.usePointStyle){const O={radius:m*Math.SQRT2/2,pointStyle:k.pointStyle,rotation:k.rotation,borderWidth:D},M=l.xPlus(w,_/2),L=S+f;Su(n,O,M,L,r.pointStyleWidth&&_)}else{const O=S+Math.max((u-m)/2,0),M=l.leftForLtr(w,_),L=Ci(k.borderRadius);n.beginPath(),Object.values(L).some(X=>X!==0)?rn(n,{x:M,y:O,w:_,h:m,radius:L}):n.rect(M,O,_,m),n.fill(),D!==0&&n.stroke()}n.restore()},E=function(w,S,k){Ei(n,k.text,w,S+y/2,c,{strikethrough:k.hidden,textAlign:l.textAlign(k.textAlign)})},C=this.isHorizontal(),T=this._computeTitleHeight();C?p={x:pt(o,this.left+d,this.right-s[0]),y:this.top+d+T,line:0}:p={x:this.left+d,y:pt(o,this.top+T+d,this.bottom-e[0].height),line:0},Wu(this.ctx,t.textDirection);const A=y+d;this.legendItems.forEach((w,S)=>{n.strokeStyle=w.fontColor||h,n.fillStyle=w.fontColor||h;const k=n.measureText(w.text).width,D=l.textAlign(w.textAlign||(w.textAlign=r.textAlign)),O=_+f+k;let M=p.x,L=p.y;l.setWidth(this.width),C?S>0&&M+O+d>this.right&&(L=p.y+=A,p.line++,M=p.x=pt(o,this.left+d,this.right-s[p.line])):S>0&&L+A>this.bottom&&(M=p.x=M+e[p.line].width+d,p.line++,L=p.y=pt(o,this.top+T+d,this.bottom-e[p.line].height));const X=l.x(M);x(X,L,w),M=KE(D,M+_+f,C?M+O:this.right,t.rtl),E(l.x(M),L,w),C?p.x+=O+d:p.y+=A}),zu(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,s=lt(e.font),n=ht(e.padding);if(!e.display)return;const o=ds(t.rtl,this.left,this.width),r=this.ctx,a=e.position,l=s.size/2,c=n.top+l;let h,d=this.left,u=this.width;if(this.isHorizontal())u=Math.max(...this.lineWidths),h=this.top+c,d=pt(t.align,d,this.right-u);else{const p=this.columnSizes.reduce((_,m)=>Math.max(_,m.height),0);h=c+pt(t.align,this.top,this.bottom-p-t.labels.padding-this._computeTitleHeight())}const f=pt(a,d,d+u);r.textAlign=o.textAlign(za(a)),r.textBaseline=\"middle\",r.strokeStyle=e.color,r.fillStyle=e.color,r.font=s.string,Ei(r,e.text,f,h,s)}_computeTitleHeight(){const t=this.options.title,e=lt(t.font),s=ht(t.padding);return t.display?e.lineHeight+s.height:0}_getLegendItemAt(t,e){let s,n,o;if(Ae(t,this.left,this.right)&&Ae(e,this.top,this.bottom)){for(o=this.legendHitBoxes,s=0;s<o.length;++s)if(n=o[s],Ae(t,n.left,n.left+n.width)&&Ae(e,n.top,n.top+n.height))return this.legendItems[s]}return null}handleEvent(t){const e=this.options;if(!ww(t.type,e))return;const s=this._getLegendItemAt(t.x,t.y);if(t.type===\"mousemove\"||t.type===\"mouseout\"){const n=this._hoveredItem,o=Aw(n,s);n&&!o&&G(e.onLeave,[t,n,this],this),this._hoveredItem=s,s&&!o&&G(e.onHover,[t,s,this],this)}else s&&G(e.onClick,[t,s,this],this)}}function ww(i,t){return!!((i===\"mousemove\"||i===\"mouseout\")&&(t.onHover||t.onLeave)||t.onClick&&(i===\"click\"||i===\"mouseup\"))}var rp={id:\"legend\",_element:op,start(i,t,e){const s=i.legend=new op({ctx:i.ctx,options:e,chart:i});dt.configure(i,s,e),dt.addBox(i,s)},stop(i){dt.removeBox(i,i.legend),delete i.legend},beforeUpdate(i,t,e){const s=i.legend;dt.configure(i,s,e),s.options=e},afterUpdate(i){const t=i.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(i,t){t.replay||i.legend.handleEvent(t.event)},defaults:{display:!0,position:\"top\",align:\"center\",fullSize:!0,reverse:!1,weight:1e3,onClick(i,t,e){const s=t.datasetIndex,n=e.chart;n.isDatasetVisible(s)?(n.hide(s),t.hidden=!0):(n.show(s),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:i=>i.chart.options.color,boxWidth:40,padding:10,generateLabels(i){const t=i.data.datasets,{labels:{usePointStyle:e,pointStyle:s,textAlign:n,color:o}}=i.legend.options;return i._getSortedDatasetMetas().map(r=>{const a=r.controller.getStyle(e?0:void 0),l=ht(a.borderWidth);return{text:t[r.index].label,fillStyle:a.backgroundColor,fontColor:o,hidden:!r.visible,lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:a.borderColor,pointStyle:s||a.pointStyle,rotation:a.rotation,textAlign:n||a.textAlign,borderRadius:0,datasetIndex:r.index}},this)}},title:{color:i=>i.chart.options.color,display:!1,position:\"center\",text:\"\"}},descriptors:{_scriptable:i=>!i.startsWith(\"on\"),labels:{_scriptable:i=>![\"generateLabels\",\"filter\",\"sort\"].includes(i)}}};class Tl extends jt{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const s=this.options;if(this.left=0,this.top=0,!s.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=t,this.height=this.bottom=e;const n=Q(s.text)?s.text.length:1;this._padding=ht(s.padding);const o=n*lt(s.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=o:this.width=o}isHorizontal(){const t=this.options.position;return t===\"top\"||t===\"bottom\"}_drawArgs(t){const{top:e,left:s,bottom:n,right:o,options:r}=this,a=r.align;let l=0,c,h,d;return this.isHorizontal()?(h=pt(a,s,o),d=e+t,c=o-s):(r.position===\"left\"?(h=s+t,d=pt(a,n,e),l=et*-.5):(h=o-t,d=pt(a,e,n),l=et*.5),c=n-e),{titleX:h,titleY:d,maxWidth:c,rotation:l}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const s=lt(e.font),o=s.lineHeight/2+this._padding.top,{titleX:r,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(o);Ei(t,e.text,0,0,s,{color:e.color,maxWidth:l,rotation:c,textAlign:za(e.align),textBaseline:\"middle\",translation:[r,a]})}}function kw(i,t){const e=new Tl({ctx:i.ctx,options:t,chart:i});dt.configure(i,e,t),dt.addBox(i,e),i.titleBlock=e}var ap={id:\"title\",_element:Tl,start(i,t,e){kw(i,e)},stop(i){const t=i.titleBlock;dt.removeBox(i,t),delete i.titleBlock},beforeUpdate(i,t,e){const s=i.titleBlock;dt.configure(i,s,e),s.options=e},defaults:{align:\"center\",display:!1,font:{weight:\"bold\"},fullSize:!0,padding:10,position:\"top\",text:\"\",weight:2e3},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const or=new WeakMap;var lp={id:\"subtitle\",start(i,t,e){const s=new Tl({ctx:i.ctx,options:e,chart:i});dt.configure(i,s,e),dt.addBox(i,s),or.set(i,s)},stop(i){dt.removeBox(i,or.get(i)),or.delete(i)},beforeUpdate(i,t,e){const s=or.get(i);dt.configure(i,s,e),s.options=e},defaults:{align:\"center\",display:!1,font:{weight:\"normal\"},fullSize:!0,padding:0,position:\"top\",text:\"\",weight:1500},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const Cn={average(i){if(!i.length)return!1;let t,e,s=0,n=0,o=0;for(t=0,e=i.length;t<e;++t){const r=i[t].element;if(r&&r.hasValue()){const a=r.tooltipPosition();s+=a.x,n+=a.y,++o}}return{x:s/o,y:n/o}},nearest(i,t){if(!i.length)return!1;let e=t.x,s=t.y,n=Number.POSITIVE_INFINITY,o,r,a;for(o=0,r=i.length;o<r;++o){const l=i[o].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),h=Va(t,c);h<n&&(n=h,a=l)}}if(a){const l=a.tooltipPosition();e=l.x,s=l.y}return{x:e,y:s}}};function ve(i,t){return t&&(Q(t)?Array.prototype.push.apply(i,t):i.push(t)),i}function Oe(i){return(typeof i==\"string\"||i instanceof String)&&i.indexOf(`\n`)>-1?i.split(`\n`):i}function Sw(i,t){const{element:e,datasetIndex:s,index:n}=t,o=i.getDatasetMeta(s).controller,{label:r,value:a}=o.getLabelAndValue(n);return{chart:i,label:r,parsed:o.getParsed(n),raw:i.data.datasets[s].data[n],formattedValue:a,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:e}}function cp(i,t){const e=i.chart.ctx,{body:s,footer:n,title:o}=i,{boxWidth:r,boxHeight:a}=t,l=lt(t.bodyFont),c=lt(t.titleFont),h=lt(t.footerFont),d=o.length,u=n.length,f=s.length,p=ht(t.padding);let _=p.height,m=0,y=s.reduce((C,T)=>C+T.before.length+T.lines.length+T.after.length,0);if(y+=i.beforeBody.length+i.afterBody.length,d&&(_+=d*c.lineHeight+(d-1)*t.titleSpacing+t.titleMarginBottom),y){const C=t.displayColors?Math.max(a,l.lineHeight):l.lineHeight;_+=f*C+(y-f)*l.lineHeight+(y-1)*t.bodySpacing}u&&(_+=t.footerMarginTop+u*h.lineHeight+(u-1)*t.footerSpacing);let x=0;const E=function(C){m=Math.max(m,e.measureText(C).width+x)};return e.save(),e.font=c.string,U(i.title,E),e.font=l.string,U(i.beforeBody.concat(i.afterBody),E),x=t.displayColors?r+2+t.boxPadding:0,U(s,C=>{U(C.before,E),U(C.lines,E),U(C.after,E)}),x=0,e.font=h.string,U(i.footer,E),e.restore(),m+=p.width,{width:m,height:_}}function Ow(i,t){const{y:e,height:s}=t;return e<s/2?\"top\":e>i.height-s/2?\"bottom\":\"center\"}function Dw(i,t,e,s){const{x:n,width:o}=s,r=e.caretSize+e.caretPadding;if(i===\"left\"&&n+o+r>t.width||i===\"right\"&&n-o-r<0)return!0}function Mw(i,t,e,s){const{x:n,width:o}=e,{width:r,chartArea:{left:a,right:l}}=i;let c=\"center\";return s===\"center\"?c=n<=(a+l)/2?\"left\":\"right\":n<=o/2?c=\"left\":n>=r-o/2&&(c=\"right\"),Dw(c,i,t,e)&&(c=\"center\"),c}function hp(i,t,e){const s=e.yAlign||t.yAlign||Ow(i,e);return{xAlign:e.xAlign||t.xAlign||Mw(i,t,e,s),yAlign:s}}function Iw(i,t){let{x:e,width:s}=i;return t===\"right\"?e-=s:t===\"center\"&&(e-=s/2),e}function Lw(i,t,e){let{y:s,height:n}=i;return t===\"top\"?s+=e:t===\"bottom\"?s-=n+e:s-=n/2,s}function dp(i,t,e,s){const{caretSize:n,caretPadding:o,cornerRadius:r}=i,{xAlign:a,yAlign:l}=e,c=n+o,{topLeft:h,topRight:d,bottomLeft:u,bottomRight:f}=Ci(r);let p=Iw(t,a);const _=Lw(t,l,c);return l===\"center\"?a===\"left\"?p+=c:a===\"right\"&&(p-=c):a===\"left\"?p-=Math.max(h,u)+n:a===\"right\"&&(p+=Math.max(d,f)+n),{x:ct(p,0,s.width-t.width),y:ct(_,0,s.height-t.height)}}function rr(i,t,e){const s=ht(e.padding);return t===\"center\"?i.x+i.width/2:t===\"right\"?i.x+i.width-s.right:i.x+s.left}function up(i){return ve([],Oe(i))}function Pw(i,t,e){return qe(i,{tooltip:t,tooltipItems:e,type:\"tooltip\"})}function fp(i,t){const e=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return e?i.override(e):i}class Al extends jt{constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart||t._chart,this._chart=this.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,s=this.options.setContext(this.getContext()),n=s.enabled&&e.options.animation&&s.animations,o=new ol(this.chart,n);return n._cacheable&&(this._cachedAnimations=Object.freeze(o)),o}getContext(){return this.$context||(this.$context=Pw(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:s}=e,n=s.beforeTitle.apply(this,[t]),o=s.title.apply(this,[t]),r=s.afterTitle.apply(this,[t]);let a=[];return a=ve(a,Oe(n)),a=ve(a,Oe(o)),a=ve(a,Oe(r)),a}getBeforeBody(t,e){return up(e.callbacks.beforeBody.apply(this,[t]))}getBody(t,e){const{callbacks:s}=e,n=[];return U(t,o=>{const r={before:[],lines:[],after:[]},a=fp(s,o);ve(r.before,Oe(a.beforeLabel.call(this,o))),ve(r.lines,a.label.call(this,o)),ve(r.after,Oe(a.afterLabel.call(this,o))),n.push(r)}),n}getAfterBody(t,e){return up(e.callbacks.afterBody.apply(this,[t]))}getFooter(t,e){const{callbacks:s}=e,n=s.beforeFooter.apply(this,[t]),o=s.footer.apply(this,[t]),r=s.afterFooter.apply(this,[t]);let a=[];return a=ve(a,Oe(n)),a=ve(a,Oe(o)),a=ve(a,Oe(r)),a}_createItems(t){const e=this._active,s=this.chart.data,n=[],o=[],r=[];let a=[],l,c;for(l=0,c=e.length;l<c;++l)a.push(Sw(this.chart,e[l]));return t.filter&&(a=a.filter((h,d,u)=>t.filter(h,d,u,s))),t.itemSort&&(a=a.sort((h,d)=>t.itemSort(h,d,s))),U(a,h=>{const d=fp(t.callbacks,h);n.push(d.labelColor.call(this,h)),o.push(d.labelPointStyle.call(this,h)),r.push(d.labelTextColor.call(this,h))}),this.labelColors=n,this.labelPointStyles=o,this.labelTextColors=r,this.dataPoints=a,a}update(t,e){const s=this.options.setContext(this.getContext()),n=this._active;let o,r=[];if(!n.length)this.opacity!==0&&(o={opacity:0});else{const a=Cn[s.position].call(this,n,this._eventPosition);r=this._createItems(s),this.title=this.getTitle(r,s),this.beforeBody=this.getBeforeBody(r,s),this.body=this.getBody(r,s),this.afterBody=this.getAfterBody(r,s),this.footer=this.getFooter(r,s);const l=this._size=cp(this,s),c=Object.assign({},a,l),h=hp(this.chart,s,c),d=dp(s,c,h,this.chart);this.xAlign=h.xAlign,this.yAlign=h.yAlign,o={opacity:1,x:d.x,y:d.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=r,this.$context=void 0,o&&this._resolveAnimations().update(this,o),t&&s.external&&s.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,s,n){const o=this.getCaretPosition(t,s,n);e.lineTo(o.x1,o.y1),e.lineTo(o.x2,o.y2),e.lineTo(o.x3,o.y3)}getCaretPosition(t,e,s){const{xAlign:n,yAlign:o}=this,{caretSize:r,cornerRadius:a}=s,{topLeft:l,topRight:c,bottomLeft:h,bottomRight:d}=Ci(a),{x:u,y:f}=t,{width:p,height:_}=e;let m,y,x,E,C,T;return o===\"center\"?(C=f+_/2,n===\"left\"?(m=u,y=m-r,E=C+r,T=C-r):(m=u+p,y=m+r,E=C-r,T=C+r),x=m):(n===\"left\"?y=u+Math.max(l,h)+r:n===\"right\"?y=u+p-Math.max(c,d)-r:y=this.caretX,o===\"top\"?(E=f,C=E-r,m=y-r,x=y+r):(E=f+_,C=E+r,m=y+r,x=y-r),T=E),{x1:m,x2:y,x3:x,y1:E,y2:C,y3:T}}drawTitle(t,e,s){const n=this.title,o=n.length;let r,a,l;if(o){const c=ds(s.rtl,this.x,this.width);for(t.x=rr(this,s.titleAlign,s),e.textAlign=c.textAlign(s.titleAlign),e.textBaseline=\"middle\",r=lt(s.titleFont),a=s.titleSpacing,e.fillStyle=s.titleColor,e.font=r.string,l=0;l<o;++l)e.fillText(n[l],c.x(t.x),t.y+r.lineHeight/2),t.y+=r.lineHeight+a,l+1===o&&(t.y+=s.titleMarginBottom-a)}}_drawColorBox(t,e,s,n,o){const r=this.labelColors[s],a=this.labelPointStyles[s],{boxHeight:l,boxWidth:c,boxPadding:h}=o,d=lt(o.bodyFont),u=rr(this,\"left\",o),f=n.x(u),p=l<d.lineHeight?(d.lineHeight-l)/2:0,_=e.y+p;if(o.usePointStyle){const m={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=n.leftForLtr(f,c)+c/2,x=_+l/2;t.strokeStyle=o.multiKeyBackground,t.fillStyle=o.multiKeyBackground,Qa(t,m,y,x),t.strokeStyle=r.borderColor,t.fillStyle=r.backgroundColor,Qa(t,m,y,x)}else{t.lineWidth=$(r.borderWidth)?Math.max(...Object.values(r.borderWidth)):r.borderWidth||1,t.strokeStyle=r.borderColor,t.setLineDash(r.borderDash||[]),t.lineDashOffset=r.borderDashOffset||0;const m=n.leftForLtr(f,c-h),y=n.leftForLtr(n.xPlus(f,1),c-h-2),x=Ci(r.borderRadius);Object.values(x).some(E=>E!==0)?(t.beginPath(),t.fillStyle=o.multiKeyBackground,rn(t,{x:m,y:_,w:c,h:l,radius:x}),t.fill(),t.stroke(),t.fillStyle=r.backgroundColor,t.beginPath(),rn(t,{x:y,y:_+1,w:c-2,h:l-2,radius:x}),t.fill()):(t.fillStyle=o.multiKeyBackground,t.fillRect(m,_,c,l),t.strokeRect(m,_,c,l),t.fillStyle=r.backgroundColor,t.fillRect(y,_+1,c-2,l-2))}t.fillStyle=this.labelTextColors[s]}drawBody(t,e,s){const{body:n}=this,{bodySpacing:o,bodyAlign:r,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:h}=s,d=lt(s.bodyFont);let u=d.lineHeight,f=0;const p=ds(s.rtl,this.x,this.width),_=function(S){e.fillText(S,p.x(t.x+f),t.y+u/2),t.y+=u+o},m=p.textAlign(r);let y,x,E,C,T,A,w;for(e.textAlign=r,e.textBaseline=\"middle\",e.font=d.string,t.x=rr(this,m,s),e.fillStyle=s.bodyColor,U(this.beforeBody,_),f=a&&m!==\"right\"?r===\"center\"?c/2+h:c+2+h:0,C=0,A=n.length;C<A;++C){for(y=n[C],x=this.labelTextColors[C],e.fillStyle=x,U(y.before,_),E=y.lines,a&&E.length&&(this._drawColorBox(e,t,C,p,s),u=Math.max(d.lineHeight,l)),T=0,w=E.length;T<w;++T)_(E[T]),u=d.lineHeight;U(y.after,_)}f=0,u=d.lineHeight,U(this.afterBody,_),t.y-=o}drawFooter(t,e,s){const n=this.footer,o=n.length;let r,a;if(o){const l=ds(s.rtl,this.x,this.width);for(t.x=rr(this,s.footerAlign,s),t.y+=s.footerMarginTop,e.textAlign=l.textAlign(s.footerAlign),e.textBaseline=\"middle\",r=lt(s.footerFont),e.fillStyle=s.footerColor,e.font=r.string,a=0;a<o;++a)e.fillText(n[a],l.x(t.x),t.y+r.lineHeight/2),t.y+=r.lineHeight+s.footerSpacing}}drawBackground(t,e,s,n){const{xAlign:o,yAlign:r}=this,{x:a,y:l}=t,{width:c,height:h}=s,{topLeft:d,topRight:u,bottomLeft:f,bottomRight:p}=Ci(n.cornerRadius);e.fillStyle=n.backgroundColor,e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.beginPath(),e.moveTo(a+d,l),r===\"top\"&&this.drawCaret(t,e,s,n),e.lineTo(a+c-u,l),e.quadraticCurveTo(a+c,l,a+c,l+u),r===\"center\"&&o===\"right\"&&this.drawCaret(t,e,s,n),e.lineTo(a+c,l+h-p),e.quadraticCurveTo(a+c,l+h,a+c-p,l+h),r===\"bottom\"&&this.drawCaret(t,e,s,n),e.lineTo(a+f,l+h),e.quadraticCurveTo(a,l+h,a,l+h-f),r===\"center\"&&o===\"left\"&&this.drawCaret(t,e,s,n),e.lineTo(a,l+d),e.quadraticCurveTo(a,l,a+d,l),e.closePath(),e.fill(),n.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,s=this.$animations,n=s&&s.x,o=s&&s.y;if(n||o){const r=Cn[t.position].call(this,this._active,this._eventPosition);if(!r)return;const a=this._size=cp(this,t),l=Object.assign({},r,this._size),c=hp(e,t,l),h=dp(t,l,c,e);(n._to!==h.x||o._to!==h.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=r.x,this.caretY=r.y,this._resolveAnimations().update(this,h))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let s=this.opacity;if(!s)return;this._updateAnimationTarget(e);const n={width:this.width,height:this.height},o={x:this.x,y:this.y};s=Math.abs(s)<.001?0:s;const r=ht(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=s,this.drawBackground(o,t,n,e),Wu(t,e.textDirection),o.y+=r.top,this.drawTitle(o,t,e),this.drawBody(o,t,e),this.drawFooter(o,t,e),zu(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const s=this._active,n=t.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error(\"Cannot find a dataset at index \"+a);return{datasetIndex:a,element:c.data[l],index:l}}),o=!$o(s,n),r=this._positionChanged(n,e);(o||r)&&(this._active=n,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,s=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const n=this.options,o=this._active||[],r=this._getActiveElements(t,o,e,s),a=this._positionChanged(r,t),l=e||!$o(r,o)||a;return l&&(this._active=r,(n.enabled||n.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),l}_getActiveElements(t,e,s,n){const o=this.options;if(t.type===\"mouseout\")return[];if(!n)return e;const r=this.chart.getElementsAtEventForMode(t,o.mode,o,s);return o.reverse&&r.reverse(),r}_positionChanged(t,e){const{caretX:s,caretY:n,options:o}=this,r=Cn[o.position].call(this,t,e);return r!==!1&&(s!==r.x||n!==r.y)}}Al.positioners=Cn;var pp={id:\"tooltip\",_element:Al,positioners:Cn,afterInit(i,t,e){e&&(i.tooltip=new Al({chart:i,options:e}))},beforeUpdate(i,t,e){i.tooltip&&i.tooltip.initialize(e)},reset(i,t,e){i.tooltip&&i.tooltip.initialize(e)},afterDraw(i){const t=i.tooltip;if(t&&t._willRender()){const e={tooltip:t};if(i.notifyPlugins(\"beforeTooltipDraw\",e)===!1)return;t.draw(i.ctx),i.notifyPlugins(\"afterTooltipDraw\",e)}},afterEvent(i,t){if(i.tooltip){const e=t.replay;i.tooltip.handleEvent(t.event,e,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:\"average\",backgroundColor:\"rgba(0,0,0,0.8)\",titleColor:\"#fff\",titleFont:{weight:\"bold\"},titleSpacing:2,titleMarginBottom:6,titleAlign:\"left\",bodyColor:\"#fff\",bodySpacing:2,bodyFont:{},bodyAlign:\"left\",footerColor:\"#fff\",footerSpacing:2,footerMarginTop:6,footerFont:{weight:\"bold\"},footerAlign:\"left\",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(i,t)=>t.bodyFont.size,boxWidth:(i,t)=>t.bodyFont.size,multiKeyBackground:\"#fff\",displayColors:!0,boxPadding:0,borderColor:\"rgba(0,0,0,0)\",borderWidth:0,animation:{duration:400,easing:\"easeOutQuart\"},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"width\",\"height\",\"caretX\",\"caretY\"]},opacity:{easing:\"linear\",duration:200}},callbacks:{beforeTitle:Te,title(i){if(i.length>0){const t=i[0],e=t.chart.data.labels,s=e?e.length:0;if(this&&this.options&&this.options.mode===\"dataset\")return t.dataset.label||\"\";if(t.label)return t.label;if(s>0&&t.dataIndex<s)return e[t.dataIndex]}return\"\"},afterTitle:Te,beforeBody:Te,beforeLabel:Te,label(i){if(this&&this.options&&this.options.mode===\"dataset\")return i.label+\": \"+i.formattedValue||i.formattedValue;let t=i.dataset.label||\"\";t&&(t+=\": \");const e=i.formattedValue;return N(e)||(t+=e),t},labelColor(i){const e=i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(i){const e=i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Te,afterBody:Te,beforeFooter:Te,footer:Te,afterFooter:Te}},defaultRoutes:{bodyFont:\"font\",footerFont:\"font\",titleFont:\"font\"},descriptors:{_scriptable:i=>i!==\"filter\"&&i!==\"itemSort\"&&i!==\"external\",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:\"animation\"}},additionalOptionScopes:[\"interaction\"]},_p=Object.freeze({__proto__:null,Decimation:Gf,Filler:sp,Legend:rp,SubTitle:lp,Title:ap,Tooltip:pp});const Rw=(i,t,e,s)=>(typeof t==\"string\"?(e=i.push(t)-1,s.unshift({index:e,label:t})):isNaN(t)&&(e=null),e);function Nw(i,t,e,s){const n=i.indexOf(t);if(n===-1)return Rw(i,t,e,s);const o=i.lastIndexOf(t);return n!==o?e:n}const $w=(i,t)=>i===null?null:ct(Math.round(i),0,t);class Tn extends Ze{constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const s=this.getLabels();for(const{index:n,label:o}of e)s[n]===o&&s.splice(n,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(N(t))return null;const s=this.getLabels();return e=isFinite(e)&&s[e]===t?e:Nw(s,t,R(e,t),this._addedLabels),$w(e,s.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:s,max:n}=this.getMinMax(!0);this.options.bounds===\"ticks\"&&(t||(s=0),e||(n=this.getLabels().length-1)),this.min=s,this.max=n}buildTicks(){const t=this.min,e=this.max,s=this.options.offset,n=[];let o=this.getLabels();o=t===0&&e===o.length-1?o:o.slice(t,e+1),this._valueRange=Math.max(o.length-(s?0:1),1),this._startValue=this.min-(s?.5:0);for(let r=t;r<=e;r++)n.push({value:r});return n}getLabelForValue(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return typeof t!=\"number\"&&(t=this.parse(t)),t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}Tn.id=\"category\",Tn.defaults={ticks:{callback:Tn.prototype.getLabelForValue}};function Bw(i,t){const e=[],{bounds:n,step:o,min:r,max:a,precision:l,count:c,maxTicks:h,maxDigits:d,includeBounds:u}=i,f=o||1,p=h-1,{min:_,max:m}=t,y=!N(r),x=!N(a),E=!N(c),C=(m-_)/(d+1);let T=nu((m-_)/p/f)*f,A,w,S,k;if(T<1e-14&&!y&&!x)return[{value:_},{value:m}];k=Math.ceil(m/T)-Math.floor(_/T),k>p&&(T=nu(k*T/p/f)*f),N(l)||(A=Math.pow(10,l),T=Math.ceil(T*A)/A),n===\"ticks\"?(w=Math.floor(_/T)*T,S=Math.ceil(m/T)*T):(w=_,S=m),y&&x&&o&&HE((a-r)/o,T/1e3)?(k=Math.round(Math.min((a-r)/T,h)),T=(a-r)/k,w=r,S=a):E?(w=y?r:w,S=x?a:S,k=c-1,T=(S-w)/k):(k=(S-w)/T,Qs(k,Math.round(k),T/1e3)?k=Math.round(k):k=Math.ceil(k));const D=Math.max(ru(T),ru(w));A=Math.pow(10,N(l)?D:l),w=Math.round(w*A)/A,S=Math.round(S*A)/A;let O=0;for(y&&(u&&w!==r?(e.push({value:r}),w<r&&O++,Qs(Math.round((w+O*T)*A)/A,r,gp(r,C,i))&&O++):w<r&&O++);O<k;++O)e.push({value:Math.round((w+O*T)*A)/A});return x&&u&&S!==a?e.length&&Qs(e[e.length-1].value,a,gp(a,C,i))?e[e.length-1].value=a:e.push({value:a}):(!x||S===a)&&e.push({value:S}),e}function gp(i,t,{horizontal:e,minRotation:s}){const n=Jt(s),o=(e?Math.sin(n):Math.cos(n))||.001,r=.75*t*(\"\"+i).length;return Math.min(t/o,r)}class ar extends Ze{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return N(t)||(typeof t==\"number\"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:s}=this.getUserBounds();let{min:n,max:o}=this;const r=l=>n=e?n:l,a=l=>o=s?o:l;if(t){const l=me(n),c=me(o);l<0&&c<0?a(0):l>0&&c>0&&r(0)}if(n===o){let l=1;(o>=Number.MAX_SAFE_INTEGER||n<=Number.MIN_SAFE_INTEGER)&&(l=Math.abs(o*.05)),a(o+l),t||r(n-l)}this.min=n,this.max=o}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:s}=t,n;return s?(n=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,n>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${n} ticks. Limiting to 1000.`),n=1e3)):(n=this.computeTickLimit(),e=e||11),e&&(n=Math.min(e,n)),n}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let s=this.getTickLimit();s=Math.max(2,s);const n={maxTicks:s,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:e.includeBounds!==!1},o=this._range||this,r=Bw(n,o);return t.bounds===\"ticks\"&&ou(r,this,\"value\"),t.reverse?(r.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),r}configure(){const t=this.ticks;let e=this.min,s=this.max;if(super.configure(),this.options.offset&&t.length){const n=(s-e)/Math.max(t.length-1,1)/2;e-=n,s+=n}this._startValue=e,this._endValue=s,this._valueRange=s-e}getLabelForValue(t){return an(t,this.chart.options.locale,this.options.ticks.format)}}class lr extends ar{determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=rt(t)?t:0,this.max=rt(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,s=Jt(this.options.ticks.minRotation),n=(t?Math.sin(s):Math.cos(s))||.001,o=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,o.lineHeight/n))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}lr.id=\"linear\",lr.defaults={ticks:{callback:pn.formatters.numeric}};function mp(i){return i/Math.pow(10,Math.floor(Vt(i)))===1}function Hw(i,t){const e=Math.floor(Vt(t.max)),s=Math.ceil(t.max/Math.pow(10,e)),n=[];let o=Ht(i.min,Math.pow(10,Math.floor(Vt(t.min)))),r=Math.floor(Vt(o)),a=Math.floor(o/Math.pow(10,r)),l=r<0?Math.pow(10,Math.abs(r)):1;do n.push({value:o,major:mp(o)}),++a,a===10&&(a=1,++r,l=r>=0?1:l),o=Math.round(a*Math.pow(10,r)*l)/l;while(r<e||r===e&&a<s);const c=Ht(i.max,o);return n.push({value:c,major:mp(o)}),n}class cr extends Ze{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const s=ar.prototype.parse.apply(this,[t,e]);if(s===0){this._zero=!0;return}return rt(s)&&s>0?s:null}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=rt(t)?Math.max(0,t):null,this.max=rt(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let s=this.min,n=this.max;const o=l=>s=t?s:l,r=l=>n=e?n:l,a=(l,c)=>Math.pow(10,Math.floor(Vt(l))+c);s===n&&(s<=0?(o(1),r(10)):(o(a(s,-1)),r(a(n,1)))),s<=0&&o(a(n,-1)),n<=0&&r(a(s,1)),this._zero&&this.min!==this._suggestedMin&&s===a(this.min,0)&&o(a(s,-1)),this.min=s,this.max=n}buildTicks(){const t=this.options,e={min:this._userMin,max:this._userMax},s=Hw(e,this);return t.bounds===\"ticks\"&&ou(s,this,\"value\"),t.reverse?(s.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),s}getLabelForValue(t){return t===void 0?\"0\":an(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=Vt(t),this._valueRange=Vt(this.max)-Vt(t)}getPixelForValue(t){return(t===void 0||t===0)&&(t=this.min),t===null||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(Vt(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}cr.id=\"logarithmic\",cr.defaults={ticks:{callback:pn.formatters.logarithmic,major:{enabled:!0}}};function wl(i){const t=i.ticks;if(t.display&&i.display){const e=ht(t.backdropPadding);return R(t.font&&t.font.size,B.font.size)+e.height}return 0}function Fw(i,t,e){return e=Q(e)?e:[e],{w:mC(i,t.string,e),h:e.length*t.lineHeight}}function bp(i,t,e,s,n){return i===s||i===n?{start:t-e/2,end:t+e/2}:i<s||i>n?{start:t-e,end:t}:{start:t,end:t+e}}function Vw(i){const t={l:i.left+i._padding.left,r:i.right-i._padding.right,t:i.top+i._padding.top,b:i.bottom-i._padding.bottom},e=Object.assign({},t),s=[],n=[],o=i._pointLabels.length,r=i.options.pointLabels,a=r.centerPointLabels?et/o:0;for(let l=0;l<o;l++){const c=r.setContext(i.getPointLabelContext(l));n[l]=c.padding;const h=i.getPointPosition(l,i.drawingArea+n[l],a),d=lt(c.font),u=Fw(i.ctx,d,i._pointLabels[l]);s[l]=u;const f=Nt(i.getIndexAngle(l)+a),p=Math.round(Fa(f)),_=bp(p,h.x,u.w,0,180),m=bp(p,h.y,u.h,90,270);Ww(e,t,f,_,m)}i.setCenterPoint(t.l-e.l,e.r-t.r,t.t-e.t,e.b-t.b),i._pointLabelItems=zw(i,s,n)}function Ww(i,t,e,s,n){const o=Math.abs(Math.sin(e)),r=Math.abs(Math.cos(e));let a=0,l=0;s.start<t.l?(a=(t.l-s.start)/o,i.l=Math.min(i.l,t.l-a)):s.end>t.r&&(a=(s.end-t.r)/o,i.r=Math.max(i.r,t.r+a)),n.start<t.t?(l=(t.t-n.start)/r,i.t=Math.min(i.t,t.t-l)):n.end>t.b&&(l=(n.end-t.b)/r,i.b=Math.max(i.b,t.b+l))}function zw(i,t,e){const s=[],n=i._pointLabels.length,o=i.options,r=wl(o)/2,a=i.drawingArea,l=o.pointLabels.centerPointLabels?et/n:0;for(let c=0;c<n;c++){const h=i.getPointPosition(c,a+r+e[c],l),d=Math.round(Fa(Nt(h.angle+nt))),u=t[c],f=Kw(h.y,u.h,d),p=jw(d),_=Yw(h.x,u.w,p);s.push({x:h.x,y:f,textAlign:p,left:_,top:f,right:_+u.w,bottom:f+u.h})}return s}function jw(i){return i===0||i===180?\"center\":i<180?\"left\":\"right\"}function Yw(i,t,e){return e===\"right\"?i-=t:e===\"center\"&&(i-=t/2),i}function Kw(i,t,e){return e===90||e===270?i-=t/2:(e>270||e<90)&&(i-=t),i}function Uw(i,t){const{ctx:e,options:{pointLabels:s}}=i;for(let n=t-1;n>=0;n--){const o=s.setContext(i.getPointLabelContext(n)),r=lt(o.font),{x:a,y:l,textAlign:c,left:h,top:d,right:u,bottom:f}=i._pointLabelItems[n],{backdropColor:p}=o;if(!N(p)){const _=Ci(o.borderRadius),m=ht(o.backdropPadding);e.fillStyle=p;const y=h-m.left,x=d-m.top,E=u-h+m.width,C=f-d+m.height;Object.values(_).some(T=>T!==0)?(e.beginPath(),rn(e,{x:y,y:x,w:E,h:C,radius:_}),e.fill()):e.fillRect(y,x,E,C)}Ei(e,i._pointLabels[n],a,l+r.lineHeight/2,r,{color:o.color,textAlign:c,textBaseline:\"middle\"})}}function vp(i,t,e,s){const{ctx:n}=i;if(e)n.arc(i.xCenter,i.yCenter,t,0,q);else{let o=i.getPointPosition(0,t);n.moveTo(o.x,o.y);for(let r=1;r<s;r++)o=i.getPointPosition(r,t),n.lineTo(o.x,o.y)}}function Xw(i,t,e,s){const n=i.ctx,o=t.circular,{color:r,lineWidth:a}=t;!o&&!s||!r||!a||e<0||(n.save(),n.strokeStyle=r,n.lineWidth=a,n.setLineDash(t.borderDash),n.lineDashOffset=t.borderDashOffset,n.beginPath(),vp(i,e,o,s),n.closePath(),n.stroke(),n.restore())}function Gw(i,t,e){return qe(i,{label:e,index:t,type:\"pointLabel\"})}class gs extends ar{constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=ht(wl(this.options)/2),e=this.width=this.maxWidth-t.width,s=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+s/2+t.top),this.drawingArea=Math.floor(Math.min(e,s)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=rt(t)&&!isNaN(t)?t:0,this.max=rt(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/wl(this.options))}generateTickLabels(t){ar.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((e,s)=>{const n=G(this.options.pointLabels.callback,[e,s],this);return n||n===0?n:\"\"}).filter((e,s)=>this.chart.getDataVisibility(s))}fit(){const t=this.options;t.display&&t.pointLabels.display?Vw(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,s,n){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((s-n)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,s,n))}getIndexAngle(t){const e=q/(this._pointLabels.length||1),s=this.options.startAngle||0;return Nt(t*e+Jt(s))}getDistanceFromCenterForValue(t){if(N(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(N(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const s=e[t];return Gw(this.getContext(),t,s)}}getPointPosition(t,e,s=0){const n=this.getIndexAngle(t)-nt+s;return{x:Math.cos(n)*e+this.xCenter,y:Math.sin(n)*e+this.yCenter,angle:n}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:s,right:n,bottom:o}=this._pointLabelItems[t];return{left:e,top:s,right:n,bottom:o}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const s=this.ctx;s.save(),s.beginPath(),vp(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),s.closePath(),s.fillStyle=t,s.fill(),s.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:s,grid:n}=e,o=this._pointLabels.length;let r,a,l;if(e.pointLabels.display&&Uw(this,o),n.display&&this.ticks.forEach((c,h)=>{if(h!==0){a=this.getDistanceFromCenterForValue(c.value);const d=n.setContext(this.getContext(h-1));Xw(this,d,a,o)}}),s.display){for(t.save(),r=o-1;r>=0;r--){const c=s.setContext(this.getPointLabelContext(r)),{color:h,lineWidth:d}=c;!d||!h||(t.lineWidth=d,t.strokeStyle=h,t.setLineDash(c.borderDash),t.lineDashOffset=c.borderDashOffset,a=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(r,a),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,s=e.ticks;if(!s.display)return;const n=this.getIndexAngle(0);let o,r;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(n),t.textAlign=\"center\",t.textBaseline=\"middle\",this.ticks.forEach((a,l)=>{if(l===0&&!e.reverse)return;const c=s.setContext(this.getContext(l)),h=lt(c.font);if(o=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){t.font=h.string,r=t.measureText(a.label).width,t.fillStyle=c.backdropColor;const d=ht(c.backdropPadding);t.fillRect(-r/2-d.left,-o-h.size/2-d.top,r+d.width,h.size+d.height)}Ei(t,a.label,0,-o,h,{color:c.color})}),t.restore()}drawTitle(){}}gs.id=\"radialLinear\",gs.defaults={display:!0,animate:!0,position:\"chartArea\",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:pn.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(i){return i},padding:5,centerPointLabels:!1}},gs.defaultRoutes={\"angleLines.color\":\"borderColor\",\"pointLabels.color\":\"color\",\"ticks.color\":\"color\"},gs.descriptors={angleLines:{_fallback:\"grid\"}};const hr={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},kt=Object.keys(hr);function qw(i,t){return i-t}function yp(i,t){if(N(t))return null;const e=i._adapter,{parser:s,round:n,isoWeekday:o}=i._parseOpts;let r=t;return typeof s==\"function\"&&(r=s(r)),rt(r)||(r=typeof s==\"string\"?e.parse(r,s):e.parse(r)),r===null?null:(n&&(r=n===\"week\"&&(as(o)||o===!0)?e.startOf(r,\"isoWeek\",o):e.startOf(r,n)),+r)}function xp(i,t,e,s){const n=kt.length;for(let o=kt.indexOf(i);o<n-1;++o){const r=hr[kt[o]],a=r.steps?r.steps:Number.MAX_SAFE_INTEGER;if(r.common&&Math.ceil((e-t)/(a*r.size))<=s)return kt[o]}return kt[n-1]}function Zw(i,t,e,s,n){for(let o=kt.length-1;o>=kt.indexOf(e);o--){const r=kt[o];if(hr[r].common&&i._adapter.diff(n,s,r)>=t-1)return r}return kt[e?kt.indexOf(e):0]}function Qw(i){for(let t=kt.indexOf(i)+1,e=kt.length;t<e;++t)if(hr[kt[t]].common)return kt[t]}function Ep(i,t,e){if(!e)i[t]=!0;else if(e.length){const{lo:s,hi:n}=Wa(e,t),o=e[s]>=t?e[s]:e[n];i[o]=!0}}function Jw(i,t,e,s){const n=i._adapter,o=+n.startOf(t[0].value,s),r=t[t.length-1].value;let a,l;for(a=o;a<=r;a=+n.add(a,1,s))l=e[a],l>=0&&(t[l].major=!0);return t}function Cp(i,t,e){const s=[],n={},o=t.length;let r,a;for(r=0;r<o;++r)a=t[r],n[a]=r,s.push({value:a,major:!1});return o===0||!e?s:Jw(i,s,n,e)}class ms extends Ze{constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit=\"day\",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e){const s=t.time||(t.time={}),n=this._adapter=new _f._date(t.adapters.date);n.init(e),qs(s.displayFormats,n.formats()),this._parseOpts={parser:s.parser,round:s.round,isoWeekday:s.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return t===void 0?null:yp(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,s=t.time.unit||\"day\";let{min:n,max:o,minDefined:r,maxDefined:a}=this.getUserBounds();function l(c){!r&&!isNaN(c.min)&&(n=Math.min(n,c.min)),!a&&!isNaN(c.max)&&(o=Math.max(o,c.max))}(!r||!a)&&(l(this._getLabelBounds()),(t.bounds!==\"ticks\"||t.ticks.source!==\"labels\")&&l(this.getMinMax(!1))),n=rt(n)&&!isNaN(n)?n:+e.startOf(Date.now(),s),o=rt(o)&&!isNaN(o)?o:+e.endOf(Date.now(),s)+1,this.min=Math.min(n,o-1),this.max=Math.max(n+1,o)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],s=t[t.length-1]),{min:e,max:s}}buildTicks(){const t=this.options,e=t.time,s=t.ticks,n=s.source===\"labels\"?this.getLabelTimestamps():this._generate();t.bounds===\"ticks\"&&n.length&&(this.min=this._userMin||n[0],this.max=this._userMax||n[n.length-1]);const o=this.min,r=this.max,a=zE(n,o,r);return this._unit=e.unit||(s.autoSkip?xp(e.minUnit,this.min,this.max,this._getLabelCapacity(o)):Zw(this,a.length,e.minUnit,this.min,this.max)),this._majorUnit=!s.major.enabled||this._unit===\"year\"?void 0:Qw(this._unit),this.initOffsets(n),t.reverse&&a.reverse(),Cp(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(t=>+t.value))}initOffsets(t){let e=0,s=0,n,o;this.options.offset&&t.length&&(n=this.getDecimalForValue(t[0]),t.length===1?e=1-n:e=(this.getDecimalForValue(t[1])-n)/2,o=this.getDecimalForValue(t[t.length-1]),t.length===1?s=o:s=(o-this.getDecimalForValue(t[t.length-2]))/2);const r=t.length<3?.5:.25;e=ct(e,0,r),s=ct(s,0,r),this._offsets={start:e,end:s,factor:1/(e+1+s)}}_generate(){const t=this._adapter,e=this.min,s=this.max,n=this.options,o=n.time,r=o.unit||xp(o.minUnit,e,s,this._getLabelCapacity(e)),a=R(o.stepSize,1),l=r===\"week\"?o.isoWeekday:!1,c=as(l)||l===!0,h={};let d=e,u,f;if(c&&(d=+t.startOf(d,\"isoWeek\",l)),d=+t.startOf(d,c?\"day\":r),t.diff(s,e,r)>1e5*a)throw new Error(e+\" and \"+s+\" are too far apart with stepSize of \"+a+\" \"+r);const p=n.ticks.source===\"data\"&&this.getDataTimestamps();for(u=d,f=0;u<s;u=+t.add(u,a,r),f++)Ep(h,u,p);return(u===s||n.bounds===\"ticks\"||f===1)&&Ep(h,u,p),Object.keys(h).sort((_,m)=>_-m).map(_=>+_)}getLabelForValue(t){const e=this._adapter,s=this.options.time;return s.tooltipFormat?e.format(t,s.tooltipFormat):e.format(t,s.displayFormats.datetime)}_tickFormatFunction(t,e,s,n){const o=this.options,r=o.time.displayFormats,a=this._unit,l=this._majorUnit,c=a&&r[a],h=l&&r[l],d=s[e],u=l&&h&&d&&d.major,f=this._adapter.format(t,n||(u?h:c)),p=o.ticks.callback;return p?G(p,[f,e,s],this):f}generateTickLabels(t){let e,s,n;for(e=0,s=t.length;e<s;++e)n=t[e],n.label=this._tickFormatFunction(n.value,e,t)}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,s=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+s)*e.factor)}getValueForPixel(t){const e=this._offsets,s=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+s*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,s=this.ctx.measureText(t).width,n=Jt(this.isHorizontal()?e.maxRotation:e.minRotation),o=Math.cos(n),r=Math.sin(n),a=this._resolveTickFontOptions(0).size;return{w:s*o+a*r,h:s*r+a*o}}_getLabelCapacity(t){const e=this.options.time,s=e.displayFormats,n=s[e.unit]||s.millisecond,o=this._tickFormatFunction(t,0,Cp(this,[t],this._majorUnit),n),r=this._getLabelSize(o),a=Math.floor(this.isHorizontal()?this.width/r.w:this.height/r.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[],e,s;if(t.length)return t;const n=this.getMatchingVisibleMetas();if(this._normalized&&n.length)return this._cache.data=n[0].controller.getAllParsedValues(this);for(e=0,s=n.length;e<s;++e)t=t.concat(n[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,s;if(t.length)return t;const n=this.getLabels();for(e=0,s=n.length;e<s;++e)t.push(yp(this,n[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return hu(t.sort(qw))}}ms.id=\"time\",ms.defaults={bounds:\"data\",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:\"millisecond\",displayFormats:{}},ticks:{source:\"auto\",major:{enabled:!1}}};function dr(i,t,e){let s=0,n=i.length-1,o,r,a,l;e?(t>=i[s].pos&&t<=i[n].pos&&({lo:s,hi:n}=we(i,\"pos\",t)),{pos:o,time:a}=i[s],{pos:r,time:l}=i[n]):(t>=i[s].time&&t<=i[n].time&&({lo:s,hi:n}=we(i,\"time\",t)),{time:o,pos:a}=i[s],{time:r,pos:l}=i[n]);const c=r-o;return c?a+(l-a)*(t-o)/c:a}class ur extends ms{constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=dr(e,this.min),this._tableRange=dr(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:s}=this,n=[],o=[];let r,a,l,c,h;for(r=0,a=t.length;r<a;++r)c=t[r],c>=e&&c<=s&&n.push(c);if(n.length<2)return[{time:e,pos:0},{time:s,pos:1}];for(r=0,a=n.length;r<a;++r)h=n[r+1],l=n[r-1],c=n[r],Math.round((h+l)/2)!==c&&o.push({time:c,pos:r/(a-1)});return o}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),s=this.getLabelTimestamps();return e.length&&s.length?t=this.normalize(e.concat(s)):t=e.length?e:s,t=this._cache.all=t,t}getDecimalForValue(t){return(dr(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,s=this.getDecimalForPixel(t)/e.factor-e.end;return dr(this._table,s*this._tableRange+this._minPos,!0)}}ur.id=\"timeseries\",ur.defaults=ms.defaults;var Tp=Object.freeze({__proto__:null,CategoryScale:Tn,LinearScale:lr,LogarithmicScale:cr,RadialLinearScale:gs,TimeScale:ms,TimeSeriesScale:ur});const tk=Object.freeze(Object.defineProperty({__proto__:null,Animation:Zu,Animations:ol,ArcElement:fs,BarController:cn,BarElement:_s,BasePlatform:ul,BasicPlatform:Cf,BubbleController:hn,CategoryScale:Tn,Chart:gl,DatasetController:zt,Decimation:Gf,DomPlatform:Sf,DoughnutController:ki,Element:jt,Filler:sp,Interaction:mf,Legend:rp,LineController:dn,LineElement:Se,LinearScale:lr,LogarithmicScale:cr,PieController:Zo,PointElement:ps,PolarAreaController:un,RadarController:fn,RadialLinearScale:gs,Scale:Ze,ScatterController:gn,SubTitle:lp,Ticks:pn,TimeScale:ms,TimeSeriesScale:ur,Title:ap,Tooltip:pp,_adapters:_f,_detectPlatform:Of,animator:be,controllers:pf,defaults:B,elements:Kf,layouts:dt,plugins:_p,registerables:[pf,Kf,_p,Tp],registry:te,scales:Tp},Symbol.toStringTag,{value:\"Module\"}));/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */var Ap=function(){if(typeof window<\"u\"){if(window.devicePixelRatio)return window.devicePixelRatio;var i=window.screen;if(i)return(i.deviceXDPI||1)/(i.logicalXDPI||1)}return 1}(),An={toTextLines:function(i){var t=[],e;for(i=[].concat(i);i.length;)e=i.pop(),typeof e==\"string\"?t.unshift.apply(t,e.split(`\n`)):Array.isArray(e)?i.push.apply(i,e):N(i)||t.unshift(\"\"+e);return t},textSize:function(i,t,e){var s=[].concat(t),n=s.length,o=i.font,r=0,a;for(i.font=e.string,a=0;a<n;++a)r=Math.max(i.measureText(s[a]).width,r);return i.font=o,{height:n*e.lineHeight,width:r}},bound:function(i,t,e){return Math.max(i,Math.min(t,e))},arrayDiff:function(i,t){var e=i.slice(),s=[],n,o,r,a;for(n=0,r=t.length;n<r;++n)a=t[n],o=e.indexOf(a),o===-1?s.push([a,1]):e.splice(o,1);for(n=0,r=e.length;n<r;++n)s.push([e[n],-1]);return s},rasterize:function(i){return Math.round(i*Ap)/Ap}};function kl(i,t){var e=t.x,s=t.y;if(e===null)return{x:0,y:-1};if(s===null)return{x:1,y:0};var n=i.x-e,o=i.y-s,r=Math.sqrt(n*n+o*o);return{x:r?n/r:0,y:r?o/r:-1}}function ek(i,t,e,s,n){switch(n){case\"center\":e=s=0;break;case\"bottom\":e=0,s=1;break;case\"right\":e=1,s=0;break;case\"left\":e=-1,s=0;break;case\"top\":e=0,s=-1;break;case\"start\":e=-e,s=-s;break;case\"end\":break;default:n*=Math.PI/180,e=Math.cos(n),s=Math.sin(n);break}return{x:i,y:t,vx:e,vy:s}}var ik=0,wp=1,kp=2,Sp=4,Op=8;function fr(i,t,e){var s=ik;return i<e.left?s|=wp:i>e.right&&(s|=kp),t<e.top?s|=Op:t>e.bottom&&(s|=Sp),s}function sk(i,t){for(var e=i.x0,s=i.y0,n=i.x1,o=i.y1,r=fr(e,s,t),a=fr(n,o,t),l,c,h;!(!(r|a)||r&a);)l=r||a,l&Op?(c=e+(n-e)*(t.top-s)/(o-s),h=t.top):l&Sp?(c=e+(n-e)*(t.bottom-s)/(o-s),h=t.bottom):l&kp?(h=s+(o-s)*(t.right-e)/(n-e),c=t.right):l&wp&&(h=s+(o-s)*(t.left-e)/(n-e),c=t.left),l===r?(e=c,s=h,r=fr(e,s,t)):(n=c,o=h,a=fr(n,o,t));return{x0:e,x1:n,y0:s,y1:o}}function pr(i,t){var e=t.anchor,s=i,n,o;return t.clamp&&(s=sk(s,t.area)),e===\"start\"?(n=s.x0,o=s.y0):e===\"end\"?(n=s.x1,o=s.y1):(n=(s.x0+s.x1)/2,o=(s.y0+s.y1)/2),ek(n,o,i.vx,i.vy,t.align)}var _r={arc:function(i,t){var e=(i.startAngle+i.endAngle)/2,s=Math.cos(e),n=Math.sin(e),o=i.innerRadius,r=i.outerRadius;return pr({x0:i.x+s*o,y0:i.y+n*o,x1:i.x+s*r,y1:i.y+n*r,vx:s,vy:n},t)},point:function(i,t){var e=kl(i,t.origin),s=e.x*i.options.radius,n=e.y*i.options.radius;return pr({x0:i.x-s,y0:i.y-n,x1:i.x+s,y1:i.y+n,vx:e.x,vy:e.y},t)},bar:function(i,t){var e=kl(i,t.origin),s=i.x,n=i.y,o=0,r=0;return i.horizontal?(s=Math.min(i.x,i.base),o=Math.abs(i.base-i.x)):(n=Math.min(i.y,i.base),r=Math.abs(i.base-i.y)),pr({x0:s,y0:n+r,x1:s+o,y1:n,vx:e.x,vy:e.y},t)},fallback:function(i,t){var e=kl(i,t.origin);return pr({x0:i.x,y0:i.y,x1:i.x+(i.width||0),y1:i.y+(i.height||0),vx:e.x,vy:e.y},t)}},De=An.rasterize;function nk(i){var t=i.borderWidth||0,e=i.padding,s=i.size.height,n=i.size.width,o=-n/2,r=-s/2;return{frame:{x:o-e.left-t,y:r-e.top-t,w:n+e.width+t*2,h:s+e.height+t*2},text:{x:o,y:r,w:n,h:s}}}function ok(i,t){var e=t.chart.getDatasetMeta(t.datasetIndex).vScale;if(!e)return null;if(e.xCenter!==void 0&&e.yCenter!==void 0)return{x:e.xCenter,y:e.yCenter};var s=e.getBasePixel();return i.horizontal?{x:s,y:null}:{x:null,y:s}}function rk(i){return i instanceof fs?_r.arc:i instanceof ps?_r.point:i instanceof _s?_r.bar:_r.fallback}function ak(i,t,e,s,n,o){var r=Math.PI/2;if(o){var a=Math.min(o,n/2,s/2),l=t+a,c=e+a,h=t+s-a,d=e+n-a;i.moveTo(t,c),l<h&&c<d?(i.arc(l,c,a,-Math.PI,-r),i.arc(h,c,a,-r,0),i.arc(h,d,a,0,r),i.arc(l,d,a,r,Math.PI)):l<h?(i.moveTo(l,e),i.arc(h,c,a,-r,r),i.arc(l,c,a,r,Math.PI+r)):c<d?(i.arc(l,c,a,-Math.PI,0),i.arc(l,d,a,0,Math.PI)):i.arc(l,c,a,-Math.PI,Math.PI),i.closePath(),i.moveTo(t,e)}else i.rect(t,e,s,n)}function lk(i,t,e){var s=e.backgroundColor,n=e.borderColor,o=e.borderWidth;!s&&(!n||!o)||(i.beginPath(),ak(i,De(t.x)+o/2,De(t.y)+o/2,De(t.w)-o,De(t.h)-o,e.borderRadius),i.closePath(),s&&(i.fillStyle=s,i.fill()),n&&o&&(i.strokeStyle=n,i.lineWidth=o,i.lineJoin=\"miter\",i.stroke()))}function ck(i,t,e){var s=e.lineHeight,n=i.w,o=i.x,r=i.y+s/2;return t===\"center\"?o+=n/2:(t===\"end\"||t===\"right\")&&(o+=n),{h:s,w:n,x:o,y:r}}function hk(i,t,e){var s=i.shadowBlur,n=e.stroked,o=De(e.x),r=De(e.y),a=De(e.w);n&&i.strokeText(t,o,r,a),e.filled&&(s&&n&&(i.shadowBlur=0),i.fillText(t,o,r,a),s&&n&&(i.shadowBlur=s))}function dk(i,t,e,s){var n=s.textAlign,o=s.color,r=!!o,a=s.font,l=t.length,c=s.textStrokeColor,h=s.textStrokeWidth,d=c&&h,u;if(!(!l||!r&&!d))for(e=ck(e,n,a),i.font=a.string,i.textAlign=n,i.textBaseline=\"middle\",i.shadowBlur=s.textShadowBlur,i.shadowColor=s.textShadowColor,r&&(i.fillStyle=o),d&&(i.lineJoin=\"round\",i.lineWidth=h,i.strokeStyle=c),u=0,l=t.length;u<l;++u)hk(i,t[u],{stroked:d,filled:r,w:e.w,x:e.x,y:e.y+e.h*u})}var Dp=function(i,t,e,s){var n=this;n._config=i,n._index=s,n._model=null,n._rects=null,n._ctx=t,n._el=e};ge(Dp.prototype,{_modelize:function(i,t,e,s){var n=this,o=n._index,r=lt(tt([e.font,{}],s,o)),a=tt([e.color,B.color],s,o);return{align:tt([e.align,\"center\"],s,o),anchor:tt([e.anchor,\"center\"],s,o),area:s.chart.chartArea,backgroundColor:tt([e.backgroundColor,null],s,o),borderColor:tt([e.borderColor,null],s,o),borderRadius:tt([e.borderRadius,0],s,o),borderWidth:tt([e.borderWidth,0],s,o),clamp:tt([e.clamp,!1],s,o),clip:tt([e.clip,!1],s,o),color:a,display:i,font:r,lines:t,offset:tt([e.offset,4],s,o),opacity:tt([e.opacity,1],s,o),origin:ok(n._el,s),padding:ht(tt([e.padding,4],s,o)),positioner:rk(n._el),rotation:tt([e.rotation,0],s,o)*(Math.PI/180),size:An.textSize(n._ctx,t,r),textAlign:tt([e.textAlign,\"start\"],s,o),textShadowBlur:tt([e.textShadowBlur,0],s,o),textShadowColor:tt([e.textShadowColor,a],s,o),textStrokeColor:tt([e.textStrokeColor,a],s,o),textStrokeWidth:tt([e.textStrokeWidth,0],s,o)}},update:function(i){var t=this,e=null,s=null,n=t._index,o=t._config,r,a,l,c=tt([o.display,!0],i,n);c&&(r=i.dataset.data[n],a=R(G(o.formatter,[r,i]),r),l=N(a)?[]:An.toTextLines(a),l.length&&(e=t._modelize(c,l,o,i),s=nk(e))),t._model=e,t._rects=s},geometry:function(){return this._rects?this._rects.frame:{}},rotation:function(){return this._model?this._model.rotation:0},visible:function(){return this._model&&this._model.opacity},model:function(){return this._model},draw:function(i,t){var e=this,s=i.ctx,n=e._model,o=e._rects,r;this.visible()&&(s.save(),n.clip&&(r=n.area,s.beginPath(),s.rect(r.left,r.top,r.right-r.left,r.bottom-r.top),s.clip()),s.globalAlpha=An.bound(0,n.opacity,1),s.translate(De(t.x),De(t.y)),s.rotate(n.rotation),lk(s,o.frame,n),dk(s,n.lines,o.text,n),s.restore())}});var uk=Number.MIN_SAFE_INTEGER||-9007199254740991,fk=Number.MAX_SAFE_INTEGER||9007199254740991;function wn(i,t,e){var s=Math.cos(e),n=Math.sin(e),o=t.x,r=t.y;return{x:o+s*(i.x-o)-n*(i.y-r),y:r+n*(i.x-o)+s*(i.y-r)}}function Mp(i,t){var e=fk,s=uk,n=t.origin,o,r,a,l,c;for(o=0;o<i.length;++o)r=i[o],a=r.x-n.x,l=r.y-n.y,c=t.vx*a+t.vy*l,e=Math.min(e,c),s=Math.max(s,c);return{min:e,max:s}}function gr(i,t){var e=t.x-i.x,s=t.y-i.y,n=Math.sqrt(e*e+s*s);return{vx:(t.x-i.x)/n,vy:(t.y-i.y)/n,origin:i,ln:n}}var Ip=function(){this._rotation=0,this._rect={x:0,y:0,w:0,h:0}};ge(Ip.prototype,{center:function(){var i=this._rect;return{x:i.x+i.w/2,y:i.y+i.h/2}},update:function(i,t,e){this._rotation=e,this._rect={x:t.x+i.x,y:t.y+i.y,w:t.w,h:t.h}},contains:function(i){var t=this,e=1,s=t._rect;return i=wn(i,t.center(),-t._rotation),!(i.x<s.x-e||i.y<s.y-e||i.x>s.x+s.w+e*2||i.y>s.y+s.h+e*2)},intersects:function(i){var t=this._points(),e=i._points(),s=[gr(t[0],t[1]),gr(t[0],t[3])],n,o,r;for(this._rotation!==i._rotation&&s.push(gr(e[0],e[1]),gr(e[0],e[3])),n=0;n<s.length;++n)if(o=Mp(t,s[n]),r=Mp(e,s[n]),o.max<r.min||r.max<o.min)return!1;return!0},_points:function(){var i=this,t=i._rect,e=i._rotation,s=i.center();return[wn({x:t.x,y:t.y},s,e),wn({x:t.x+t.w,y:t.y},s,e),wn({x:t.x+t.w,y:t.y+t.h},s,e),wn({x:t.x,y:t.y+t.h},s,e)]}});function Lp(i,t,e){var s=t.positioner(i,t),n=s.vx,o=s.vy;if(!n&&!o)return{x:s.x,y:s.y};var r=e.w,a=e.h,l=t.rotation,c=Math.abs(r/2*Math.cos(l))+Math.abs(a/2*Math.sin(l)),h=Math.abs(r/2*Math.sin(l))+Math.abs(a/2*Math.cos(l)),d=1/Math.max(Math.abs(n),Math.abs(o));return c*=n*d,h*=o*d,c+=t.offset*n,h+=t.offset*o,{x:s.x+c,y:s.y+h}}function pk(i,t){var e,s,n,o;for(e=i.length-1;e>=0;--e)for(n=i[e].$layout,s=e-1;s>=0&&n._visible;--s)o=i[s].$layout,o._visible&&n._box.intersects(o._box)&&t(n,o);return i}function _k(i){var t,e,s,n,o,r,a;for(t=0,e=i.length;t<e;++t)s=i[t],n=s.$layout,n._visible&&(a=new Proxy(s._el,{get:(l,c)=>l.getProps([c],!0)[c]}),o=s.geometry(),r=Lp(a,s.model(),o),n._box.update(r,o,s.rotation()));return pk(i,function(l,c){var h=l._hidable,d=c._hidable;h&&d||d?c._visible=!1:h&&(l._visible=!1)})}var kn={prepare:function(i){var t=[],e,s,n,o,r;for(e=0,n=i.length;e<n;++e)for(s=0,o=i[e].length;s<o;++s)r=i[e][s],t.push(r),r.$layout={_box:new Ip,_hidable:!1,_visible:!0,_set:e,_idx:r._index};return t.sort(function(a,l){var c=a.$layout,h=l.$layout;return c._idx===h._idx?h._set-c._set:h._idx-c._idx}),this.update(t),t},update:function(i){var t=!1,e,s,n,o,r;for(e=0,s=i.length;e<s;++e)n=i[e],o=n.model(),r=n.$layout,r._hidable=o&&o.display===\"auto\",r._visible=n.visible(),t|=r._hidable;t&&_k(i)},lookup:function(i,t){var e,s;for(e=i.length-1;e>=0;--e)if(s=i[e].$layout,s&&s._visible&&s._box.contains(t))return i[e];return null},draw:function(i,t){var e,s,n,o,r,a;for(e=0,s=t.length;e<s;++e)n=t[e],o=n.$layout,o._visible&&(r=n.geometry(),a=Lp(n._el,n.model(),r),o._box.update(a,r,n.rotation()),n.draw(i,a))}},gk=function(i){if(N(i))return null;var t=i,e,s,n;if($(i))if(!N(i.label))t=i.label;else if(!N(i.r))t=i.r;else for(t=\"\",e=Object.keys(i),n=0,s=e.length;n<s;++n)t+=(n!==0?\", \":\"\")+e[n]+\": \"+i[e[n]];return\"\"+t},mk={align:\"center\",anchor:\"center\",backgroundColor:null,borderColor:null,borderRadius:0,borderWidth:0,clamp:!1,clip:!1,color:void 0,display:!0,font:{family:void 0,lineHeight:1.2,size:void 0,style:void 0,weight:null},formatter:gk,labels:void 0,listeners:{},offset:4,opacity:1,padding:{top:4,right:4,bottom:4,left:4},rotation:0,textAlign:\"start\",textStrokeColor:void 0,textStrokeWidth:0,textShadowBlur:0,textShadowColor:void 0},St=\"$datalabels\",Pp=\"$default\";function bk(i,t){var e=i.datalabels,s={},n=[],o,r;return e===!1?null:(e===!0&&(e={}),t=ge({},[t,e]),o=t.labels||{},r=Object.keys(o),delete t.labels,r.length?r.forEach(function(a){o[a]&&n.push(ge({},[t,o[a],{_key:a}]))}):n.push(t),s=n.reduce(function(a,l){return U(l.listeners||{},function(c,h){a[h]=a[h]||{},a[h][l._key||Pp]=c}),delete l.listeners,a},{}),{labels:n,listeners:s})}function Sl(i,t,e,s){if(t){var n=e.$context,o=e.$groups,r;t[o._set]&&(r=t[o._set][o._key],r&&G(r,[n,s])===!0&&(i[St]._dirty=!0,e.update(n)))}}function vk(i,t,e,s,n){var o,r;!e&&!s||(e?s?e!==s&&(r=o=!0):r=!0:o=!0,r&&Sl(i,t.leave,e,n),o&&Sl(i,t.enter,s,n))}function yk(i,t){var e=i[St],s=e._listeners,n,o;if(!(!s.enter&&!s.leave)){if(t.type===\"mousemove\")o=kn.lookup(e._labels,t);else if(t.type!==\"mouseout\")return;n=e._hovered,e._hovered=o,vk(i,s,n,o,t)}}function xk(i,t){var e=i[St],s=e._listeners.click,n=s&&kn.lookup(e._labels,t);n&&Sl(i,s,n,t)}var Ek={id:\"datalabels\",defaults:mk,beforeInit:function(i){i[St]={_actives:[]}},beforeUpdate:function(i){var t=i[St];t._listened=!1,t._listeners={},t._datasets=[],t._labels=[]},afterDatasetUpdate:function(i,t,e){var s=t.index,n=i[St],o=n._datasets[s]=[],r=i.isDatasetVisible(s),a=i.data.datasets[s],l=bk(a,e),c=t.meta.data||[],h=i.ctx,d,u,f,p,_,m,y,x;for(h.save(),d=0,f=c.length;d<f;++d)if(y=c[d],y[St]=[],r&&y&&i.getDataVisibility(d)&&!y.skip)for(u=0,p=l.labels.length;u<p;++u)_=l.labels[u],m=_._key,x=new Dp(_,h,y,d),x.$groups={_set:s,_key:m||Pp},x.$context={active:!1,chart:i,dataIndex:d,dataset:a,datasetIndex:s},x.update(x.$context),y[St].push(x),o.push(x);h.restore(),ge(n._listeners,l.listeners,{merger:function(E,C,T){C[E]=C[E]||{},C[E][t.index]=T[E],n._listened=!0}})},afterUpdate:function(i){i[St]._labels=kn.prepare(i[St]._datasets)},afterDatasetsDraw:function(i){kn.draw(i,i[St]._labels)},beforeEvent:function(i,t){if(i[St]._listened){var e=t.event;switch(e.type){case\"mousemove\":case\"mouseout\":yk(i,e);break;case\"click\":xk(i,e);break}}},afterEvent:function(i){var t=i[St],e=t._actives,s=t._actives=i.getActiveElements(),n=An.arrayDiff(e,s),o,r,a,l,c,h,d;for(o=0,r=n.length;o<r;++o)if(c=n[o],c[1])for(d=c[0].element[St]||[],a=0,l=d.length;a<l;++a)h=d[a],h.$context.active=c[1]===1,h.update(h.$context);(t._dirty||n.length)&&(kn.update(t._labels),i.render()),delete t._dirty}};const Ck=Object.freeze(Object.defineProperty({__proto__:null,default:Ek},Symbol.toStringTag,{value:\"Module\"}));V.Alert=As,V.Animate=qn,V.Button=On,V.Carousel=ae,V.Chart=Qd,V.Chip=vi,V.ChipsInput=Ud,V.Collapse=re,V.Datepicker=Ph,V.Dropdown=$t,V.Input=Z,V.Modal=Ss,V.Offcanvas=zi,V.Popover=zn,V.Ripple=Ui,V.ScrollSpy=Is,V.Select=Lo,V.Sidenav=bi,V.Stepper=vd,V.Tab=Un,V.Timepicker=od,V.Toast=Ls,V.Tooltip=Ms,V.initTE=Ia,Object.defineProperty(V,Symbol.toStringTag,{value:\"Module\"})});\n//# sourceMappingURL=tw-elements.umd.min.js.map\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst mapData = (() => {\r\n  const storeData = {};\r\n  let id = 1;\r\n  return {\r\n    set(element, key, data) {\r\n      if (typeof element[key] === \"undefined\") {\r\n        element[key] = {\r\n          key,\r\n          id,\r\n        };\r\n        id++;\r\n      }\r\n\r\n      storeData[element[key].id] = data;\r\n    },\r\n    get(element, key) {\r\n      if (!element || typeof element[key] === \"undefined\") {\r\n        return null;\r\n      }\r\n\r\n      const keyProperties = element[key];\r\n      if (keyProperties.key === key) {\r\n        return storeData[keyProperties.id];\r\n      }\r\n\r\n      return null;\r\n    },\r\n    delete(element, key) {\r\n      if (typeof element[key] === \"undefined\") {\r\n        return;\r\n      }\r\n\r\n      const keyProperties = element[key];\r\n      if (keyProperties.key === key) {\r\n        delete storeData[keyProperties.id];\r\n        delete element[key];\r\n      }\r\n    },\r\n  };\r\n})();\r\n\r\nconst Data = {\r\n  setData(instance, key, data) {\r\n    mapData.set(instance, key, data);\r\n  },\r\n  getData(instance, key) {\r\n    return mapData.get(instance, key);\r\n  },\r\n  removeData(instance, key) {\r\n    mapData.delete(instance, key);\r\n  },\r\n};\r\n\r\nexport default Data;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nconst MAX_UID = 1000000;\r\nconst MILLISECONDS_MULTIPLIER = 1000;\r\nconst TRANSITION_END = \"transitionend\";\r\n\r\n// Shoutout AngusCroll (https://goo.gl/pxwQGp)\r\nconst toType = (obj) => {\r\n  if (obj === null || obj === undefined) {\r\n    return `${obj}`;\r\n  }\r\n\r\n  return {}.toString\r\n    .call(obj)\r\n    .match(/\\s([a-z]+)/i)[1]\r\n    .toLowerCase();\r\n};\r\n\r\n/**\r\n * --------------------------------------------------------------------------\r\n * Public Util Api\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\nconst getUID = (prefix) => {\r\n  do {\r\n    prefix += Math.floor(Math.random() * MAX_UID);\r\n  } while (document.getElementById(prefix));\r\n\r\n  return prefix;\r\n};\r\n\r\nconst getSelector = (element) => {\r\n  let selector = element.getAttribute(\"data-te-target\");\r\n\r\n  if (!selector || selector === \"#\") {\r\n    let hrefAttr = element.getAttribute(\"href\");\r\n\r\n    // The only valid content that could double as a selector are IDs or classes,\r\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\r\n    // `document.querySelector` will rightfully complain it is invalid.\r\n    // See https://github.com/twbs/bootstrap/issues/32273\r\n    if (!hrefAttr || (!hrefAttr.includes(\"#\") && !hrefAttr.startsWith(\".\"))) {\r\n      return null;\r\n    }\r\n\r\n    // Just in case some CMS puts out a full URL with the anchor appended\r\n    if (hrefAttr.includes(\"#\") && !hrefAttr.startsWith(\"#\")) {\r\n      hrefAttr = `#${hrefAttr.split(\"#\")[1]}`;\r\n    }\r\n\r\n    selector = hrefAttr && hrefAttr !== \"#\" ? hrefAttr.trim() : null;\r\n  }\r\n\r\n  return selector;\r\n};\r\n\r\nconst getSelectorFromElement = (element) => {\r\n  const selector = getSelector(element);\r\n\r\n  if (selector) {\r\n    return document.querySelector(selector) ? selector : null;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nconst getElementFromSelector = (element) => {\r\n  const selector = getSelector(element);\r\n\r\n  return selector ? document.querySelector(selector) : null;\r\n};\r\n\r\nconst getTransitionDurationFromElement = (element) => {\r\n  if (!element) {\r\n    return 0;\r\n  }\r\n\r\n  // Get transition-duration of the element\r\n  let { transitionDuration, transitionDelay } =\r\n    window.getComputedStyle(element);\r\n\r\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\r\n  const floatTransitionDelay = Number.parseFloat(transitionDelay);\r\n\r\n  // Return 0 if element or transition duration is not found\r\n  if (!floatTransitionDuration && !floatTransitionDelay) {\r\n    return 0;\r\n  }\r\n\r\n  // If multiple durations are defined, take the first\r\n  transitionDuration = transitionDuration.split(\",\")[0];\r\n  transitionDelay = transitionDelay.split(\",\")[0];\r\n\r\n  return (\r\n    (Number.parseFloat(transitionDuration) +\r\n      Number.parseFloat(transitionDelay)) *\r\n    MILLISECONDS_MULTIPLIER\r\n  );\r\n};\r\n\r\nconst triggerTransitionEnd = (element) => {\r\n  element.dispatchEvent(new Event(TRANSITION_END));\r\n};\r\n\r\nconst isElement = (obj) => {\r\n  if (!obj || typeof obj !== \"object\") {\r\n    return false;\r\n  }\r\n\r\n  if (typeof obj.jquery !== \"undefined\") {\r\n    obj = obj[0];\r\n  }\r\n\r\n  return typeof obj.nodeType !== \"undefined\";\r\n};\r\n\r\nconst getElement = (obj) => {\r\n  if (isElement(obj)) {\r\n    // it's a jQuery object or a node element\r\n    return obj.jquery ? obj[0] : obj;\r\n  }\r\n\r\n  if (typeof obj === \"string\" && obj.length > 0) {\r\n    return document.querySelector(obj);\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nconst emulateTransitionEnd = (element, duration) => {\r\n  let called = false;\r\n  const durationPadding = 5;\r\n  const emulatedDuration = duration + durationPadding;\r\n\r\n  function listener() {\r\n    called = true;\r\n    element.removeEventListener(TRANSITION_END, listener);\r\n  }\r\n\r\n  element.addEventListener(TRANSITION_END, listener);\r\n  setTimeout(() => {\r\n    if (!called) {\r\n      triggerTransitionEnd(element);\r\n    }\r\n  }, emulatedDuration);\r\n};\r\n\r\nconst typeCheckConfig = (componentName, config, configTypes) => {\r\n  Object.keys(configTypes).forEach((property) => {\r\n    const expectedTypes = configTypes[property];\r\n    const value = config[property];\r\n    const valueType = value && isElement(value) ? \"element\" : toType(value);\r\n\r\n    if (!new RegExp(expectedTypes).test(valueType)) {\r\n      throw new Error(\r\n        `${componentName.toUpperCase()}: ` +\r\n          `Option \"${property}\" provided type \"${valueType}\" ` +\r\n          `but expected type \"${expectedTypes}\".`\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\nconst isVisible = (element) => {\r\n  if (!element || element.getClientRects().length === 0) {\r\n    return false;\r\n  }\r\n\r\n  if (element.style && element.parentNode && element.parentNode.style) {\r\n    const elementStyle = getComputedStyle(element);\r\n    const parentNodeStyle = getComputedStyle(element.parentNode);\r\n\r\n    return (\r\n      getComputedStyle(element).getPropertyValue(\"visibility\") === \"visible\" ||\r\n      (elementStyle.display !== \"none\" &&\r\n        parentNodeStyle.display !== \"none\" &&\r\n        elementStyle.visibility !== \"hidden\")\r\n    );\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst isDisabled = (element) => {\r\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\r\n    return true;\r\n  }\r\n\r\n  if (element.classList.contains(\"disabled\")) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof element.disabled !== \"undefined\") {\r\n    return element.disabled;\r\n  }\r\n\r\n  return (\r\n    element.hasAttribute(\"disabled\") &&\r\n    element.getAttribute(\"disabled\") !== \"false\"\r\n  );\r\n};\r\n\r\nconst findShadowRoot = (element) => {\r\n  if (!document.documentElement.attachShadow) {\r\n    return null;\r\n  }\r\n\r\n  // Can find the shadow root otherwise it'll return the document\r\n  if (typeof element.getRootNode === \"function\") {\r\n    const root = element.getRootNode();\r\n    return root instanceof ShadowRoot ? root : null;\r\n  }\r\n\r\n  if (element instanceof ShadowRoot) {\r\n    return element;\r\n  }\r\n\r\n  // when we don't find a shadow root\r\n  if (!element.parentNode) {\r\n    return null;\r\n  }\r\n\r\n  return findShadowRoot(element.parentNode);\r\n};\r\n\r\nconst noop = () => function () {};\r\n\r\n/**\r\n * Trick to restart an element's animation\r\n *\r\n * @param {HTMLElement} element\r\n * @return void\r\n *\r\n * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\r\n */\r\nconst reflow = (element) => {\r\n  // eslint-disable-next-line no-unused-expressions\r\n  element.offsetHeight;\r\n};\r\n\r\nconst getjQuery = () => {\r\n  const { jQuery } = window;\r\n\r\n  if (jQuery && !document.body.hasAttribute(\"data-te-no-jquery\")) {\r\n    return jQuery;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nconst DOMContentLoadedCallbacks = [];\r\n\r\nconst onDOMContentLoaded = (callback) => {\r\n  if (document.readyState === \"loading\") {\r\n    // add listener on the first call when the document is in loading state\r\n    if (!DOMContentLoadedCallbacks.length) {\r\n      document.addEventListener(\"DOMContentLoaded\", () => {\r\n        DOMContentLoadedCallbacks.forEach((callback) => callback());\r\n      });\r\n    }\r\n\r\n    DOMContentLoadedCallbacks.push(callback);\r\n  } else {\r\n    callback();\r\n  }\r\n};\r\n\r\nconst isRTL = () => document.documentElement.dir === \"rtl\";\r\n\r\nconst array = (collection) => {\r\n  return Array.from(collection);\r\n};\r\n\r\nconst element = (tag) => {\r\n  return document.createElement(tag);\r\n};\r\n\r\nconst defineJQueryPlugin = (plugin) => {\r\n  onDOMContentLoaded(() => {\r\n    const $ = getjQuery();\r\n    /* istanbul ignore if */\r\n    if ($) {\r\n      const name = plugin.NAME;\r\n      const JQUERY_NO_CONFLICT = $.fn[name];\r\n      $.fn[name] = plugin.jQueryInterface;\r\n      $.fn[name].Constructor = plugin;\r\n      $.fn[name].noConflict = () => {\r\n        $.fn[name] = JQUERY_NO_CONFLICT;\r\n        return plugin.jQueryInterface;\r\n      };\r\n    }\r\n  });\r\n};\r\n\r\nconst execute = (callback) => {\r\n  if (typeof callback === \"function\") {\r\n    callback();\r\n  }\r\n};\r\n\r\nconst executeAfterTransition = (\r\n  callback,\r\n  transitionElement,\r\n  waitForTransition = true\r\n) => {\r\n  if (!waitForTransition) {\r\n    execute(callback);\r\n    return;\r\n  }\r\n\r\n  const durationPadding = 5;\r\n  const emulatedDuration =\r\n    getTransitionDurationFromElement(transitionElement) + durationPadding;\r\n\r\n  let called = false;\r\n\r\n  const handler = ({ target }) => {\r\n    if (target !== transitionElement) {\r\n      return;\r\n    }\r\n\r\n    called = true;\r\n    transitionElement.removeEventListener(TRANSITION_END, handler);\r\n    execute(callback);\r\n  };\r\n\r\n  transitionElement.addEventListener(TRANSITION_END, handler);\r\n  setTimeout(() => {\r\n    if (!called) {\r\n      triggerTransitionEnd(transitionElement);\r\n    }\r\n  }, emulatedDuration);\r\n};\r\n\r\n/**\r\n * Return the previous/next element of a list.\r\n *\r\n * @param {array} list    The list of elements\r\n * @param activeElement   The active element\r\n * @param shouldGetNext   Choose to get next or previous element\r\n * @param isCycleAllowed\r\n * @return {Element|elem} The proper element\r\n */\r\nconst getNextActiveElement = (\r\n  list,\r\n  activeElement,\r\n  shouldGetNext,\r\n  isCycleAllowed\r\n) => {\r\n  let index = list.indexOf(activeElement);\r\n\r\n  // if the element does not exist in the list return an element depending on the direction and if cycle is allowed\r\n  if (index === -1) {\r\n    return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];\r\n  }\r\n\r\n  const listLength = list.length;\r\n\r\n  index += shouldGetNext ? 1 : -1;\r\n\r\n  if (isCycleAllowed) {\r\n    index = (index + listLength) % listLength;\r\n  }\r\n\r\n  return list[Math.max(0, Math.min(index, listLength - 1))];\r\n};\r\n\r\nexport {\r\n  getjQuery,\r\n  TRANSITION_END,\r\n  getUID,\r\n  getSelectorFromElement,\r\n  getElementFromSelector,\r\n  getTransitionDurationFromElement,\r\n  triggerTransitionEnd,\r\n  isElement,\r\n  emulateTransitionEnd,\r\n  typeCheckConfig,\r\n  isVisible,\r\n  findShadowRoot,\r\n  noop,\r\n  reflow,\r\n  array,\r\n  element,\r\n  onDOMContentLoaded,\r\n  isRTL,\r\n  defineJQueryPlugin,\r\n  getElement,\r\n  isDisabled,\r\n  execute,\r\n  executeAfterTransition,\r\n  getNextActiveElement,\r\n};\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { getjQuery } from \"../util/index\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\r\nconst stripNameRegex = /\\..*/;\r\nconst stripUidRegex = /::\\d+$/;\r\nconst eventRegistry = {}; // Events storage\r\nlet uidEvent = 1;\r\nconst customEvents = {\r\n  mouseenter: \"mouseover\",\r\n  mouseleave: \"mouseout\",\r\n};\r\nconst customEventsRegex = /^(mouseenter|mouseleave)/i;\r\nconst nativeEvents = new Set([\r\n  \"click\",\r\n  \"dblclick\",\r\n  \"mouseup\",\r\n  \"mousedown\",\r\n  \"contextmenu\",\r\n  \"mousewheel\",\r\n  \"DOMMouseScroll\",\r\n  \"mouseover\",\r\n  \"mouseout\",\r\n  \"mousemove\",\r\n  \"selectstart\",\r\n  \"selectend\",\r\n  \"keydown\",\r\n  \"keypress\",\r\n  \"keyup\",\r\n  \"orientationchange\",\r\n  \"touchstart\",\r\n  \"touchmove\",\r\n  \"touchend\",\r\n  \"touchcancel\",\r\n  \"pointerdown\",\r\n  \"pointermove\",\r\n  \"pointerup\",\r\n  \"pointerleave\",\r\n  \"pointercancel\",\r\n  \"gesturestart\",\r\n  \"gesturechange\",\r\n  \"gestureend\",\r\n  \"focus\",\r\n  \"blur\",\r\n  \"change\",\r\n  \"reset\",\r\n  \"select\",\r\n  \"submit\",\r\n  \"focusin\",\r\n  \"focusout\",\r\n  \"load\",\r\n  \"unload\",\r\n  \"beforeunload\",\r\n  \"resize\",\r\n  \"move\",\r\n  \"DOMContentLoaded\",\r\n  \"readystatechange\",\r\n  \"error\",\r\n  \"abort\",\r\n  \"scroll\",\r\n]);\r\n\r\n/**\r\n * ------------------------------------------------------------------------\r\n * Private methods\r\n * ------------------------------------------------------------------------\r\n */\r\n\r\nfunction getUidEvent(element, uid) {\r\n  return (uid && `${uid}::${uidEvent++}`) || element.uidEvent || uidEvent++;\r\n}\r\n\r\nfunction getEvent(element) {\r\n  const uid = getUidEvent(element);\r\n\r\n  element.uidEvent = uid;\r\n  eventRegistry[uid] = eventRegistry[uid] || {};\r\n\r\n  return eventRegistry[uid];\r\n}\r\n\r\nfunction bootstrapHandler(element, fn) {\r\n  return function handler(event) {\r\n    event.delegateTarget = element;\r\n\r\n    if (handler.oneOff) {\r\n      EventHandler.off(element, event.type, fn);\r\n    }\r\n\r\n    return fn.apply(element, [event]);\r\n  };\r\n}\r\n\r\nfunction bootstrapDelegationHandler(element, selector, fn) {\r\n  return function handler(event) {\r\n    const domElements = element.querySelectorAll(selector);\r\n\r\n    for (\r\n      let { target } = event;\r\n      target && target !== this;\r\n      target = target.parentNode\r\n    ) {\r\n      for (let i = domElements.length; i--; \"\") {\r\n        if (domElements[i] === target) {\r\n          event.delegateTarget = target;\r\n\r\n          if (handler.oneOff) {\r\n            EventHandler.off(element, event.type, fn);\r\n          }\r\n\r\n          return fn.apply(target, [event]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // To please ESLint\r\n    return null;\r\n  };\r\n}\r\n\r\nfunction findHandler(events, handler, delegationSelector = null) {\r\n  const uidEventList = Object.keys(events);\r\n\r\n  for (let i = 0, len = uidEventList.length; i < len; i++) {\r\n    const event = events[uidEventList[i]];\r\n\r\n    if (\r\n      event.originalHandler === handler &&\r\n      event.delegationSelector === delegationSelector\r\n    ) {\r\n      return event;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction normalizeParams(originalTypeEvent, handler, delegationFn) {\r\n  const delegation = typeof handler === \"string\";\r\n  const originalHandler = delegation ? delegationFn : handler;\r\n\r\n  let typeEvent = getTypeEvent(originalTypeEvent);\r\n  const isNative = nativeEvents.has(typeEvent);\r\n\r\n  if (!isNative) {\r\n    typeEvent = originalTypeEvent;\r\n  }\r\n\r\n  return [delegation, originalHandler, typeEvent];\r\n}\r\n\r\nfunction addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {\r\n  if (typeof originalTypeEvent !== \"string\" || !element) {\r\n    return;\r\n  }\r\n\r\n  if (!handler) {\r\n    handler = delegationFn;\r\n    delegationFn = null;\r\n  }\r\n\r\n  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\r\n  // this prevents the handler from being dispatched the same way as mouseover or mouseout does\r\n  if (customEventsRegex.test(originalTypeEvent)) {\r\n    const wrapFn = (fn) => {\r\n      return function (event) {\r\n        if (\r\n          !event.relatedTarget ||\r\n          (event.relatedTarget !== event.delegateTarget &&\r\n            !event.delegateTarget.contains(event.relatedTarget))\r\n        ) {\r\n          return fn.call(this, event);\r\n        }\r\n      };\r\n    };\r\n\r\n    if (delegationFn) {\r\n      delegationFn = wrapFn(delegationFn);\r\n    } else {\r\n      handler = wrapFn(handler);\r\n    }\r\n  }\r\n\r\n  const [delegation, originalHandler, typeEvent] = normalizeParams(\r\n    originalTypeEvent,\r\n    handler,\r\n    delegationFn\r\n  );\r\n  const events = getEvent(element);\r\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\r\n  const previousFn = findHandler(\r\n    handlers,\r\n    originalHandler,\r\n    delegation ? handler : null\r\n  );\r\n\r\n  if (previousFn) {\r\n    previousFn.oneOff = previousFn.oneOff && oneOff;\r\n\r\n    return;\r\n  }\r\n\r\n  const uid = getUidEvent(\r\n    originalHandler,\r\n    originalTypeEvent.replace(namespaceRegex, \"\")\r\n  );\r\n  const fn = delegation\r\n    ? bootstrapDelegationHandler(element, handler, delegationFn)\r\n    : bootstrapHandler(element, handler);\r\n\r\n  fn.delegationSelector = delegation ? handler : null;\r\n  fn.originalHandler = originalHandler;\r\n  fn.oneOff = oneOff;\r\n  fn.uidEvent = uid;\r\n  handlers[uid] = fn;\r\n\r\n  element.addEventListener(typeEvent, fn, delegation);\r\n}\r\n\r\nfunction removeHandler(\r\n  element,\r\n  events,\r\n  typeEvent,\r\n  handler,\r\n  delegationSelector\r\n) {\r\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\r\n\r\n  if (!fn) {\r\n    return;\r\n  }\r\n\r\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\r\n  delete events[typeEvent][fn.uidEvent];\r\n}\r\n\r\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\r\n  const storeElementEvent = events[typeEvent] || {};\r\n\r\n  Object.keys(storeElementEvent).forEach((handlerKey) => {\r\n    if (handlerKey.includes(namespace)) {\r\n      const event = storeElementEvent[handlerKey];\r\n\r\n      removeHandler(\r\n        element,\r\n        events,\r\n        typeEvent,\r\n        event.originalHandler,\r\n        event.delegationSelector\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nfunction getTypeEvent(event) {\r\n  // allow to get the native events from namespaced events ('click.te.button' --> 'click')\r\n  event = event.replace(stripNameRegex, \"\");\r\n  return customEvents[event] || event;\r\n}\r\n\r\nconst EventHandler = {\r\n  on(element, event, handler, delegationFn) {\r\n    addHandler(element, event, handler, delegationFn, false);\r\n  },\r\n\r\n  one(element, event, handler, delegationFn) {\r\n    addHandler(element, event, handler, delegationFn, true);\r\n  },\r\n\r\n  off(element, originalTypeEvent, handler, delegationFn) {\r\n    if (typeof originalTypeEvent !== \"string\" || !element) {\r\n      return;\r\n    }\r\n\r\n    const [delegation, originalHandler, typeEvent] = normalizeParams(\r\n      originalTypeEvent,\r\n      handler,\r\n      delegationFn\r\n    );\r\n    const inNamespace = typeEvent !== originalTypeEvent;\r\n    const events = getEvent(element);\r\n    const isNamespace = originalTypeEvent.startsWith(\".\");\r\n\r\n    if (typeof originalHandler !== \"undefined\") {\r\n      // Simplest case: handler is passed, remove that listener ONLY.\r\n      if (!events || !events[typeEvent]) {\r\n        return;\r\n      }\r\n\r\n      removeHandler(\r\n        element,\r\n        events,\r\n        typeEvent,\r\n        originalHandler,\r\n        delegation ? handler : null\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (isNamespace) {\r\n      Object.keys(events).forEach((elementEvent) => {\r\n        removeNamespacedHandlers(\r\n          element,\r\n          events,\r\n          elementEvent,\r\n          originalTypeEvent.slice(1)\r\n        );\r\n      });\r\n    }\r\n\r\n    const storeElementEvent = events[typeEvent] || {};\r\n    Object.keys(storeElementEvent).forEach((keyHandlers) => {\r\n      const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\r\n\r\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\r\n        const event = storeElementEvent[keyHandlers];\r\n\r\n        removeHandler(\r\n          element,\r\n          events,\r\n          typeEvent,\r\n          event.originalHandler,\r\n          event.delegationSelector\r\n        );\r\n      }\r\n    });\r\n  },\r\n\r\n  trigger(element, event, args) {\r\n    if (typeof event !== \"string\" || !element) {\r\n      return null;\r\n    }\r\n\r\n    const $ = getjQuery();\r\n    const typeEvent = getTypeEvent(event);\r\n    const inNamespace = event !== typeEvent;\r\n    const isNative = nativeEvents.has(typeEvent);\r\n\r\n    let jQueryEvent;\r\n    let bubbles = true;\r\n    let nativeDispatch = true;\r\n    let defaultPrevented = false;\r\n    let evt = null;\r\n\r\n    if (inNamespace && $) {\r\n      jQueryEvent = $.Event(event, args);\r\n\r\n      $(element).trigger(jQueryEvent);\r\n      bubbles = !jQueryEvent.isPropagationStopped();\r\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\r\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\r\n    }\r\n\r\n    if (isNative) {\r\n      evt = document.createEvent(\"HTMLEvents\");\r\n      evt.initEvent(typeEvent, bubbles, true);\r\n    } else {\r\n      evt = new CustomEvent(event, {\r\n        bubbles,\r\n        cancelable: true,\r\n      });\r\n    }\r\n\r\n    // merge custom information in our event\r\n    if (typeof args !== \"undefined\") {\r\n      Object.keys(args).forEach((key) => {\r\n        Object.defineProperty(evt, key, {\r\n          get() {\r\n            return args[key];\r\n          },\r\n        });\r\n      });\r\n    }\r\n\r\n    if (defaultPrevented) {\r\n      evt.preventDefault();\r\n    }\r\n\r\n    if (nativeDispatch) {\r\n      element.dispatchEvent(evt);\r\n    }\r\n\r\n    if (evt.defaultPrevented && typeof jQueryEvent !== \"undefined\") {\r\n      jQueryEvent.preventDefault();\r\n    }\r\n\r\n    return evt;\r\n  },\r\n};\r\n\r\nexport const EventHandlerMulti = {\r\n  on(element, eventsName, handler, delegationFn) {\r\n    const events = eventsName.split(\" \");\r\n\r\n    for (let i = 0; i < events.length; i++) {\r\n      EventHandler.on(element, events[i], handler, delegationFn);\r\n    }\r\n  },\r\n  off(element, originalTypeEvent, handler, delegationFn) {\r\n    const events = originalTypeEvent.split(\" \");\r\n\r\n    for (let i = 0; i < events.length; i++) {\r\n      EventHandler.off(element, events[i], handler, delegationFn);\r\n    }\r\n  },\r\n};\r\n\r\nexport default EventHandler;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Data from \"./dom/data\";\r\nimport { executeAfterTransition, getElement } from \"./util/index\";\r\nimport EventHandler from \"./dom/event-handler\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst VERSION = \"5.1.3\";\r\n\r\nclass BaseComponent {\r\n  constructor(element) {\r\n    element = getElement(element);\r\n\r\n    if (!element) {\r\n      return;\r\n    }\r\n\r\n    this._element = element;\r\n    Data.setData(this._element, this.constructor.DATA_KEY, this);\r\n  }\r\n\r\n  dispose() {\r\n    Data.removeData(this._element, this.constructor.DATA_KEY);\r\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\r\n\r\n    Object.getOwnPropertyNames(this).forEach((propertyName) => {\r\n      this[propertyName] = null;\r\n    });\r\n  }\r\n\r\n  _queueCallback(callback, element, isAnimated = true) {\r\n    executeAfterTransition(callback, element, isAnimated);\r\n  }\r\n\r\n  /** Static */\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(getElement(element), this.DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n\r\n  static get VERSION() {\r\n    return VERSION;\r\n  }\r\n\r\n  static get NAME() {\r\n    throw new Error(\r\n      'You have to implement the static method \"NAME\", for each component!'\r\n    );\r\n  }\r\n\r\n  static get DATA_KEY() {\r\n    return `te.${this.NAME}`;\r\n  }\r\n\r\n  static get EVENT_KEY() {\r\n    return `.${this.DATA_KEY}`;\r\n  }\r\n}\r\n\r\nexport default BaseComponent;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"button\";\r\n\r\nconst CLASS_NAME_ACTIVE = \"active\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Button extends BaseComponent {\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  toggle() {\r\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\r\n    this._element.setAttribute(\r\n      \"aria-pressed\",\r\n      this._element.classList.toggle(CLASS_NAME_ACTIVE)\r\n    );\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Button.getOrCreateInstance(this);\r\n\r\n      if (config === \"toggle\") {\r\n        data[config]();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Button;\r\n","export var top = 'top';\nexport var bottom = 'bottom';\nexport var right = 'right';\nexport var left = 'left';\nexport var auto = 'auto';\nexport var basePlacements = [top, bottom, right, left];\nexport var start = 'start';\nexport var end = 'end';\nexport var clippingParents = 'clippingParents';\nexport var viewport = 'viewport';\nexport var popper = 'popper';\nexport var reference = 'reference';\nexport var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nexport var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nexport var beforeRead = 'beforeRead';\nexport var read = 'read';\nexport var afterRead = 'afterRead'; // pure-logic modifiers\n\nexport var beforeMain = 'beforeMain';\nexport var main = 'main';\nexport var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nexport var beforeWrite = 'beforeWrite';\nexport var write = 'write';\nexport var afterWrite = 'afterWrite';\nexport var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];","export default function getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}","export default function getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}","import getWindow from \"./getWindow.js\";\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };","import getNodeName from \"../dom-utils/getNodeName.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n};","import { auto } from \"../enums.js\";\nexport default function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}","export var max = Math.max;\nexport var min = Math.min;\nexport var round = Math.round;","export default function getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}","import getUAString from \"../utils/userAgent.js\";\nexport default function isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}","import { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nimport getWindow from \"./getWindow.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\"; // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nexport default function getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}","import { isShadowRoot } from \"./instanceOf.js\";\nexport default function contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}","import getWindow from \"./getWindow.js\";\nexport default function getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}","import getNodeName from \"./getNodeName.js\";\nexport default function isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}","import { isElement } from \"./instanceOf.js\";\nexport default function getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}","import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}","import getWindow from \"./getWindow.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isHTMLElement, isShadowRoot } from \"./instanceOf.js\";\nimport isTableElement from \"./isTableElement.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getUAString from \"../utils/userAgent.js\";\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","export default function getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}","import { max as mathMax, min as mathMin } from \"./math.js\";\nexport function within(min, value, max) {\n  return mathMax(min, mathMin(value, max));\n}\nexport function withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}","export default function getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}","import getFreshSideObject from \"./getFreshSideObject.js\";\nexport default function mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}","export default function expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport contains from \"../dom-utils/contains.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport { within } from \"../utils/within.js\";\nimport mergePaddingObject from \"../utils/mergePaddingObject.js\";\nimport expandToHashMap from \"../utils/expandToHashMap.js\";\nimport { left, right, basePlacements, top, bottom } from \"../enums.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","export default function getVariation(placement) {\n  return placement.split('-')[1];\n}","import { top, left, right, bottom, end } from \"../enums.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getWindow from \"../dom-utils/getWindow.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getComputedStyle from \"../dom-utils/getComputedStyle.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport { round } from \"../utils/math.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","import getWindow from \"../dom-utils/getWindow.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};","var hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nexport default function getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}","var hash = {\n  start: 'end',\n  end: 'start'\n};\nexport default function getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}","import getWindow from \"./getWindow.js\";\nexport default function getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nexport default function getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}","import getWindow from \"./getWindow.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}","import getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nimport { max } from \"../utils/math.js\"; // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nexport default function getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}","import getComputedStyle from \"./getComputedStyle.js\";\nexport default function isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}","import getParentNode from \"./getParentNode.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nexport default function getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}","import getScrollParent from \"./getScrollParent.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getWindow from \"./getWindow.js\";\nimport isScrollParent from \"./isScrollParent.js\";\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nexport default function listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}","export default function rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}","import { viewport } from \"../enums.js\";\nimport getViewportRect from \"./getViewportRect.js\";\nimport getDocumentRect from \"./getDocumentRect.js\";\nimport listScrollParents from \"./listScrollParents.js\";\nimport getOffsetParent from \"./getOffsetParent.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport contains from \"./contains.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport rectToClientRect from \"../utils/rectToClientRect.js\";\nimport { max, min } from \"../utils/math.js\";\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nexport default function getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","import getBasePlacement from \"./getBasePlacement.js\";\nimport getVariation from \"./getVariation.js\";\nimport getMainAxisFromPlacement from \"./getMainAxisFromPlacement.js\";\nimport { top, right, bottom, left, start, end } from \"../enums.js\";\nexport default function computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}","import getClippingRect from \"../dom-utils/getClippingRect.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getBoundingClientRect from \"../dom-utils/getBoundingClientRect.js\";\nimport computeOffsets from \"./computeOffsets.js\";\nimport rectToClientRect from \"./rectToClientRect.js\";\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from \"../enums.js\";\nimport { isElement } from \"../dom-utils/instanceOf.js\";\nimport mergePaddingObject from \"./mergePaddingObject.js\";\nimport expandToHashMap from \"./expandToHashMap.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport default function detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","import getVariation from \"./getVariation.js\";\nimport { variationPlacements, basePlacements, placements as allPlacements } from \"../enums.js\";\nimport detectOverflow from \"./detectOverflow.js\";\nimport getBasePlacement from \"./getBasePlacement.js\";\nexport default function computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(' '));\n    }\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","import getOppositePlacement from \"../utils/getOppositePlacement.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getOppositeVariationPlacement from \"../utils/getOppositeVariationPlacement.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport computeAutoPlacement from \"../utils/computeAutoPlacement.js\";\nimport { bottom, top, start, right, left, auto } from \"../enums.js\";\nimport getVariation from \"../utils/getVariation.js\"; // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","import { top, bottom, left, right } from \"../enums.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport { top, left, right, placements } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};","import computeOffsets from \"../utils/computeOffsets.js\";\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};","export default function getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}","import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","export default function getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}","import getWindowScroll from \"./getWindowScroll.js\";\nimport getWindow from \"./getWindow.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getHTMLElementScroll from \"./getHTMLElementScroll.js\";\nexport default function getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getNodeScroll from \"./getNodeScroll.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport { round } from \"../utils/math.js\";\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nexport default function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}","import { modifierPhases } from \"../enums.js\"; // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nexport default function orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}","export default function debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}","export default function format(str) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}","import format from \"./format.js\";\nimport { modifierPhases } from \"../enums.js\";\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];\nexport default function validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`\n    .filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    }).forEach(function (key) {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', \"\\\"\" + String(modifier.name) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', \"\\\"\" + String(modifier.enabled) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'phase':\n          if (modifierPhases.indexOf(modifier.phase) < 0) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(', '), \"\\\"\" + String(modifier.phase) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'effect':\n          if (modifier.effect != null && typeof modifier.effect !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requires':\n          if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', \"\\\"\" + String(modifier.requires) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requiresIfExists':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', \"\\\"\" + String(modifier.requiresIfExists) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'options':\n        case 'data':\n          break;\n\n        default:\n          console.error(\"PopperJS: an invalid property has been provided to the \\\"\" + modifier.name + \"\\\" modifier, valid properties are \" + VALID_PROPERTIES.map(function (s) {\n            return \"\\\"\" + s + \"\\\"\";\n          }).join(', ') + \"; but \\\"\" + key + \"\\\" was provided.\");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}","export default function uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}","export default function mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}","import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow };","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nimport offset from \"./modifiers/offset.js\";\nimport flip from \"./modifiers/flip.js\";\nimport preventOverflow from \"./modifiers/preventOverflow.js\";\nimport arrow from \"./modifiers/arrow.js\";\nimport hide from \"./modifiers/hide.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles, offset, flip, preventOverflow, arrow, hide];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow }; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper as createPopperLite } from \"./popper-lite.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport * from \"./modifiers/index.js\";","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nfunction normalizeData(val) {\r\n  if (val === \"true\") {\r\n    return true;\r\n  }\r\n\r\n  if (val === \"false\") {\r\n    return false;\r\n  }\r\n\r\n  if (val === Number(val).toString()) {\r\n    return Number(val);\r\n  }\r\n\r\n  if (val === \"\" || val === \"null\") {\r\n    return null;\r\n  }\r\n\r\n  return val;\r\n}\r\n\r\nfunction normalizeDataKey(key) {\r\n  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);\r\n}\r\n\r\nconst Manipulator = {\r\n  setDataAttribute(element, key, value) {\r\n    element.setAttribute(`data-te-${normalizeDataKey(key)}`, value);\r\n  },\r\n\r\n  removeDataAttribute(element, key) {\r\n    element.removeAttribute(`data-te-${normalizeDataKey(key)}`);\r\n  },\r\n\r\n  getDataAttributes(element) {\r\n    if (!element) {\r\n      return {};\r\n    }\r\n\r\n    const attributes = {};\r\n\r\n    Object.keys(element.dataset)\r\n      .filter((key) => key.startsWith(\"te\"))\r\n      .forEach((key) => {\r\n        if (key.startsWith(\"teClass\")) {\r\n          return;\r\n        }\r\n\r\n        let pureKey = key.replace(/^te/, \"\");\r\n        pureKey =\r\n          pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\r\n        attributes[pureKey] = normalizeData(element.dataset[key]);\r\n      });\r\n\r\n    return attributes;\r\n  },\r\n\r\n  getDataClassAttributes(element) {\r\n    if (!element) {\r\n      return {};\r\n    }\r\n\r\n    const attributes = {\r\n      ...element.dataset,\r\n    };\r\n\r\n    Object.keys(attributes)\r\n      .filter((key) => key.startsWith(\"teClass\"))\r\n      .forEach((key) => {\r\n        let pureKey = key.replace(/^teClass/, \"\");\r\n        pureKey =\r\n          pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\r\n        attributes[pureKey] = normalizeData(attributes[key]);\r\n      });\r\n\r\n    return attributes;\r\n  },\r\n\r\n  getDataAttribute(element, key) {\r\n    return normalizeData(\r\n      element.getAttribute(`data-te-${normalizeDataKey(key)}`)\r\n    );\r\n  },\r\n\r\n  offset(element) {\r\n    const rect = element.getBoundingClientRect();\r\n\r\n    return {\r\n      top: rect.top + document.body.scrollTop,\r\n      left: rect.left + document.body.scrollLeft,\r\n    };\r\n  },\r\n\r\n  position(element) {\r\n    return {\r\n      top: element.offsetTop,\r\n      left: element.offsetLeft,\r\n    };\r\n  },\r\n\r\n  style(element, style) {\r\n    Object.assign(element.style, style);\r\n  },\r\n\r\n  toggleClass(element, classNameOrList) {\r\n    if (!element) {\r\n      return;\r\n    }\r\n\r\n    _classNameOrListToArray(classNameOrList).forEach((className) => {\r\n      if (element.classList.contains(className)) {\r\n        element.classList.remove(className);\r\n      } else {\r\n        element.classList.add(className);\r\n      }\r\n    });\r\n  },\r\n\r\n  addClass(element, classNameOrList) {\r\n    _classNameOrListToArray(classNameOrList).forEach(\r\n      (className) =>\r\n        !element.classList.contains(className) &&\r\n        element.classList.add(className)\r\n    );\r\n  },\r\n\r\n  addStyle(element, style) {\r\n    Object.keys(style).forEach((property) => {\r\n      element.style[property] = style[property];\r\n    });\r\n  },\r\n\r\n  removeClass(element, classNameOrList) {\r\n    _classNameOrListToArray(classNameOrList).forEach(\r\n      (className) =>\r\n        element.classList.contains(className) &&\r\n        element.classList.remove(className)\r\n    );\r\n  },\r\n\r\n  hasClass(element, className) {\r\n    return element.classList.contains(className);\r\n  },\r\n};\r\n\r\nfunction _classNameOrListToArray(classNameOrList) {\r\n  if (typeof classNameOrList === \"string\") {\r\n    return classNameOrList.split(\" \");\r\n  } else if (Array.isArray(classNameOrList)) {\r\n    return classNameOrList;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport default Manipulator;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nimport { isDisabled, isVisible } from \"../util/index\";\r\n\r\nconst NODE_TEXT = 3;\r\n\r\nconst SelectorEngine = {\r\n  closest(element, selector) {\r\n    return element.closest(selector);\r\n  },\r\n\r\n  matches(element, selector) {\r\n    return element.matches(selector);\r\n  },\r\n\r\n  find(selector, element = document.documentElement) {\r\n    return [].concat(\r\n      ...Element.prototype.querySelectorAll.call(element, selector)\r\n    );\r\n  },\r\n\r\n  findOne(selector, element = document.documentElement) {\r\n    return Element.prototype.querySelector.call(element, selector);\r\n  },\r\n\r\n  children(element, selector) {\r\n    const children = [].concat(...element.children);\r\n\r\n    return children.filter((child) => child.matches(selector));\r\n  },\r\n\r\n  parents(element, selector) {\r\n    const parents = [];\r\n\r\n    let ancestor = element.parentNode;\r\n\r\n    while (\r\n      ancestor &&\r\n      ancestor.nodeType === Node.ELEMENT_NODE &&\r\n      ancestor.nodeType !== NODE_TEXT\r\n    ) {\r\n      if (this.matches(ancestor, selector)) {\r\n        parents.push(ancestor);\r\n      }\r\n\r\n      ancestor = ancestor.parentNode;\r\n    }\r\n\r\n    return parents;\r\n  },\r\n\r\n  prev(element, selector) {\r\n    let previous = element.previousElementSibling;\r\n\r\n    while (previous) {\r\n      if (previous.matches(selector)) {\r\n        return [previous];\r\n      }\r\n\r\n      previous = previous.previousElementSibling;\r\n    }\r\n\r\n    return [];\r\n  },\r\n\r\n  next(element, selector) {\r\n    let next = element.nextElementSibling;\r\n\r\n    while (next) {\r\n      if (this.matches(next, selector)) {\r\n        return [next];\r\n      }\r\n\r\n      next = next.nextElementSibling;\r\n    }\r\n\r\n    return [];\r\n  },\r\n\r\n  focusableChildren(element) {\r\n    const focusables = [\r\n      \"a\",\r\n      \"button\",\r\n      \"input\",\r\n      \"textarea\",\r\n      \"select\",\r\n      \"details\",\r\n      \"[tabindex]\",\r\n      '[contenteditable=\"true\"]',\r\n    ]\r\n      .map((selector) => `${selector}:not([tabindex^=\"-\"])`)\r\n      .join(\", \");\r\n\r\n    return this.find(focusables, element).filter(\r\n      (el) => !isDisabled(el) && isVisible(el)\r\n    );\r\n  },\r\n};\r\n\r\nexport default SelectorEngine;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\nimport * as Popper from \"@popperjs/core\";\r\n\r\nimport {\r\n  getElement,\r\n  getElementFromSelector,\r\n  getNextActiveElement,\r\n  isDisabled,\r\n  isElement,\r\n  isRTL,\r\n  isVisible,\r\n  noop,\r\n  typeCheckConfig,\r\n} from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"dropdown\";\r\nconst DATA_KEY = \"te.dropdown\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\n\r\nconst ESCAPE_KEY = \"Escape\";\r\nconst SPACE_KEY = \"Space\";\r\nconst TAB_KEY = \"Tab\";\r\nconst ARROW_UP_KEY = \"ArrowUp\";\r\nconst ARROW_DOWN_KEY = \"ArrowDown\";\r\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\r\n\r\nconst REGEXP_KEYDOWN = new RegExp(\r\n  `${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY}`\r\n);\r\n\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY}${DATA_API_KEY}`;\r\n\r\nconst CLASS_NAME_SHOW = \"show\";\r\nconst CLASS_NAME_DROPUP = \"dropup\";\r\nconst CLASS_NAME_DROPEND = \"dropend\";\r\nconst CLASS_NAME_DROPSTART = \"dropstart\";\r\n\r\nconst SELECTOR_NAVBAR = \"[data-te-navbar-ref]\";\r\nconst SELECTOR_DATA_TOGGLE = \"[data-te-dropdown-toggle-ref]\";\r\nconst SELECTOR_MENU = \"[data-te-dropdown-menu-ref]\";\r\nconst SELECTOR_NAVBAR_NAV = \"[data-te-navbar-nav-ref]\";\r\nconst SELECTOR_VISIBLE_ITEMS =\r\n  \"[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)\";\r\n\r\nconst PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\r\nconst PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\r\nconst PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\r\nconst PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\r\nconst PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\r\nconst PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\r\n\r\nconst ANIMATION_FADE_IN = [{ opacity: \"0\" }, { opacity: \"1\" }];\r\nconst ANIMATION_FADE_OUT = [{ opacity: \"1\" }, { opacity: \"0\" }];\r\n\r\nconst ANIMATION_TIMING = {\r\n  duration: 550,\r\n  iterations: 1,\r\n  easing: \"ease\",\r\n  fill: \"both\",\r\n};\r\n\r\nconst Default = {\r\n  offset: [0, 2],\r\n  boundary: \"clippingParents\",\r\n  reference: \"toggle\",\r\n  display: \"dynamic\",\r\n  popperConfig: null,\r\n  autoClose: true,\r\n  dropdownAnimation: \"on\",\r\n};\r\n\r\nconst DefaultType = {\r\n  offset: \"(array|string|function)\",\r\n  boundary: \"(string|element)\",\r\n  reference: \"(string|element|object)\",\r\n  display: \"string\",\r\n  popperConfig: \"(null|object|function)\",\r\n  autoClose: \"(boolean|string)\",\r\n  dropdownAnimation: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Dropdown extends BaseComponent {\r\n  constructor(element, config) {\r\n    super(element);\r\n\r\n    this._popper = null;\r\n    this._config = this._getConfig(config);\r\n    this._menu = this._getMenuElement();\r\n    this._inNavbar = this._detectNavbar();\r\n    this._fadeOutAnimate = null;\r\n\r\n    //* prevents dropdown close issue when system animation is turned off\r\n    const isPrefersReducedMotionSet = window.matchMedia(\r\n      \"(prefers-reduced-motion: reduce)\"\r\n    ).matches;\r\n    this._animationCanPlay =\r\n      this._config.dropdownAnimation === \"on\" && !isPrefersReducedMotionSet;\r\n\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get DefaultType() {\r\n    return DefaultType;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  toggle() {\r\n    return this._isShown() ? this.hide() : this.show();\r\n  }\r\n\r\n  show() {\r\n    if (isDisabled(this._element) || this._isShown(this._menu)) {\r\n      return;\r\n    }\r\n\r\n    const relatedTarget = {\r\n      relatedTarget: this._element,\r\n    };\r\n\r\n    const showEvent = EventHandler.trigger(\r\n      this._element,\r\n      EVENT_SHOW,\r\n      relatedTarget\r\n    );\r\n\r\n    if (showEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const parent = Dropdown.getParentFromElement(this._element);\r\n    // Totally disable Popper for Dropdowns in Navbar\r\n    if (this._inNavbar) {\r\n      Manipulator.setDataAttribute(this._menu, \"popper\", \"none\");\r\n    } else {\r\n      this._createPopper(parent);\r\n    }\r\n\r\n    // If this is a touch-enabled device we add extra\r\n    // empty mouseover listeners to the body's immediate children;\r\n    // only needed because of broken event delegation on iOS\r\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n    if (\r\n      \"ontouchstart\" in document.documentElement &&\r\n      !parent.closest(SELECTOR_NAVBAR_NAV)\r\n    ) {\r\n      []\r\n        .concat(...document.body.children)\r\n        .forEach((elem) => EventHandler.on(elem, \"mouseover\", noop));\r\n    }\r\n\r\n    this._element.focus();\r\n    this._element.setAttribute(\"aria-expanded\", true);\r\n\r\n    this._menu.setAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`, \"\");\r\n    this._animationCanPlay &&\r\n      this._menu.animate(ANIMATION_FADE_IN, ANIMATION_TIMING);\r\n    this._element.setAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`, \"\");\r\n\r\n    setTimeout(\r\n      () => {\r\n        EventHandler.trigger(this._element, EVENT_SHOWN, relatedTarget);\r\n      },\r\n      this._animationCanPlay ? ANIMATION_TIMING.duration : 0\r\n    );\r\n  }\r\n\r\n  hide() {\r\n    if (isDisabled(this._element) || !this._isShown(this._menu)) {\r\n      return;\r\n    }\r\n\r\n    const relatedTarget = {\r\n      relatedTarget: this._element,\r\n    };\r\n\r\n    this._completeHide(relatedTarget);\r\n  }\r\n\r\n  dispose() {\r\n    if (this._popper) {\r\n      this._popper.destroy();\r\n    }\r\n\r\n    super.dispose();\r\n  }\r\n\r\n  update() {\r\n    this._inNavbar = this._detectNavbar();\r\n    if (this._popper) {\r\n      this._popper.update();\r\n    }\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n\r\n    EventHandler.on(\r\n      document,\r\n      EVENT_KEYDOWN_DATA_API,\r\n      SELECTOR_DATA_TOGGLE,\r\n      Dropdown.dataApiKeydownHandler\r\n    );\r\n    EventHandler.on(\r\n      document,\r\n      EVENT_KEYDOWN_DATA_API,\r\n      SELECTOR_MENU,\r\n      Dropdown.dataApiKeydownHandler\r\n    );\r\n    EventHandler.on(document, EVENT_CLICK_DATA_API, Dropdown.clearMenus);\r\n    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\r\n\r\n    this._didInit = true;\r\n  }\r\n\r\n  _completeHide(relatedTarget) {\r\n    if (this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\") {\r\n      return;\r\n    }\r\n\r\n    const hideEvent = EventHandler.trigger(\r\n      this._element,\r\n      EVENT_HIDE,\r\n      relatedTarget\r\n    );\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    // If this is a touch-enabled device we remove the extra\r\n    // empty mouseover listeners we added for iOS support\r\n    if (\"ontouchstart\" in document.documentElement) {\r\n      []\r\n        .concat(...document.body.children)\r\n        .forEach((elem) => EventHandler.off(elem, \"mouseover\", noop));\r\n    }\r\n\r\n    if (this._animationCanPlay) {\r\n      this._fadeOutAnimate = this._menu.animate(\r\n        ANIMATION_FADE_OUT,\r\n        ANIMATION_TIMING\r\n      );\r\n    }\r\n\r\n    setTimeout(\r\n      () => {\r\n        if (this._popper) {\r\n          this._popper.destroy();\r\n        }\r\n\r\n        this._menu.removeAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`);\r\n        this._element.removeAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`);\r\n\r\n        this._element.setAttribute(\"aria-expanded\", \"false\");\r\n        Manipulator.removeDataAttribute(this._menu, \"popper\");\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN, relatedTarget);\r\n      },\r\n      this._animationCanPlay ? ANIMATION_TIMING.duration : 0\r\n    );\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...this.constructor.Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\r\n\r\n    if (\r\n      typeof config.reference === \"object\" &&\r\n      !isElement(config.reference) &&\r\n      typeof config.reference.getBoundingClientRect !== \"function\"\r\n    ) {\r\n      // Popper virtual elements require a getBoundingClientRect method\r\n      throw new TypeError(\r\n        `${NAME.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\r\n      );\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  _createPopper(parent) {\r\n    if (typeof Popper === \"undefined\") {\r\n      throw new TypeError(\r\n        \"Bootstrap's dropdowns require Popper (https://popper.js.org)\"\r\n      );\r\n    }\r\n\r\n    let referenceElement = this._element;\r\n\r\n    if (this._config.reference === \"parent\") {\r\n      referenceElement = parent;\r\n    } else if (isElement(this._config.reference)) {\r\n      referenceElement = getElement(this._config.reference);\r\n    } else if (typeof this._config.reference === \"object\") {\r\n      referenceElement = this._config.reference;\r\n    }\r\n\r\n    const popperConfig = this._getPopperConfig();\r\n    const isDisplayStatic = popperConfig.modifiers.find(\r\n      (modifier) =>\r\n        modifier.name === \"applyStyles\" && modifier.enabled === false\r\n    );\r\n\r\n    this._popper = Popper.createPopper(\r\n      referenceElement,\r\n      this._menu,\r\n      popperConfig\r\n    );\r\n\r\n    if (isDisplayStatic) {\r\n      Manipulator.setDataAttribute(this._menu, \"popper\", \"static\");\r\n    }\r\n  }\r\n\r\n  _isShown(element = this._element) {\r\n    return (\r\n      element.dataset[\r\n        `teDropdown${\r\n          CLASS_NAME_SHOW.charAt(0).toUpperCase() + CLASS_NAME_SHOW.slice(1)\r\n        }`\r\n      ] === \"\"\r\n    );\r\n  }\r\n\r\n  _getMenuElement() {\r\n    return SelectorEngine.next(this._element, SELECTOR_MENU)[0];\r\n  }\r\n\r\n  _getPlacement() {\r\n    const parentDropdown = this._element.parentNode;\r\n\r\n    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPEND) {\r\n      return PLACEMENT_RIGHT;\r\n    }\r\n\r\n    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPSTART) {\r\n      return PLACEMENT_LEFT;\r\n    }\r\n\r\n    // We need to trim the value because custom properties can also include spaces\r\n    const isEnd =\r\n      getComputedStyle(this._menu).getPropertyValue(\"--te-position\").trim() ===\r\n      \"end\";\r\n\r\n    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPUP) {\r\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\r\n    }\r\n\r\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\r\n  }\r\n\r\n  _detectNavbar() {\r\n    return this._element.closest(SELECTOR_NAVBAR) !== null;\r\n  }\r\n\r\n  _getOffset() {\r\n    const { offset } = this._config;\r\n\r\n    if (typeof offset === \"string\") {\r\n      return offset.split(\",\").map((val) => Number.parseInt(val, 10));\r\n    }\r\n\r\n    if (typeof offset === \"function\") {\r\n      return (popperData) => offset(popperData, this._element);\r\n    }\r\n\r\n    return offset;\r\n  }\r\n\r\n  _getPopperConfig() {\r\n    const defaultBsPopperConfig = {\r\n      placement: this._getPlacement(),\r\n      modifiers: [\r\n        {\r\n          name: \"preventOverflow\",\r\n          options: {\r\n            boundary: this._config.boundary,\r\n          },\r\n        },\r\n        {\r\n          name: \"offset\",\r\n          options: {\r\n            offset: this._getOffset(),\r\n          },\r\n        },\r\n      ],\r\n    };\r\n\r\n    // Disable Popper if we have a static display\r\n    if (this._config.display === \"static\") {\r\n      defaultBsPopperConfig.modifiers = [\r\n        {\r\n          name: \"applyStyles\",\r\n          enabled: false,\r\n        },\r\n      ];\r\n    }\r\n\r\n    return {\r\n      ...defaultBsPopperConfig,\r\n      ...(typeof this._config.popperConfig === \"function\"\r\n        ? this._config.popperConfig(defaultBsPopperConfig)\r\n        : this._config.popperConfig),\r\n    };\r\n  }\r\n\r\n  _selectMenuItem({ key, target }) {\r\n    const items = SelectorEngine.find(\r\n      SELECTOR_VISIBLE_ITEMS,\r\n      this._menu\r\n    ).filter(isVisible);\r\n\r\n    if (!items.length) {\r\n      return;\r\n    }\r\n\r\n    // if target isn't included in items (e.g. when expanding the dropdown)\r\n    // allow cycling to get the last item in case key equals ARROW_UP_KEY\r\n    getNextActiveElement(\r\n      items,\r\n      target,\r\n      key === ARROW_DOWN_KEY,\r\n      !items.includes(target)\r\n    ).focus();\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Dropdown.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config !== \"string\") {\r\n        return;\r\n      }\r\n\r\n      if (typeof data[config] === \"undefined\") {\r\n        throw new TypeError(`No method named \"${config}\"`);\r\n      }\r\n\r\n      data[config]();\r\n    });\r\n  }\r\n\r\n  static clearMenus(event) {\r\n    if (\r\n      event &&\r\n      (event.button === RIGHT_MOUSE_BUTTON ||\r\n        (event.type === \"keyup\" && event.key !== TAB_KEY))\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE);\r\n\r\n    for (let i = 0, len = toggles.length; i < len; i++) {\r\n      const context = Dropdown.getInstance(toggles[i]);\r\n      if (!context || context._config.autoClose === false) {\r\n        continue;\r\n      }\r\n\r\n      if (!context._isShown()) {\r\n        continue;\r\n      }\r\n\r\n      const relatedTarget = {\r\n        relatedTarget: context._element,\r\n      };\r\n\r\n      if (event) {\r\n        const composedPath = event.composedPath();\r\n        const isMenuTarget = composedPath.includes(context._menu);\r\n        if (\r\n          composedPath.includes(context._element) ||\r\n          (context._config.autoClose === \"inside\" && !isMenuTarget) ||\r\n          (context._config.autoClose === \"outside\" && isMenuTarget)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\r\n        if (\r\n          context._menu.contains(event.target) &&\r\n          ((event.type === \"keyup\" && event.key === TAB_KEY) ||\r\n            /input|select|option|textarea|form/i.test(event.target.tagName))\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        if (event.type === \"click\") {\r\n          relatedTarget.clickEvent = event;\r\n        }\r\n      }\r\n\r\n      context._completeHide(relatedTarget);\r\n    }\r\n  }\r\n\r\n  static getParentFromElement(element) {\r\n    return getElementFromSelector(element) || element.parentNode;\r\n  }\r\n\r\n  static dataApiKeydownHandler(event) {\r\n    // If not input/textarea:\r\n    //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\r\n    // If input/textarea:\r\n    //  - If space key => not a dropdown command\r\n    //  - If key is other than escape\r\n    //    - If key is not up or down => not a dropdown command\r\n    //    - If trigger inside the menu => not a dropdown command\r\n    if (\r\n      /input|textarea/i.test(event.target.tagName)\r\n        ? event.key === SPACE_KEY ||\r\n          (event.key !== ESCAPE_KEY &&\r\n            ((event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY) ||\r\n              event.target.closest(SELECTOR_MENU)))\r\n        : !REGEXP_KEYDOWN.test(event.key)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const isActive =\r\n      this.dataset[\r\n        `teDropdown${\r\n          CLASS_NAME_SHOW.charAt(0).toUpperCase() + CLASS_NAME_SHOW.slice(1)\r\n        }`\r\n      ] === \"\";\r\n\r\n    if (!isActive && event.key === ESCAPE_KEY) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n\r\n    if (isDisabled(this)) {\r\n      return;\r\n    }\r\n\r\n    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE)\r\n      ? this\r\n      : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE)[0];\r\n    const instance = Dropdown.getOrCreateInstance(getToggleButton);\r\n\r\n    if (event.key === ESCAPE_KEY) {\r\n      instance.hide();\r\n      return;\r\n    }\r\n\r\n    if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {\r\n      if (!isActive) {\r\n        instance.show();\r\n      }\r\n\r\n      instance._selectMenuItem(event);\r\n      return;\r\n    }\r\n\r\n    if (!isActive || event.key === SPACE_KEY) {\r\n      Dropdown.clearMenus();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Dropdown;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport {\r\n  getElement,\r\n  getSelectorFromElement,\r\n  getElementFromSelector,\r\n  reflow,\r\n  typeCheckConfig,\r\n} from \"../util/index\";\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"collapse\";\r\nconst DATA_KEY = \"te.collapse\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\n\r\nconst Default = {\r\n  toggle: true,\r\n  parent: null,\r\n};\r\n\r\nconst DefaultType = {\r\n  toggle: \"boolean\",\r\n  parent: \"(null|element)\",\r\n};\r\n\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\n\r\nconst ATTR_SHOW = \"data-te-collapse-show\";\r\nconst ATTR_COLLAPSED = \"data-te-collapse-collapsed\";\r\nconst ATTR_COLLAPSING = \"data-te-collapse-collapsing\";\r\nconst ATTR_HORIZONTAL = \"data-te-collapse-horizontal\";\r\nconst ATTR_COLLAPSE_ITEM = \"data-te-collapse-item\";\r\nconst ATTR_COLLAPSE_DEEPER_CHILDREN = `:scope [${ATTR_COLLAPSE_ITEM}] [${ATTR_COLLAPSE_ITEM}]`;\r\n\r\nconst WIDTH = \"width\";\r\nconst HEIGHT = \"height\";\r\n\r\nconst SELECTOR_DATA_ACTIVES =\r\n  \"[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]\";\r\nconst SELECTOR_DATA_COLLAPSE_INIT = \"[data-te-collapse-init]\";\r\n\r\nconst DefaultClasses = {\r\n  visible: \"!visible\",\r\n  hidden: \"hidden\",\r\n  baseTransition:\r\n    \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\r\n  collapsing:\r\n    \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\r\n  collapsingHorizontal:\r\n    \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  visible: \"string\",\r\n  hidden: \"string\",\r\n  baseTransition: \"string\",\r\n  collapsing: \"string\",\r\n  collapsingHorizontal: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Collapse extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n\r\n    this._isTransitioning = false;\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._triggerArray = [];\r\n\r\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_COLLAPSE_INIT);\r\n\r\n    for (let i = 0, len = toggleList.length; i < len; i++) {\r\n      const elem = toggleList[i];\r\n      const selector = getSelectorFromElement(elem);\r\n      const filterElement = SelectorEngine.find(selector).filter(\r\n        (foundElem) => foundElem === this._element\r\n      );\r\n\r\n      if (selector !== null && filterElement.length) {\r\n        this._selector = selector;\r\n        this._triggerArray.push(elem);\r\n      }\r\n    }\r\n\r\n    this._initializeChildren();\r\n\r\n    if (!this._config.parent) {\r\n      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\r\n    }\r\n\r\n    if (this._config.toggle) {\r\n      this.toggle();\r\n    }\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  toggle() {\r\n    if (this._isShown()) {\r\n      this.hide();\r\n    } else {\r\n      this.show();\r\n    }\r\n  }\r\n\r\n  show() {\r\n    if (this._isTransitioning || this._isShown()) {\r\n      return;\r\n    }\r\n\r\n    let actives = [];\r\n    let activesData;\r\n\r\n    if (this._config.parent) {\r\n      const children = SelectorEngine.find(\r\n        ATTR_COLLAPSE_DEEPER_CHILDREN,\r\n        this._config.parent\r\n      );\r\n      actives = SelectorEngine.find(\r\n        SELECTOR_DATA_ACTIVES,\r\n        this._config.parent\r\n      ).filter((elem) => !children.includes(elem)); // remove children if greater depth\r\n    }\r\n\r\n    const container = SelectorEngine.findOne(this._selector);\r\n    if (actives.length) {\r\n      const tempActiveData = actives.find((elem) => container !== elem);\r\n      activesData = tempActiveData\r\n        ? Collapse.getInstance(tempActiveData)\r\n        : null;\r\n\r\n      if (activesData && activesData._isTransitioning) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW);\r\n    if (startEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    actives.forEach((elemActive) => {\r\n      if (container !== elemActive) {\r\n        Collapse.getOrCreateInstance(elemActive, { toggle: false }).hide();\r\n      }\r\n\r\n      if (!activesData) {\r\n        Data.setData(elemActive, DATA_KEY, null);\r\n      }\r\n    });\r\n\r\n    const dimension = this._getDimension();\r\n    const CLASS_NAME_TRANSITION =\r\n      dimension === \"height\"\r\n        ? this._classes.collapsing\r\n        : this._classes.collapsingHorizontal;\r\n\r\n    Manipulator.removeClass(this._element, this._classes.visible);\r\n    Manipulator.removeClass(this._element, this._classes.hidden);\r\n    Manipulator.addClass(this._element, CLASS_NAME_TRANSITION);\r\n    this._element.removeAttribute(ATTR_COLLAPSE_ITEM);\r\n    this._element.setAttribute(ATTR_COLLAPSING, \"\");\r\n\r\n    this._element.style[dimension] = 0;\r\n\r\n    this._addAriaAndCollapsedClass(this._triggerArray, true);\r\n    this._isTransitioning = true;\r\n\r\n    const complete = () => {\r\n      this._isTransitioning = false;\r\n\r\n      Manipulator.removeClass(this._element, this._classes.hidden);\r\n      Manipulator.removeClass(this._element, CLASS_NAME_TRANSITION);\r\n      Manipulator.addClass(this._element, this._classes.visible);\r\n      this._element.removeAttribute(ATTR_COLLAPSING);\r\n      this._element.setAttribute(ATTR_COLLAPSE_ITEM, \"\");\r\n      this._element.setAttribute(ATTR_SHOW, \"\");\r\n\r\n      this._element.style[dimension] = \"\";\r\n\r\n      EventHandler.trigger(this._element, EVENT_SHOWN);\r\n    };\r\n\r\n    const capitalizedDimension =\r\n      dimension[0].toUpperCase() + dimension.slice(1);\r\n    const scrollSize = `scroll${capitalizedDimension}`;\r\n\r\n    this._queueCallback(complete, this._element, true);\r\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\r\n  }\r\n\r\n  hide() {\r\n    if (this._isTransitioning || !this._isShown()) {\r\n      return;\r\n    }\r\n\r\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n    if (startEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const dimension = this._getDimension();\r\n    const CLASS_NAME_TRANSITION =\r\n      dimension === \"height\"\r\n        ? this._classes.collapsing\r\n        : this._classes.collapsingHorizontal;\r\n\r\n    this._element.style[dimension] = `${\r\n      this._element.getBoundingClientRect()[dimension]\r\n    }px`;\r\n\r\n    reflow(this._element);\r\n\r\n    Manipulator.addClass(this._element, CLASS_NAME_TRANSITION);\r\n    Manipulator.removeClass(this._element, this._classes.visible);\r\n    Manipulator.removeClass(this._element, this._classes.hidden);\r\n    this._element.setAttribute(ATTR_COLLAPSING, \"\");\r\n    this._element.removeAttribute(ATTR_COLLAPSE_ITEM);\r\n    this._element.removeAttribute(ATTR_SHOW);\r\n\r\n    const triggerArrayLength = this._triggerArray.length;\r\n    for (let i = 0; i < triggerArrayLength; i++) {\r\n      const trigger = this._triggerArray[i];\r\n      const elem = getElementFromSelector(trigger);\r\n\r\n      if (elem && !this._isShown(elem)) {\r\n        this._addAriaAndCollapsedClass([trigger], false);\r\n      }\r\n    }\r\n\r\n    this._isTransitioning = true;\r\n\r\n    const complete = () => {\r\n      this._isTransitioning = false;\r\n\r\n      Manipulator.removeClass(this._element, CLASS_NAME_TRANSITION);\r\n      Manipulator.addClass(this._element, this._classes.visible);\r\n      Manipulator.addClass(this._element, this._classes.hidden);\r\n\r\n      this._element.removeAttribute(ATTR_COLLAPSING);\r\n      this._element.setAttribute(ATTR_COLLAPSE_ITEM, \"\");\r\n\r\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n    };\r\n\r\n    this._element.style[dimension] = \"\";\r\n\r\n    this._queueCallback(complete, this._element, true);\r\n  }\r\n\r\n  _isShown(element = this._element) {\r\n    return element.hasAttribute(ATTR_SHOW);\r\n  }\r\n\r\n  // Private\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...config,\r\n    };\r\n    config.toggle = Boolean(config.toggle); // Coerce string values\r\n    config.parent = getElement(config.parent);\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n    return classes;\r\n  }\r\n\r\n  _getDimension() {\r\n    return this._element.hasAttribute(ATTR_HORIZONTAL) ? WIDTH : HEIGHT;\r\n  }\r\n\r\n  _initializeChildren() {\r\n    if (!this._config.parent) {\r\n      return;\r\n    }\r\n\r\n    const children = SelectorEngine.find(\r\n      ATTR_COLLAPSE_DEEPER_CHILDREN,\r\n      this._config.parent\r\n    );\r\n    SelectorEngine.find(SELECTOR_DATA_COLLAPSE_INIT, this._config.parent)\r\n      .filter((elem) => !children.includes(elem))\r\n      .forEach((element) => {\r\n        const selected = getElementFromSelector(element);\r\n\r\n        if (selected) {\r\n          this._addAriaAndCollapsedClass([element], this._isShown(selected));\r\n        }\r\n      });\r\n  }\r\n\r\n  _addAriaAndCollapsedClass(triggerArray, isOpen) {\r\n    if (!triggerArray.length) {\r\n      return;\r\n    }\r\n\r\n    triggerArray.forEach((elem) => {\r\n      if (isOpen) {\r\n        elem.removeAttribute(ATTR_COLLAPSED);\r\n      } else {\r\n        elem.setAttribute(`${ATTR_COLLAPSED}`, \"\");\r\n      }\r\n\r\n      elem.setAttribute(\"aria-expanded\", isOpen);\r\n    });\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const _config = {};\r\n      if (typeof config === \"string\" && /show|hide/.test(config)) {\r\n        _config.toggle = false;\r\n      }\r\n\r\n      const data = Collapse.getOrCreateInstance(this, _config);\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config]();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Collapse;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport { isElement } from \"./index\";\r\n\r\nconst SELECTOR_FIXED_CONTENT =\r\n  \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\r\nconst SELECTOR_STICKY_CONTENT = \".sticky-top\";\r\n\r\nclass ScrollBarHelper {\r\n  constructor() {\r\n    this._element = document.body;\r\n  }\r\n\r\n  getWidth() {\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\r\n    const documentWidth = document.documentElement.clientWidth;\r\n    return Math.abs(window.innerWidth - documentWidth);\r\n  }\r\n\r\n  hide() {\r\n    const width = this.getWidth();\r\n    this._disableOverFlow();\r\n    // give padding to element to balance the hidden scrollbar width\r\n    this._setElementAttributes(\r\n      this._element,\r\n      \"paddingRight\",\r\n      (calculatedValue) => calculatedValue + width\r\n    );\r\n    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\r\n    this._setElementAttributes(\r\n      SELECTOR_FIXED_CONTENT,\r\n      \"paddingRight\",\r\n      (calculatedValue) => calculatedValue + width\r\n    );\r\n    this._setElementAttributes(\r\n      SELECTOR_STICKY_CONTENT,\r\n      \"marginRight\",\r\n      (calculatedValue) => calculatedValue - width\r\n    );\r\n  }\r\n\r\n  _disableOverFlow() {\r\n    this._saveInitialAttribute(this._element, \"overflow\");\r\n    this._element.style.overflow = \"hidden\";\r\n  }\r\n\r\n  _setElementAttributes(selector, styleProp, callback) {\r\n    const scrollbarWidth = this.getWidth();\r\n    const manipulationCallBack = (element) => {\r\n      if (\r\n        element !== this._element &&\r\n        window.innerWidth > element.clientWidth + scrollbarWidth\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      this._saveInitialAttribute(element, styleProp);\r\n      const calculatedValue = window.getComputedStyle(element)[styleProp];\r\n      element.style[styleProp] = `${callback(\r\n        Number.parseFloat(calculatedValue)\r\n      )}px`;\r\n    };\r\n\r\n    this._applyManipulationCallback(selector, manipulationCallBack);\r\n  }\r\n\r\n  reset() {\r\n    this._resetElementAttributes(this._element, \"overflow\");\r\n    this._resetElementAttributes(this._element, \"paddingRight\");\r\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, \"paddingRight\");\r\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, \"marginRight\");\r\n  }\r\n\r\n  _saveInitialAttribute(element, styleProp) {\r\n    const actualValue = element.style[styleProp];\r\n    if (actualValue) {\r\n      Manipulator.setDataAttribute(element, styleProp, actualValue);\r\n    }\r\n  }\r\n\r\n  _resetElementAttributes(selector, styleProp) {\r\n    const manipulationCallBack = (element) => {\r\n      const value = Manipulator.getDataAttribute(element, styleProp);\r\n      if (typeof value === \"undefined\") {\r\n        element.style.removeProperty(styleProp);\r\n      } else {\r\n        Manipulator.removeDataAttribute(element, styleProp);\r\n        element.style[styleProp] = value;\r\n      }\r\n    };\r\n\r\n    this._applyManipulationCallback(selector, manipulationCallBack);\r\n  }\r\n\r\n  _applyManipulationCallback(selector, callBack) {\r\n    if (isElement(selector)) {\r\n      callBack(selector);\r\n    } else {\r\n      SelectorEngine.find(selector, this._element).forEach(callBack);\r\n    }\r\n  }\r\n\r\n  isOverflowing() {\r\n    return this.getWidth() > 0;\r\n  }\r\n}\r\n\r\nexport default ScrollBarHelper;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport {\r\n  execute,\r\n  executeAfterTransition,\r\n  getElement,\r\n  reflow,\r\n  typeCheckConfig,\r\n} from \"./index\";\r\n\r\nconst Default = {\r\n  isVisible: true, // if false, we use the backdrop helper without adding any element to the dom\r\n  isAnimated: false,\r\n  rootElement: \"body\", // give the choice to place backdrop under different elements\r\n  clickCallback: null,\r\n  backdropClasses: null,\r\n};\r\n\r\nconst DefaultType = {\r\n  isVisible: \"boolean\",\r\n  isAnimated: \"boolean\",\r\n  rootElement: \"(element|string)\",\r\n  clickCallback: \"(function|null)\",\r\n  backdropClasses: \"(array|null)\",\r\n};\r\nconst NAME = \"backdrop\";\r\nconst EVENT_MOUSEDOWN = `mousedown.te.${NAME}`;\r\n\r\nclass Backdrop {\r\n  constructor(config) {\r\n    this._config = this._getConfig(config);\r\n    this._isAppended = false;\r\n    this._element = null;\r\n  }\r\n\r\n  show(callback) {\r\n    if (!this._config.isVisible) {\r\n      execute(callback);\r\n      return;\r\n    }\r\n\r\n    this._append();\r\n\r\n    if (this._config.isAnimated) {\r\n      reflow(this._getElement());\r\n    }\r\n\r\n    const backdropClasses = this._config.backdropClasses || [\r\n      \"opacity-50\",\r\n      \"transition-all\",\r\n      \"duration-300\",\r\n      \"ease-in-out\",\r\n      \"fixed\",\r\n      \"top-0\",\r\n      \"left-0\",\r\n      \"z-[1040]\",\r\n      \"bg-black\",\r\n      \"w-screen\",\r\n      \"h-screen\",\r\n    ];\r\n\r\n    Manipulator.removeClass(this._getElement(), \"opacity-0\");\r\n    Manipulator.addClass(this._getElement(), backdropClasses);\r\n    this._element.setAttribute(\"data-te-backdrop-show\", \"\");\r\n\r\n    this._emulateAnimation(() => {\r\n      execute(callback);\r\n    });\r\n  }\r\n\r\n  hide(callback) {\r\n    if (!this._config.isVisible) {\r\n      execute(callback);\r\n      return;\r\n    }\r\n\r\n    this._element.removeAttribute(\"data-te-backdrop-show\");\r\n    this._getElement().classList.add(\"opacity-0\");\r\n    this._getElement().classList.remove(\"opacity-50\");\r\n\r\n    this._emulateAnimation(() => {\r\n      this.dispose();\r\n      execute(callback);\r\n    });\r\n  }\r\n\r\n  // Private\r\n\r\n  _getElement() {\r\n    if (!this._element) {\r\n      const backdrop = document.createElement(\"div\");\r\n      backdrop.className = this._config.className;\r\n      if (this._config.isAnimated) {\r\n        backdrop.classList.add(\"opacity-50\");\r\n      }\r\n\r\n      this._element = backdrop;\r\n    }\r\n\r\n    return this._element;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...(typeof config === \"object\" ? config : {}),\r\n    };\r\n\r\n    // use getElement() with the default \"body\" to get a fresh Element on each instantiation\r\n    config.rootElement = getElement(config.rootElement);\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _append() {\r\n    if (this._isAppended) {\r\n      return;\r\n    }\r\n\r\n    this._config.rootElement.append(this._getElement());\r\n\r\n    EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {\r\n      execute(this._config.clickCallback);\r\n    });\r\n\r\n    this._isAppended = true;\r\n  }\r\n\r\n  dispose() {\r\n    if (!this._isAppended) {\r\n      return;\r\n    }\r\n\r\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\r\n\r\n    this._element.remove();\r\n    this._isAppended = false;\r\n  }\r\n\r\n  _emulateAnimation(callback) {\r\n    executeAfterTransition(\r\n      callback,\r\n      this._getElement(),\r\n      this._config.isAnimated\r\n    );\r\n  }\r\n}\r\n\r\nexport default Backdrop;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport { isVisible } from \"./index\";\r\n\r\nclass FocusTrap {\r\n  constructor(element, options = {}, toggler) {\r\n    this._element = element;\r\n    this._toggler = toggler;\r\n    this._event = options.event || \"blur\";\r\n    this._condition = options.condition || (() => true);\r\n    this._selector =\r\n      options.selector ||\r\n      'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])';\r\n    this._onlyVisible = options.onlyVisible || false;\r\n    this._focusableElements = [];\r\n    this._firstElement = null;\r\n    this._lastElement = null;\r\n\r\n    this.handler = (e) => {\r\n      if (this._condition(e) && !e.shiftKey && e.target === this._lastElement) {\r\n        e.preventDefault();\r\n        this._firstElement.focus();\r\n      } else if (\r\n        this._condition(e) &&\r\n        e.shiftKey &&\r\n        e.target === this._firstElement\r\n      ) {\r\n        e.preventDefault();\r\n        this._lastElement.focus();\r\n      }\r\n    };\r\n  }\r\n\r\n  trap() {\r\n    this._setElements();\r\n    this._init();\r\n    this._setFocusTrap();\r\n  }\r\n\r\n  disable() {\r\n    this._focusableElements.forEach((element) => {\r\n      element.removeEventListener(this._event, this.handler);\r\n    });\r\n\r\n    if (this._toggler) {\r\n      this._toggler.focus();\r\n    }\r\n  }\r\n\r\n  update() {\r\n    this._setElements();\r\n    this._setFocusTrap();\r\n  }\r\n\r\n  _init() {\r\n    const handler = (e) => {\r\n      if (\r\n        !this._firstElement ||\r\n        e.key !== \"Tab\" ||\r\n        this._focusableElements.includes(e.target)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      e.preventDefault();\r\n      this._firstElement.focus();\r\n\r\n      window.removeEventListener(\"keydown\", handler);\r\n    };\r\n\r\n    window.addEventListener(\"keydown\", handler);\r\n  }\r\n\r\n  _filterVisible(elements) {\r\n    return elements.filter((el) => {\r\n      if (!isVisible(el)) return false;\r\n\r\n      const ancestors = SelectorEngine.parents(el, \"*\");\r\n\r\n      for (let i = 0; i < ancestors.length; i++) {\r\n        const style = window.getComputedStyle(ancestors[i]);\r\n        if (\r\n          style &&\r\n          (style.display === \"none\" || style.visibility === \"hidden\")\r\n        )\r\n          return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  _setElements() {\r\n    this._focusableElements = SelectorEngine.focusableChildren(this._element);\r\n\r\n    if (this._onlyVisible) {\r\n      this._focusableElements = this._filterVisible(this._focusableElements);\r\n    }\r\n\r\n    this._firstElement = this._focusableElements[0];\r\n    this._lastElement =\r\n      this._focusableElements[this._focusableElements.length - 1];\r\n  }\r\n\r\n  _setFocusTrap() {\r\n    this._focusableElements.forEach((element, i) => {\r\n      if (i === this._focusableElements.length - 1 || i === 0) {\r\n        element.addEventListener(this._event, this.handler);\r\n      } else {\r\n        element.removeEventListener(this._event, this.handler);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default FocusTrap;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport { getElementFromSelector, isDisabled } from \"./index\";\r\n\r\nconst enableDismissTrigger = (component, method = \"hide\") => {\r\n  const clickEvent = `click.dismiss${component.EVENT_KEY}`;\r\n  const name = component.NAME;\r\n  EventHandler.on(\r\n    document,\r\n    clickEvent,\r\n    `[data-te-${name}-dismiss]`,\r\n    function (event) {\r\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      if (isDisabled(this)) {\r\n        return;\r\n      }\r\n\r\n      const target =\r\n        getElementFromSelector(this) ||\r\n        this.closest(`.${name}`) ||\r\n        this.closest(`[data-te-${name}-init]`);\r\n\r\n      if (!target) {\r\n        return;\r\n      }\r\n      const instance = component.getOrCreateInstance(target);\r\n\r\n      // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\r\n      instance[method]();\r\n    }\r\n  );\r\n};\r\n\r\nexport { enableDismissTrigger };\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { typeCheckConfig } from \"../util/index\";\r\nimport ScrollBarHelper from \"../util/scrollbar\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport BaseComponent from \"../base-component\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport Backdrop from \"../util/backdrop\";\r\nimport FocusTrap from \"../util/focusTrap\";\r\nimport { enableDismissTrigger } from \"../util/component-functions\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"offcanvas\";\r\nconst DATA_KEY = \"te.offcanvas\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;\r\nconst ESCAPE_KEY = \"Escape\";\r\n\r\nconst Default = {\r\n  backdrop: true,\r\n  keyboard: true,\r\n  scroll: false,\r\n};\r\n\r\nconst DefaultType = {\r\n  backdrop: \"boolean\",\r\n  keyboard: \"boolean\",\r\n  scroll: \"boolean\",\r\n};\r\n\r\nconst CLASS_NAME_SHOW = \"show\";\r\nconst OPEN_SELECTOR = \"[data-te-offcanvas-init][data-te-offcanvas-show]\";\r\n\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Offcanvas extends BaseComponent {\r\n  constructor(element, config) {\r\n    super(element);\r\n\r\n    this._config = this._getConfig(config);\r\n    this._isShown = false;\r\n    this._backdrop = this._initializeBackDrop();\r\n    this._focustrap = this._initializeFocusTrap();\r\n    this._addEventListeners();\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  // Public\r\n\r\n  toggle(relatedTarget) {\r\n    return this._isShown ? this.hide() : this.show(relatedTarget);\r\n  }\r\n\r\n  show(relatedTarget) {\r\n    if (this._isShown) {\r\n      return;\r\n    }\r\n\r\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW, {\r\n      relatedTarget,\r\n    });\r\n\r\n    if (showEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._isShown = true;\r\n    this._element.style.visibility = \"visible\";\r\n\r\n    this._backdrop.show();\r\n\r\n    if (!this._config.scroll) {\r\n      new ScrollBarHelper().hide();\r\n    }\r\n\r\n    this._element.removeAttribute(\"aria-hidden\");\r\n    this._element.setAttribute(\"aria-modal\", true);\r\n    this._element.setAttribute(\"role\", \"dialog\");\r\n    this._element.setAttribute(`data-te-offcanvas-${CLASS_NAME_SHOW}`, \"\");\r\n\r\n    const completeCallBack = () => {\r\n      if (!this._config.scroll) {\r\n        this._focustrap.trap();\r\n      }\r\n\r\n      EventHandler.trigger(this._element, EVENT_SHOWN, { relatedTarget });\r\n    };\r\n\r\n    this._queueCallback(completeCallBack, this._element, true);\r\n  }\r\n\r\n  hide() {\r\n    if (!this._isShown) {\r\n      return;\r\n    }\r\n\r\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._focustrap.disable();\r\n    this._element.blur();\r\n    this._isShown = false;\r\n    this._element.removeAttribute(`data-te-offcanvas-${CLASS_NAME_SHOW}`);\r\n    this._backdrop.hide();\r\n\r\n    const completeCallback = () => {\r\n      this._element.setAttribute(\"aria-hidden\", true);\r\n      this._element.removeAttribute(\"aria-modal\");\r\n      this._element.removeAttribute(\"role\");\r\n      this._element.style.visibility = \"hidden\";\r\n\r\n      if (!this._config.scroll) {\r\n        new ScrollBarHelper().reset();\r\n      }\r\n\r\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n    };\r\n\r\n    this._queueCallback(completeCallback, this._element, true);\r\n  }\r\n\r\n  dispose() {\r\n    this._backdrop.dispose();\r\n    this._focustrap.disable();\r\n    super.dispose();\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n\r\n    EventHandler.on(window, EVENT_LOAD_DATA_API, () =>\r\n      SelectorEngine.find(OPEN_SELECTOR).forEach((el) =>\r\n        Offcanvas.getOrCreateInstance(el).show()\r\n      )\r\n    );\r\n\r\n    enableDismissTrigger(Offcanvas);\r\n    this._didInit = true;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" ? config : {}),\r\n    };\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _initializeBackDrop() {\r\n    return new Backdrop({\r\n      isVisible: this._config.backdrop,\r\n      isAnimated: true,\r\n      rootElement: this._element.parentNode,\r\n      clickCallback: () => this.hide(),\r\n    });\r\n  }\r\n\r\n  _initializeFocusTrap() {\r\n    return new FocusTrap(this._element, {\r\n      event: \"keydown\",\r\n      condition: (event) => event.key === \"Tab\",\r\n    });\r\n  }\r\n\r\n  _addEventListeners() {\r\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {\r\n      if (this._config.keyboard && event.key === ESCAPE_KEY) {\r\n        this.hide();\r\n      }\r\n    });\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Offcanvas.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config !== \"string\") {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        data[config] === undefined ||\r\n        config.startsWith(\"_\") ||\r\n        config === \"constructor\"\r\n      ) {\r\n        throw new TypeError(`No method named \"${config}\"`);\r\n      }\r\n\r\n      data[config](this);\r\n    });\r\n  }\r\n}\r\n\r\nexport default Offcanvas;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { typeCheckConfig, isVisible } from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport BaseComponent from \"../base-component\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport { enableDismissTrigger } from \"../util/component-functions\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"alert\";\r\nconst DATA_KEY = \"te.alert\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\n\r\nconst EVENT_CLOSE = `close${EVENT_KEY}`;\r\nconst EVENT_CLOSED = `closed${EVENT_KEY}`;\r\n\r\nconst SHOW_DATA_ATTRIBUTE = \"data-te-alert-show\";\r\n\r\nconst DefaultType = {\r\n  animation: \"boolean\",\r\n  autohide: \"boolean\",\r\n  delay: \"number\",\r\n};\r\n\r\nconst Default = {\r\n  animation: true,\r\n  autohide: true,\r\n  delay: 1000,\r\n};\r\n\r\nconst DefaultClasses = {\r\n  fadeIn:\r\n    \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\r\n  fadeOut:\r\n    \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  fadeIn: \"string\",\r\n  fadeOut: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Alert extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n    this._element = element;\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n  static get DefaultType() {\r\n    return DefaultType;\r\n  }\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  close() {\r\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\r\n\r\n    if (closeEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    let timeout = 0;\r\n    if (this._config.animation) {\r\n      timeout = 300;\r\n      Manipulator.addClass(this._element, this._classes.fadeOut);\r\n    }\r\n    this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);\r\n\r\n    setTimeout(() => {\r\n      this._queueCallback(\r\n        () => this._destroyElement(),\r\n        this._element,\r\n        this._config.animation\r\n      );\r\n    }, timeout);\r\n  }\r\n\r\n  show() {\r\n    if (!this._element) {\r\n      return;\r\n    }\r\n\r\n    if (this._config.autohide) {\r\n      this._setupAutohide();\r\n    }\r\n    if (!this._element.hasAttribute(SHOW_DATA_ATTRIBUTE)) {\r\n      Manipulator.removeClass(this._element, \"hidden\");\r\n      Manipulator.addClass(this._element, \"block\");\r\n      if (isVisible(this._element)) {\r\n        const handler = (e) => {\r\n          Manipulator.removeClass(this._element, \"hidden\");\r\n          Manipulator.addClass(this._element, \"block\");\r\n          EventHandler.off(e.target, \"animationend\", handler);\r\n        };\r\n        this._element.setAttribute(SHOW_DATA_ATTRIBUTE, \"\");\r\n\r\n        EventHandler.on(this._element, \"animationend\", handler);\r\n      }\r\n    }\r\n\r\n    if (this._config.animation) {\r\n      Manipulator.removeClass(this._element, this._classes.fadeOut);\r\n      Manipulator.addClass(this._element, this._classes.fadeIn);\r\n    }\r\n  }\r\n\r\n  hide() {\r\n    if (!this._element) {\r\n      return;\r\n    }\r\n    if (this._element.hasAttribute(SHOW_DATA_ATTRIBUTE)) {\r\n      this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);\r\n      const handler = (e) => {\r\n        Manipulator.addClass(this._element, \"hidden\");\r\n        Manipulator.removeClass(this._element, \"block\");\r\n\r\n        if (this._timeout !== null) {\r\n          clearTimeout(this._timeout);\r\n          this._timeout = null;\r\n        }\r\n\r\n        EventHandler.off(e.target, \"animationend\", handler);\r\n      };\r\n\r\n      EventHandler.on(this._element, \"animationend\", handler);\r\n\r\n      Manipulator.removeClass(this._element, this._classes.fadeIn);\r\n      Manipulator.addClass(this._element, this._classes.fadeOut);\r\n    }\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n    enableDismissTrigger(Alert, \"close\");\r\n    this._didInit = true;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" && config ? config : {}),\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _setupAutohide() {\r\n    this._timeout = setTimeout(() => {\r\n      this.hide();\r\n    }, this._config.delay);\r\n  }\r\n\r\n  _destroyElement() {\r\n    this._element.remove();\r\n    EventHandler.trigger(this._element, EVENT_CLOSED);\r\n    this.dispose();\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Alert.getOrCreateInstance(this);\r\n\r\n      if (typeof config !== \"string\") {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        data[config] === undefined ||\r\n        config.startsWith(\"_\") ||\r\n        config === \"constructor\"\r\n      ) {\r\n        throw new TypeError(`No method named \"${config}\"`);\r\n      }\r\n\r\n      data[config](this);\r\n    });\r\n  }\r\n}\r\n\r\nexport default Alert;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport {\r\n  getElementFromSelector,\r\n  isRTL,\r\n  isVisible,\r\n  getNextActiveElement,\r\n  reflow,\r\n  triggerTransitionEnd,\r\n  typeCheckConfig,\r\n} from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"carousel\";\r\nconst DATA_KEY = \"te.carousel\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\n\r\nconst ARROW_LEFT_KEY = \"ArrowLeft\";\r\nconst ARROW_RIGHT_KEY = \"ArrowRight\";\r\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\r\nconst SWIPE_THRESHOLD = 40;\r\n\r\nconst Default = {\r\n  interval: 5000,\r\n  keyboard: true,\r\n  slide: false,\r\n  pause: \"hover\",\r\n  wrap: true,\r\n  touch: true,\r\n};\r\n\r\nconst DefaultType = {\r\n  interval: \"(number|boolean)\",\r\n  keyboard: \"boolean\",\r\n  slide: \"(boolean|string)\",\r\n  pause: \"(string|boolean)\",\r\n  wrap: \"boolean\",\r\n  touch: \"boolean\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  pointer: \"touch-pan-y\",\r\n  block: \"!block\",\r\n  visible: \"data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]\",\r\n  invisible:\r\n    \"data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600\",\r\n  slideRight: \"translate-x-full\",\r\n  slideLeft: \"-translate-x-full\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  pointer: \"string\",\r\n  block: \"string\",\r\n  visible: \"string\",\r\n  invisible: \"string\",\r\n  slideRight: \"string\",\r\n  slideLeft: \"string\",\r\n};\r\n\r\nconst ORDER_NEXT = \"next\";\r\nconst ORDER_PREV = \"prev\";\r\nconst DIRECTION_LEFT = \"left\";\r\nconst DIRECTION_RIGHT = \"right\";\r\n\r\nconst KEY_TO_DIRECTION = {\r\n  [ARROW_LEFT_KEY]: DIRECTION_RIGHT,\r\n  [ARROW_RIGHT_KEY]: DIRECTION_LEFT,\r\n};\r\n\r\nconst EVENT_SLIDE = `slide${EVENT_KEY}`;\r\nconst EVENT_SLID = `slid${EVENT_KEY}`;\r\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY}`;\r\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY}`;\r\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY}`;\r\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY}`;\r\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY}`;\r\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY}`;\r\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY}`;\r\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY}`;\r\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY}`;\r\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\r\n\r\nconst ATTR_CAROUSEL = \"data-te-carousel-init\";\r\nconst ATTR_ACTIVE = \"data-te-carousel-active\";\r\nconst ATTR_SLIDE = \"data-te-carousel-slide\";\r\nconst ATTR_END = \"data-te-carousel-item-end\";\r\nconst ATTR_START = \"data-te-carousel-item-start\";\r\nconst ATTR_NEXT = \"data-te-carousel-item-next\";\r\nconst ATTR_PREV = \"data-te-carousel-item-prev\";\r\nconst ATTR_POINTER_EVENT = \"data-te-carousel-pointer-event\";\r\n\r\nconst SELECTOR_DATA_CAROUSEL_INIT = \"[data-te-carousel-init]\";\r\nconst SELECTOR_DATA_ACTIVE = \"[data-te-carousel-active]\";\r\nconst SELECTOR_DATA_ITEM = \"[data-te-carousel-item]\";\r\nconst SELECTOR_DATA_ACTIVE_ITEM = `${SELECTOR_DATA_ACTIVE}${SELECTOR_DATA_ITEM}`;\r\nconst SELECTOR_DATA_ITEM_IMG = `${SELECTOR_DATA_ITEM} img`;\r\nconst SELECTOR_DATA_NEXT_PREV =\r\n  \"[data-te-carousel-item-next], [data-te-carousel-item-prev]\";\r\nconst SELECTOR_DATA_INDICATORS = \"[data-te-carousel-indicators]\";\r\nconst SELECTOR_INDICATOR = \"[data-te-target]\";\r\nconst SELECTOR_DATA_SLIDE = \"[data-te-slide], [data-te-slide-to]\";\r\n\r\nconst POINTER_TYPE_TOUCH = \"touch\";\r\nconst POINTER_TYPE_PEN = \"pen\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\nclass Carousel extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n\r\n    this._items = null;\r\n    this._interval = null;\r\n    this._activeElement = null;\r\n    this._isPaused = false;\r\n    this._isSliding = false;\r\n    this.touchTimeout = null;\r\n    this.touchStartX = 0;\r\n    this.touchDeltaX = 0;\r\n\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._indicatorsElement = SelectorEngine.findOne(\r\n      SELECTOR_DATA_INDICATORS,\r\n      this._element\r\n    );\r\n    this._touchSupported =\r\n      \"ontouchstart\" in document.documentElement ||\r\n      navigator.maxTouchPoints > 0;\r\n    this._pointerEvent = Boolean(window.PointerEvent);\r\n\r\n    this._setActiveElementClass();\r\n    this._addEventListeners();\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  next() {\r\n    this._slide(ORDER_NEXT);\r\n  }\r\n\r\n  nextWhenVisible() {\r\n    // Don't call next when the page isn't visible\r\n    // or the carousel or its parent isn't visible\r\n    if (!document.hidden && isVisible(this._element)) {\r\n      this.next();\r\n    }\r\n  }\r\n\r\n  prev() {\r\n    this._slide(ORDER_PREV);\r\n  }\r\n\r\n  pause(event) {\r\n    if (!event) {\r\n      this._isPaused = true;\r\n    }\r\n\r\n    if (SelectorEngine.findOne(SELECTOR_DATA_NEXT_PREV, this._element)) {\r\n      triggerTransitionEnd(this._element);\r\n      this.cycle(true);\r\n    }\r\n\r\n    clearInterval(this._interval);\r\n    this._interval = null;\r\n  }\r\n\r\n  cycle(event) {\r\n    if (!event) {\r\n      this._isPaused = false;\r\n    }\r\n\r\n    if (this._interval) {\r\n      clearInterval(this._interval);\r\n      this._interval = null;\r\n    }\r\n\r\n    if (this._config && this._config.interval && !this._isPaused) {\r\n      this._updateInterval();\r\n\r\n      this._interval = setInterval(\r\n        (document.visibilityState ? this.nextWhenVisible : this.next).bind(\r\n          this\r\n        ),\r\n        this._config.interval\r\n      );\r\n    }\r\n  }\r\n\r\n  to(index) {\r\n    this._activeElement = SelectorEngine.findOne(\r\n      SELECTOR_DATA_ACTIVE_ITEM,\r\n      this._element\r\n    );\r\n    const activeIndex = this._getItemIndex(this._activeElement);\r\n\r\n    if (index > this._items.length - 1 || index < 0) {\r\n      return;\r\n    }\r\n\r\n    if (this._isSliding) {\r\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\r\n      return;\r\n    }\r\n\r\n    if (activeIndex === index) {\r\n      this.pause();\r\n      this.cycle();\r\n      return;\r\n    }\r\n\r\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\r\n\r\n    this._slide(order, this._items[index]);\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n    EventHandler.on(\r\n      document,\r\n      EVENT_CLICK_DATA_API,\r\n      SELECTOR_DATA_SLIDE,\r\n      Carousel.dataApiClickHandler\r\n    );\r\n\r\n    EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\r\n      const carousels = SelectorEngine.find(SELECTOR_DATA_CAROUSEL_INIT);\r\n\r\n      for (let i = 0, len = carousels.length; i < len; i++) {\r\n        Carousel.carouselInterface(\r\n          carousels[i],\r\n          Carousel.getInstance(carousels[i])\r\n        );\r\n      }\r\n    });\r\n\r\n    this._didInit = true;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" ? config : {}),\r\n    };\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _applyInitialClasses() {\r\n    const activeElement = SelectorEngine.findOne(\r\n      SELECTOR_DATA_ACTIVE_ITEM,\r\n      this._element\r\n    );\r\n    activeElement.classList.add(\r\n      this._classes.block,\r\n      ...this._classes.visible.split(\" \")\r\n    );\r\n\r\n    this._setActiveIndicatorElement(activeElement);\r\n  }\r\n\r\n  _handleSwipe() {\r\n    const absDeltax = Math.abs(this.touchDeltaX);\r\n\r\n    if (absDeltax <= SWIPE_THRESHOLD) {\r\n      return;\r\n    }\r\n\r\n    const direction = absDeltax / this.touchDeltaX;\r\n\r\n    this.touchDeltaX = 0;\r\n\r\n    if (!direction) {\r\n      return;\r\n    }\r\n\r\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\r\n  }\r\n\r\n  _setActiveElementClass() {\r\n    this._activeElement = SelectorEngine.findOne(\r\n      SELECTOR_DATA_ACTIVE_ITEM,\r\n      this._element\r\n    );\r\n    Manipulator.addClass(this._activeElement, \"hidden\");\r\n  }\r\n\r\n  _addEventListeners() {\r\n    if (this._config.keyboard) {\r\n      EventHandler.on(this._element, EVENT_KEYDOWN, (event) =>\r\n        this._keydown(event)\r\n      );\r\n    }\r\n\r\n    if (this._config.pause === \"hover\") {\r\n      EventHandler.on(this._element, EVENT_MOUSEENTER, (event) =>\r\n        this.pause(event)\r\n      );\r\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, (event) =>\r\n        this.cycle(event)\r\n      );\r\n    }\r\n\r\n    if (this._config.touch && this._touchSupported) {\r\n      this._addTouchEventListeners();\r\n    }\r\n\r\n    this._applyInitialClasses();\r\n  }\r\n\r\n  _addTouchEventListeners() {\r\n    const hasPointerPenTouch = (event) => {\r\n      return (\r\n        this._pointerEvent &&\r\n        (event.pointerType === POINTER_TYPE_PEN ||\r\n          event.pointerType === POINTER_TYPE_TOUCH)\r\n      );\r\n    };\r\n\r\n    const start = (event) => {\r\n      if (hasPointerPenTouch(event)) {\r\n        this.touchStartX = event.clientX;\r\n      } else if (!this._pointerEvent) {\r\n        this.touchStartX = event.touches[0].clientX;\r\n      }\r\n    };\r\n\r\n    const move = (event) => {\r\n      // ensure swiping with one touch and not pinching\r\n      this.touchDeltaX =\r\n        event.touches && event.touches.length > 1\r\n          ? 0\r\n          : event.touches[0].clientX - this.touchStartX;\r\n    };\r\n\r\n    const end = (event) => {\r\n      if (hasPointerPenTouch(event)) {\r\n        this.touchDeltaX = event.clientX - this.touchStartX;\r\n      }\r\n\r\n      this._handleSwipe();\r\n      if (this._config.pause === \"hover\") {\r\n        // If it's a touch-enabled device, mouseenter/leave are fired as\r\n        // part of the mouse compatibility events on first tap - the carousel\r\n        // would stop cycling until user tapped out of it;\r\n        // here, we listen for touchend, explicitly pause the carousel\r\n        // (as if it's the second time we tap on it, mouseenter compat event\r\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\r\n        // events to fire) we explicitly restart cycling\r\n\r\n        this.pause();\r\n        if (this.touchTimeout) {\r\n          clearTimeout(this.touchTimeout);\r\n        }\r\n\r\n        this.touchTimeout = setTimeout(\r\n          (event) => this.cycle(event),\r\n          TOUCHEVENT_COMPAT_WAIT + this._config.interval\r\n        );\r\n      }\r\n    };\r\n\r\n    SelectorEngine.find(SELECTOR_DATA_ITEM_IMG, this._element).forEach(\r\n      (itemImg) => {\r\n        EventHandler.on(itemImg, EVENT_DRAG_START, (event) =>\r\n          event.preventDefault()\r\n        );\r\n      }\r\n    );\r\n\r\n    if (this._pointerEvent) {\r\n      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) =>\r\n        start(event)\r\n      );\r\n      EventHandler.on(this._element, EVENT_POINTERUP, (event) => end(event));\r\n\r\n      this._element.classList.add(this._classes.pointer);\r\n      this._element.setAttribute(`${ATTR_POINTER_EVENT}`, \"\");\r\n    } else {\r\n      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => start(event));\r\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => move(event));\r\n      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => end(event));\r\n    }\r\n  }\r\n\r\n  _keydown(event) {\r\n    if (/input|textarea/i.test(event.target.tagName)) {\r\n      return;\r\n    }\r\n\r\n    const direction = KEY_TO_DIRECTION[event.key];\r\n    if (direction) {\r\n      event.preventDefault();\r\n      this._slide(direction);\r\n    }\r\n  }\r\n\r\n  _getItemIndex(element) {\r\n    this._items =\r\n      element && element.parentNode\r\n        ? SelectorEngine.find(SELECTOR_DATA_ITEM, element.parentNode)\r\n        : [];\r\n\r\n    return this._items.indexOf(element);\r\n  }\r\n\r\n  _getItemByOrder(order, activeElement) {\r\n    const isNext = order === ORDER_NEXT;\r\n    return getNextActiveElement(\r\n      this._items,\r\n      activeElement,\r\n      isNext,\r\n      this._config.wrap\r\n    );\r\n  }\r\n\r\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\r\n    const targetIndex = this._getItemIndex(relatedTarget);\r\n    const fromIndex = this._getItemIndex(\r\n      SelectorEngine.findOne(SELECTOR_DATA_ACTIVE_ITEM, this._element)\r\n    );\r\n\r\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\r\n      relatedTarget,\r\n      direction: eventDirectionName,\r\n      from: fromIndex,\r\n      to: targetIndex,\r\n    });\r\n  }\r\n\r\n  _setActiveIndicatorElement(element) {\r\n    if (this._indicatorsElement) {\r\n      const activeIndicator = SelectorEngine.findOne(\r\n        SELECTOR_DATA_ACTIVE,\r\n        this._indicatorsElement\r\n      );\r\n\r\n      activeIndicator.removeAttribute(ATTR_ACTIVE);\r\n      activeIndicator.removeAttribute(\"aria-current\");\r\n      activeIndicator.classList.remove(\"!opacity-100\");\r\n\r\n      const indicators = SelectorEngine.find(\r\n        SELECTOR_INDICATOR,\r\n        this._indicatorsElement\r\n      );\r\n\r\n      for (let i = 0; i < indicators.length; i++) {\r\n        if (\r\n          Number.parseInt(\r\n            indicators[i].getAttribute(\"data-te-slide-to\"),\r\n            10\r\n          ) === this._getItemIndex(element)\r\n        ) {\r\n          indicators[i].setAttribute(`${ATTR_ACTIVE}`, \"\");\r\n          indicators[i].setAttribute(\"aria-current\", \"true\");\r\n          indicators[i].classList.add(\"!opacity-100\");\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _updateInterval() {\r\n    const element =\r\n      this._activeElement ||\r\n      SelectorEngine.findOne(SELECTOR_DATA_ACTIVE_ITEM, this._element);\r\n\r\n    if (!element) {\r\n      return;\r\n    }\r\n\r\n    const elementInterval = Number.parseInt(\r\n      element.getAttribute(\"data-te-interval\"),\r\n      10\r\n    );\r\n\r\n    if (elementInterval) {\r\n      this._config.defaultInterval =\r\n        this._config.defaultInterval || this._config.interval;\r\n      this._config.interval = elementInterval;\r\n    } else {\r\n      this._config.interval =\r\n        this._config.defaultInterval || this._config.interval;\r\n    }\r\n  }\r\n\r\n  _slide(directionOrOrder, element) {\r\n    const order = this._directionToOrder(directionOrOrder);\r\n\r\n    const activeElement = SelectorEngine.findOne(\r\n      SELECTOR_DATA_ACTIVE_ITEM,\r\n      this._element\r\n    );\r\n    const activeElementIndex = this._getItemIndex(activeElement);\r\n\r\n    const nextElement = element || this._getItemByOrder(order, activeElement);\r\n    const nextElementIndex = this._getItemIndex(nextElement);\r\n\r\n    const isCycling = Boolean(this._interval);\r\n\r\n    const isNext = order === ORDER_NEXT;\r\n    const directionalAttr = isNext ? ATTR_START : ATTR_END;\r\n    const orderAttr = isNext ? ATTR_NEXT : ATTR_PREV;\r\n    const eventDirectionName = this._orderToDirection(order);\r\n\r\n    const activeClass =\r\n      directionalAttr === ATTR_START\r\n        ? this._classes.slideLeft\r\n        : this._classes.slideRight;\r\n    const nextClass =\r\n      directionalAttr !== ATTR_START\r\n        ? this._classes.slideLeft\r\n        : this._classes.slideRight;\r\n\r\n    if (nextElement && nextElement.hasAttribute(ATTR_ACTIVE)) {\r\n      this._isSliding = false;\r\n      return;\r\n    }\r\n\r\n    if (this._isSliding) {\r\n      return;\r\n    }\r\n\r\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\r\n    if (slideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (!activeElement || !nextElement) {\r\n      // Some weirdness is happening, so we bail\r\n      return;\r\n    }\r\n\r\n    this._isSliding = true;\r\n\r\n    if (isCycling) {\r\n      this.pause();\r\n    }\r\n\r\n    this._setActiveIndicatorElement(nextElement);\r\n    this._activeElement = nextElement;\r\n\r\n    const triggerSlidEvent = () => {\r\n      EventHandler.trigger(this._element, EVENT_SLID, {\r\n        relatedTarget: nextElement,\r\n        direction: eventDirectionName,\r\n        from: activeElementIndex,\r\n        to: nextElementIndex,\r\n      });\r\n    };\r\n\r\n    if (this._element.hasAttribute(ATTR_SLIDE)) {\r\n      nextElement.setAttribute(`${orderAttr}`, \"\");\r\n      nextElement.classList.add(this._classes.block, nextClass);\r\n\r\n      reflow(nextElement);\r\n\r\n      activeElement.setAttribute(`${directionalAttr}`, \"\");\r\n      activeElement.classList.add(\r\n        activeClass,\r\n        ...this._classes.invisible.split(\" \")\r\n      );\r\n      activeElement.classList.remove(...this._classes.visible.split(\" \"));\r\n\r\n      nextElement.setAttribute(`${directionalAttr}`, \"\");\r\n      nextElement.classList.add(...this._classes.visible.split(\" \"));\r\n      nextElement.classList.remove(\r\n        this._classes.slideRight,\r\n        this._classes.slideLeft\r\n      );\r\n\r\n      const completeCallBack = () => {\r\n        nextElement.removeAttribute(directionalAttr);\r\n        nextElement.removeAttribute(orderAttr);\r\n        nextElement.setAttribute(`${ATTR_ACTIVE}`, \"\");\r\n\r\n        activeElement.removeAttribute(ATTR_ACTIVE);\r\n        activeElement.classList.remove(\r\n          activeClass,\r\n          ...this._classes.invisible.split(\" \"),\r\n          this._classes.block\r\n        );\r\n        activeElement.removeAttribute(orderAttr);\r\n        activeElement.removeAttribute(directionalAttr);\r\n\r\n        this._isSliding = false;\r\n\r\n        setTimeout(triggerSlidEvent, 0);\r\n      };\r\n\r\n      this._queueCallback(completeCallBack, activeElement, true);\r\n    } else {\r\n      activeElement.removeAttribute(ATTR_ACTIVE);\r\n      activeElement.classList.remove(this._classes.block);\r\n\r\n      nextElement.setAttribute(`${ATTR_ACTIVE}`, \"\");\r\n      nextElement.classList.add(this._classes.block);\r\n\r\n      this._isSliding = false;\r\n      triggerSlidEvent();\r\n    }\r\n\r\n    if (isCycling) {\r\n      this.cycle();\r\n    }\r\n  }\r\n\r\n  _directionToOrder(direction) {\r\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\r\n      return direction;\r\n    }\r\n\r\n    if (isRTL()) {\r\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\r\n    }\r\n\r\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\r\n  }\r\n\r\n  _orderToDirection(order) {\r\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\r\n      return order;\r\n    }\r\n\r\n    if (isRTL()) {\r\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n\r\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\r\n  }\r\n\r\n  // Static\r\n\r\n  static carouselInterface(element, config) {\r\n    const data = Carousel.getOrCreateInstance(element, config);\r\n\r\n    let { _config } = data;\r\n    if (typeof config === \"object\") {\r\n      _config = {\r\n        ..._config,\r\n        ...config,\r\n      };\r\n    }\r\n\r\n    const action = typeof config === \"string\" ? config : _config.slide;\r\n\r\n    if (typeof config === \"number\") {\r\n      data.to(config);\r\n    } else if (typeof action === \"string\") {\r\n      if (typeof data[action] === \"undefined\") {\r\n        throw new TypeError(`No method named \"${action}\"`);\r\n      }\r\n\r\n      data[action]();\r\n    } else if (_config.interval && _config.carouselInit === null) {\r\n      data.pause();\r\n      data.cycle();\r\n    }\r\n  }\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      Carousel.carouselInterface(this, config);\r\n    });\r\n  }\r\n\r\n  static dataApiClickHandler(event) {\r\n    const target = getElementFromSelector(this);\r\n\r\n    if (!target || !target.hasAttribute(ATTR_CAROUSEL)) {\r\n      return;\r\n    }\r\n\r\n    const config = {\r\n      ...Manipulator.getDataAttributes(target),\r\n      ...Manipulator.getDataAttributes(this),\r\n    };\r\n    const slideIndex = this.getAttribute(\"data-te-slide-to\");\r\n\r\n    if (slideIndex) {\r\n      config.interval = false;\r\n    }\r\n\r\n    Carousel.carouselInterface(target, config);\r\n\r\n    if (slideIndex) {\r\n      Carousel.getInstance(target).to(slideIndex);\r\n    }\r\n\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexport default Carousel;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { isRTL, reflow, typeCheckConfig } from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport ScrollBarHelper from \"../util/scrollbar\";\r\nimport BaseComponent from \"../base-component\";\r\nimport Backdrop from \"../util/backdrop\";\r\nimport FocusTrap from \"../util/focusTrap\";\r\nimport { enableDismissTrigger } from \"../util/component-functions\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"modal\";\r\nconst DATA_KEY = \"te.modal\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst ESCAPE_KEY = \"Escape\";\r\n\r\nconst Default = {\r\n  backdrop: true,\r\n  keyboard: true,\r\n  focus: true,\r\n};\r\n\r\nconst DefaultType = {\r\n  backdrop: \"(boolean|string)\",\r\n  keyboard: \"boolean\",\r\n  focus: \"boolean\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  show: \"transform-none\",\r\n  static: \"scale-[1.02]\",\r\n  staticProperties: \"transition-scale duration-300 ease-in-out\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  show: \"string\",\r\n  static: \"string\",\r\n  staticProperties: \"string\",\r\n};\r\n\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\nconst EVENT_RESIZE = `resize${EVENT_KEY}`;\r\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;\r\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;\r\nconst EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY}`;\r\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY}`;\r\n\r\nconst OPEN_SELECTOR_BODY = \"data-te-modal-open\";\r\nconst OPEN_SELECTOR = \"data-te-open\";\r\nconst SELECTOR_DIALOG = \"[data-te-modal-dialog-ref]\";\r\nconst SELECTOR_MODAL_BODY = \"[data-te-modal-body-ref]\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Modal extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n    this._backdrop = this._initializeBackDrop();\r\n    this._focustrap = this._initializeFocusTrap();\r\n    this._isShown = false;\r\n    this._ignoreBackdropClick = false;\r\n    this._isTransitioning = false;\r\n    this._scrollBar = new ScrollBarHelper();\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  toggle(relatedTarget) {\r\n    return this._isShown ? this.hide() : this.show(relatedTarget);\r\n  }\r\n\r\n  show(relatedTarget) {\r\n    if (this._isShown || this._isTransitioning) {\r\n      return;\r\n    }\r\n\r\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW, {\r\n      relatedTarget,\r\n    });\r\n\r\n    if (showEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._isShown = true;\r\n\r\n    if (this._isAnimated()) {\r\n      this._isTransitioning = true;\r\n    }\r\n\r\n    this._scrollBar.hide();\r\n\r\n    document.body.setAttribute(OPEN_SELECTOR_BODY, \"true\");\r\n\r\n    this._adjustDialog();\r\n\r\n    this._setEscapeEvent();\r\n    this._setResizeEvent();\r\n\r\n    EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {\r\n      EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (event) => {\r\n        if (event.target === this._element) {\r\n          this._ignoreBackdropClick = true;\r\n        }\r\n      });\r\n    });\r\n    this._showElement(relatedTarget);\r\n    this._showBackdrop();\r\n  }\r\n\r\n  hide() {\r\n    if (!this._isShown || this._isTransitioning) {\r\n      return;\r\n    }\r\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._isShown = false;\r\n    const isAnimated = this._isAnimated();\r\n\r\n    if (isAnimated) {\r\n      this._isTransitioning = true;\r\n    }\r\n\r\n    this._setEscapeEvent();\r\n    this._setResizeEvent();\r\n\r\n    this._focustrap.disable();\r\n\r\n    const modalDialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n    modalDialog.classList.remove(this._classes.show);\r\n\r\n    EventHandler.off(this._element, EVENT_CLICK_DISMISS);\r\n    EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);\r\n\r\n    this._queueCallback(() => this._hideModal(), this._element, isAnimated);\r\n    this._element.removeAttribute(OPEN_SELECTOR);\r\n  }\r\n\r\n  dispose() {\r\n    [window, this._dialog].forEach((htmlElement) =>\r\n      EventHandler.off(htmlElement, EVENT_KEY)\r\n    );\r\n\r\n    this._backdrop.dispose();\r\n    this._focustrap.disable();\r\n    super.dispose();\r\n  }\r\n\r\n  handleUpdate() {\r\n    this._adjustDialog();\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n\r\n    enableDismissTrigger(Modal);\r\n\r\n    this._didInit = true;\r\n  }\r\n\r\n  _initializeBackDrop() {\r\n    return new Backdrop({\r\n      isVisible: Boolean(this._config.backdrop), // 'static' option will be translated to true, and booleans will keep their value\r\n      isAnimated: this._isAnimated(),\r\n    });\r\n  }\r\n\r\n  _initializeFocusTrap() {\r\n    return new FocusTrap(this._element, {\r\n      event: \"keydown\",\r\n      condition: (event) => event.key === \"Tab\",\r\n    });\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" ? config : {}),\r\n    };\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _showElement(relatedTarget) {\r\n    const isAnimated = this._isAnimated();\r\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\r\n\r\n    if (\r\n      !this._element.parentNode ||\r\n      this._element.parentNode.nodeType !== Node.ELEMENT_NODE\r\n    ) {\r\n      // Don't move modal's DOM position\r\n      document.body.append(this._element);\r\n    }\r\n\r\n    this._element.style.display = \"block\";\r\n    this._element.classList.remove(\"hidden\");\r\n    this._element.removeAttribute(\"aria-hidden\");\r\n    this._element.setAttribute(\"aria-modal\", true);\r\n    this._element.setAttribute(\"role\", \"dialog\");\r\n    this._element.setAttribute(`${OPEN_SELECTOR}`, \"true\");\r\n    this._element.scrollTop = 0;\r\n\r\n    const modalDialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n\r\n    modalDialog.classList.add(this._classes.show);\r\n    modalDialog.classList.remove(\"opacity-0\");\r\n    modalDialog.classList.add(\"opacity-100\");\r\n\r\n    if (modalBody) {\r\n      modalBody.scrollTop = 0;\r\n    }\r\n\r\n    if (isAnimated) {\r\n      reflow(this._element);\r\n    }\r\n\r\n    const transitionComplete = () => {\r\n      if (this._config.focus) {\r\n        this._focustrap.trap();\r\n      }\r\n\r\n      this._isTransitioning = false;\r\n      EventHandler.trigger(this._element, EVENT_SHOWN, {\r\n        relatedTarget,\r\n      });\r\n    };\r\n\r\n    this._queueCallback(transitionComplete, this._dialog, isAnimated);\r\n  }\r\n\r\n  _setEscapeEvent() {\r\n    if (this._isShown) {\r\n      EventHandler.on(document, EVENT_KEYDOWN_DISMISS, (event) => {\r\n        if (this._config.keyboard && event.key === ESCAPE_KEY) {\r\n          event.preventDefault();\r\n          this.hide();\r\n        } else if (!this._config.keyboard && event.key === ESCAPE_KEY) {\r\n          this._triggerBackdropTransition();\r\n        }\r\n      });\r\n    } else {\r\n      EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS);\r\n    }\r\n  }\r\n\r\n  _setResizeEvent() {\r\n    if (this._isShown) {\r\n      EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());\r\n    } else {\r\n      EventHandler.off(window, EVENT_RESIZE);\r\n    }\r\n  }\r\n\r\n  _hideModal() {\r\n    const modalDialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n    modalDialog.classList.remove(this._classes.show);\r\n    modalDialog.classList.remove(\"opacity-100\");\r\n    modalDialog.classList.add(\"opacity-0\");\r\n\r\n    setTimeout(() => {\r\n      this._element.style.display = \"none\";\r\n    }, 300);\r\n\r\n    this._element.setAttribute(\"aria-hidden\", true);\r\n    this._element.removeAttribute(\"aria-modal\");\r\n    this._element.removeAttribute(\"role\");\r\n    this._isTransitioning = false;\r\n    this._backdrop.hide(() => {\r\n      document.body.removeAttribute(OPEN_SELECTOR_BODY);\r\n      this._resetAdjustments();\r\n      this._scrollBar.reset();\r\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n    });\r\n  }\r\n\r\n  _showBackdrop(callback) {\r\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS, (event) => {\r\n      if (this._ignoreBackdropClick) {\r\n        this._ignoreBackdropClick = false;\r\n        return;\r\n      }\r\n\r\n      if (event.target !== event.currentTarget) {\r\n        return;\r\n      }\r\n\r\n      if (this._config.backdrop === true) {\r\n        this.hide();\r\n      } else if (this._config.backdrop === \"static\") {\r\n        this._triggerBackdropTransition();\r\n      }\r\n    });\r\n\r\n    this._backdrop.show(callback);\r\n  }\r\n\r\n  _isAnimated() {\r\n    const animate = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n    return !!animate;\r\n  }\r\n\r\n  _triggerBackdropTransition() {\r\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const { classList, scrollHeight, style } = this._element;\r\n    const isModalOverflowing =\r\n      scrollHeight > document.documentElement.clientHeight;\r\n\r\n    // return if the following background transition hasn't yet completed\r\n    if (\r\n      (!isModalOverflowing && style.overflowY === \"hidden\") ||\r\n      classList.contains(this._classes.static)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    if (!isModalOverflowing) {\r\n      style.overflowY = \"hidden\";\r\n    }\r\n\r\n    classList.add(...this._classes.static.split(\" \"));\r\n    classList.add(...this._classes.staticProperties.split(\" \"));\r\n\r\n    this._queueCallback(() => {\r\n      classList.remove(this._classes.static);\r\n\r\n      setTimeout(() => {\r\n        classList.remove(...this._classes.staticProperties.split(\" \"));\r\n      }, 300);\r\n\r\n      if (!isModalOverflowing) {\r\n        this._queueCallback(() => {\r\n          style.overflowY = \"\";\r\n        }, this._dialog);\r\n      }\r\n    }, this._dialog);\r\n\r\n    this._element.focus();\r\n  }\r\n\r\n  // ----------------------------------------------------------------------\r\n  // the following methods are used to handle overflowing modals\r\n  // ----------------------------------------------------------------------\r\n\r\n  _adjustDialog() {\r\n    const isModalOverflowing =\r\n      this._element.scrollHeight > document.documentElement.clientHeight;\r\n    const scrollbarWidth = this._scrollBar.getWidth();\r\n    const isBodyOverflowing = scrollbarWidth > 0;\r\n\r\n    if (\r\n      (!isBodyOverflowing && isModalOverflowing && !isRTL()) ||\r\n      (isBodyOverflowing && !isModalOverflowing && isRTL())\r\n    ) {\r\n      this._element.style.paddingLeft = `${scrollbarWidth}px`;\r\n    }\r\n\r\n    if (\r\n      (isBodyOverflowing && !isModalOverflowing && !isRTL()) ||\r\n      (!isBodyOverflowing && isModalOverflowing && isRTL())\r\n    ) {\r\n      this._element.style.paddingRight = `${scrollbarWidth}px`;\r\n    }\r\n  }\r\n\r\n  _resetAdjustments() {\r\n    this._element.style.paddingLeft = \"\";\r\n    this._element.style.paddingRight = \"\";\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config, relatedTarget) {\r\n    return this.each(function () {\r\n      const data = Modal.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config !== \"string\") {\r\n        return;\r\n      }\r\n\r\n      if (typeof data[config] === \"undefined\") {\r\n        throw new TypeError(`No method named \"${config}\"`);\r\n      }\r\n\r\n      data[config](relatedTarget);\r\n    });\r\n  }\r\n}\r\n\r\nexport default Modal;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nconst uriAttributes = new Set([\r\n  \"background\",\r\n  \"cite\",\r\n  \"href\",\r\n  \"itemtype\",\r\n  \"longdesc\",\r\n  \"poster\",\r\n  \"src\",\r\n  \"xlink:href\",\r\n]);\r\n\r\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\r\n\r\n/**\r\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n *\r\n * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\r\n */\r\nconst SAFE_URL_PATTERN =\r\n  /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\r\n\r\n/**\r\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\r\n *\r\n * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\r\n */\r\nconst DATA_URL_PATTERN =\r\n  /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\r\n\r\nconst allowedAttribute = (attribute, allowedAttributeList) => {\r\n  const attributeName = attribute.nodeName.toLowerCase();\r\n\r\n  if (allowedAttributeList.includes(attributeName)) {\r\n    if (uriAttributes.has(attributeName)) {\r\n      return Boolean(\r\n        SAFE_URL_PATTERN.test(attribute.nodeValue) ||\r\n          DATA_URL_PATTERN.test(attribute.nodeValue)\r\n      );\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  const regExp = allowedAttributeList.filter(\r\n    (attributeRegex) => attributeRegex instanceof RegExp\r\n  );\r\n\r\n  // Check if a regular expression validates the attribute.\r\n  for (let i = 0, len = regExp.length; i < len; i++) {\r\n    if (regExp[i].test(attributeName)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const DefaultAllowlist = {\r\n  // Global attributes allowed on any supplied element below.\r\n  \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", ARIA_ATTRIBUTE_PATTERN],\r\n  a: [\"target\", \"href\", \"title\", \"rel\"],\r\n  area: [],\r\n  b: [],\r\n  br: [],\r\n  col: [],\r\n  code: [],\r\n  div: [],\r\n  em: [],\r\n  hr: [],\r\n  h1: [],\r\n  h2: [],\r\n  h3: [],\r\n  h4: [],\r\n  h5: [],\r\n  h6: [],\r\n  i: [],\r\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\r\n  li: [],\r\n  ol: [],\r\n  p: [],\r\n  pre: [],\r\n  s: [],\r\n  small: [],\r\n  span: [],\r\n  sub: [],\r\n  sup: [],\r\n  strong: [],\r\n  u: [],\r\n  ul: [],\r\n};\r\n\r\nexport function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {\r\n  if (!unsafeHtml.length) {\r\n    return unsafeHtml;\r\n  }\r\n\r\n  if (sanitizeFn && typeof sanitizeFn === \"function\") {\r\n    return sanitizeFn(unsafeHtml);\r\n  }\r\n\r\n  const domParser = new window.DOMParser();\r\n  const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\r\n  const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\r\n\r\n  for (let i = 0, len = elements.length; i < len; i++) {\r\n    const element = elements[i];\r\n    const elementName = element.nodeName.toLowerCase();\r\n\r\n    if (!Object.keys(allowList).includes(elementName)) {\r\n      element.remove();\r\n\r\n      continue;\r\n    }\r\n\r\n    const attributeList = [].concat(...element.attributes);\r\n    const allowedAttributes = [].concat(\r\n      allowList[\"*\"] || [],\r\n      allowList[elementName] || []\r\n    );\r\n\r\n    attributeList.forEach((attribute) => {\r\n      if (!allowedAttribute(attribute, allowedAttributes)) {\r\n        element.removeAttribute(attribute.nodeName);\r\n      }\r\n    });\r\n  }\r\n\r\n  return createdDocument.body.innerHTML;\r\n}\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport * as Popper from \"@popperjs/core\";\r\n\r\nimport {\r\n  findShadowRoot,\r\n  getElement,\r\n  getUID,\r\n  isElement,\r\n  isRTL,\r\n  noop,\r\n  typeCheckConfig,\r\n} from \"../util/index\";\r\nimport { DefaultAllowlist, sanitizeHtml } from \"../util/sanitizer\";\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"tooltip\";\r\nconst DATA_KEY = \"te.tooltip\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst CLASS_PREFIX = \"te-tooltip\";\r\nconst DISALLOWED_ATTRIBUTES = new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]);\r\n\r\nconst DefaultType = {\r\n  animation: \"boolean\",\r\n  template: \"string\",\r\n  title: \"(string|element|function)\",\r\n  trigger: \"string\",\r\n  delay: \"(number|object)\",\r\n  html: \"boolean\",\r\n  selector: \"(string|boolean)\",\r\n  placement: \"(string|function)\",\r\n  offset: \"(array|string|function)\",\r\n  container: \"(string|element|boolean)\",\r\n  fallbackPlacements: \"array\",\r\n  boundary: \"(string|element)\",\r\n  customClass: \"(string|function)\",\r\n  sanitize: \"boolean\",\r\n  sanitizeFn: \"(null|function)\",\r\n  allowList: \"object\",\r\n  popperConfig: \"(null|object|function)\",\r\n};\r\n\r\nconst AttachmentMap = {\r\n  AUTO: \"auto\",\r\n  TOP: \"top\",\r\n  RIGHT: isRTL() ? \"left\" : \"right\",\r\n  BOTTOM: \"bottom\",\r\n  LEFT: isRTL() ? \"right\" : \"left\",\r\n};\r\n\r\nconst Default = {\r\n  animation: true,\r\n  template:\r\n    '<div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\">' +\r\n    '<div data-te-tooltip-inner-ref class=\"tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div>' +\r\n    \"</div>\",\r\n  trigger: \"hover focus\",\r\n  title: \"\",\r\n  delay: 0,\r\n  html: false,\r\n  selector: false,\r\n  placement: \"top\",\r\n  offset: [0, 0],\r\n  container: false,\r\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\r\n  boundary: \"clippingParents\",\r\n  customClass: \"\",\r\n  sanitize: true,\r\n  sanitizeFn: null,\r\n  allowList: DefaultAllowlist,\r\n  popperConfig: { hide: true },\r\n};\r\n\r\nconst Event = {\r\n  HIDE: `hide${EVENT_KEY}`,\r\n  HIDDEN: `hidden${EVENT_KEY}`,\r\n  SHOW: `show${EVENT_KEY}`,\r\n  SHOWN: `shown${EVENT_KEY}`,\r\n  INSERTED: `inserted${EVENT_KEY}`,\r\n  CLICK: `click${EVENT_KEY}`,\r\n  FOCUSIN: `focusin${EVENT_KEY}`,\r\n  FOCUSOUT: `focusout${EVENT_KEY}`,\r\n  MOUSEENTER: `mouseenter${EVENT_KEY}`,\r\n  MOUSELEAVE: `mouseleave${EVENT_KEY}`,\r\n};\r\n\r\nconst CLASS_NAME_FADE = \"fade\";\r\nconst CLASS_NAME_MODAL = \"modal\";\r\nconst CLASS_NAME_SHOW = \"show\";\r\n\r\nconst HOVER_STATE_SHOW = \"show\";\r\nconst HOVER_STATE_OUT = \"out\";\r\n\r\nconst SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\r\nconst SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\r\n\r\nconst EVENT_MODAL_HIDE = \"hide.te.modal\";\r\n\r\nconst TRIGGER_HOVER = \"hover\";\r\nconst TRIGGER_FOCUS = \"focus\";\r\nconst TRIGGER_CLICK = \"click\";\r\nconst TRIGGER_MANUAL = \"manual\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Tooltip extends BaseComponent {\r\n  constructor(element, config) {\r\n    if (typeof Popper === \"undefined\") {\r\n      throw new TypeError(\r\n        \"Bootstrap's tooltips require Popper (https://popper.js.org)\"\r\n      );\r\n    }\r\n\r\n    super(element);\r\n\r\n    // private\r\n    this._isEnabled = true;\r\n    this._timeout = 0;\r\n    this._hoverState = \"\";\r\n    this._activeTrigger = {};\r\n    this._popper = null;\r\n\r\n    // Protected\r\n    this._config = this._getConfig(config);\r\n    this.tip = null;\r\n\r\n    this._setListeners();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  static get Event() {\r\n    return Event;\r\n  }\r\n\r\n  static get DefaultType() {\r\n    return DefaultType;\r\n  }\r\n\r\n  // Public\r\n\r\n  enable() {\r\n    this._isEnabled = true;\r\n  }\r\n\r\n  disable() {\r\n    this._isEnabled = false;\r\n  }\r\n\r\n  toggleEnabled() {\r\n    this._isEnabled = !this._isEnabled;\r\n  }\r\n\r\n  toggle(event) {\r\n    if (!this._isEnabled) {\r\n      return;\r\n    }\r\n\r\n    if (event) {\r\n      const context = this._initializeOnDelegatedTarget(event);\r\n\r\n      context._activeTrigger.click = !context._activeTrigger.click;\r\n\r\n      if (context._isWithActiveTrigger()) {\r\n        context._enter(null, context);\r\n      } else {\r\n        context._leave(null, context);\r\n      }\r\n    } else {\r\n      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW)) {\r\n        this._leave(null, this);\r\n        return;\r\n      }\r\n\r\n      this._enter(null, this);\r\n    }\r\n  }\r\n\r\n  dispose() {\r\n    clearTimeout(this._timeout);\r\n\r\n    EventHandler.off(\r\n      this._element.closest(SELECTOR_MODAL),\r\n      EVENT_MODAL_HIDE,\r\n      this._hideModalHandler\r\n    );\r\n\r\n    if (this.tip) {\r\n      this.tip.remove();\r\n    }\r\n\r\n    this._disposePopper();\r\n    super.dispose();\r\n  }\r\n\r\n  show() {\r\n    if (this._element.style.display === \"none\") {\r\n      throw new Error(\"Please use show on visible elements\");\r\n    }\r\n\r\n    if (!(this.isWithContent() && this._isEnabled)) {\r\n      return;\r\n    }\r\n\r\n    const showEvent = EventHandler.trigger(\r\n      this._element,\r\n      this.constructor.Event.SHOW\r\n    );\r\n    const shadowRoot = findShadowRoot(this._element);\r\n    const isInTheDom =\r\n      shadowRoot === null\r\n        ? this._element.ownerDocument.documentElement.contains(this._element)\r\n        : shadowRoot.contains(this._element);\r\n\r\n    if (showEvent.defaultPrevented || !isInTheDom) {\r\n      return;\r\n    }\r\n\r\n    // A trick to recreate a tooltip in case a new title is given by using the NOT documented `data-te-original-title`\r\n    // This will be removed later in favor of a `setContent` method\r\n    if (\r\n      this.constructor.NAME === \"tooltip\" &&\r\n      this.tip &&\r\n      this.getTitle() !==\r\n        this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML\r\n    ) {\r\n      this._disposePopper();\r\n      this.tip.remove();\r\n      this.tip = null;\r\n    }\r\n\r\n    const tip = this.getTipElement();\r\n    const tipId = getUID(this.constructor.NAME);\r\n\r\n    tip.setAttribute(\"id\", tipId);\r\n    this._element.setAttribute(\"aria-describedby\", tipId);\r\n\r\n    if (this._config.animation) {\r\n      setTimeout(() => {\r\n        this.tip.classList.add(\"opacity-100\");\r\n        this.tip.classList.remove(\"opacity-0\");\r\n      }, 100);\r\n    }\r\n\r\n    const placement =\r\n      typeof this._config.placement === \"function\"\r\n        ? this._config.placement.call(this, tip, this._element)\r\n        : this._config.placement;\r\n\r\n    const attachment = this._getAttachment(placement);\r\n    this._addAttachmentClass(attachment);\r\n\r\n    const { container } = this._config;\r\n    Data.setData(tip, this.constructor.DATA_KEY, this);\r\n\r\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\r\n      container.append(tip);\r\n      EventHandler.trigger(this._element, this.constructor.Event.INSERTED);\r\n    }\r\n\r\n    if (this._popper) {\r\n      this._popper.update();\r\n    } else {\r\n      this._popper = Popper.createPopper(\r\n        this._element,\r\n        tip,\r\n        this._getPopperConfig(attachment)\r\n      );\r\n    }\r\n\r\n    const notPopover = tip.getAttribute(\"id\").includes(\"tooltip\");\r\n    if (notPopover) {\r\n      switch (placement) {\r\n        case \"bottom\":\r\n          tip.classList.add(\"py-[0.4rem]\");\r\n          break;\r\n        case \"left\":\r\n          tip.classList.add(\"px-[0.4rem]\");\r\n          break;\r\n        case \"right\":\r\n          tip.classList.add(\"px-[0.4rem]\");\r\n          break;\r\n\r\n        default:\r\n          tip.classList.add(\"py-[0.4rem]\");\r\n          break;\r\n      }\r\n    }\r\n\r\n    const customClass = this._resolvePossibleFunction(this._config.customClass);\r\n    if (customClass) {\r\n      tip.classList.add(...customClass.split(\" \"));\r\n    }\r\n\r\n    // If this is a touch-enabled device we add extra\r\n    // empty mouseover listeners to the body's immediate children;\r\n    // only needed because of broken event delegation on iOS\r\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n    if (\"ontouchstart\" in document.documentElement) {\r\n      [].concat(...document.body.children).forEach((element) => {\r\n        EventHandler.on(element, \"mouseover\", noop);\r\n      });\r\n    }\r\n\r\n    const complete = () => {\r\n      const prevHoverState = this._hoverState;\r\n\r\n      this._hoverState = null;\r\n      EventHandler.trigger(this._element, this.constructor.Event.SHOWN);\r\n\r\n      if (prevHoverState === HOVER_STATE_OUT) {\r\n        this._leave(null, this);\r\n      }\r\n    };\r\n\r\n    const isAnimated = this.tip.classList.contains(\"transition-opacity\");\r\n    this._queueCallback(complete, this.tip, isAnimated);\r\n  }\r\n\r\n  hide() {\r\n    if (!this._popper) {\r\n      return;\r\n    }\r\n\r\n    const tip = this.getTipElement();\r\n    const complete = () => {\r\n      if (this._isWithActiveTrigger()) {\r\n        return;\r\n      }\r\n\r\n      if (this._hoverState !== HOVER_STATE_SHOW) {\r\n        tip.remove();\r\n      }\r\n\r\n      this._cleanTipClass();\r\n      this._element.removeAttribute(\"aria-describedby\");\r\n      EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);\r\n\r\n      this._disposePopper();\r\n    };\r\n\r\n    const hideEvent = EventHandler.trigger(\r\n      this._element,\r\n      this.constructor.Event.HIDE\r\n    );\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    tip.classList.add(\"opacity-0\");\r\n    tip.classList.remove(\"opacity-100\");\r\n\r\n    // If this is a touch-enabled device we remove the extra\r\n    // empty mouseover listeners we added for iOS support\r\n    if (\"ontouchstart\" in document.documentElement) {\r\n      []\r\n        .concat(...document.body.children)\r\n        .forEach((element) => EventHandler.off(element, \"mouseover\", noop));\r\n    }\r\n\r\n    this._activeTrigger[TRIGGER_CLICK] = false;\r\n    this._activeTrigger[TRIGGER_FOCUS] = false;\r\n    this._activeTrigger[TRIGGER_HOVER] = false;\r\n\r\n    const isAnimated = this.tip.classList.contains(\"opacity-0\");\r\n    this._queueCallback(complete, this.tip, isAnimated);\r\n    this._hoverState = \"\";\r\n  }\r\n\r\n  update() {\r\n    if (this._popper !== null) {\r\n      this._popper.update();\r\n    }\r\n  }\r\n\r\n  // Protected\r\n\r\n  isWithContent() {\r\n    return Boolean(this.getTitle());\r\n  }\r\n\r\n  getTipElement() {\r\n    if (this.tip) {\r\n      return this.tip;\r\n    }\r\n\r\n    const element = document.createElement(\"div\");\r\n    element.innerHTML = this._config.template;\r\n\r\n    const tip = element.children[0];\r\n    this.setContent(tip);\r\n    tip.classList.remove(CLASS_NAME_FADE, CLASS_NAME_SHOW);\r\n\r\n    this.tip = tip;\r\n    return this.tip;\r\n  }\r\n\r\n  setContent(tip) {\r\n    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);\r\n  }\r\n\r\n  _sanitizeAndSetContent(template, content, selector) {\r\n    const templateElement = SelectorEngine.findOne(selector, template);\r\n\r\n    if (!content && templateElement) {\r\n      templateElement.remove();\r\n      return;\r\n    }\r\n\r\n    // we use append for html objects to maintain js events\r\n    this.setElementContent(templateElement, content);\r\n  }\r\n\r\n  setElementContent(element, content) {\r\n    if (element === null) {\r\n      return;\r\n    }\r\n\r\n    if (isElement(content)) {\r\n      content = getElement(content);\r\n\r\n      // content is a DOM node or a jQuery\r\n      if (this._config.html) {\r\n        if (content.parentNode !== element) {\r\n          element.innerHTML = \"\";\r\n          element.append(content);\r\n        }\r\n      } else {\r\n        element.textContent = content.textContent;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (this._config.html) {\r\n      if (this._config.sanitize) {\r\n        content = sanitizeHtml(\r\n          content,\r\n          this._config.allowList,\r\n          this._config.sanitizeFn\r\n        );\r\n      }\r\n\r\n      element.innerHTML = content;\r\n    } else {\r\n      element.textContent = content;\r\n    }\r\n  }\r\n\r\n  getTitle() {\r\n    const title =\r\n      this._element.getAttribute(\"data-te-original-title\") ||\r\n      this._config.title;\r\n\r\n    return this._resolvePossibleFunction(title);\r\n  }\r\n\r\n  updateAttachment(attachment) {\r\n    if (attachment === \"right\") {\r\n      return \"end\";\r\n    }\r\n\r\n    if (attachment === \"left\") {\r\n      return \"start\";\r\n    }\r\n\r\n    return attachment;\r\n  }\r\n\r\n  // Private\r\n\r\n  _initializeOnDelegatedTarget(event, context) {\r\n    return (\r\n      context ||\r\n      this.constructor.getOrCreateInstance(\r\n        event.delegateTarget,\r\n        this._getDelegateConfig()\r\n      )\r\n    );\r\n  }\r\n\r\n  _getOffset() {\r\n    const { offset } = this._config;\r\n\r\n    if (typeof offset === \"string\") {\r\n      return offset.split(\",\").map((val) => Number.parseInt(val, 10));\r\n    }\r\n\r\n    if (typeof offset === \"function\") {\r\n      return (popperData) => offset(popperData, this._element);\r\n    }\r\n\r\n    return offset;\r\n  }\r\n\r\n  _resolvePossibleFunction(content) {\r\n    return typeof content === \"function\"\r\n      ? content.call(this._element)\r\n      : content;\r\n  }\r\n\r\n  _getPopperConfig(attachment) {\r\n    const defaultBsPopperConfig = {\r\n      placement: attachment,\r\n      modifiers: [\r\n        {\r\n          name: \"flip\",\r\n          options: {\r\n            fallbackPlacements: this._config.fallbackPlacements,\r\n          },\r\n        },\r\n        {\r\n          name: \"offset\",\r\n          options: {\r\n            offset: this._getOffset(),\r\n          },\r\n        },\r\n        {\r\n          name: \"preventOverflow\",\r\n          options: {\r\n            boundary: this._config.boundary,\r\n          },\r\n        },\r\n        {\r\n          name: \"arrow\",\r\n          options: {\r\n            element: `.${this.constructor.NAME}-arrow`,\r\n          },\r\n        },\r\n        {\r\n          name: \"onChange\",\r\n          enabled: true,\r\n          phase: \"afterWrite\",\r\n          fn: (data) => this._handlePopperPlacementChange(data),\r\n        },\r\n      ],\r\n      onFirstUpdate: (data) => {\r\n        if (data.options.placement !== data.placement) {\r\n          this._handlePopperPlacementChange(data);\r\n        }\r\n      },\r\n    };\r\n\r\n    return {\r\n      ...defaultBsPopperConfig,\r\n      ...(typeof this._config.popperConfig === \"function\"\r\n        ? this._config.popperConfig(defaultBsPopperConfig)\r\n        : this._config.popperConfig),\r\n    };\r\n  }\r\n\r\n  _addAttachmentClass(attachment) {\r\n    this.getTipElement().classList.add(\r\n      `${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`\r\n    );\r\n  }\r\n\r\n  _getAttachment(placement) {\r\n    return AttachmentMap[placement.toUpperCase()];\r\n  }\r\n\r\n  _setListeners() {\r\n    const triggers = this._config.trigger.split(\" \");\r\n\r\n    triggers.forEach((trigger) => {\r\n      if (trigger === \"click\") {\r\n        EventHandler.on(\r\n          this._element,\r\n          this.constructor.Event.CLICK,\r\n          this._config.selector,\r\n          (event) => this.toggle(event)\r\n        );\r\n      } else if (trigger !== TRIGGER_MANUAL) {\r\n        const eventIn =\r\n          trigger === TRIGGER_HOVER\r\n            ? this.constructor.Event.MOUSEENTER\r\n            : this.constructor.Event.FOCUSIN;\r\n        const eventOut =\r\n          trigger === TRIGGER_HOVER\r\n            ? this.constructor.Event.MOUSELEAVE\r\n            : this.constructor.Event.FOCUSOUT;\r\n\r\n        EventHandler.on(\r\n          this._element,\r\n          eventIn,\r\n          this._config.selector,\r\n          (event) => this._enter(event)\r\n        );\r\n        EventHandler.on(\r\n          this._element,\r\n          eventOut,\r\n          this._config.selector,\r\n          (event) => this._leave(event)\r\n        );\r\n      }\r\n    });\r\n\r\n    this._hideModalHandler = () => {\r\n      if (this._element) {\r\n        this.hide();\r\n      }\r\n    };\r\n\r\n    EventHandler.on(\r\n      this._element.closest(SELECTOR_MODAL),\r\n      EVENT_MODAL_HIDE,\r\n      this._hideModalHandler\r\n    );\r\n\r\n    if (this._config.selector) {\r\n      this._config = {\r\n        ...this._config,\r\n        trigger: \"manual\",\r\n        selector: \"\",\r\n      };\r\n    } else {\r\n      this._fixTitle();\r\n    }\r\n  }\r\n\r\n  _fixTitle() {\r\n    const title = this._element.getAttribute(\"title\");\r\n    const originalTitleType = typeof this._element.getAttribute(\r\n      \"data-te-original-title\"\r\n    );\r\n\r\n    if (title || originalTitleType !== \"string\") {\r\n      this._element.setAttribute(\"data-te-original-title\", title || \"\");\r\n      if (\r\n        title &&\r\n        !this._element.getAttribute(\"aria-label\") &&\r\n        !this._element.textContent\r\n      ) {\r\n        this._element.setAttribute(\"aria-label\", title);\r\n      }\r\n\r\n      this._element.setAttribute(\"title\", \"\");\r\n    }\r\n  }\r\n\r\n  _enter(event, context) {\r\n    context = this._initializeOnDelegatedTarget(event, context);\r\n\r\n    if (event) {\r\n      context._activeTrigger[\r\n        event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER\r\n      ] = true;\r\n    }\r\n\r\n    if (\r\n      context.getTipElement().classList.contains(CLASS_NAME_SHOW) ||\r\n      context._hoverState === HOVER_STATE_SHOW\r\n    ) {\r\n      context._hoverState = HOVER_STATE_SHOW;\r\n      return;\r\n    }\r\n\r\n    clearTimeout(context._timeout);\r\n\r\n    context._hoverState = HOVER_STATE_SHOW;\r\n\r\n    if (!context._config.delay || !context._config.delay.show) {\r\n      context.show();\r\n      return;\r\n    }\r\n\r\n    context._timeout = setTimeout(() => {\r\n      if (context._hoverState === HOVER_STATE_SHOW) {\r\n        context.show();\r\n      }\r\n    }, context._config.delay.show);\r\n  }\r\n\r\n  _leave(event, context) {\r\n    context = this._initializeOnDelegatedTarget(event, context);\r\n\r\n    if (event) {\r\n      context._activeTrigger[\r\n        event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER\r\n      ] = context._element.contains(event.relatedTarget);\r\n    }\r\n\r\n    if (context._isWithActiveTrigger()) {\r\n      return;\r\n    }\r\n\r\n    clearTimeout(context._timeout);\r\n\r\n    context._hoverState = HOVER_STATE_OUT;\r\n\r\n    if (!context._config.delay || !context._config.delay.hide) {\r\n      context.hide();\r\n      return;\r\n    }\r\n\r\n    context._timeout = setTimeout(() => {\r\n      if (context._hoverState === HOVER_STATE_OUT) {\r\n        context.hide();\r\n      }\r\n    }, context._config.delay.hide);\r\n  }\r\n\r\n  _isWithActiveTrigger() {\r\n    for (const trigger in this._activeTrigger) {\r\n      if (this._activeTrigger[trigger]) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    Object.keys(dataAttributes).forEach((dataAttr) => {\r\n      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {\r\n        delete dataAttributes[dataAttr];\r\n      }\r\n    });\r\n\r\n    config = {\r\n      ...this.constructor.Default,\r\n      ...dataAttributes,\r\n      ...(typeof config === \"object\" && config ? config : {}),\r\n    };\r\n\r\n    config.container =\r\n      config.container === false ? document.body : getElement(config.container);\r\n\r\n    if (typeof config.delay === \"number\") {\r\n      config.delay = {\r\n        show: config.delay,\r\n        hide: config.delay,\r\n      };\r\n    }\r\n\r\n    if (typeof config.title === \"number\") {\r\n      config.title = config.title.toString();\r\n    }\r\n\r\n    if (typeof config.content === \"number\") {\r\n      config.content = config.content.toString();\r\n    }\r\n\r\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\r\n\r\n    if (config.sanitize) {\r\n      config.template = sanitizeHtml(\r\n        config.template,\r\n        config.allowList,\r\n        config.sanitizeFn\r\n      );\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  _getDelegateConfig() {\r\n    const config = {};\r\n\r\n    for (const key in this._config) {\r\n      if (this.constructor.Default[key] !== this._config[key]) {\r\n        config[key] = this._config[key];\r\n      }\r\n    }\r\n\r\n    // In the future can be replaced with:\r\n    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\r\n    // `Object.fromEntries(keysWithDifferentValues)`\r\n    return config;\r\n  }\r\n\r\n  _cleanTipClass() {\r\n    const tip = this.getTipElement();\r\n    const basicClassPrefixRegex = new RegExp(\r\n      `(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\r\n      \"g\"\r\n    );\r\n    const tabClass = tip.getAttribute(\"class\").match(basicClassPrefixRegex);\r\n    if (tabClass !== null && tabClass.length > 0) {\r\n      tabClass\r\n        .map((token) => token.trim())\r\n        .forEach((tClass) => tip.classList.remove(tClass));\r\n    }\r\n  }\r\n\r\n  _getBasicClassPrefix() {\r\n    return CLASS_PREFIX;\r\n  }\r\n\r\n  _handlePopperPlacementChange(popperData) {\r\n    const { state } = popperData;\r\n\r\n    if (!state) {\r\n      return;\r\n    }\r\n\r\n    this.tip = state.elements.popper;\r\n    this._cleanTipClass();\r\n    this._addAttachmentClass(this._getAttachment(state.placement));\r\n  }\r\n\r\n  _disposePopper() {\r\n    if (this._popper) {\r\n      this._popper.destroy();\r\n      this._popper = null;\r\n    }\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Tooltip.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config]();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Tooltip;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Tooltip from \"./tooltip\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"popover\";\r\nconst DATA_KEY = \"te.popover\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst CLASS_PREFIX = \"te-popover\";\r\n\r\nconst Default = {\r\n  ...Tooltip.Default,\r\n  placement: \"right\",\r\n  offset: [0, 8],\r\n  trigger: \"click\",\r\n  content: \"\",\r\n  template:\r\n    '<div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\">' +\r\n    '<h3 class=\"popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500\"></h3>' +\r\n    '<div class=\"popover-body p-4 text-[#212529] dark:text-white\"></div>' +\r\n    \"</div>\",\r\n};\r\n\r\nconst DefaultType = {\r\n  ...Tooltip.DefaultType,\r\n  content: \"(string|element|function)\",\r\n};\r\n\r\nconst Event = {\r\n  HIDE: `hide${EVENT_KEY}`,\r\n  HIDDEN: `hidden${EVENT_KEY}`,\r\n  SHOW: `show${EVENT_KEY}`,\r\n  SHOWN: `shown${EVENT_KEY}`,\r\n  INSERTED: `inserted${EVENT_KEY}`,\r\n  CLICK: `click${EVENT_KEY}`,\r\n  FOCUSIN: `focusin${EVENT_KEY}`,\r\n  FOCUSOUT: `focusout${EVENT_KEY}`,\r\n  MOUSEENTER: `mouseenter${EVENT_KEY}`,\r\n  MOUSELEAVE: `mouseleave${EVENT_KEY}`,\r\n};\r\n\r\nconst SELECTOR_TITLE = \".popover-header\";\r\nconst SELECTOR_CONTENT = \".popover-body\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Popover extends Tooltip {\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  static get Event() {\r\n    return Event;\r\n  }\r\n\r\n  static get DefaultType() {\r\n    return DefaultType;\r\n  }\r\n\r\n  // Overrides\r\n\r\n  isWithContent() {\r\n    return this.getTitle() || this._getContent();\r\n  }\r\n\r\n  setContent(tip) {\r\n    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);\r\n    this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);\r\n  }\r\n\r\n  // Private\r\n\r\n  _getContent() {\r\n    return this._resolvePossibleFunction(this._config.content);\r\n  }\r\n\r\n  _getBasicClassPrefix() {\r\n    return CLASS_PREFIX;\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Popover.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config]();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Popover;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport {\r\n  getElement,\r\n  getSelectorFromElement,\r\n  typeCheckConfig,\r\n} from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport MDBManipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"scrollspy\";\r\nconst DATA_KEY = \"te.scrollspy\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\n\r\nconst Default = {\r\n  offset: 10,\r\n  method: \"auto\",\r\n  target: \"\",\r\n};\r\n\r\nconst DefaultType = {\r\n  offset: \"number\",\r\n  method: \"string\",\r\n  target: \"(string|element)\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  active:\r\n    \"!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  active: \"string\",\r\n};\r\n\r\nconst EVENT_ACTIVATE = `activate${EVENT_KEY}`;\r\nconst EVENT_SCROLL = `scroll${EVENT_KEY}`;\r\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;\r\n\r\nconst LINK_ACTIVE = \"data-te-nav-link-active\";\r\nconst SELECTOR_DROPDOWN_ITEM = \"[data-te-dropdown-item-ref]\";\r\nconst SELECTOR_DATA_SPY = '[data-te-spy=\"scroll\"]';\r\nconst SELECTOR_NAV_LIST_GROUP = \"[data-te-nav-list-ref]\";\r\nconst SELECTOR_NAV_LINKS = \"[data-te-nav-link-ref]\";\r\nconst SELECTOR_NAV_ITEMS = \"[data-te-nav-item-ref]\";\r\nconst SELECTOR_LIST_ITEMS = \"[data-te-list-group-item-ref]\";\r\nconst SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, ${SELECTOR_DROPDOWN_ITEM}`;\r\nconst SELECTOR_DROPDOWN = \"[data-te-dropdown-ref]\";\r\nconst SELECTOR_DROPDOWN_TOGGLE = \"[data-te-dropdown-toggle-ref]\";\r\n\r\nconst METHOD_OFFSET = \"offset\";\r\nconst METHOD_POSITION = \"position\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass ScrollSpy extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n    this._scrollElement =\r\n      this._element.tagName === \"BODY\" ? window : this._element;\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._offsets = [];\r\n    this._targets = [];\r\n    this._activeTarget = null;\r\n    this._scrollHeight = 0;\r\n\r\n    EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());\r\n\r\n    this.refresh();\r\n    this._process();\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  refresh() {\r\n    const autoMethod =\r\n      this._scrollElement === this._scrollElement.window\r\n        ? METHOD_OFFSET\r\n        : METHOD_POSITION;\r\n\r\n    const offsetMethod =\r\n      this._config.method === \"auto\" ? autoMethod : this._config.method;\r\n\r\n    const offsetBase =\r\n      offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\r\n\r\n    this._offsets = [];\r\n    this._targets = [];\r\n    this._scrollHeight = this._getScrollHeight();\r\n\r\n    const targets = SelectorEngine.find(\r\n      SELECTOR_LINK_ITEMS,\r\n      this._config.target\r\n    );\r\n\r\n    targets\r\n      .map((element) => {\r\n        const targetSelector = getSelectorFromElement(element);\r\n        const target = targetSelector\r\n          ? SelectorEngine.findOne(targetSelector)\r\n          : null;\r\n\r\n        if (target) {\r\n          const targetBCR = target.getBoundingClientRect();\r\n          if (targetBCR.width || targetBCR.height) {\r\n            return [\r\n              Manipulator[offsetMethod](target).top + offsetBase,\r\n              targetSelector,\r\n            ];\r\n          }\r\n        }\r\n\r\n        return null;\r\n      })\r\n      .filter((item) => item)\r\n      .sort((a, b) => a[0] - b[0])\r\n      .forEach((item) => {\r\n        this._offsets.push(item[0]);\r\n        this._targets.push(item[1]);\r\n      });\r\n  }\r\n\r\n  dispose() {\r\n    EventHandler.off(this._scrollElement, EVENT_KEY);\r\n    super.dispose();\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n    EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\r\n      SelectorEngine.find(SELECTOR_DATA_SPY).forEach(\r\n        (spy) => new ScrollSpy(spy)\r\n      );\r\n    });\r\n\r\n    this._didInit = true;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" && config ? config : {}),\r\n    };\r\n\r\n    config.target = getElement(config.target) || document.documentElement;\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = MDBManipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getScrollTop() {\r\n    return this._scrollElement === window\r\n      ? this._scrollElement.pageYOffset\r\n      : this._scrollElement.scrollTop;\r\n  }\r\n\r\n  _getScrollHeight() {\r\n    return (\r\n      this._scrollElement.scrollHeight ||\r\n      Math.max(\r\n        document.body.scrollHeight,\r\n        document.documentElement.scrollHeight\r\n      )\r\n    );\r\n  }\r\n\r\n  _getOffsetHeight() {\r\n    return this._scrollElement === window\r\n      ? window.innerHeight\r\n      : this._scrollElement.getBoundingClientRect().height;\r\n  }\r\n\r\n  _process() {\r\n    const scrollTop = this._getScrollTop() + this._config.offset;\r\n    const scrollHeight = this._getScrollHeight();\r\n    const maxScroll =\r\n      this._config.offset + scrollHeight - this._getOffsetHeight();\r\n\r\n    if (this._scrollHeight !== scrollHeight) {\r\n      this.refresh();\r\n    }\r\n\r\n    if (scrollTop >= maxScroll) {\r\n      const target = this._targets[this._targets.length - 1];\r\n\r\n      if (this._activeTarget !== target) {\r\n        this._activate(target);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (\r\n      this._activeTarget &&\r\n      scrollTop < this._offsets[0] &&\r\n      this._offsets[0] > 0\r\n    ) {\r\n      this._activeTarget = null;\r\n      this._clear();\r\n      return;\r\n    }\r\n\r\n    for (let i = this._offsets.length; i--; ) {\r\n      const isActiveTarget =\r\n        this._activeTarget !== this._targets[i] &&\r\n        scrollTop >= this._offsets[i] &&\r\n        (typeof this._offsets[i + 1] === \"undefined\" ||\r\n          scrollTop < this._offsets[i + 1]);\r\n\r\n      if (isActiveTarget) {\r\n        this._activate(this._targets[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  _activate(target) {\r\n    this._activeTarget = target;\r\n\r\n    this._clear();\r\n\r\n    const queries = SELECTOR_LINK_ITEMS.split(\",\").map(\r\n      (selector) =>\r\n        `${selector}[data-te-target=\"${target}\"],${selector}[href=\"${target}\"]`\r\n    );\r\n\r\n    const link = SelectorEngine.findOne(queries.join(\",\"), this._config.target);\r\n\r\n    link.classList.add(...this._classes.active.split(\" \"));\r\n    link.setAttribute(LINK_ACTIVE, \"\");\r\n\r\n    if (link.getAttribute(SELECTOR_DROPDOWN_ITEM)) {\r\n      SelectorEngine.findOne(\r\n        SELECTOR_DROPDOWN_TOGGLE,\r\n        link.closest(SELECTOR_DROPDOWN)\r\n      ).classList.add(...this._classes.active.split(\" \"));\r\n    } else {\r\n      SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP).forEach(\r\n        (listGroup) => {\r\n          // Set triggered links parents as active\r\n          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\r\n          SelectorEngine.prev(\r\n            listGroup,\r\n            `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`\r\n          ).forEach((item) => {\r\n            item.classList.add(...this._classes.active.split(\" \"));\r\n            item.setAttribute(LINK_ACTIVE, \"\");\r\n          });\r\n\r\n          // Handle special case when .nav-link is inside .nav-item\r\n          SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(\r\n            (navItem) => {\r\n              SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(\r\n                (item) => item.classList.add(...this._classes.active.split(\" \"))\r\n              );\r\n            }\r\n          );\r\n        }\r\n      );\r\n    }\r\n\r\n    EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {\r\n      relatedTarget: target,\r\n    });\r\n  }\r\n\r\n  _clear() {\r\n    SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target)\r\n      .filter((node) =>\r\n        node.classList.contains(...this._classes.active.split(\" \"))\r\n      )\r\n      .forEach((node) => {\r\n        node.classList.remove(...this._classes.active.split(\" \"));\r\n        node.removeAttribute(LINK_ACTIVE);\r\n      });\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = ScrollSpy.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config !== \"string\") {\r\n        return;\r\n      }\r\n\r\n      if (typeof data[config] === \"undefined\") {\r\n        throw new TypeError(`No method named \"${config}\"`);\r\n      }\r\n\r\n      data[config]();\r\n    });\r\n  }\r\n}\r\n\r\nexport default ScrollSpy;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { getElementFromSelector, reflow, typeCheckConfig } from \"../util/index\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport BaseComponent from \"../base-component\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"tab\";\r\nconst DATA_KEY = \"te.tab\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\n\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\n\r\nconst DATA_NAME_DROPDOWN_MENU = \"data-te-dropdown-menu-ref\";\r\nconst TAB_ACTIVE = \"data-te-tab-active\";\r\nconst NAV_ACTIVE = \"data-te-nav-active\";\r\n\r\nconst SELECTOR_DROPDOWN = \"[data-te-dropdown-ref]\";\r\nconst SELECTOR_NAV = \"[data-te-nav-ref]\";\r\nconst SELECTOR_TAB_ACTIVE = `[${TAB_ACTIVE}]`;\r\nconst SELECTOR_NAV_ACTIVE = `[${NAV_ACTIVE}]`;\r\nconst SELECTOR_ACTIVE_UL = \":scope > li > .active\";\r\nconst SELECTOR_DROPDOWN_TOGGLE = \"[data-te-dropdown-toggle-ref]\";\r\nconst SELECTOR_DROPDOWN_ACTIVE_CHILD =\r\n  \":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]\";\r\n\r\nconst DefaultClasses = {\r\n  show: \"opacity-100\",\r\n  hide: \"opacity-0\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  show: \"string\",\r\n  hide: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Tab extends BaseComponent {\r\n  constructor(element, classes) {\r\n    super(element);\r\n    this._classes = this._getClasses(classes);\r\n  }\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  show() {\r\n    if (\r\n      this._element.parentNode &&\r\n      this._element.parentNode.nodeType === Node.ELEMENT_NODE &&\r\n      this._element.getAttribute(NAV_ACTIVE) === \"\"\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    let previous;\r\n    const target = getElementFromSelector(this._element);\r\n    const listElement = this._element.closest(SELECTOR_NAV);\r\n    const activeNavElement = SelectorEngine.findOne(\r\n      SELECTOR_NAV_ACTIVE,\r\n      listElement\r\n    );\r\n\r\n    if (listElement) {\r\n      const itemSelector =\r\n        listElement.nodeName === \"UL\" || listElement.nodeName === \"OL\"\r\n          ? SELECTOR_ACTIVE_UL\r\n          : SELECTOR_TAB_ACTIVE;\r\n      previous = SelectorEngine.find(itemSelector, listElement);\r\n      previous = previous[previous.length - 1];\r\n    }\r\n\r\n    const hideEvent = previous\r\n      ? EventHandler.trigger(previous, EVENT_HIDE, {\r\n          relatedTarget: this._element,\r\n        })\r\n      : null;\r\n\r\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW, {\r\n      relatedTarget: previous,\r\n    });\r\n\r\n    if (\r\n      showEvent.defaultPrevented ||\r\n      (hideEvent !== null && hideEvent.defaultPrevented)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._activate(\r\n      this._element,\r\n      listElement,\r\n      null,\r\n      activeNavElement,\r\n      this._element\r\n    );\r\n\r\n    const complete = () => {\r\n      EventHandler.trigger(previous, EVENT_HIDDEN, {\r\n        relatedTarget: this._element,\r\n      });\r\n      EventHandler.trigger(this._element, EVENT_SHOWN, {\r\n        relatedTarget: previous,\r\n      });\r\n    };\r\n\r\n    if (target) {\r\n      this._activate(\r\n        target,\r\n        target.parentNode,\r\n        complete,\r\n        activeNavElement,\r\n        this._element\r\n      );\r\n    } else {\r\n      complete();\r\n    }\r\n  }\r\n\r\n  // Private\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _activate(element, container, callback, activeNavElement, navElement) {\r\n    const activeElements =\r\n      container && (container.nodeName === \"UL\" || container.nodeName === \"OL\")\r\n        ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container)\r\n        : SelectorEngine.children(container, SELECTOR_TAB_ACTIVE);\r\n\r\n    const active = activeElements[0];\r\n    const isTransitioning =\r\n      callback && active && active.hasAttribute(TAB_ACTIVE);\r\n\r\n    const complete = () =>\r\n      this._transitionComplete(\r\n        element,\r\n        active,\r\n        callback,\r\n        activeNavElement,\r\n        navElement\r\n      );\r\n\r\n    if (active && isTransitioning) {\r\n      Manipulator.removeClass(active, this._classes.show);\r\n      Manipulator.addClass(active, this._classes.hide);\r\n      this._queueCallback(complete, element, true);\r\n    } else {\r\n      complete();\r\n    }\r\n  }\r\n\r\n  _transitionComplete(element, active, callback, activeNavElement, navElement) {\r\n    if (active && activeNavElement) {\r\n      active.removeAttribute(TAB_ACTIVE);\r\n      activeNavElement.removeAttribute(NAV_ACTIVE);\r\n\r\n      const dropdownChild = SelectorEngine.findOne(\r\n        SELECTOR_DROPDOWN_ACTIVE_CHILD,\r\n        active.parentNode\r\n      );\r\n\r\n      if (dropdownChild) {\r\n        dropdownChild.removeAttribute(TAB_ACTIVE);\r\n      }\r\n\r\n      if (active.getAttribute(\"role\") === \"tab\") {\r\n        active.setAttribute(\"aria-selected\", false);\r\n      }\r\n    }\r\n\r\n    element.setAttribute(TAB_ACTIVE, \"\");\r\n    navElement.setAttribute(NAV_ACTIVE, \"\");\r\n\r\n    if (element.getAttribute(\"role\") === \"tab\") {\r\n      element.setAttribute(\"aria-selected\", true);\r\n    }\r\n\r\n    reflow(element);\r\n\r\n    if (element.classList.contains(this._classes.hide)) {\r\n      Manipulator.removeClass(element, this._classes.hide);\r\n      Manipulator.addClass(element, this._classes.show);\r\n    }\r\n\r\n    let parent = element.parentNode;\r\n    if (parent && parent.nodeName === \"LI\") {\r\n      parent = parent.parentNode;\r\n    }\r\n\r\n    if (parent && parent.hasAttribute(DATA_NAME_DROPDOWN_MENU)) {\r\n      const dropdownElement = element.closest(SELECTOR_DROPDOWN);\r\n\r\n      if (dropdownElement) {\r\n        SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(\r\n          (dropdown) => dropdown.setAttribute(TAB_ACTIVE, \"\")\r\n        );\r\n      }\r\n\r\n      element.setAttribute(\"aria-expanded\", true);\r\n    }\r\n\r\n    if (callback) {\r\n      callback();\r\n    }\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Tab.getOrCreateInstance(this);\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config]();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Tab;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { reflow, typeCheckConfig } from \"../util/index\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport BaseComponent from \"../base-component\";\r\nimport { enableDismissTrigger } from \"../util/component-functions\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"toast\";\r\nconst DATA_KEY = \"te.toast\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\n\r\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\r\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\r\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\r\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\r\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\r\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\nconst EVENT_SHOW = `show${EVENT_KEY}`;\r\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\r\n\r\nconst HIDE_DATA_ATTRIBUTE = \"data-te-toast-hide\";\r\nconst SHOW_DATA_ATTRIBUTE = \"data-te-toast-show\";\r\nconst SHOWING_DATA_ATTRIBUTE = \"data-te-toast-showing\";\r\n\r\nconst DefaultType = {\r\n  animation: \"boolean\",\r\n  autohide: \"boolean\",\r\n  delay: \"number\",\r\n};\r\n\r\nconst Default = {\r\n  animation: true,\r\n  autohide: true,\r\n  delay: 5000,\r\n};\r\n\r\nconst DefaultClasses = {\r\n  fadeIn:\r\n    \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\r\n  fadeOut:\r\n    \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  fadeIn: \"string\",\r\n  fadeOut: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Toast extends BaseComponent {\r\n  constructor(element, config, classes) {\r\n    super(element);\r\n\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n    this._timeout = null;\r\n    this._hasMouseInteraction = false;\r\n    this._hasKeyboardInteraction = false;\r\n    this._setListeners();\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get DefaultType() {\r\n    return DefaultType;\r\n  }\r\n\r\n  static get Default() {\r\n    return Default;\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  show() {\r\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\r\n\r\n    if (showEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._clearTimeout();\r\n\r\n    if (this._config.animation) {\r\n      Manipulator.removeClass(this._element, this._classes.fadeOut);\r\n      Manipulator.addClass(this._element, this._classes.fadeIn);\r\n    }\r\n\r\n    const complete = () => {\r\n      this._element.removeAttribute(SHOWING_DATA_ATTRIBUTE);\r\n      EventHandler.trigger(this._element, EVENT_SHOWN);\r\n\r\n      this._maybeScheduleHide();\r\n    };\r\n\r\n    this._element.removeAttribute(HIDE_DATA_ATTRIBUTE);\r\n    reflow(this._element);\r\n    this._element.setAttribute(SHOW_DATA_ATTRIBUTE, \"\");\r\n    this._element.setAttribute(SHOWING_DATA_ATTRIBUTE, \"\");\r\n\r\n    this._queueCallback(complete, this._element, this._config.animation);\r\n  }\r\n\r\n  hide() {\r\n    if (!this._element || this._element.dataset.teToastShow === undefined) {\r\n      return;\r\n    }\r\n\r\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n\r\n    if (hideEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const complete = () => {\r\n      let timeout = 0;\r\n      if (this._config.animation) {\r\n        timeout = 300;\r\n        Manipulator.removeClass(this._element, this._classes.fadeIn);\r\n        Manipulator.addClass(this._element, this._classes.fadeOut);\r\n      }\r\n      setTimeout(() => {\r\n        this._element.setAttribute(HIDE_DATA_ATTRIBUTE, \"\");\r\n        this._element.removeAttribute(SHOWING_DATA_ATTRIBUTE);\r\n        this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n      }, timeout);\r\n    };\r\n\r\n    this._element.setAttribute(SHOWING_DATA_ATTRIBUTE, \"\");\r\n    this._queueCallback(complete, this._element, this._config.animation);\r\n  }\r\n\r\n  dispose() {\r\n    this._clearTimeout();\r\n\r\n    if (this._element.dataset.teToastShow !== undefined) {\r\n      this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);\r\n    }\r\n\r\n    super.dispose();\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n\r\n    enableDismissTrigger(Toast);\r\n    this._didInit = true;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...(typeof config === \"object\" && config ? config : {}),\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _maybeScheduleHide() {\r\n    if (!this._config.autohide) {\r\n      return;\r\n    }\r\n\r\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\r\n      return;\r\n    }\r\n\r\n    this._timeout = setTimeout(() => {\r\n      this.hide();\r\n    }, this._config.delay);\r\n  }\r\n\r\n  _onInteraction(event, isInteracting) {\r\n    switch (event.type) {\r\n      case \"mouseover\":\r\n      case \"mouseout\":\r\n        this._hasMouseInteraction = isInteracting;\r\n        break;\r\n      case \"focusin\":\r\n      case \"focusout\":\r\n        this._hasKeyboardInteraction = isInteracting;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (isInteracting) {\r\n      this._clearTimeout();\r\n      return;\r\n    }\r\n\r\n    const nextElement = event.relatedTarget;\r\n    if (this._element === nextElement || this._element.contains(nextElement)) {\r\n      return;\r\n    }\r\n\r\n    this._maybeScheduleHide();\r\n  }\r\n\r\n  _setListeners() {\r\n    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) =>\r\n      this._onInteraction(event, true)\r\n    );\r\n    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) =>\r\n      this._onInteraction(event, false)\r\n    );\r\n    EventHandler.on(this._element, EVENT_FOCUSIN, (event) =>\r\n      this._onInteraction(event, true)\r\n    );\r\n    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) =>\r\n      this._onInteraction(event, false)\r\n    );\r\n  }\r\n\r\n  _clearTimeout() {\r\n    clearTimeout(this._timeout);\r\n    this._timeout = null;\r\n  }\r\n\r\n  // Static\r\n\r\n  static jQueryInterface(config) {\r\n    return this.each(function () {\r\n      const data = Toast.getOrCreateInstance(this, config);\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config](this);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Toast;\r\n","(()=>{var e={454:(e,t,n)=>{\"use strict\";n.d(t,{Z:()=>a});var r=n(645),o=n.n(r)()((function(e){return e[1]}));o.push([e.id,\"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\",\"\"]);const a=o},645:e=>{\"use strict\";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=e(t);return t[2]?\"@media \".concat(t[2],\" {\").concat(n,\"}\"):n})).join(\"\")},t.i=function(e,n,r){\"string\"==typeof e&&(e=[[null,e,\"\"]]);var o={};if(r)for(var a=0;a<this.length;a++){var i=this[a][0];null!=i&&(o[i]=!0)}for(var u=0;u<e.length;u++){var c=[].concat(e[u]);r&&o[c[0]]||(n&&(c[2]?c[2]=\"\".concat(n,\" and \").concat(c[2]):c[2]=n),t.push(c))}},t}},810:()=>{!function(){if(\"undefined\"!=typeof window)try{var e=new window.CustomEvent(\"test\",{cancelable:!0});if(e.preventDefault(),!0!==e.defaultPrevented)throw new Error(\"Could not prevent default\")}catch(e){var t=function(e,t){var n,r;return(t=t||{}).bubbles=!!t.bubbles,t.cancelable=!!t.cancelable,(n=document.createEvent(\"CustomEvent\")).initCustomEvent(e,t.bubbles,t.cancelable,t.detail),r=n.preventDefault,n.preventDefault=function(){r.call(this);try{Object.defineProperty(this,\"defaultPrevented\",{get:function(){return!0}})}catch(e){this.defaultPrevented=!0}},n};t.prototype=window.Event.prototype,window.CustomEvent=t}}()},379:(e,t,n)=>{\"use strict\";var r,o=function(){var e={};return function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}e[t]=n}return e[t]}}(),a=[];function i(e){for(var t=-1,n=0;n<a.length;n++)if(a[n].identifier===e){t=n;break}return t}function u(e,t){for(var n={},r=[],o=0;o<e.length;o++){var u=e[o],c=t.base?u[0]+t.base:u[0],l=n[c]||0,s=\"\".concat(c,\" \").concat(l);n[c]=l+1;var d=i(s),f={css:u[1],media:u[2],sourceMap:u[3]};-1!==d?(a[d].references++,a[d].updater(f)):a.push({identifier:s,updater:m(f,t),references:1}),r.push(s)}return r}function c(e){var t=document.createElement(\"style\"),r=e.attributes||{};if(void 0===r.nonce){var a=n.nc;a&&(r.nonce=a)}if(Object.keys(r).forEach((function(e){t.setAttribute(e,r[e])})),\"function\"==typeof e.insert)e.insert(t);else{var i=o(e.insert||\"head\");if(!i)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");i.appendChild(t)}return t}var l,s=(l=[],function(e,t){return l[e]=t,l.filter(Boolean).join(\"\\n\")});function d(e,t,n,r){var o=n?\"\":r.media?\"@media \".concat(r.media,\" {\").concat(r.css,\"}\"):r.css;if(e.styleSheet)e.styleSheet.cssText=s(t,o);else{var a=document.createTextNode(o),i=e.childNodes;i[t]&&e.removeChild(i[t]),i.length?e.insertBefore(a,i[t]):e.appendChild(a)}}function f(e,t,n){var r=n.css,o=n.media,a=n.sourceMap;if(o?e.setAttribute(\"media\",o):e.removeAttribute(\"media\"),a&&\"undefined\"!=typeof btoa&&(r+=\"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),\" */\")),e.styleSheet)e.styleSheet.cssText=r;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(r))}}var v=null,p=0;function m(e,t){var n,r,o;if(t.singleton){var a=p++;n=v||(v=c(t)),r=d.bind(null,n,a,!1),o=d.bind(null,n,a,!0)}else n=c(t),r=f.bind(null,n,t),o=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)};return r(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;r(e=t)}else o()}}e.exports=function(e,t){(t=t||{}).singleton||\"boolean\"==typeof t.singleton||(t.singleton=(void 0===r&&(r=Boolean(window&&document&&document.all&&!window.atob)),r));var n=u(e=e||[],t);return function(e){if(e=e||[],\"[object Array]\"===Object.prototype.toString.call(e)){for(var r=0;r<n.length;r++){var o=i(n[r]);a[o].references--}for(var c=u(e,t),l=0;l<n.length;l++){var s=i(n[l]);0===a[s].references&&(a[s].updater(),a.splice(s,1))}n=c}}}}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,exports:{}};return e[r](a,a.exports,n),a.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{\"use strict\";var e=n(379),t=n.n(e),r=n(454);function o(e){if(!e.hasAttribute(\"autocompleted\")){e.setAttribute(\"autocompleted\",\"\");var t=new window.CustomEvent(\"onautocomplete\",{bubbles:!0,cancelable:!0,detail:null});e.dispatchEvent(t)||(e.value=\"\")}}function a(e){e.hasAttribute(\"autocompleted\")&&(e.removeAttribute(\"autocompleted\"),e.dispatchEvent(new window.CustomEvent(\"onautocomplete\",{bubbles:!0,cancelable:!1,detail:null})))}t()(r.Z,{insert:\"head\",singleton:!1}),r.Z.locals,n(810),document.addEventListener(\"animationstart\",(function(e){\"onautofillstart\"===e.animationName?o(e.target):a(e.target)}),!0),document.addEventListener(\"input\",(function(e){\"insertReplacementText\"!==e.inputType&&\"data\"in e?a(e.target):o(e.target)}),!0)})()})();","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { element, onDOMContentLoaded, typeCheckConfig } from \"../util/index\";\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport \"detect-autofill\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"input\";\r\nconst DATA_KEY = \"te.input\";\r\nconst DATA_WRAPPER = \"data-te-input-wrapper-init\";\r\nconst DATA_NOTCH = \"data-te-input-notch-ref\";\r\nconst DATA_NOTCH_LEADING = \"data-te-input-notch-leading-ref\";\r\nconst DATA_NOTCH_MIDDLE = \"data-te-input-notch-middle-ref\";\r\nconst DATA_NOTCH_TRAILING = \"data-te-input-notch-trailing-ref\";\r\nconst DATA_HELPER = \"data-te-input-helper-ref\";\r\nconst DATA_PLACEHOLDER_ACTIVE = \"data-te-input-placeholder-active\";\r\nconst DATA_ACTIVE = \"data-te-input-state-active\";\r\nconst DATA_FOCUSED = \"data-te-input-focused\";\r\nconst DATA_FORM_COUNTER = \"data-te-input-form-counter\";\r\n\r\nconst SELECTOR_OUTLINE_INPUT = `[${DATA_WRAPPER}] input`;\r\nconst SELECTOR_OUTLINE_TEXTAREA = `[${DATA_WRAPPER}] textarea`;\r\n\r\nconst SELECTOR_NOTCH = `[${DATA_NOTCH}]`;\r\nconst SELECTOR_NOTCH_LEADING = `[${DATA_NOTCH_LEADING}]`;\r\nconst SELECTOR_NOTCH_MIDDLE = `[${DATA_NOTCH_MIDDLE}]`;\r\nconst SELECTOR_HELPER = `[${DATA_HELPER}]`;\r\n\r\nconst Default = {\r\n  inputFormWhite: false,\r\n};\r\n\r\nconst DefaultType = {\r\n  inputFormWhite: \"(boolean)\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  notch:\r\n    \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\r\n  notchLeading:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0\",\r\n  notchLeadingNormal:\r\n    \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n  notchLeadingWhite:\r\n    \"border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\r\n  notchMiddle:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent\",\r\n  notchMiddleNormal:\r\n    \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n  notchMiddleWhite:\r\n    \"border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\r\n  notchTrailing:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0\",\r\n  notchTrailingNormal:\r\n    \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n  notchTrailingWhite:\r\n    \"border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\r\n  counter: \"text-right leading-[1.6]\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  notch: \"string\",\r\n  notchLeading: \"string\",\r\n  notchLeadingNormal: \"string\",\r\n  notchLeadingWhite: \"string\",\r\n  notchMiddle: \"string\",\r\n  notchMiddleNormal: \"string\",\r\n  notchMiddleWhite: \"string\",\r\n  notchTrailing: \"string\",\r\n  notchTrailingNormal: \"string\",\r\n  notchTrailingWhite: \"string\",\r\n  counter: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Input {\r\n  constructor(element, config, classes) {\r\n    this._config = this._getConfig(config, element);\r\n    this._element = element;\r\n    this._classes = this._getClasses(classes);\r\n    this._label = null;\r\n    this._labelWidth = 0;\r\n    this._labelMarginLeft = 0;\r\n    this._notchLeading = null;\r\n    this._notchMiddle = null;\r\n    this._notchTrailing = null;\r\n    this._initiated = false;\r\n    this._helper = null;\r\n    this._counter = false;\r\n    this._counterElement = null;\r\n    this._maxLength = 0;\r\n    this._leadingIcon = null;\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n      this.init();\r\n    }\r\n  }\r\n\r\n  // Getters\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get input() {\r\n    const inputElement =\r\n      SelectorEngine.findOne(\"input\", this._element) ||\r\n      SelectorEngine.findOne(\"textarea\", this._element);\r\n    return inputElement;\r\n  }\r\n\r\n  // Public\r\n  init() {\r\n    if (this._initiated) {\r\n      return;\r\n    }\r\n    this._getLabelData();\r\n    this._applyDivs();\r\n    this._applyNotch();\r\n    this._activate();\r\n    this._getHelper();\r\n    this._getCounter();\r\n    this._getEvents();\r\n    this._initiated = true;\r\n  }\r\n\r\n  update() {\r\n    this._getLabelData();\r\n    this._getNotchData();\r\n    this._applyNotch();\r\n    this._activate();\r\n    this._getHelper();\r\n    this._getCounter();\r\n  }\r\n\r\n  forceActive() {\r\n    this.input.setAttribute(DATA_ACTIVE, \"\");\r\n\r\n    SelectorEngine.findOne(SELECTOR_NOTCH, this.input.parentNode).setAttribute(\r\n      DATA_ACTIVE,\r\n      \"\"\r\n    );\r\n  }\r\n\r\n  forceInactive() {\r\n    this.input.removeAttribute(DATA_ACTIVE);\r\n\r\n    SelectorEngine.findOne(\r\n      SELECTOR_NOTCH,\r\n      this.input.parentNode\r\n    ).removeAttribute(DATA_ACTIVE);\r\n  }\r\n\r\n  dispose() {\r\n    this._removeBorder();\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n    this._element = null;\r\n  }\r\n\r\n  // Private\r\n\r\n  _getConfig(config, element) {\r\n    config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(element),\r\n      ...(typeof config === \"object\" ? config : {}),\r\n    };\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getLabelData() {\r\n    this._label = SelectorEngine.findOne(\"label\", this._element);\r\n\r\n    if (this._label === null) {\r\n      this._showPlaceholder();\r\n    } else {\r\n      this._getLabelWidth();\r\n      this._getLabelPositionInInputGroup();\r\n      this._toggleDefaultDatePlaceholder();\r\n    }\r\n  }\r\n\r\n  _getHelper() {\r\n    this._helper = SelectorEngine.findOne(SELECTOR_HELPER, this._element);\r\n  }\r\n\r\n  _getCounter() {\r\n    this._counter = Manipulator.getDataAttribute(\r\n      this.input,\r\n      \"inputShowcounter\"\r\n    );\r\n    if (this._counter) {\r\n      this._maxLength = this.input.maxLength;\r\n      this._showCounter();\r\n    }\r\n  }\r\n\r\n  _getEvents() {\r\n    EventHandler.on(\r\n      document,\r\n      \"focus\",\r\n      SELECTOR_OUTLINE_INPUT,\r\n      Input.activate(new Input())\r\n    );\r\n    EventHandler.on(\r\n      document,\r\n      \"input\",\r\n      SELECTOR_OUTLINE_INPUT,\r\n      Input.activate(new Input())\r\n    );\r\n    EventHandler.on(\r\n      document,\r\n      \"blur\",\r\n      SELECTOR_OUTLINE_INPUT,\r\n      Input.deactivate(new Input())\r\n    );\r\n\r\n    EventHandler.on(\r\n      document,\r\n      \"focus\",\r\n      SELECTOR_OUTLINE_TEXTAREA,\r\n      Input.activate(new Input())\r\n    );\r\n    EventHandler.on(\r\n      document,\r\n      \"input\",\r\n      SELECTOR_OUTLINE_TEXTAREA,\r\n      Input.activate(new Input())\r\n    );\r\n    EventHandler.on(\r\n      document,\r\n      \"blur\",\r\n      SELECTOR_OUTLINE_TEXTAREA,\r\n      Input.deactivate(new Input())\r\n    );\r\n\r\n    EventHandler.on(window, \"shown.te.modal\", (e) => {\r\n      SelectorEngine.find(SELECTOR_OUTLINE_INPUT, e.target).forEach(\r\n        (element) => {\r\n          const instance = Input.getInstance(element.parentNode);\r\n          if (!instance) {\r\n            return;\r\n          }\r\n          instance.update();\r\n        }\r\n      );\r\n      SelectorEngine.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach(\r\n        (element) => {\r\n          const instance = Input.getInstance(element.parentNode);\r\n          if (!instance) {\r\n            return;\r\n          }\r\n          instance.update();\r\n        }\r\n      );\r\n    });\r\n\r\n    EventHandler.on(window, \"shown.te.dropdown\", (e) => {\r\n      const target = e.target.parentNode.querySelector(\r\n        \"[data-te-dropdown-menu-ref]\"\r\n      );\r\n      if (target) {\r\n        SelectorEngine.find(SELECTOR_OUTLINE_INPUT, target).forEach(\r\n          (element) => {\r\n            const instance = Input.getInstance(element.parentNode);\r\n            if (!instance) {\r\n              return;\r\n            }\r\n            instance.update();\r\n          }\r\n        );\r\n        SelectorEngine.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach(\r\n          (element) => {\r\n            const instance = Input.getInstance(element.parentNode);\r\n            if (!instance) {\r\n              return;\r\n            }\r\n            instance.update();\r\n          }\r\n        );\r\n      }\r\n    });\r\n\r\n    EventHandler.on(window, \"shown.te.tab\", (e) => {\r\n      let targetId;\r\n\r\n      if (e.target.href) {\r\n        targetId = e.target.href.split(\"#\")[1];\r\n      } else {\r\n        targetId = Manipulator.getDataAttribute(e.target, \"target\").split(\r\n          \"#\"\r\n        )[1];\r\n      }\r\n\r\n      const target = SelectorEngine.findOne(`#${targetId}`);\r\n      SelectorEngine.find(SELECTOR_OUTLINE_INPUT, target).forEach((element) => {\r\n        const instance = Input.getInstance(element.parentNode);\r\n        if (!instance) {\r\n          return;\r\n        }\r\n        instance.update();\r\n      });\r\n      SelectorEngine.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach(\r\n        (element) => {\r\n          const instance = Input.getInstance(element.parentNode);\r\n          if (!instance) {\r\n            return;\r\n          }\r\n          instance.update();\r\n        }\r\n      );\r\n    });\r\n\r\n    // form reset handler\r\n    EventHandler.on(window, \"reset\", (e) => {\r\n      SelectorEngine.find(SELECTOR_OUTLINE_INPUT, e.target).forEach(\r\n        (element) => {\r\n          const instance = Input.getInstance(element.parentNode);\r\n          if (!instance) {\r\n            return;\r\n          }\r\n          instance.forceInactive();\r\n        }\r\n      );\r\n      SelectorEngine.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach(\r\n        (element) => {\r\n          const instance = Input.getInstance(element.parentNode);\r\n          if (!instance) {\r\n            return;\r\n          }\r\n          instance.forceInactive();\r\n        }\r\n      );\r\n    });\r\n\r\n    // auto-fill\r\n    EventHandler.on(window, \"onautocomplete\", (e) => {\r\n      const instance = Input.getInstance(e.target.parentNode);\r\n      if (!instance || !e.cancelable) {\r\n        return;\r\n      }\r\n      instance.forceActive();\r\n    });\r\n  }\r\n\r\n  _showCounter() {\r\n    const counters = SelectorEngine.find(\r\n      `[${DATA_FORM_COUNTER}]`,\r\n      this._element\r\n    );\r\n    if (counters.length > 0) {\r\n      return;\r\n    }\r\n    this._counterElement = document.createElement(\"div\");\r\n    Manipulator.addClass(this._counterElement, this._classes.counter);\r\n    this._counterElement.setAttribute(DATA_FORM_COUNTER, \"\");\r\n    const actualLength = this.input.value.length;\r\n    this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;\r\n    this._helper.appendChild(this._counterElement);\r\n    this._bindCounter();\r\n  }\r\n\r\n  _bindCounter() {\r\n    EventHandler.on(this.input, \"input\", () => {\r\n      const actualLength = this.input.value.length;\r\n      this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;\r\n    });\r\n  }\r\n\r\n  _toggleDefaultDatePlaceholder(input = this.input) {\r\n    const isTypeDate = input.getAttribute(\"type\") === \"date\";\r\n    if (!isTypeDate) {\r\n      return;\r\n    }\r\n    const isInputFocused = document.activeElement === input;\r\n\r\n    if (!isInputFocused && !input.value) {\r\n      input.style.opacity = 0;\r\n    } else {\r\n      input.style.opacity = 1;\r\n    }\r\n  }\r\n\r\n  _showPlaceholder() {\r\n    this.input.setAttribute(DATA_PLACEHOLDER_ACTIVE, \"\");\r\n  }\r\n\r\n  _getNotchData() {\r\n    this._notchMiddle = SelectorEngine.findOne(\r\n      SELECTOR_NOTCH_MIDDLE,\r\n      this._element\r\n    );\r\n    this._notchLeading = SelectorEngine.findOne(\r\n      SELECTOR_NOTCH_LEADING,\r\n      this._element\r\n    );\r\n  }\r\n\r\n  _getLabelWidth() {\r\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\r\n  }\r\n\r\n  _getLabelPositionInInputGroup() {\r\n    this._labelMarginLeft = 0;\r\n    if (!this._element.hasAttribute(\"data-te-input-group-ref\")) return;\r\n    const input = this.input;\r\n    const prefix = SelectorEngine.prev(\r\n      input,\r\n      \"[data-te-input-group-text-ref]\"\r\n    )[0];\r\n    if (prefix === undefined) {\r\n      this._labelMarginLeft = 0;\r\n    } else {\r\n      this._labelMarginLeft = prefix.offsetWidth - 1;\r\n    }\r\n  }\r\n\r\n  _applyDivs() {\r\n    const shadowLeading = this._config.inputFormWhite\r\n      ? this._classes.notchLeadingWhite\r\n      : this._classes.notchLeadingNormal;\r\n    const shadowMiddle = this._config.inputFormWhite\r\n      ? this._classes.notchMiddleWhite\r\n      : this._classes.notchMiddleNormal;\r\n    const shadowTrailing = this._config.inputFormWhite\r\n      ? this._classes.notchTrailingWhite\r\n      : this._classes.notchTrailingNormal;\r\n\r\n    const allNotchWrappers = SelectorEngine.find(SELECTOR_NOTCH, this._element);\r\n    const notchWrapper = element(\"div\");\r\n    Manipulator.addClass(notchWrapper, this._classes.notch);\r\n    notchWrapper.setAttribute(DATA_NOTCH, \"\");\r\n    this._notchLeading = element(\"div\");\r\n\r\n    Manipulator.addClass(\r\n      this._notchLeading,\r\n      `${this._classes.notchLeading} ${shadowLeading}`\r\n    );\r\n    this._notchLeading.setAttribute(DATA_NOTCH_LEADING, \"\");\r\n    this._notchMiddle = element(\"div\");\r\n\r\n    Manipulator.addClass(\r\n      this._notchMiddle,\r\n      `${this._classes.notchMiddle} ${shadowMiddle}`\r\n    );\r\n    this._notchMiddle.setAttribute(DATA_NOTCH_MIDDLE, \"\");\r\n    this._notchTrailing = element(\"div\");\r\n\r\n    Manipulator.addClass(\r\n      this._notchTrailing,\r\n      `${this._classes.notchTrailing} ${shadowTrailing}`\r\n    );\r\n    this._notchTrailing.setAttribute(DATA_NOTCH_TRAILING, \"\");\r\n    if (allNotchWrappers.length >= 1) {\r\n      return;\r\n    }\r\n    notchWrapper.append(this._notchLeading);\r\n    notchWrapper.append(this._notchMiddle);\r\n    notchWrapper.append(this._notchTrailing);\r\n    this._element.append(notchWrapper);\r\n  }\r\n\r\n  _applyNotch() {\r\n    this._notchMiddle.style.width = `${this._labelWidth}px`;\r\n    this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`;\r\n\r\n    if (this._label === null) return;\r\n    this._label.style.marginLeft = `${this._labelMarginLeft}px`;\r\n  }\r\n\r\n  _removeBorder() {\r\n    const border = SelectorEngine.findOne(SELECTOR_NOTCH, this._element);\r\n    if (border) border.remove();\r\n  }\r\n\r\n  _activate(event) {\r\n    onDOMContentLoaded(() => {\r\n      this._getElements(event);\r\n      const input = event ? event.target : this.input;\r\n      const notchWrapper = SelectorEngine.findOne(\r\n        SELECTOR_NOTCH,\r\n        this._element\r\n      );\r\n\r\n      if (event && event.type === \"focus\") {\r\n        notchWrapper.setAttribute(DATA_FOCUSED, \"\");\r\n      }\r\n\r\n      if (input.value !== \"\") {\r\n        input.setAttribute(DATA_ACTIVE, \"\");\r\n        notchWrapper.setAttribute(DATA_ACTIVE, \"\");\r\n      }\r\n      this._toggleDefaultDatePlaceholder(input);\r\n    });\r\n  }\r\n\r\n  _getElements(event) {\r\n    if (event) {\r\n      this._element = event.target.parentNode;\r\n      this._label = SelectorEngine.findOne(\"label\", this._element);\r\n    }\r\n\r\n    if (event && this._label) {\r\n      const prevLabelWidth = this._labelWidth;\r\n      this._getLabelData();\r\n\r\n      if (prevLabelWidth !== this._labelWidth) {\r\n        this._notchMiddle = SelectorEngine.findOne(\r\n          SELECTOR_NOTCH_MIDDLE,\r\n          event.target.parentNode\r\n        );\r\n        this._notchLeading = SelectorEngine.findOne(\r\n          SELECTOR_NOTCH_LEADING,\r\n          event.target.parentNode\r\n        );\r\n        this._applyNotch();\r\n      }\r\n    }\r\n  }\r\n\r\n  _deactivate(event) {\r\n    const input = event ? event.target : this.input;\r\n    const notchWrapper = SelectorEngine.findOne(\r\n      SELECTOR_NOTCH,\r\n      input.parentNode\r\n    );\r\n    notchWrapper.removeAttribute(DATA_FOCUSED);\r\n\r\n    if (input.value === \"\") {\r\n      input.removeAttribute(DATA_ACTIVE);\r\n      notchWrapper.removeAttribute(DATA_ACTIVE);\r\n    }\r\n    this._toggleDefaultDatePlaceholder(input);\r\n  }\r\n\r\n  static activate(instance) {\r\n    return function (event) {\r\n      instance._activate(event);\r\n    };\r\n  }\r\n\r\n  static deactivate(instance) {\r\n    return function (event) {\r\n      instance._deactivate(event);\r\n    };\r\n  }\r\n\r\n  static jQueryInterface(config, options) {\r\n    return this.each(function () {\r\n      let data = Data.getData(this, DATA_KEY);\r\n      const _config = typeof config === \"object\" && config;\r\n      if (!data && /dispose/.test(config)) {\r\n        return;\r\n      }\r\n      if (!data) {\r\n        data = new Input(this, _config);\r\n      }\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](options);\r\n      }\r\n    });\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Input;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { typeCheckConfig } from \"../util/index\";\r\nimport Data from \"../dom/data\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport EventHandler from \"../dom/event-handler\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"animation\";\r\nconst DATA_KEY = \"te.animation\";\r\n\r\nconst DefaultType = {\r\n  animation: \"string\",\r\n  animationStart: \"string\",\r\n  animationShowOnLoad: \"boolean\",\r\n  onStart: \"(null|function)\",\r\n  onEnd: \"(null|function)\",\r\n  onHide: \"(null|function)\",\r\n  onShow: \"(null|function)\",\r\n  animationOnScroll: \"(string)\",\r\n  animationWindowHeight: \"number\",\r\n  animationOffset: \"(number|string)\",\r\n  animationDelay: \"(number|string)\",\r\n  animationReverse: \"boolean\",\r\n  animationInterval: \"(number|string)\",\r\n  animationRepeat: \"(number|boolean)\",\r\n  animationReset: \"boolean\",\r\n};\r\n\r\nconst Default = {\r\n  animation: \"fade\",\r\n  animationStart: \"onClick\",\r\n  animationShowOnLoad: true,\r\n  onStart: null,\r\n  onEnd: null,\r\n  onHide: null,\r\n  onShow: null,\r\n  animationOnScroll: \"once\",\r\n  animationWindowHeight: 0,\r\n  animationOffset: 0,\r\n  animationDelay: 0,\r\n  animationReverse: false,\r\n  animationInterval: 0,\r\n  animationRepeat: false,\r\n  animationReset: false,\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Animate {\r\n  constructor(element, options) {\r\n    this._element = element;\r\n    this._animateElement = this._getAnimateElement();\r\n    this._isFirstScroll = true;\r\n    this._repeatAnimateOnScroll = true;\r\n    this._options = this._getConfig(options);\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n      this._init();\r\n    }\r\n  }\r\n\r\n  // Getters\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n  init() {\r\n    this._init();\r\n  }\r\n\r\n  startAnimation() {\r\n    this._startAnimation();\r\n  }\r\n\r\n  stopAnimation() {\r\n    this._clearAnimationClass();\r\n  }\r\n\r\n  changeAnimationType(animation) {\r\n    this._options.animation = animation;\r\n  }\r\n\r\n  dispose() {\r\n    EventHandler.off(this._element, \"mousedown\");\r\n    EventHandler.off(this._animateElement, \"animationend\");\r\n    EventHandler.off(window, \"scroll\");\r\n    EventHandler.off(this._element, \"mouseover\");\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n    this._element = null;\r\n    this._animateElement = null;\r\n    this._isFirstScroll = null;\r\n    this._repeatAnimateOnScroll = null;\r\n    this._options = null;\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    switch (this._options.animationStart) {\r\n      case \"onHover\":\r\n        this._bindHoverEvents();\r\n        break;\r\n      case \"onLoad\":\r\n        this._startAnimation();\r\n        break;\r\n      case \"onScroll\":\r\n        this._bindScrollEvents();\r\n        break;\r\n      case \"onClick\":\r\n        this._bindClickEvents();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    this._bindTriggerOnEndCallback();\r\n    if (this._options.animationReset) {\r\n      this._bindResetAnimationAfterFinish();\r\n    }\r\n  }\r\n\r\n  _getAnimateElement() {\r\n    const targetId = Manipulator.getDataAttribute(\r\n      this._element,\r\n      \"animation-target\"\r\n    );\r\n    return targetId ? SelectorEngine.find(targetId)[0] : this._element;\r\n  }\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._animateElement);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _animateOnScroll() {\r\n    const elementOffsetTop = Manipulator.offset(this._animateElement).top;\r\n    const elementHeight = this._animateElement.offsetHeight;\r\n    const windowHeight = window.innerHeight;\r\n    const shouldBeVisible =\r\n      elementOffsetTop + this._options.animationOffset <= windowHeight &&\r\n      elementOffsetTop + this._options.animationOffset + elementHeight >= 0;\r\n    const isElementVisible =\r\n      this._animateElement.style.visibility === \"visible\";\r\n\r\n    switch (true) {\r\n      case shouldBeVisible && this._isFirstScroll:\r\n        this._isFirstScroll = false;\r\n        this._startAnimation();\r\n        break;\r\n      case !shouldBeVisible && this._isFirstScroll:\r\n        this._isFirstScroll = false;\r\n        this._hideAnimateElement();\r\n        break;\r\n      case shouldBeVisible && !isElementVisible && this._repeatAnimateOnScroll:\r\n        if (this._options.animationOnScroll !== \"repeat\") {\r\n          this._repeatAnimateOnScroll = false;\r\n        }\r\n        this._callback(this._options.onShow);\r\n        this._showAnimateElement();\r\n        this._startAnimation();\r\n        break;\r\n      case !shouldBeVisible && isElementVisible && this._repeatAnimateOnScroll:\r\n        this._hideAnimateElement();\r\n        this._clearAnimationClass();\r\n        this._callback(this._options.onHide);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  _addAnimatedClass() {\r\n    Manipulator.addClass(\r\n      this._animateElement,\r\n      `animate-${this._options.animation}`\r\n    );\r\n  }\r\n\r\n  _clearAnimationClass() {\r\n    this._animateElement.classList.remove(`animate-${this._options.animation}`);\r\n  }\r\n\r\n  _startAnimation() {\r\n    this._callback(this._options.onStart);\r\n\r\n    this._addAnimatedClass();\r\n\r\n    if (this._options.animationRepeat && !this._options.animationInterval) {\r\n      this._setAnimationRepeat();\r\n    }\r\n\r\n    if (this._options.animationReverse) {\r\n      this._setAnimationReverse();\r\n    }\r\n\r\n    if (this._options.animationDelay) {\r\n      this._setAnimationDelay();\r\n    }\r\n\r\n    if (this._options.animationDuration) {\r\n      this._setAnimationDuration();\r\n    }\r\n\r\n    if (this._options.animationInterval) {\r\n      this._setAnimationInterval();\r\n    }\r\n  }\r\n\r\n  _setAnimationReverse() {\r\n    Manipulator.style(this._animateElement, {\r\n      animationIterationCount:\r\n        this._options.animationRepeat === true ? \"infinite\" : \"2\",\r\n      animationDirection: \"alternate\",\r\n    });\r\n  }\r\n\r\n  _setAnimationDuration() {\r\n    Manipulator.style(this._animateElement, {\r\n      animationDuration: `${this._options.animationDuration}ms`,\r\n    });\r\n  }\r\n\r\n  _setAnimationDelay() {\r\n    Manipulator.style(this._animateElement, {\r\n      animationDelay: `${this._options.animationDelay}ms`,\r\n    });\r\n  }\r\n\r\n  _setAnimationRepeat() {\r\n    Manipulator.style(this._animateElement, {\r\n      animationIterationCount:\r\n        this._options.animationRepeat === true\r\n          ? \"infinite\"\r\n          : this._options.animationRepeat,\r\n    });\r\n  }\r\n\r\n  _setAnimationInterval() {\r\n    EventHandler.on(this._animateElement, \"click\", () => {\r\n      this._clearAnimationClass();\r\n      setTimeout(() => {\r\n        this._addAnimatedClass();\r\n      }, this._options.animationInterval);\r\n    });\r\n  }\r\n\r\n  _hideAnimateElement() {\r\n    Manipulator.style(this._animateElement, { visibility: \"hidden\" });\r\n  }\r\n\r\n  _showAnimateElement() {\r\n    Manipulator.style(this._animateElement, { visibility: \"visible\" });\r\n  }\r\n\r\n  _bindResetAnimationAfterFinish() {\r\n    EventHandler.on(this._animateElement, \"animationend\", () => {\r\n      this._clearAnimationClass();\r\n    });\r\n  }\r\n\r\n  _bindTriggerOnEndCallback() {\r\n    EventHandler.on(this._animateElement, \"animationend\", () => {\r\n      this._callback(this._options.onEnd);\r\n    });\r\n  }\r\n\r\n  _bindScrollEvents() {\r\n    if (!this._options.animationShowOnLoad) {\r\n      this._animateOnScroll();\r\n    }\r\n\r\n    EventHandler.on(window, \"scroll\", () => {\r\n      this._animateOnScroll();\r\n    });\r\n  }\r\n\r\n  _bindClickEvents() {\r\n    EventHandler.on(this._element, \"mousedown\", () => {\r\n      this._startAnimation();\r\n    });\r\n  }\r\n\r\n  _bindHoverEvents() {\r\n    EventHandler.one(this._element, \"mouseover\", () => {\r\n      this._startAnimation();\r\n    });\r\n    EventHandler.one(this._animateElement, \"animationend\", () => {\r\n      // wait after bind hoverEvents to prevent animation looping\r\n      setTimeout(() => {\r\n        this._bindHoverEvents();\r\n      }, 100);\r\n    });\r\n  }\r\n\r\n  _callback(fn) {\r\n    if (fn instanceof Function) {\r\n      fn();\r\n    }\r\n  }\r\n\r\n  // Static\r\n  static autoInit(instance) {\r\n    instance._init();\r\n  }\r\n\r\n  static jQueryInterface(options) {\r\n    const animate = new Animate(this[0], options);\r\n    animate.init();\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Animate;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { element, typeCheckConfig } from \"../util/index\";\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"ripple\";\r\nconst DATA_KEY = \"te.ripple\";\r\n\r\nconst GRADIENT =\r\n  \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\";\r\n\r\nconst SELECTOR_COMPONENT = [\"[data-te-ripple-init]\"];\r\nconst DEFAULT_RIPPLE_COLOR = [0, 0, 0];\r\n\r\nconst BOOTSTRAP_COLORS = [\r\n  { name: \"primary\", gradientColor: \"#3B71CA\" },\r\n  { name: \"secondary\", gradientColor: \"#9FA6B2\" },\r\n  { name: \"success\", gradientColor: \"#14A44D\" },\r\n  { name: \"danger\", gradientColor: \"#DC4C64\" },\r\n  { name: \"warning\", gradientColor: \"#E4A11B\" },\r\n  { name: \"info\", gradientColor: \"#54B4D3\" },\r\n  { name: \"light\", gradientColor: \"#fbfbfb\" },\r\n  { name: \"dark\", gradientColor: \"#262626\" },\r\n];\r\n\r\n// Sets value when run opacity transition\r\n// Hide element after 50% (0.5) time of animation and finish on 100%\r\nconst TRANSITION_BREAK_OPACITY = 0.5;\r\n\r\nconst Default = {\r\n  rippleCentered: false,\r\n  rippleColor: \"\",\r\n  rippleColorDark: \"\",\r\n  rippleDuration: \"500ms\",\r\n  rippleRadius: 0,\r\n  rippleUnbound: false,\r\n};\r\n\r\nconst DefaultType = {\r\n  rippleCentered: \"boolean\",\r\n  rippleColor: \"string\",\r\n  rippleColorDark: \"string\",\r\n  rippleDuration: \"string\",\r\n  rippleRadius: \"number\",\r\n  rippleUnbound: \"boolean\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  ripple: \"relative overflow-hidden inline-block align-bottom\",\r\n  rippleWave:\r\n    \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\r\n  unbound: \"overflow-visible\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  ripple: \"string\",\r\n  rippleWave: \"string\",\r\n  unbound: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Ripple {\r\n  constructor(element, options, classes) {\r\n    this._element = element;\r\n    this._options = this._getConfig(options);\r\n    this._classes = this._getClasses(classes);\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n      Manipulator.addClass(this._element, this._classes.ripple);\r\n    }\r\n    this._clickHandler = this._createRipple.bind(this);\r\n    this._rippleTimer = null;\r\n    this._isMinWidthSet = false;\r\n    this._initialClasses = null;\r\n\r\n    this.init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  init() {\r\n    this._addClickEvent(this._element);\r\n  }\r\n\r\n  dispose() {\r\n    Data.removeData(this._element, DATA_KEY);\r\n    EventHandler.off(this._element, \"click\", this._clickHandler);\r\n    this._element = null;\r\n    this._options = null;\r\n  }\r\n\r\n  // Private\r\n\r\n  _autoInit(event) {\r\n    SELECTOR_COMPONENT.forEach((selector) => {\r\n      const target = SelectorEngine.closest(event.target, selector);\r\n      if (target) {\r\n        this._element = SelectorEngine.closest(event.target, selector);\r\n      }\r\n    });\r\n\r\n    if (!this._element.style.minWidth) {\r\n      Manipulator.style(this._element, {\r\n        \"min-width\": getComputedStyle(this._element).width,\r\n      });\r\n      this._isMinWidthSet = true;\r\n    }\r\n\r\n    this._initialClasses = [...this._element.classList];\r\n    Manipulator.addClass(this._element, this._classes.ripple);\r\n\r\n    this._options = this._getConfig();\r\n    this._createRipple(event);\r\n  }\r\n\r\n  _addClickEvent(target) {\r\n    EventHandler.on(target, \"mousedown\", this._clickHandler);\r\n  }\r\n\r\n  _createRipple(event) {\r\n    if (this._element.className.indexOf(this._classes.ripple) < 0) {\r\n      Manipulator.addClass(this._element, this._classes.ripple);\r\n    }\r\n\r\n    const { layerX, layerY } = event;\r\n    const offsetX = layerX;\r\n    const offsetY = layerY;\r\n    const height = this._element.offsetHeight;\r\n    const width = this._element.offsetWidth;\r\n    const duration = this._durationToMsNumber(this._options.rippleDuration);\r\n    const diameterOptions = {\r\n      offsetX: this._options.rippleCentered ? height / 2 : offsetX,\r\n      offsetY: this._options.rippleCentered ? width / 2 : offsetY,\r\n      height,\r\n      width,\r\n    };\r\n    const diameter = this._getDiameter(diameterOptions);\r\n    const radiusValue = this._options.rippleRadius || diameter / 2;\r\n\r\n    const opacity = {\r\n      delay: duration * TRANSITION_BREAK_OPACITY,\r\n      duration: duration - duration * TRANSITION_BREAK_OPACITY,\r\n    };\r\n\r\n    const styles = {\r\n      left: this._options.rippleCentered\r\n        ? `${width / 2 - radiusValue}px`\r\n        : `${offsetX - radiusValue}px`,\r\n      top: this._options.rippleCentered\r\n        ? `${height / 2 - radiusValue}px`\r\n        : `${offsetY - radiusValue}px`,\r\n      height: `${this._options.rippleRadius * 2 || diameter}px`,\r\n      width: `${this._options.rippleRadius * 2 || diameter}px`,\r\n      transitionDelay: `0s, ${opacity.delay}ms`,\r\n      transitionDuration: `${duration}ms, ${opacity.duration}ms`,\r\n    };\r\n\r\n    const rippleHTML = element(\"div\");\r\n\r\n    this._createHTMLRipple({\r\n      wrapper: this._element,\r\n      ripple: rippleHTML,\r\n      styles,\r\n    });\r\n    this._removeHTMLRipple({ ripple: rippleHTML, duration });\r\n  }\r\n\r\n  _createHTMLRipple({ wrapper, ripple, styles }) {\r\n    Object.keys(styles).forEach(\r\n      (property) => (ripple.style[property] = styles[property])\r\n    );\r\n    Manipulator.addClass(ripple, this._classes.rippleWave);\r\n    ripple.setAttribute(\"data-te-ripple-ref\", \"\");\r\n    this._addColor(ripple, wrapper);\r\n\r\n    this._toggleUnbound(wrapper);\r\n    this._appendRipple(ripple, wrapper);\r\n  }\r\n\r\n  _removeHTMLRipple({ ripple, duration }) {\r\n    if (this._rippleTimer) {\r\n      clearTimeout(this._rippleTimer);\r\n      this._rippleTimer = null;\r\n    }\r\n    if (ripple) {\r\n      setTimeout(() => {\r\n        ripple.classList.add(\"!opacity-0\");\r\n      }, 10);\r\n    }\r\n    this._rippleTimer = setTimeout(() => {\r\n      if (ripple) {\r\n        ripple.remove();\r\n        if (this._element) {\r\n          SelectorEngine.find(\"[data-te-ripple-ref]\", this._element).forEach(\r\n            (rippleEl) => {\r\n              rippleEl.remove();\r\n            }\r\n          );\r\n          if (this._isMinWidthSet) {\r\n            Manipulator.style(this._element, { \"min-width\": \"\" });\r\n            this._isMinWidthSet = false;\r\n          }\r\n          // check if added ripple classes wasn't there initialy\r\n          const classesToRemove = this._initialClasses\r\n            ? this._addedNewRippleClasses(\r\n                this._classes.ripple,\r\n                this._initialClasses\r\n              )\r\n            : this._classes.ripple.split(\" \");\r\n          Manipulator.removeClass(this._element, classesToRemove);\r\n        }\r\n      }\r\n    }, duration);\r\n  }\r\n\r\n  _addedNewRippleClasses(defaultRipple, initialClasses) {\r\n    return defaultRipple\r\n      .split(\" \")\r\n      .filter(\r\n        (item) => initialClasses.findIndex((init) => item === init) === -1\r\n      );\r\n  }\r\n\r\n  _durationToMsNumber(time) {\r\n    return Number(time.replace(\"ms\", \"\").replace(\"s\", \"000\"));\r\n  }\r\n\r\n  _getConfig(config = {}) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getDiameter({ offsetX, offsetY, height, width }) {\r\n    const top = offsetY <= height / 2;\r\n    const left = offsetX <= width / 2;\r\n    const pythagorean = (sideA, sideB) => Math.sqrt(sideA ** 2 + sideB ** 2);\r\n\r\n    const positionCenter = offsetY === height / 2 && offsetX === width / 2;\r\n    // mouse position on the quadrants of the coordinate system\r\n    const quadrant = {\r\n      first: top === true && left === false,\r\n      second: top === true && left === true,\r\n      third: top === false && left === true,\r\n      fourth: top === false && left === false,\r\n    };\r\n\r\n    const getCorner = {\r\n      topLeft: pythagorean(offsetX, offsetY),\r\n      topRight: pythagorean(width - offsetX, offsetY),\r\n      bottomLeft: pythagorean(offsetX, height - offsetY),\r\n      bottomRight: pythagorean(width - offsetX, height - offsetY),\r\n    };\r\n\r\n    let diameter = 0;\r\n\r\n    if (positionCenter || quadrant.fourth) {\r\n      diameter = getCorner.topLeft;\r\n    } else if (quadrant.third) {\r\n      diameter = getCorner.topRight;\r\n    } else if (quadrant.second) {\r\n      diameter = getCorner.bottomRight;\r\n    } else if (quadrant.first) {\r\n      diameter = getCorner.bottomLeft;\r\n    }\r\n    return diameter * 2;\r\n  }\r\n\r\n  _appendRipple(target, parent) {\r\n    const FIX_ADD_RIPPLE_EFFECT = 50; // delay for active animations\r\n    parent.appendChild(target);\r\n    setTimeout(() => {\r\n      Manipulator.addClass(target, \"opacity-0 scale-100\");\r\n    }, FIX_ADD_RIPPLE_EFFECT);\r\n  }\r\n\r\n  _toggleUnbound(target) {\r\n    if (this._options.rippleUnbound === true) {\r\n      Manipulator.addClass(target, this._classes.unbound);\r\n    } else {\r\n      Manipulator.removeClass(target, this._classes.unbound);\r\n    }\r\n  }\r\n\r\n  _addColor(target) {\r\n    let rippleColor = this._options.rippleColor || \"rgb(0,0,0)\";\r\n\r\n    if (\r\n      localStorage.theme === \"dark\" ||\r\n      (!(\"theme\" in localStorage) &&\r\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches)\r\n    ) {\r\n      rippleColor = this._options.rippleColorDark || this._options.rippleColor;\r\n    }\r\n\r\n    const IS_BOOTSTRAP_COLOR = BOOTSTRAP_COLORS.find(\r\n      (color) => color.name === rippleColor.toLowerCase()\r\n    );\r\n\r\n    const rgbValue = IS_BOOTSTRAP_COLOR\r\n      ? this._colorToRGB(IS_BOOTSTRAP_COLOR.gradientColor).join(\",\")\r\n      : this._colorToRGB(rippleColor).join(\",\");\r\n\r\n    const gradientImage = GRADIENT.split(\"{{color}}\").join(`${rgbValue}`);\r\n    target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;\r\n  }\r\n\r\n  _colorToRGB(color) {\r\n    function hexToRgb(color) {\r\n      const HEX_COLOR_LENGTH = 7;\r\n      const IS_SHORT_HEX = color.length < HEX_COLOR_LENGTH;\r\n      if (IS_SHORT_HEX) {\r\n        color = `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;\r\n      }\r\n      return [\r\n        parseInt(color.substr(1, 2), 16),\r\n        parseInt(color.substr(3, 2), 16),\r\n        parseInt(color.substr(5, 2), 16),\r\n      ];\r\n    }\r\n\r\n    function namedColorsToRgba(color) {\r\n      const tempElem = document.body.appendChild(\r\n        document.createElement(\"fictum\")\r\n      );\r\n      const flag = \"rgb(1, 2, 3)\";\r\n      tempElem.style.color = flag;\r\n      if (tempElem.style.color !== flag) {\r\n        return DEFAULT_RIPPLE_COLOR;\r\n      }\r\n      tempElem.style.color = color;\r\n      if (tempElem.style.color === flag || tempElem.style.color === \"\") {\r\n        return DEFAULT_RIPPLE_COLOR;\r\n      } // color parse failed\r\n      color = getComputedStyle(tempElem).color;\r\n      document.body.removeChild(tempElem);\r\n      return color;\r\n    }\r\n\r\n    function rgbaToRgb(color) {\r\n      color = color.match(/[.\\d]+/g).map((a) => +Number(a));\r\n      color.length = 3;\r\n      return color;\r\n    }\r\n\r\n    if (color.toLowerCase() === \"transparent\") {\r\n      return DEFAULT_RIPPLE_COLOR;\r\n    }\r\n    if (color[0] === \"#\") {\r\n      return hexToRgb(color);\r\n    }\r\n    if (color.indexOf(\"rgb\") === -1) {\r\n      color = namedColorsToRgba(color);\r\n    }\r\n    if (color.indexOf(\"rgb\") === 0) {\r\n      return rgbaToRgb(color);\r\n    }\r\n\r\n    return DEFAULT_RIPPLE_COLOR;\r\n  }\r\n\r\n  // Static\r\n  static autoInitial(instance) {\r\n    return function (event) {\r\n      instance._autoInit(event);\r\n    };\r\n  }\r\n\r\n  static jQueryInterface(options) {\r\n    return this.each(function () {\r\n      const data = Data.getData(this, DATA_KEY);\r\n      if (!data) {\r\n        return new Ripple(this, options);\r\n      }\r\n\r\n      return null;\r\n    });\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Ripple;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nexport function getDate(date) {\r\n  return date.getDate();\r\n}\r\n\r\nexport function getDayNumber(date) {\r\n  return date.getDay();\r\n}\r\n\r\nexport function getMonth(date) {\r\n  return date.getMonth();\r\n}\r\n\r\nexport function getYear(date) {\r\n  return date.getFullYear();\r\n}\r\n\r\nexport function getFirstDayOfWeek(year, month, options) {\r\n  const firstDayIndex = options.startDay;\r\n  const sundayIndex = firstDayIndex > 0 ? 7 - firstDayIndex : 0;\r\n  const date = new Date(year, month);\r\n  const index = date.getDay() + sundayIndex;\r\n  const newIndex = index >= 7 ? index - 7 : index;\r\n  return newIndex;\r\n}\r\n\r\nexport function getDaysInMonth(date) {\r\n  return getMonthEnd(date).getDate();\r\n}\r\n\r\nexport function getMonthEnd(date) {\r\n  return createDate(date.getFullYear(), date.getMonth() + 1, 0);\r\n}\r\n\r\nexport function getToday() {\r\n  return new Date();\r\n}\r\n\r\nexport function addYears(date, years) {\r\n  return addMonths(date, years * 12);\r\n}\r\n\r\nexport function addMonths(date, months) {\r\n  const month = createDate(\r\n    date.getFullYear(),\r\n    date.getMonth() + months,\r\n    date.getDate()\r\n  );\r\n  const dayOfPreviousMonth = getDate(date);\r\n  const dayOfNewMonth = getDate(month);\r\n\r\n  // Solution for edge cases, like moving from a month with a greater number\r\n  // of days than the destination month. For example, when we move from 31 Mar 2020 to\r\n  // February, createDate(2020, 2, 31) will return 2 Mar 2020, not the desired 29 Feb 2020.\r\n  // We need to use setDate(0) to move back to the last day of the previous month (29 Feb 2020)\r\n  if (dayOfPreviousMonth !== dayOfNewMonth) {\r\n    month.setDate(0);\r\n  }\r\n\r\n  return month;\r\n}\r\n\r\nexport function addDays(date, days) {\r\n  return createDate(date.getFullYear(), date.getMonth(), date.getDate() + days);\r\n}\r\n\r\nexport function createDate(year, month, day) {\r\n  const result = new Date(year, month, day);\r\n\r\n  // In js native date years from 0 to 99 are treated as abbreviation\r\n  // for dates like 19xx\r\n  if (year >= 0 && year < 100) {\r\n    result.setFullYear(result.getFullYear() - 1900);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function convertStringToDate(dateString) {\r\n  const dateArr = dateString.split(\"-\");\r\n  const year = dateArr[0];\r\n  const month = dateArr[1];\r\n  const day = dateArr[2];\r\n\r\n  return createDate(year, month, day);\r\n}\r\n\r\nexport function isValidDate(date) {\r\n  return !Number.isNaN(date.getTime());\r\n}\r\n\r\nexport function compareDates(date1, date2) {\r\n  return (\r\n    getYear(date1) - getYear(date2) ||\r\n    getMonth(date1) - getMonth(date2) ||\r\n    getDate(date1) - getDate(date2)\r\n  );\r\n}\r\n\r\nexport function isSameDate(date1, date2) {\r\n  date1.setHours(0, 0, 0, 0);\r\n  date2.setHours(0, 0, 0, 0);\r\n\r\n  return date1.getTime() === date2.getTime();\r\n}\r\n\r\nexport function getYearsOffset(activeDate, yearsInView) {\r\n  const activeYear = getYear(activeDate);\r\n  const yearsDifference = activeYear - getStartYear();\r\n  return modulo(yearsDifference, yearsInView);\r\n}\r\n\r\nfunction modulo(a, b) {\r\n  return ((a % b) + b) % b;\r\n}\r\n\r\nexport function getStartYear(yearsInView, minDate, maxDate) {\r\n  let startYear = 0;\r\n\r\n  if (maxDate) {\r\n    const maxYear = getYear(maxDate);\r\n    startYear = maxYear - yearsInView + 1;\r\n  } else if (minDate) {\r\n    startYear = getYear(minDate);\r\n  }\r\n\r\n  return startYear;\r\n}\r\n\r\nexport function isDateDisabled(\r\n  date,\r\n  minDate,\r\n  maxDate,\r\n  filter,\r\n  disabledPast,\r\n  disabledFuture\r\n) {\r\n  const currentDate = new Date();\r\n  currentDate.setHours(0, 0, 0, 0);\r\n\r\n  const isBeforeMin = minDate && compareDates(date, minDate) <= -1;\r\n  const isAfterMax = maxDate && compareDates(date, maxDate) >= 1;\r\n\r\n  const isDisabledPast = disabledPast && compareDates(date, currentDate) <= -1;\r\n  const isDisabledFuture =\r\n    disabledFuture && compareDates(date, currentDate) >= 1;\r\n\r\n  const isDisabled = filter && filter(date) === false;\r\n\r\n  return (\r\n    isBeforeMin ||\r\n    isAfterMax ||\r\n    isDisabled ||\r\n    isDisabledPast ||\r\n    isDisabledFuture\r\n  );\r\n}\r\n\r\nexport function isMonthDisabled(\r\n  month,\r\n  year,\r\n  minDate,\r\n  maxDate,\r\n  disabledPast,\r\n  disabledFuture\r\n) {\r\n  const currentDate = new Date();\r\n  const maxYear = maxDate && getYear(maxDate);\r\n  const maxMonth = maxDate && getMonth(maxDate);\r\n  const minYear = minDate && getYear(minDate);\r\n  const minMonth = minDate && getMonth(minDate);\r\n  const currentYear = getYear(currentDate);\r\n  const currentMonth = getMonth(currentDate);\r\n\r\n  const isMonthAndYearAfterMax =\r\n    maxMonth &&\r\n    maxYear &&\r\n    (year > maxYear || (year === maxYear && month > maxMonth));\r\n\r\n  const isMonthAndYearBeforeMin =\r\n    minMonth &&\r\n    minYear &&\r\n    (year < minYear || (year === minYear && month < minMonth));\r\n\r\n  const isMonthAndYearDisabledPast =\r\n    disabledPast &&\r\n    (year < currentYear || (year === currentYear && month < currentMonth));\r\n  const isMonthAndYearDisabledFuture =\r\n    disabledFuture &&\r\n    (year > currentYear || (year === currentYear && month > currentMonth));\r\n\r\n  return (\r\n    isMonthAndYearAfterMax ||\r\n    isMonthAndYearBeforeMin ||\r\n    isMonthAndYearDisabledPast ||\r\n    isMonthAndYearDisabledFuture\r\n  );\r\n}\r\n\r\nexport function isYearDisabled(\r\n  year,\r\n  minDate,\r\n  maxDate,\r\n  disabledPast,\r\n  disabledFuture\r\n) {\r\n  const min = minDate && getYear(minDate);\r\n  const max = maxDate && getYear(maxDate);\r\n  const currentYear = getYear(new Date());\r\n\r\n  const isAfterMax = max && year > max;\r\n  const isBeforeMin = min && year < min;\r\n  const isDisabledPast = disabledPast && year < currentYear;\r\n  const isDisabledFuture = disabledFuture && year > currentYear;\r\n\r\n  return isAfterMax || isBeforeMin || isDisabledPast || isDisabledFuture;\r\n}\r\n\r\nexport function isNextDateDisabled(\r\n  disabledFuture,\r\n  activeDate,\r\n  view,\r\n  yearsInView,\r\n  minDate,\r\n  maxDate,\r\n  lastYearInView,\r\n  firstYearInView\r\n) {\r\n  const currentDate = new Date();\r\n  currentDate.setHours(0, 0, 0, 0);\r\n  if (disabledFuture && maxDate && compareDates(maxDate, currentDate) < 0) {\r\n    maxDate = currentDate;\r\n  } else if (disabledFuture) {\r\n    maxDate = currentDate;\r\n  }\r\n  return (\r\n    maxDate &&\r\n    areDatesInSameView(\r\n      activeDate,\r\n      maxDate,\r\n      view,\r\n      yearsInView,\r\n      minDate,\r\n      maxDate,\r\n      lastYearInView,\r\n      firstYearInView\r\n    )\r\n  );\r\n}\r\n\r\nexport function isPreviousDateDisabled(\r\n  disabledPast,\r\n  activeDate,\r\n  view,\r\n  yearsInView,\r\n  minDate,\r\n  maxDate,\r\n  lastYearInView,\r\n  firstYearInView\r\n) {\r\n  const currentDate = new Date();\r\n  currentDate.setHours(0, 0, 0, 0);\r\n  if (disabledPast && minDate && compareDates(minDate, currentDate) < 0) {\r\n    minDate = currentDate;\r\n  } else if (disabledPast) {\r\n    minDate = currentDate;\r\n  }\r\n  return (\r\n    minDate &&\r\n    areDatesInSameView(\r\n      activeDate,\r\n      minDate,\r\n      view,\r\n      yearsInView,\r\n      minDate,\r\n      maxDate,\r\n      lastYearInView,\r\n      firstYearInView\r\n    )\r\n  );\r\n}\r\n\r\nexport function areDatesInSameView(\r\n  date1,\r\n  date2,\r\n  view,\r\n  yearsInView,\r\n  minDate,\r\n  maxDate,\r\n  lastYearInView,\r\n  firstYearInView\r\n) {\r\n  if (view === \"days\") {\r\n    return (\r\n      getYear(date1) === getYear(date2) && getMonth(date1) === getMonth(date2)\r\n    );\r\n  }\r\n\r\n  if (view === \"months\") {\r\n    return getYear(date1) === getYear(date2);\r\n  }\r\n\r\n  if (view === \"years\") {\r\n    return (\r\n      getYear(date2) >= firstYearInView && getYear(date2) <= lastYearInView\r\n    );\r\n  }\r\n\r\n  return false;\r\n}\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\n/* eslint-disable indent */\r\n\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport { element } from \"../../util\";\r\nimport {\r\n  getYear,\r\n  getMonth,\r\n  getDate,\r\n  getDayNumber,\r\n  getFirstDayOfWeek,\r\n  addMonths,\r\n  getDaysInMonth,\r\n  createDate,\r\n  isSameDate,\r\n  getToday,\r\n  getYearsOffset,\r\n  isDateDisabled,\r\n  isMonthDisabled,\r\n  isYearDisabled,\r\n} from \"./date-utils\";\r\n\r\nconst MODAL_CONTAINER_REF = \"data-te-datepicker-modal-container-ref\";\r\nconst DROPDOWN_CONTAINER_REF = \"data-te-datepicker-dropdown-container-ref\";\r\nconst BACKDROP_REF = \"data-te-dropdown-backdrop-ref\";\r\nconst DATE_TEXT_REF = \"data-te-datepicker-date-text-ref\";\r\nconst VIEW_REF = \"data-te-datepicker-view-ref\";\r\nconst PREVIOUS_BUTTON_REF = \"data-te-datepicker-previous-button-ref\";\r\nconst NEXT_BUTTON_REF = \"data-te-datepicker-next-button-ref\";\r\nconst OK_BUTTON_REF = \"data-te-datepicker-ok-button-ref\";\r\nconst CANCEL_BUTTON_REF = \"data-te-datepicker-cancel-button-ref\";\r\nconst CLEAR_BUTTON_REF = \"data-te-datepicker-clear-button-ref\";\r\nconst VIEW_CHANGE_BUTTON_REF = \"data-te-datepicker-view-change-button-ref\";\r\n\r\nexport function getDatepickerTemplate(\r\n  date,\r\n  selectedDate,\r\n  selectedYear,\r\n  selectedMonth,\r\n  options,\r\n  monthsInRow,\r\n  yearsInView,\r\n  yearsInRow,\r\n  id,\r\n  classes\r\n) {\r\n  const month = getMonth(date);\r\n  const year = getYear(date);\r\n  const day = getDate(date);\r\n  const dayNumber = getDayNumber(date);\r\n  const template = element(\"div\");\r\n  const inlineContent = `\r\n        ${createMainContent(\r\n          date,\r\n          month,\r\n          year,\r\n          selectedDate,\r\n          selectedYear,\r\n          selectedMonth,\r\n          options,\r\n          monthsInRow,\r\n          yearsInView,\r\n          yearsInRow,\r\n          classes\r\n        )}\r\n    `;\r\n  const modalContent = `\r\n      ${createHeader(day, dayNumber, month, options, classes)}\r\n      ${createMainContent(\r\n        date,\r\n        month,\r\n        year,\r\n        selectedDate,\r\n        selectedYear,\r\n        selectedMonth,\r\n        options,\r\n        monthsInRow,\r\n        yearsInView,\r\n        yearsInRow,\r\n        classes\r\n      )}\r\n    `;\r\n\r\n  if (options.inline) {\r\n    Manipulator.addClass(template, classes.datepickerDropdownContainer);\r\n    template.setAttribute(DROPDOWN_CONTAINER_REF, id);\r\n\r\n    template.innerHTML = inlineContent;\r\n  } else {\r\n    Manipulator.addClass(template, classes.modalContainer);\r\n    template.setAttribute(MODAL_CONTAINER_REF, id);\r\n\r\n    template.innerHTML = modalContent;\r\n  }\r\n\r\n  return template;\r\n}\r\n\r\nexport function getBackdropTemplate(backdropClasses) {\r\n  const backdrop = element(\"div\");\r\n  Manipulator.addClass(backdrop, backdropClasses);\r\n  backdrop.setAttribute(BACKDROP_REF, \"\");\r\n\r\n  return backdrop;\r\n}\r\n\r\nexport function createContainer(modalContainerClasses) {\r\n  const container = element(\"div\");\r\n  Manipulator.addClass(container, modalContainerClasses);\r\n  container.setAttribute(MODAL_CONTAINER_REF, \"\");\r\n\r\n  return container;\r\n}\r\n\r\nfunction createHeader(day, dayNumber, month, options, classes) {\r\n  return `\r\n      <div class=\"${classes.datepickerHeader}\">\r\n        <div class=\"${classes.datepickerTitle}\">\r\n          <span class=\"${classes.datepickerTitleText}\">${options.title}</span>\r\n        </div>\r\n        <div class=\"${classes.datepickerDate}\">\r\n          <span class=\"${classes.datepickerDateText}\" ${DATE_TEXT_REF} >${options.weekdaysShort[dayNumber]}, ${options.monthsShort[month]} ${day}</span>\r\n        </div>\r\n      </div>\r\n    `;\r\n}\r\n\r\nfunction createMainContent(\r\n  date,\r\n  month,\r\n  year,\r\n  selectedDate,\r\n  selectedYear,\r\n  selectedMonth,\r\n  options,\r\n  monthsInRow,\r\n  yearsInView,\r\n  yearsInRow,\r\n  classes\r\n) {\r\n  let mainContentTemplate;\r\n  if (options.inline) {\r\n    mainContentTemplate = `\r\n    <div class=\"${classes.datepickerMain}\">\r\n      ${createControls(month, year, options, classes)}\r\n      <div class=\"${classes.datepickerView}\" ${VIEW_REF} tabindex=\"0\">\r\n        ${createViewTemplate(\r\n          date,\r\n          year,\r\n          selectedDate,\r\n          selectedYear,\r\n          selectedMonth,\r\n          options,\r\n          monthsInRow,\r\n          yearsInView,\r\n          yearsInRow,\r\n          classes\r\n        )}\r\n      </div>\r\n    </div>\r\n  `;\r\n  } else {\r\n    mainContentTemplate = `\r\n    <div class=\"${classes.datepickerMain}\">\r\n      ${createControls(month, year, options, classes)}\r\n      <div class=\"${classes.datepickerView}\" ${VIEW_REF} tabindex=\"0\">\r\n        ${createViewTemplate(\r\n          date,\r\n          year,\r\n          selectedDate,\r\n          selectedYear,\r\n          selectedMonth,\r\n          options,\r\n          monthsInRow,\r\n          yearsInView,\r\n          yearsInRow,\r\n          classes\r\n        )}\r\n      </div>\r\n      ${createFooter(options, classes)}\r\n    </div>\r\n  `;\r\n  }\r\n\r\n  return mainContentTemplate;\r\n}\r\n\r\nfunction createViewTemplate(\r\n  date,\r\n  year,\r\n  selectedDate,\r\n  selectedYear,\r\n  selectedMonth,\r\n  options,\r\n  monthsInRow,\r\n  yearsInView,\r\n  yearsInRow,\r\n  classes\r\n) {\r\n  let viewTemplate;\r\n  if (options.view === \"days\") {\r\n    viewTemplate = createDayViewTemplate(date, selectedDate, options, classes);\r\n  } else if (options.view === \"months\") {\r\n    viewTemplate = createMonthViewTemplate(\r\n      year,\r\n      selectedYear,\r\n      selectedMonth,\r\n      options,\r\n      monthsInRow,\r\n      classes\r\n    );\r\n  } else {\r\n    viewTemplate = createYearViewTemplate(\r\n      date,\r\n      selectedYear,\r\n      options,\r\n      yearsInView,\r\n      yearsInRow,\r\n      classes\r\n    );\r\n  }\r\n\r\n  return viewTemplate;\r\n}\r\n\r\nfunction createControls(month, year, options, classes) {\r\n  return `\r\n    <div class=\"${classes.datepickerDateControls}\">\r\n      <button class=\"${classes.datepickerViewChangeButton}\" aria-label=\"${\r\n    options.switchToMultiYearViewLabel\r\n  }\" ${VIEW_CHANGE_BUTTON_REF}>\r\n        ${options.monthsFull[month]} ${year} ${createViewChangeButtonIcon(\r\n    options,\r\n    classes\r\n  )}\r\n      </button>\r\n      <div class=\"${classes.datepickerArrowControls}\">\r\n        <button class=\"${classes.datepickerPreviousButton}\" aria-label=\"${\r\n    options.prevMonthLabel\r\n  }\" ${PREVIOUS_BUTTON_REF}>${options.changeMonthIconTemplate}</button>\r\n        <button class=\"${classes.datepickerNextButton}\" aria-label=\"${\r\n    options.nextMonthLabel\r\n  }\" ${NEXT_BUTTON_REF}>${options.changeMonthIconTemplate}</button>\r\n      </div>\r\n    </div>\r\n    `;\r\n}\r\n\r\nexport function createViewChangeButtonIcon(options, classes) {\r\n  return `\r\n  <span class=\"${classes.datepickerViewChangeIcon}\">\r\n  ${options.viewChangeIconTemplate}\r\n  </span>\r\n  `;\r\n}\r\n\r\nfunction createFooter(options, classes) {\r\n  const okBtn = `<button class=\"${classes.datepickerFooterBtn}\" aria-label=\"${options.okBtnLabel}\" ${OK_BUTTON_REF}>${options.okBtnText}</button>`;\r\n  const cancelButton = `<button class=\"${classes.datepickerFooterBtn}\" aria-label=\"${options.cancelBtnLabel}\" ${CANCEL_BUTTON_REF}>${options.cancelBtnText}</button>`;\r\n  const clearButton = `<button class=\"${classes.datepickerFooterBtn} ${classes.datepickerClearBtn}\" aria-label=\"${options.clearBtnLabel}\" ${CLEAR_BUTTON_REF}>${options.clearBtnText}</button>`;\r\n\r\n  return `\r\n        <div class=\"${classes.datepickerFooter}\">\r\n          \r\n        ${options.removeClearBtn ? \"\" : clearButton}\r\n        ${options.removeCancelBtn ? \"\" : cancelButton}\r\n        ${options.removeOkBtn ? \"\" : okBtn}\r\n        </div>\r\n      `;\r\n}\r\n\r\nexport function createDayViewTemplate(date, headerDate, options, classes) {\r\n  const dates = getDatesArray(date, headerDate, options);\r\n  const dayNames = options.weekdaysNarrow;\r\n\r\n  const tableHeadContent = `\r\n      <tr>\r\n        ${dayNames\r\n          .map((name, i) => {\r\n            return `<th class=\"${classes.datepickerDayHeading}\" scope=\"col\" aria-label=\"${options.weekdaysFull[i]}\">${name}</th>`;\r\n          })\r\n          .join(\"\")}\r\n      </tr>\r\n    `;\r\n\r\n  const tableBodyContent = dates\r\n    .map((week) => {\r\n      return `\r\n        <tr>\r\n          ${week\r\n            .map((day) => {\r\n              return `\r\n              <td\r\n              class=\"${classes.datepickerCell} ${classes.datepickerCellSmall}\"\r\n              data-te-date=\"${getYear(day.date)}-${getMonth(\r\n                day.date\r\n              )}-${getDate(day.date)}\"\r\n              aria-label=\"${day.date}\"\r\n              aria-selected=\"${day.isSelected}\"\r\n              ${day.isSelected ? \"data-te-datepicker-cell-selected\" : \"\"}\r\n              ${\r\n                !day.currentMonth || day.disabled\r\n                  ? \"data-te-datepicker-cell-disabled\"\r\n                  : \"\"\r\n              }\r\n              ${day.isToday ? \"data-te-datepicker-cell-current\" : \"\"}\r\n              >\r\n                <div\r\n                  class=\"${classes.datepickerCellContent} ${\r\n                classes.datepickerCellContentSmall\r\n              }\"\r\n                  style=\"${\r\n                    day.currentMonth ? \"display: block\" : \"display: none\"\r\n                  }\"\r\n                  >\r\n                  ${day.dayNumber}\r\n                  </div>\r\n              </td>\r\n            `;\r\n            })\r\n            .join(\"\")}\r\n        </tr>\r\n      `;\r\n    })\r\n    .join(\"\");\r\n\r\n  return `\r\n      <table class=\"${classes.datepickerTable}\">\r\n        <thead>\r\n          ${tableHeadContent}\r\n        </thead>\r\n        <tbody>\r\n         ${tableBodyContent}\r\n        </tbody>\r\n      </table>\r\n    `;\r\n}\r\n\r\nfunction getDatesArray(activeDate, headerDate, options) {\r\n  const dates = [];\r\n\r\n  const month = getMonth(activeDate);\r\n  const previousMonth = getMonth(addMonths(activeDate, -1));\r\n  const nextMonth = getMonth(addMonths(activeDate, 1));\r\n  const year = getYear(activeDate);\r\n\r\n  const firstDay = getFirstDayOfWeek(year, month, options);\r\n  const daysInMonth = getDaysInMonth(activeDate);\r\n  const daysInPreviousMonth = getDaysInMonth(addMonths(activeDate, -1));\r\n  const daysInWeek = 7;\r\n\r\n  let dayNumber = 1;\r\n  let isCurrentMonth = false;\r\n  for (let i = 1; i < daysInWeek; i++) {\r\n    const week = [];\r\n    if (i === 1) {\r\n      // First week\r\n      const previousMonthDay = daysInPreviousMonth - firstDay + 1;\r\n      // Previous month\r\n      for (let j = previousMonthDay; j <= daysInPreviousMonth; j++) {\r\n        const date = createDate(year, previousMonth, j);\r\n\r\n        week.push({\r\n          date,\r\n          currentMonth: isCurrentMonth,\r\n          isSelected: headerDate && isSameDate(date, headerDate),\r\n          isToday: isSameDate(date, getToday()),\r\n          dayNumber: getDate(date),\r\n        });\r\n      }\r\n\r\n      isCurrentMonth = true;\r\n      // Current month\r\n      const daysLeft = daysInWeek - week.length;\r\n      for (let j = 0; j < daysLeft; j++) {\r\n        const date = createDate(year, month, dayNumber);\r\n\r\n        week.push({\r\n          date,\r\n          currentMonth: isCurrentMonth,\r\n          isSelected: headerDate && isSameDate(date, headerDate),\r\n          isToday: isSameDate(date, getToday()),\r\n          dayNumber: getDate(date),\r\n          disabled: isDateDisabled(\r\n            date,\r\n            options.min,\r\n            options.max,\r\n            options.filter,\r\n            options.disablePast,\r\n            options.disableFuture\r\n          ),\r\n        });\r\n        dayNumber++;\r\n      }\r\n    } else {\r\n      // Rest of the weeks\r\n      for (let j = 1; j < 8; j++) {\r\n        if (dayNumber > daysInMonth) {\r\n          // Next month\r\n          dayNumber = 1;\r\n          isCurrentMonth = false;\r\n        }\r\n        const date = createDate(\r\n          year,\r\n          isCurrentMonth ? month : nextMonth,\r\n          dayNumber\r\n        );\r\n\r\n        week.push({\r\n          date,\r\n          currentMonth: isCurrentMonth,\r\n          isSelected: headerDate && isSameDate(date, headerDate),\r\n          isToday: isSameDate(date, getToday()),\r\n          dayNumber: getDate(date),\r\n          disabled: isDateDisabled(\r\n            date,\r\n            options.min,\r\n            options.max,\r\n            options.filter,\r\n            options.disablePast,\r\n            options.disableFuture\r\n          ),\r\n        });\r\n        dayNumber++;\r\n      }\r\n    }\r\n    dates.push(week);\r\n  }\r\n\r\n  return dates;\r\n}\r\n\r\nexport function createMonthViewTemplate(\r\n  year,\r\n  selectedYear,\r\n  selectedMonth,\r\n  options,\r\n  monthsInRow,\r\n  classes\r\n) {\r\n  const months = getMonthsArray(options, monthsInRow);\r\n  const currentMonth = getMonth(getToday());\r\n  const currentYear = getYear(getToday());\r\n\r\n  const tableBodyContent = `\r\n      ${months\r\n        .map((row) => {\r\n          return `\r\n          <tr>\r\n            ${row\r\n              .map((month) => {\r\n                const monthIndex = options.monthsShort.indexOf(month);\r\n                return `\r\n                <td class=\"${classes.datepickerCell} ${\r\n                  classes.datepickerCellLarge\r\n                }\"\r\n                ${\r\n                  isMonthDisabled(\r\n                    monthIndex,\r\n                    year,\r\n                    options.min,\r\n                    options.max,\r\n                    options.disablePast,\r\n                    options.disableFuture\r\n                  )\r\n                    ? \"data-te-datepicker-cell-disabled\"\r\n                    : \"\"\r\n                }\r\n                \r\n                data-te-month=\"${monthIndex}\" data-te-year=\"${year}\" aria-label=\"${month}, ${year}\"\r\n                ${\r\n                  monthIndex === selectedMonth && year === selectedYear\r\n                    ? \"data-te-datepicker-cell-selected\"\r\n                    : \"\"\r\n                }\r\n                ${\r\n                  monthIndex === currentMonth && year === currentYear\r\n                    ? \"data-te-datepicker-cell-current\"\r\n                    : \"\"\r\n                }\" data-te-month=\"${monthIndex}\" data-te-year=\"${year}\" aria-label=\"${month}, ${year}\">\r\n                  <div class=\"${classes.datepickerCellContent} ${\r\n                  classes.datepickerCellContentLarge\r\n                }\">${month}</div>\r\n                </td>\r\n              `;\r\n              })\r\n              .join(\"\")}\r\n          </tr>\r\n        `;\r\n        })\r\n        .join(\"\")}\r\n    `;\r\n\r\n  return `\r\n      <table class=\"${classes.datepickerTable}\">\r\n        <tbody>\r\n         ${tableBodyContent}\r\n        </tbody>\r\n      </table>\r\n    `;\r\n}\r\n\r\nfunction getMonthsArray(options, monthsInRow) {\r\n  const months = [];\r\n\r\n  let row = [];\r\n\r\n  for (let i = 0; i < options.monthsShort.length; i++) {\r\n    row.push(options.monthsShort[i]);\r\n\r\n    if (row.length === monthsInRow) {\r\n      const monthsRow = row;\r\n      months.push(monthsRow);\r\n      row = [];\r\n    }\r\n  }\r\n\r\n  return months;\r\n}\r\n\r\nexport function createYearViewTemplate(\r\n  date,\r\n  selectedYear,\r\n  options,\r\n  yearsInView,\r\n  yearsInRow,\r\n  classes\r\n) {\r\n  const years = getYearsArray(date, yearsInView, yearsInRow);\r\n  const currentYear = getYear(getToday());\r\n\r\n  const tableBodyContent = `\r\n    ${years\r\n      .map((row) => {\r\n        return `\r\n        <tr>\r\n          ${row\r\n            .map((year) => {\r\n              return `\r\n              <td class=\"${classes.datepickerCell} ${\r\n                classes.datepickerCellLarge\r\n              }\"  aria-label=\"${year}\" data-te-year=\"${year}\"\r\n              ${\r\n                isYearDisabled(\r\n                  year,\r\n                  options.min,\r\n                  options.max,\r\n                  options.disablePast,\r\n                  options.disableFuture\r\n                )\r\n                  ? \"data-te-datepicker-cell-disabled\"\r\n                  : \"\"\r\n              }\r\n              ${year === selectedYear ? \"data-te-datepicker-cell-selected\" : \"\"}\r\n              ${year === currentYear ? \"data-te-datepicker-cell-current\" : \"\"}\r\n              >\r\n                <div class=\"${classes.datepickerCellContent} ${\r\n                classes.datepickerCellContentLarge\r\n              }\">${year}</div>\r\n              </td>\r\n            `;\r\n            })\r\n            .join(\"\")}\r\n        </tr>\r\n      `;\r\n      })\r\n      .join(\"\")}\r\n  `;\r\n\r\n  return `\r\n      <table class=\"${classes.datepickerTable}\">\r\n        <tbody>\r\n        ${tableBodyContent}\r\n        </tbody>\r\n      </table>\r\n    `;\r\n}\r\n\r\nfunction getYearsArray(date, yearsInView, yearsInRow) {\r\n  const years = [];\r\n  const activeYear = getYear(date);\r\n  const yearsOffset = getYearsOffset(date, yearsInView);\r\n\r\n  const firstYearInView = activeYear - yearsOffset;\r\n\r\n  let row = [];\r\n\r\n  for (let i = 0; i < yearsInView; i++) {\r\n    row.push(firstYearInView + i);\r\n\r\n    if (row.length === yearsInRow) {\r\n      const yearsRow = row;\r\n      years.push(yearsRow);\r\n      row = [];\r\n    }\r\n  }\r\n\r\n  return years;\r\n}\r\n\r\nexport function getToggleButtonTemplate(id, toggleBtnClasses) {\r\n  return `\r\n    <button id=\"${id}\" type=\"button\" class=\"${toggleBtnClasses}\" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>\r\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\r\n      <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\r\n      </svg>  \r\n    </button>\r\n  `;\r\n}\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nexport const LEFT_ARROW = 37;\r\nexport const UP_ARROW = 38;\r\nexport const RIGHT_ARROW = 39;\r\nexport const DOWN_ARROW = 40;\r\nexport const HOME = 36;\r\nexport const END = 35;\r\nexport const PAGE_UP = 33;\r\nexport const PAGE_DOWN = 34;\r\nexport const ENTER = 13;\r\nexport const SPACE = 32;\r\nexport const ESCAPE = 27;\r\nexport const TAB = 9;\r\nexport const BACKSPACE = 8;\r\nexport const DELETE = 46;\r\nexport const A = 65;\r\nexport const B = 66;\r\nexport const C = 67;\r\nexport const D = 68;\r\nexport const E = 69;\r\nexport const F = 70;\r\nexport const G = 71;\r\nexport const H = 72;\r\nexport const I = 73;\r\nexport const J = 74;\r\nexport const K = 75;\r\nexport const L = 76;\r\nexport const M = 77;\r\nexport const N = 78;\r\nexport const O = 79;\r\nexport const P = 80;\r\nexport const Q = 81;\r\nexport const R = 82;\r\nexport const S = 83;\r\nexport const T = 84;\r\nexport const U = 85;\r\nexport const V = 86;\r\nexport const W = 87;\r\nexport const X = 88;\r\nexport const Y = 89;\r\nexport const Z = 90;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { createPopper } from \"@popperjs/core\";\r\nimport Data from \"../../dom/data\";\r\nimport EventHandler from \"../../dom/event-handler\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\nimport ScrollBarHelper from \"../../util/scrollbar\";\r\nimport { typeCheckConfig, getUID, isRTL } from \"../../util/index\";\r\nimport FocusTrap from \"../../util/focusTrap\";\r\nimport {\r\n  getDate,\r\n  getDayNumber,\r\n  getMonth,\r\n  getYear,\r\n  getDaysInMonth,\r\n  addYears,\r\n  addMonths,\r\n  addDays,\r\n  createDate,\r\n  convertStringToDate,\r\n  isSameDate,\r\n  areDatesInSameView,\r\n  isDateDisabled,\r\n  isMonthDisabled,\r\n  isYearDisabled,\r\n  isNextDateDisabled,\r\n  isPreviousDateDisabled,\r\n  getYearsOffset,\r\n  isValidDate,\r\n} from \"./date-utils\";\r\nimport {\r\n  getBackdropTemplate,\r\n  getDatepickerTemplate,\r\n  createDayViewTemplate,\r\n  createMonthViewTemplate,\r\n  createYearViewTemplate,\r\n  getToggleButtonTemplate,\r\n  createViewChangeButtonIcon,\r\n} from \"./templates\";\r\nimport {\r\n  ENTER,\r\n  SPACE,\r\n  ESCAPE,\r\n  LEFT_ARROW,\r\n  RIGHT_ARROW,\r\n  DOWN_ARROW,\r\n  UP_ARROW,\r\n  HOME,\r\n  END,\r\n  PAGE_UP,\r\n  PAGE_DOWN,\r\n} from \"../../util/keycodes\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst YEARS_IN_VIEW = 24;\r\nconst YEARS_IN_ROW = 4;\r\nconst MONTHS_IN_ROW = 4;\r\n\r\nconst NAME = \"datepicker\";\r\nconst DATA_KEY = \"te.datepicker\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\n\r\nconst EVENT_CLOSE = `close${EVENT_KEY}`;\r\nconst EVENT_OPEN = `open${EVENT_KEY}`;\r\nconst EVENT_DATE_CHANGE = `dateChange${EVENT_KEY}`;\r\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\r\n\r\nconst MODAL_CONTAINER_NAME = \"data-te-datepicker-modal-container-ref\";\r\nconst DROPDOWN_CONTAINER_NAME = \"data-te-datepicker-dropdown-container-ref\";\r\n\r\nconst DATEPICKER_TOGGLE_SELECTOR = \"[data-te-datepicker-toggle-ref]\";\r\nconst MODAL_CONTAINER_SELECTOR = `[${MODAL_CONTAINER_NAME}]`;\r\nconst DROPDOWN_CONTAINER_SELECTOR = `[${DROPDOWN_CONTAINER_NAME}]`;\r\nconst VIEW_CHANGE_BUTTON_SELECTOR =\r\n  \"[data-te-datepicker-view-change-button-ref]\";\r\nconst PREVIOUS_BUTTON_SELECTOR = \"[data-te-datepicker-previous-button-ref]\";\r\nconst NEXT_BUTTON_SELECTOR = \"[data-te-datepicker-next-button-ref]\";\r\nconst OK_BUTTON_SELECTOR = \"[data-te-datepicker-ok-button-ref]\";\r\nconst CANCEL_BUTTON_SELECTOR = \"[data-te-datepicker-cancel-button-ref]\";\r\nconst CLEAR_BUTTON_SELECTOR = \"[data-te-datepicker-clear-button-ref]\";\r\nconst VIEW_SELECTOR = \"[data-te-datepicker-view-ref]\";\r\nconst TOGGLE_BUTTON_SELECTOR = \"[data-te-datepicker-toggle-button-ref]\";\r\nconst DATE_TEXT_SELECTOR = \"[data-te-datepicker-date-text-ref]\";\r\nconst BACKDROP_SELECTOR = \"[data-te-dropdown-backdrop-ref]\";\r\n\r\nconst FADE_IN_CLASSES =\r\n  \"animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\";\r\nconst FADE_OUT_CLASSES =\r\n  \"animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\";\r\nconst FADE_IN_SHORT_CLASSES =\r\n  \"animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\";\r\nconst FADE_OUT_SHORT_CLASSES =\r\n  \"animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\";\r\n\r\n// templates classes\r\nconst MODAL_CONTAINER_CLASSES =\r\n  \"flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700\";\r\nconst DATEPICKER_BACKDROP_CLASSES =\r\n  \"w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]\";\r\nconst DATEPICKER_MAIN_CLASSES = \"relative h-full\";\r\nconst DATEPICKER_HEADER_CLASSES =\r\n  \"xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800\";\r\nconst DATEPICKER_TITLE_CLASSES = \"h-8 flex flex-col justify-end\";\r\nconst DATEPICKER_TITLE_TEXT_CLASSES =\r\n  \"text-[10px] font-normal uppercase tracking-[1.7px] text-white\";\r\nconst DATEPICKER_DATE_CLASSES =\r\n  \"xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end\";\r\nconst DATEPICKER_DATE_TEXT_CLASSES = \"text-[34px] font-normal text-white\";\r\nconst DATEPICKER_VIEW_CLASSES = \"outline-none px-3\";\r\nconst DATEPICKER_DATE_CONTROLS_CLASSES =\r\n  \"px-3 pt-2.5 pb-0 flex justify-between text-black/[64]\";\r\nconst DATEPICKER_VIEW_CHANGE_BUTTON_CLASSES = `flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10`;\r\nconst DATEPICKER_ARROW_CONTROLS_CLASSES = \"mt-2.5\";\r\nconst DATEPICKER_PREVIOUS_BUTTON_CLASSES =\r\n  \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto\";\r\nconst DATEPICKER_NEXT_BUTTON_CLASSES =\r\n  \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto\";\r\nconst DATEPICKER_FOOTER_CLASSES =\r\n  \"h-14 flex absolute w-full bottom-0 justify-end items-center px-3\";\r\nconst DATEPICKER_FOOTER_BTN_CLASSES =\r\n  \"outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\";\r\nconst DATEPICKER_CLEAR_BTN_CLASSES = \"mr-auto\";\r\nconst DATEPICKER_DAY_HEADING_CLASSES =\r\n  \"w-10 h-10 text-center text-[12px] font-normal dark:text-white\";\r\nconst DATEPICKER_CELL_CLASSES =\r\n  \"text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group\";\r\nconst DATEPICKER_CELL_SMALL_CLASSES =\r\n  \"w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8\";\r\nconst DATEPICKER_CELL_LARGE_CLASSES = \"w-[76px] h-[42px]\";\r\nconst DATEPICKER_CELL_CONTENT_CLASSES =\r\n  \"mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500\";\r\nconst DATEPICKER_CELL_CONTENT_SMALL_CLASSES =\r\n  \"w-9 h-9 leading-9 rounded-[50%] text-[13px]\";\r\nconst DATEPICKER_CELL_CONTENT_LARGE_CLASSES =\r\n  \"w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]\";\r\nconst DATEPICKER_TABLE_CLASSES = \"mx-auto w-[304px]\";\r\nconst DATEPICKER_TOGGLE_BUTTON_CLASSES =\r\n  \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\";\r\nconst DATEPICKER_VIEW_CHANGE_ICON_CLASSES =\r\n  \"inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white\";\r\nconst DATEPICKER_DROPDOWN_CONTAINER_CLASSES =\r\n  \"w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700\";\r\n\r\nconst Default = {\r\n  title: \"Select date\",\r\n  container: \"body\",\r\n  disablePast: false,\r\n  disableFuture: false,\r\n  monthsFull: [\r\n    \"January\",\r\n    \"February\",\r\n    \"March\",\r\n    \"April\",\r\n    \"May\",\r\n    \"June\",\r\n    \"July\",\r\n    \"August\",\r\n    \"September\",\r\n    \"October\",\r\n    \"November\",\r\n    \"December\",\r\n  ],\r\n  monthsShort: [\r\n    \"Jan\",\r\n    \"Feb\",\r\n    \"Mar\",\r\n    \"Apr\",\r\n    \"May\",\r\n    \"Jun\",\r\n    \"Jul\",\r\n    \"Aug\",\r\n    \"Sep\",\r\n    \"Oct\",\r\n    \"Nov\",\r\n    \"Dec\",\r\n  ],\r\n  weekdaysFull: [\r\n    \"Sunday\",\r\n    \"Monday\",\r\n    \"Tuesday\",\r\n    \"Wednesday\",\r\n    \"Thursday\",\r\n    \"Friday\",\r\n    \"Saturday\",\r\n  ],\r\n  weekdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\r\n  weekdaysNarrow: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\r\n  okBtnText: \"Ok\",\r\n  clearBtnText: \"Clear\",\r\n  cancelBtnText: \"Cancel\",\r\n\r\n  okBtnLabel: \"Confirm selection\",\r\n  clearBtnLabel: \"Clear selection\",\r\n  cancelBtnLabel: \"Cancel selection\",\r\n  nextMonthLabel: \"Next month\",\r\n  prevMonthLabel: \"Previous month\",\r\n  nextYearLabel: \"Next year\",\r\n  prevYearLabel: \"Previous year\",\r\n  changeMonthIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-6 h-6\">\r\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\r\n  </svg>\r\n  `,\r\n  nextMultiYearLabel: \"Next 24 years\",\r\n  prevMultiYearLabel: \"Previous 24 years\",\r\n  switchToMultiYearViewLabel: \"Choose year and month\",\r\n  switchToMonthViewLabel: \"Choose date\",\r\n  switchToDayViewLabel: \"Choose date\",\r\n\r\n  startDate: null,\r\n  startDay: 0,\r\n  format: \"dd/mm/yyyy\",\r\n  view: \"days\",\r\n  viewChangeIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"0\" stroke=\"currentColor\" class=\"w-6 h-6\">\r\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\r\n  </svg>\r\n  `,\r\n\r\n  min: null,\r\n  max: null,\r\n  filter: null,\r\n\r\n  inline: false,\r\n  toggleButton: true,\r\n  disableToggleButton: false,\r\n  disableInput: false,\r\n  animations: true,\r\n  confirmDateOnSelect: false,\r\n  removeOkBtn: false,\r\n  removeCancelBtn: false,\r\n  removeClearBtn: false,\r\n};\r\n\r\nconst DefaultType = {\r\n  title: \"string\",\r\n  container: \"string\",\r\n  disablePast: \"boolean\",\r\n  disableFuture: \"boolean\",\r\n  monthsFull: \"array\",\r\n  monthsShort: \"array\",\r\n  weekdaysFull: \"array\",\r\n  weekdaysShort: \"array\",\r\n  weekdaysNarrow: \"array\",\r\n\r\n  okBtnText: \"string\",\r\n  clearBtnText: \"string\",\r\n  cancelBtnText: \"string\",\r\n  okBtnLabel: \"string\",\r\n  clearBtnLabel: \"string\",\r\n  cancelBtnLabel: \"string\",\r\n  nextMonthLabel: \"string\",\r\n  prevMonthLabel: \"string\",\r\n  nextYearLabel: \"string\",\r\n  prevYearLabel: \"string\",\r\n  nextMultiYearLabel: \"string\",\r\n  prevMultiYearLabel: \"string\",\r\n  changeMonthIconTemplate: \"string\",\r\n  switchToMultiYearViewLabel: \"string\",\r\n  switchToMonthViewLabel: \"string\",\r\n  switchToDayViewLabel: \"string\",\r\n\r\n  startDate: \"(null|string|date)\",\r\n  startDay: \"number\",\r\n  format: \"string\",\r\n  view: \"string\",\r\n  viewChangeIconTemplate: \"string\",\r\n\r\n  min: \"(null|string|date)\",\r\n  max: \"(null|string|date)\",\r\n  filter: \"(null|function)\",\r\n\r\n  inline: \"boolean\",\r\n  toggleButton: \"boolean\",\r\n  disableToggleButton: \"boolean\",\r\n  disableInput: \"boolean\",\r\n  animations: \"boolean\",\r\n  confirmDateOnSelect: \"boolean\",\r\n  removeOkBtn: \"boolean\",\r\n  removeCancelBtn: \"boolean\",\r\n  removeClearBtn: \"boolean\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  fadeIn: FADE_IN_CLASSES,\r\n  fadeOut: FADE_OUT_CLASSES,\r\n  fadeInShort: FADE_IN_SHORT_CLASSES,\r\n  fadeOutShort: FADE_OUT_SHORT_CLASSES,\r\n  modalContainer: MODAL_CONTAINER_CLASSES,\r\n  datepickerBackdrop: DATEPICKER_BACKDROP_CLASSES,\r\n  datepickerMain: DATEPICKER_MAIN_CLASSES,\r\n  datepickerHeader: DATEPICKER_HEADER_CLASSES,\r\n  datepickerTitle: DATEPICKER_TITLE_CLASSES,\r\n  datepickerTitleText: DATEPICKER_TITLE_TEXT_CLASSES,\r\n  datepickerDate: DATEPICKER_DATE_CLASSES,\r\n  datepickerDateText: DATEPICKER_DATE_TEXT_CLASSES,\r\n  datepickerView: DATEPICKER_VIEW_CLASSES,\r\n  datepickerDateControls: DATEPICKER_DATE_CONTROLS_CLASSES,\r\n  datepickerViewChangeButton: DATEPICKER_VIEW_CHANGE_BUTTON_CLASSES,\r\n  datepickerViewChangeIcon: DATEPICKER_VIEW_CHANGE_ICON_CLASSES,\r\n  datepickerArrowControls: DATEPICKER_ARROW_CONTROLS_CLASSES,\r\n  datepickerPreviousButton: DATEPICKER_PREVIOUS_BUTTON_CLASSES,\r\n  datepickerNextButton: DATEPICKER_NEXT_BUTTON_CLASSES,\r\n  datepickerFooter: DATEPICKER_FOOTER_CLASSES,\r\n  datepickerFooterBtn: DATEPICKER_FOOTER_BTN_CLASSES,\r\n  datepickerClearBtn: DATEPICKER_CLEAR_BTN_CLASSES,\r\n  datepickerDayHeading: DATEPICKER_DAY_HEADING_CLASSES,\r\n  datepickerCell: DATEPICKER_CELL_CLASSES,\r\n  datepickerCellSmall: DATEPICKER_CELL_SMALL_CLASSES,\r\n  datepickerCellLarge: DATEPICKER_CELL_LARGE_CLASSES,\r\n  datepickerCellContent: DATEPICKER_CELL_CONTENT_CLASSES,\r\n  datepickerCellContentSmall: DATEPICKER_CELL_CONTENT_SMALL_CLASSES,\r\n  datepickerCellContentLarge: DATEPICKER_CELL_CONTENT_LARGE_CLASSES,\r\n  datepickerTable: DATEPICKER_TABLE_CLASSES,\r\n  datepickerToggleButton: DATEPICKER_TOGGLE_BUTTON_CLASSES,\r\n  datepickerDropdownContainer: DATEPICKER_DROPDOWN_CONTAINER_CLASSES,\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  fadeIn: \"string\",\r\n  fadeOut: \"string\",\r\n  fadeInShort: \"string\",\r\n  fadeOutShort: \"string\",\r\n  modalContainer: \"string\",\r\n  datepickerBackdrop: \"string\",\r\n  datepickerMain: \"string\",\r\n  datepickerHeader: \"string\",\r\n  datepickerTitle: \"string\",\r\n  datepickerTitleText: \"string\",\r\n  datepickerDate: \"string\",\r\n  datepickerDateText: \"string\",\r\n  datepickerView: \"string\",\r\n  datepickerDateControls: \"string\",\r\n  datepickerViewChangeButton: \"string\",\r\n  datepickerArrowControls: \"string\",\r\n  datepickerPreviousButton: \"string\",\r\n  datepickerNextButton: \"string\",\r\n  datepickerFooter: \"string\",\r\n  datepickerFooterBtn: \"string\",\r\n  datepickerClearBtn: \"string\",\r\n  datepickerDayHeading: \"string\",\r\n  datepickerCell: \"string\",\r\n  datepickerCellSmall: \"string\",\r\n  datepickerCellLarge: \"string\",\r\n  datepickerCellContent: \"string\",\r\n  datepickerCellContentSmall: \"string\",\r\n  datepickerCellContentLarge: \"string\",\r\n  datepickerTable: \"string\",\r\n  datepickerToggleButton: \"string\",\r\n  datepickerDropdownContainer: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Datepicker {\r\n  constructor(element, options, classes) {\r\n    this._element = element;\r\n    this._input = SelectorEngine.findOne(\"input\", this._element);\r\n    this._options = this._getConfig(options);\r\n    this._classes = this._getClasses(classes);\r\n    this._activeDate = new Date();\r\n    this._selectedDate = null;\r\n    this._selectedYear = null;\r\n    this._selectedMonth = null;\r\n    this._headerDate = null;\r\n    this._headerYear = null;\r\n    this._headerMonth = null;\r\n    this._view = this._options.view;\r\n    this._popper = null;\r\n    this._focusTrap = null;\r\n    this._isOpen = false;\r\n    this._toggleButtonId = getUID(\"datepicker-toggle-\");\r\n    this._animations =\r\n      !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches &&\r\n      this._options.animations;\r\n\r\n    this._scrollBar = new ScrollBarHelper();\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n    }\r\n\r\n    this._init();\r\n\r\n    if (this.toggleButton && this._options.disableToggle) {\r\n      this.toggleButton.disabled = \"true\";\r\n    }\r\n\r\n    if (this._options.disableInput) {\r\n      this._input.disabled = \"true\";\r\n    }\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get container() {\r\n    return (\r\n      SelectorEngine.findOne(\r\n        `[${MODAL_CONTAINER_NAME}='${this._toggleButtonId}']`\r\n      ) ||\r\n      SelectorEngine.findOne(\r\n        `[${DROPDOWN_CONTAINER_NAME}='${this._toggleButtonId}']`\r\n      )\r\n    );\r\n  }\r\n\r\n  get options() {\r\n    return this._options;\r\n  }\r\n\r\n  get activeCell() {\r\n    let activeCell;\r\n\r\n    if (this._view === \"days\") {\r\n      activeCell = this._getActiveDayCell();\r\n    }\r\n\r\n    if (this._view === \"months\") {\r\n      activeCell = this._getActiveMonthCell();\r\n    }\r\n\r\n    if (this._view === \"years\") {\r\n      activeCell = this._getActiveYearCell();\r\n    }\r\n\r\n    return activeCell;\r\n  }\r\n\r\n  get activeDay() {\r\n    return getDate(this._activeDate);\r\n  }\r\n\r\n  get activeMonth() {\r\n    return getMonth(this._activeDate);\r\n  }\r\n\r\n  get activeYear() {\r\n    return getYear(this._activeDate);\r\n  }\r\n\r\n  get firstYearInView() {\r\n    return this.activeYear - getYearsOffset(this._activeDate, YEARS_IN_VIEW);\r\n  }\r\n\r\n  get lastYearInView() {\r\n    return this.firstYearInView + YEARS_IN_VIEW - 1;\r\n  }\r\n\r\n  get viewChangeButton() {\r\n    return SelectorEngine.findOne(VIEW_CHANGE_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get previousButton() {\r\n    return SelectorEngine.findOne(PREVIOUS_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get nextButton() {\r\n    return SelectorEngine.findOne(NEXT_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get okButton() {\r\n    return SelectorEngine.findOne(OK_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get cancelButton() {\r\n    return SelectorEngine.findOne(CANCEL_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get clearButton() {\r\n    return SelectorEngine.findOne(CLEAR_BUTTON_SELECTOR, this.container);\r\n  }\r\n\r\n  get datesContainer() {\r\n    return SelectorEngine.findOne(VIEW_SELECTOR, this.container);\r\n  }\r\n\r\n  get toggleButton() {\r\n    return SelectorEngine.findOne(TOGGLE_BUTTON_SELECTOR, this._element);\r\n  }\r\n\r\n  update(options = {}) {\r\n    this._options = this._getConfig({ ...this._options, ...options });\r\n  }\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    if (config.max && typeof config.max === \"string\") {\r\n      config.max = new Date(config.max);\r\n    }\r\n\r\n    if (config.min && typeof config.min === \"string\") {\r\n      config.min = new Date(config.min);\r\n    }\r\n\r\n    if (config.startDay && config.startDay !== 0) {\r\n      const sortedWeekdaysNarrow = this._getNewDaysOrderArray(config);\r\n      config.weekdaysNarrow = sortedWeekdaysNarrow;\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getContainer() {\r\n    return SelectorEngine.findOne(this._options.container);\r\n  }\r\n\r\n  _getNewDaysOrderArray(config) {\r\n    const index = config.startDay;\r\n\r\n    const weekdaysNarrow = config.weekdaysNarrow;\r\n    const sortedWeekdays = weekdaysNarrow\r\n      .slice(index)\r\n      .concat(weekdaysNarrow.slice(0, index));\r\n\r\n    return sortedWeekdays;\r\n  }\r\n\r\n  _init() {\r\n    if (!this.toggleButton && this._options.toggleButton) {\r\n      this._appendToggleButton();\r\n      if (this._input.readOnly || this._input.disabled) {\r\n        this.toggleButton.style.pointerEvents = \"none\";\r\n      }\r\n    }\r\n\r\n    this._listenToUserInput();\r\n    this._listenToToggleClick();\r\n    this._listenToToggleKeydown();\r\n  }\r\n\r\n  _appendToggleButton() {\r\n    const toggleButton = getToggleButtonTemplate(\r\n      this._toggleButtonId,\r\n      this._classes.datepickerToggleButton\r\n    );\r\n    this._element.insertAdjacentHTML(\"beforeend\", toggleButton);\r\n  }\r\n\r\n  open() {\r\n    if (this._input.readOnly || this._input.disabled) {\r\n      return;\r\n    }\r\n    const openEvent = EventHandler.trigger(this._element, EVENT_OPEN);\r\n\r\n    if (this._isOpen || openEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._setInitialDate();\r\n\r\n    const backdrop = getBackdropTemplate(this._classes.datepickerBackdrop);\r\n    const template = getDatepickerTemplate(\r\n      this._activeDate,\r\n      this._selectedDate,\r\n      this._selectedYear,\r\n      this._selectedMonth,\r\n      this._options,\r\n      MONTHS_IN_ROW,\r\n      YEARS_IN_VIEW,\r\n      YEARS_IN_ROW,\r\n      this._toggleButtonId,\r\n      this._classes\r\n    );\r\n\r\n    if (this._options.inline) {\r\n      this._openDropdown(template);\r\n    } else {\r\n      this._openModal(backdrop, template);\r\n      this._scrollBar.hide();\r\n    }\r\n\r\n    if (this._animations) {\r\n      Manipulator.addClass(this.container, this._classes.fadeIn);\r\n      Manipulator.addClass(backdrop, this._classes.fadeInShort);\r\n    }\r\n\r\n    this._setFocusTrap(this.container);\r\n\r\n    this._listenToDateSelection();\r\n    this._addControlsListeners();\r\n    this._updateControlsDisabledState();\r\n    this._listenToEscapeClick();\r\n    this._listenToKeyboardNavigation();\r\n    this._listenToDatesContainerFocus();\r\n    this._listenToDatesContainerBlur();\r\n\r\n    // We need to wait for popper initialization to avoid bug with\r\n    // focusing dates container, otherwise dates container will be\r\n    // focused before popper position update which can change the\r\n    // scroll position on the page\r\n    this._asyncFocusDatesContainer();\r\n    this._updateViewControlsAndAttributes(this._view);\r\n    this._isOpen = true;\r\n\r\n    // Wait for the component to open to prevent immediate calling of the\r\n    // close method upon detecting a click on toggle element (input/button)\r\n    setTimeout(() => {\r\n      this._listenToOutsideClick();\r\n    }, 0);\r\n  }\r\n\r\n  _openDropdown(template) {\r\n    this._popper = createPopper(this._input, template, {\r\n      placement: \"bottom-start\",\r\n    });\r\n    const container = this._getContainer();\r\n    container.appendChild(template);\r\n  }\r\n\r\n  _openModal(backdrop, template) {\r\n    const container = this._getContainer();\r\n    container.appendChild(backdrop);\r\n    container.appendChild(template);\r\n  }\r\n\r\n  _setFocusTrap(element) {\r\n    this._focusTrap = new FocusTrap(element, {\r\n      event: \"keydown\",\r\n      condition: (event) => event.key === \"Tab\",\r\n    });\r\n    this._focusTrap.trap();\r\n  }\r\n\r\n  _listenToUserInput() {\r\n    EventHandler.on(this._input, \"input\", (event) => {\r\n      this._handleUserInput(event.target.value);\r\n    });\r\n  }\r\n\r\n  _listenToToggleClick() {\r\n    EventHandler.on(\r\n      this._element,\r\n      EVENT_CLICK_DATA_API,\r\n      DATEPICKER_TOGGLE_SELECTOR,\r\n      (event) => {\r\n        event.preventDefault();\r\n        this.open();\r\n      }\r\n    );\r\n  }\r\n\r\n  _listenToToggleKeydown() {\r\n    EventHandler.on(\r\n      this._element,\r\n      \"keydown\",\r\n      DATEPICKER_TOGGLE_SELECTOR,\r\n      (event) => {\r\n        if (event.keyCode === ENTER && !this._isOpen) {\r\n          this.open();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  _listenToDateSelection() {\r\n    EventHandler.on(this.datesContainer, \"click\", (e) => {\r\n      this._handleDateSelection(e);\r\n    });\r\n  }\r\n\r\n  _handleDateSelection(e) {\r\n    const dataset =\r\n      e.target.nodeName === \"DIV\"\r\n        ? e.target.parentNode.dataset\r\n        : e.target.dataset;\r\n    const cell = e.target.nodeName === \"DIV\" ? e.target.parentNode : e.target;\r\n\r\n    if (dataset.teDate) {\r\n      this._pickDay(dataset.teDate, cell);\r\n    }\r\n\r\n    if (dataset.teMonth && dataset.teYear) {\r\n      const month = parseInt(dataset.teMonth, 10);\r\n      const year = parseInt(dataset.teYear, 10);\r\n      this._pickMonth(month, year);\r\n    }\r\n\r\n    if (dataset.teYear && !dataset.teMonth) {\r\n      const year = parseInt(dataset.teYear, 10);\r\n      this._pickYear(year);\r\n    }\r\n\r\n    if (!this._options.inline) {\r\n      this._updateHeaderDate(\r\n        this._activeDate,\r\n        this._options.monthsShort,\r\n        this._options.weekdaysShort\r\n      );\r\n    }\r\n  }\r\n\r\n  _updateHeaderDate(date, monthNames, dayNames) {\r\n    const headerDateEl = SelectorEngine.findOne(\r\n      DATE_TEXT_SELECTOR,\r\n      this.container\r\n    );\r\n    const month = getMonth(date);\r\n    const day = getDate(date);\r\n    const dayNumber = getDayNumber(date);\r\n    headerDateEl.innerHTML = `${dayNames[dayNumber]}, ${monthNames[month]} ${day}`;\r\n  }\r\n\r\n  _addControlsListeners() {\r\n    EventHandler.on(this.nextButton, \"click\", () => {\r\n      if (this._view === \"days\") {\r\n        this.nextMonth();\r\n      } else if (this._view === \"years\") {\r\n        this.nextYears();\r\n      } else {\r\n        this.nextYear();\r\n      }\r\n      this._updateControlsDisabledState();\r\n    });\r\n\r\n    EventHandler.on(this.previousButton, \"click\", () => {\r\n      if (this._view === \"days\") {\r\n        this.previousMonth();\r\n      } else if (this._view === \"years\") {\r\n        this.previousYears();\r\n      } else {\r\n        this.previousYear();\r\n      }\r\n      this._updateControlsDisabledState();\r\n    });\r\n\r\n    EventHandler.on(this.viewChangeButton, \"click\", () => {\r\n      if (this._view === \"days\") {\r\n        this._changeView(\"years\");\r\n      } else if (this._view === \"years\" || this._view === \"months\") {\r\n        this._changeView(\"days\");\r\n      }\r\n    });\r\n\r\n    if (!this._options.inline) {\r\n      this._listenToFooterButtonsClick();\r\n    }\r\n  }\r\n\r\n  _listenToFooterButtonsClick() {\r\n    EventHandler.on(this.okButton, \"click\", () => this.handleOk());\r\n    EventHandler.on(this.cancelButton, \"click\", () => this.handleCancel());\r\n    EventHandler.on(this.clearButton, \"click\", () => this.handleClear());\r\n  }\r\n\r\n  _listenToOutsideClick() {\r\n    EventHandler.on(document, EVENT_CLICK_DATA_API, (e) => {\r\n      const isContainer = e.target === this.container;\r\n      const isContainerContent =\r\n        this.container && this.container.contains(e.target);\r\n\r\n      if (!isContainer && !isContainerContent) {\r\n        this.close();\r\n      }\r\n    });\r\n  }\r\n\r\n  _listenToEscapeClick() {\r\n    EventHandler.on(document, \"keydown\", (event) => {\r\n      if (event.keyCode === ESCAPE && this._isOpen) {\r\n        this.close();\r\n      }\r\n    });\r\n  }\r\n\r\n  _listenToKeyboardNavigation() {\r\n    EventHandler.on(this.datesContainer, \"keydown\", (event) => {\r\n      this._handleKeydown(event);\r\n    });\r\n  }\r\n\r\n  _listenToDatesContainerFocus() {\r\n    EventHandler.on(this.datesContainer, \"focus\", () => {\r\n      this._focusActiveCell(this.activeCell);\r\n    });\r\n  }\r\n\r\n  _listenToDatesContainerBlur() {\r\n    EventHandler.on(this.datesContainer, \"blur\", () => {\r\n      this._removeCurrentFocusStyles();\r\n    });\r\n  }\r\n\r\n  _handleKeydown(event) {\r\n    if (this._view === \"days\") {\r\n      this._handleDaysViewKeydown(event);\r\n    }\r\n\r\n    if (this._view === \"months\") {\r\n      this._handleMonthsViewKeydown(event);\r\n    }\r\n\r\n    if (this._view === \"years\") {\r\n      this._handleYearsViewKeydown(event);\r\n    }\r\n  }\r\n\r\n  _handleDaysViewKeydown(event) {\r\n    const oldActiveDate = this._activeDate;\r\n    const previousActiveCell = this.activeCell;\r\n\r\n    switch (event.keyCode) {\r\n      case LEFT_ARROW:\r\n        this._activeDate = addDays(this._activeDate, isRTL() ? 1 : -1);\r\n        break;\r\n      case RIGHT_ARROW:\r\n        this._activeDate = addDays(this._activeDate, isRTL() ? -1 : 1);\r\n        break;\r\n      case UP_ARROW:\r\n        this._activeDate = addDays(this._activeDate, -7);\r\n        break;\r\n      case DOWN_ARROW:\r\n        this._activeDate = addDays(this._activeDate, 7);\r\n        break;\r\n      case HOME:\r\n        this._activeDate = addDays(\r\n          this._activeDate,\r\n          1 - getDate(this._activeDate)\r\n        );\r\n        break;\r\n      case END:\r\n        this._activeDate = addDays(\r\n          this._activeDate,\r\n          getDaysInMonth(this._activeDate) - getDate(this._activeDate)\r\n        );\r\n        break;\r\n      case PAGE_UP:\r\n        this._activeDate = addMonths(this._activeDate, -1);\r\n        break;\r\n      case PAGE_DOWN:\r\n        this._activeDate = addMonths(this._activeDate, 1);\r\n        break;\r\n      case ENTER:\r\n      case SPACE:\r\n        this._selectDate(this._activeDate);\r\n        this._handleDateSelection(event);\r\n        event.preventDefault();\r\n        return;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    if (\r\n      !areDatesInSameView(\r\n        oldActiveDate,\r\n        this._activeDate,\r\n        this._view,\r\n        YEARS_IN_VIEW,\r\n        this._options.min,\r\n        this._options.max\r\n      )\r\n    ) {\r\n      this._changeView(\"days\");\r\n    }\r\n\r\n    this._removeHighlightFromCell(previousActiveCell);\r\n    this._focusActiveCell(this.activeCell);\r\n    event.preventDefault();\r\n  }\r\n\r\n  _asyncFocusDatesContainer() {\r\n    setTimeout(() => {\r\n      this.datesContainer.focus();\r\n    }, 0);\r\n  }\r\n\r\n  _focusActiveCell(cell) {\r\n    if (cell) {\r\n      cell.setAttribute(\"data-te-datepicker-cell-focused\", \"\");\r\n    }\r\n  }\r\n\r\n  _removeHighlightFromCell(cell) {\r\n    if (cell) {\r\n      cell.removeAttribute(\"data-te-datepicker-cell-focused\");\r\n    }\r\n  }\r\n\r\n  _getActiveDayCell() {\r\n    const cells = SelectorEngine.find(\"td\", this.datesContainer);\r\n\r\n    const activeCell = Array.from(cells).find((cell) => {\r\n      const cellDate = convertStringToDate(cell.dataset.teDate);\r\n      return isSameDate(cellDate, this._activeDate);\r\n    });\r\n\r\n    return activeCell;\r\n  }\r\n\r\n  _handleMonthsViewKeydown(event) {\r\n    const oldActiveDate = this._activeDate;\r\n    const previousActiveCell = this.activeCell;\r\n\r\n    switch (event.keyCode) {\r\n      case LEFT_ARROW:\r\n        this._activeDate = addMonths(this._activeDate, isRTL() ? 1 : -1);\r\n        break;\r\n      case RIGHT_ARROW:\r\n        this._activeDate = addMonths(this._activeDate, isRTL() ? -1 : 1);\r\n        break;\r\n      case UP_ARROW:\r\n        this._activeDate = addMonths(this._activeDate, -4);\r\n        break;\r\n      case DOWN_ARROW:\r\n        this._activeDate = addMonths(this._activeDate, 4);\r\n        break;\r\n      case HOME:\r\n        this._activeDate = addMonths(this._activeDate, -this.activeMonth);\r\n        break;\r\n      case END:\r\n        this._activeDate = addMonths(this._activeDate, 11 - this.activeMonth);\r\n        break;\r\n      case PAGE_UP:\r\n        this._activeDate = addYears(this._activeDate, -1);\r\n        break;\r\n      case PAGE_DOWN:\r\n        this._activeDate = addYears(this._activeDate, 1);\r\n        break;\r\n      case ENTER:\r\n      case SPACE:\r\n        this._selectMonth(this.activeMonth);\r\n        return;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    if (\r\n      !areDatesInSameView(\r\n        oldActiveDate,\r\n        this._activeDate,\r\n        this._view,\r\n        YEARS_IN_VIEW,\r\n        this._options.min,\r\n        this._options.max\r\n      )\r\n    ) {\r\n      this._changeView(\"months\");\r\n    }\r\n\r\n    this._removeHighlightFromCell(previousActiveCell);\r\n    this._focusActiveCell(this.activeCell);\r\n    event.preventDefault();\r\n  }\r\n\r\n  _getActiveMonthCell() {\r\n    const cells = SelectorEngine.find(\"td\", this.datesContainer);\r\n\r\n    const activeCell = Array.from(cells).find((cell) => {\r\n      const cellYear = parseInt(cell.dataset.teYear, 10);\r\n      const cellMonth = parseInt(cell.dataset.teMonth, 10);\r\n      return cellYear === this.activeYear && cellMonth === this.activeMonth;\r\n    });\r\n\r\n    return activeCell;\r\n  }\r\n\r\n  _handleYearsViewKeydown(event) {\r\n    const oldActiveDate = this._activeDate;\r\n    const previousActiveCell = this.activeCell;\r\n    const yearsPerRow = 4;\r\n    const yearsPerPage = 24;\r\n\r\n    switch (event.keyCode) {\r\n      case LEFT_ARROW:\r\n        this._activeDate = addYears(this._activeDate, isRTL() ? 1 : -1);\r\n        break;\r\n      case RIGHT_ARROW:\r\n        this._activeDate = addYears(this._activeDate, isRTL() ? -1 : 1);\r\n        break;\r\n      case UP_ARROW:\r\n        this._activeDate = addYears(this._activeDate, -yearsPerRow);\r\n        break;\r\n      case DOWN_ARROW:\r\n        this._activeDate = addYears(this._activeDate, yearsPerRow);\r\n        break;\r\n      case HOME:\r\n        this._activeDate = addYears(\r\n          this._activeDate,\r\n          -getYearsOffset(this._activeDate, yearsPerPage)\r\n        );\r\n        break;\r\n      case END:\r\n        this._activeDate = addYears(\r\n          this._activeDate,\r\n          yearsPerPage - getYearsOffset(this._activeDate, yearsPerPage) - 1\r\n        );\r\n        break;\r\n      case PAGE_UP:\r\n        this._activeDate = addYears(this._activeDate, -yearsPerPage);\r\n        break;\r\n      case PAGE_DOWN:\r\n        this._activeDate = addYears(this._activeDate, yearsPerPage);\r\n        break;\r\n      case ENTER:\r\n      case SPACE:\r\n        this._selectYear(this.activeYear);\r\n        return;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    if (\r\n      !areDatesInSameView(\r\n        oldActiveDate,\r\n        this._activeDate,\r\n        this._view,\r\n        YEARS_IN_VIEW,\r\n        this._options.min,\r\n        this._options.max\r\n      )\r\n    ) {\r\n      this._changeView(\"years\");\r\n    }\r\n\r\n    this._removeHighlightFromCell(previousActiveCell);\r\n    this._focusActiveCell(this.activeCell);\r\n    event.preventDefault();\r\n  }\r\n\r\n  _getActiveYearCell() {\r\n    const cells = SelectorEngine.find(\"td\", this.datesContainer);\r\n\r\n    const activeCell = Array.from(cells).find((cell) => {\r\n      const cellYear = parseInt(cell.dataset.teYear, 10);\r\n      return cellYear === this.activeYear;\r\n    });\r\n\r\n    return activeCell;\r\n  }\r\n\r\n  _setInitialDate() {\r\n    if (this._input.value) {\r\n      this._handleUserInput(this._input.value);\r\n    } else if (this._options.startDate) {\r\n      this._activeDate = new Date(this._options.startDate);\r\n    } else {\r\n      this._activeDate = new Date();\r\n    }\r\n  }\r\n\r\n  close() {\r\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\r\n\r\n    if (!this._isOpen || closeEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._removeDatepickerListeners();\r\n\r\n    if (this._animations) {\r\n      Manipulator.addClass(this.container, this._classes.fadeOut);\r\n    }\r\n\r\n    if (this._options.inline) {\r\n      this._closeDropdown();\r\n    } else {\r\n      this._closeModal();\r\n    }\r\n\r\n    this._isOpen = false;\r\n    this._view = this._options.view;\r\n\r\n    if (this.toggleButton) {\r\n      this.toggleButton.focus();\r\n    } else {\r\n      this._input.focus();\r\n    }\r\n  }\r\n\r\n  _closeDropdown() {\r\n    const datepicker = SelectorEngine.findOne(DROPDOWN_CONTAINER_SELECTOR);\r\n    if (window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches) {\r\n      if (datepicker) {\r\n        document.body.removeChild(datepicker);\r\n      }\r\n\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n    }\r\n    datepicker.addEventListener(\"animationend\", () => {\r\n      if (datepicker) {\r\n        document.body.removeChild(datepicker);\r\n      }\r\n\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n    });\r\n    this._removeFocusTrap();\r\n  }\r\n\r\n  _closeModal() {\r\n    const backdrop = SelectorEngine.findOne(BACKDROP_SELECTOR);\r\n    const datepicker = SelectorEngine.findOne(MODAL_CONTAINER_SELECTOR);\r\n\r\n    if (!datepicker || !backdrop) {\r\n      return;\r\n    }\r\n\r\n    if (this._animations) {\r\n      Manipulator.addClass(backdrop, this._classes.fadeOutShort);\r\n\r\n      backdrop.addEventListener(\"animationend\", () => {\r\n        this._removePicker(backdrop, datepicker);\r\n        this._scrollBar.reset();\r\n      });\r\n    } else {\r\n      this._removePicker(backdrop, datepicker);\r\n      this._scrollBar.reset();\r\n    }\r\n  }\r\n\r\n  _removePicker(backdrop, datepicker) {\r\n    const container = this._getContainer();\r\n\r\n    container.removeChild(backdrop);\r\n    container.removeChild(datepicker);\r\n  }\r\n\r\n  _removeFocusTrap() {\r\n    if (this._focusTrap) {\r\n      this._focusTrap.disable();\r\n      this._focusTrap = null;\r\n    }\r\n  }\r\n\r\n  _removeDatepickerListeners() {\r\n    EventHandler.off(this.nextButton, \"click\");\r\n    EventHandler.off(this.previousButton, \"click\");\r\n    EventHandler.off(this.viewChangeButton, \"click\");\r\n    EventHandler.off(this.okButton, \"click\");\r\n    EventHandler.off(this.cancelButton, \"click\");\r\n    EventHandler.off(this.clearButton, \"click\");\r\n\r\n    EventHandler.off(this.datesContainer, \"click\");\r\n    EventHandler.off(this.datesContainer, \"keydown\");\r\n    EventHandler.off(this.datesContainer, \"focus\");\r\n    EventHandler.off(this.datesContainer, \"blur\");\r\n\r\n    EventHandler.off(document, EVENT_CLICK_DATA_API);\r\n  }\r\n\r\n  dispose() {\r\n    if (this._isOpen) {\r\n      this.close();\r\n    }\r\n\r\n    this._removeInputAndToggleListeners();\r\n\r\n    const generatedToggleButton = SelectorEngine.findOne(\r\n      `#${this._toggleButtonId}`\r\n    );\r\n\r\n    if (generatedToggleButton) {\r\n      this._element.removeChild(generatedToggleButton);\r\n    }\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n\r\n    this._element = null;\r\n    this._input = null;\r\n    this._options = null;\r\n    this._activeDate = null;\r\n    this._selectedDate = null;\r\n    this._selectedYear = null;\r\n    this._selectedMonth = null;\r\n    this._headerDate = null;\r\n    this._headerYear = null;\r\n    this._headerMonth = null;\r\n    this._view = null;\r\n    this._popper = null;\r\n    this._focusTrap = null;\r\n  }\r\n\r\n  _removeInputAndToggleListeners() {\r\n    EventHandler.off(this._input, \"input\");\r\n    EventHandler.off(\r\n      this._element,\r\n      EVENT_CLICK_DATA_API,\r\n      DATEPICKER_TOGGLE_SELECTOR\r\n    );\r\n    EventHandler.off(this._element, \"keydown\", DATEPICKER_TOGGLE_SELECTOR);\r\n  }\r\n\r\n  handleOk() {\r\n    this._confirmSelection(this._headerDate);\r\n    this.close();\r\n  }\r\n\r\n  _selectDate(date, cell = this.activeCell) {\r\n    const { min, max, filter, disablePast, disableFuture } = this._options;\r\n\r\n    if (isDateDisabled(date, min, max, filter, disablePast, disableFuture)) {\r\n      return;\r\n    }\r\n\r\n    this._removeCurrentSelectionStyles();\r\n    this._removeCurrentFocusStyles();\r\n    this._addSelectedStyles(cell);\r\n    this._selectedDate = date;\r\n    this._selectedYear = getYear(date);\r\n    this._selectedMonth = getMonth(date);\r\n    this._headerDate = date;\r\n\r\n    if (this._options.inline || this.options.confirmDateOnSelect) {\r\n      this._confirmSelection(date);\r\n      this.close();\r\n    }\r\n  }\r\n\r\n  _selectYear(year, cell = this.activeCell) {\r\n    this._removeCurrentSelectionStyles();\r\n    this._removeCurrentFocusStyles();\r\n    this._addSelectedStyles(cell);\r\n    this._headerYear = year;\r\n\r\n    this._asyncChangeView(\"months\");\r\n  }\r\n\r\n  _selectMonth(month, cell = this.activeCell) {\r\n    this._removeCurrentSelectionStyles();\r\n    this._removeCurrentFocusStyles();\r\n    this._addSelectedStyles(cell);\r\n    this._headerMonth = month;\r\n\r\n    this._asyncChangeView(\"days\");\r\n  }\r\n\r\n  _removeSelectedStyles(cell) {\r\n    if (cell) {\r\n      cell.removeAttribute(\"data-te-datepicker-cell-selected\");\r\n    }\r\n  }\r\n\r\n  _addSelectedStyles(cell) {\r\n    if (cell) {\r\n      cell.setAttribute(\"data-te-datepicker-cell-selected\", \"\");\r\n    }\r\n  }\r\n\r\n  _confirmSelection(date) {\r\n    if (date) {\r\n      const dateString = this.formatDate(date);\r\n      this._input.value = dateString;\r\n      EventHandler.trigger(this._element, EVENT_DATE_CHANGE, { date });\r\n      EventHandler.trigger(this._input, \"input\");\r\n    }\r\n  }\r\n\r\n  handleCancel() {\r\n    this._selectedDate = null;\r\n    this._selectedYear = null;\r\n    this._selectedMonth = null;\r\n    this.close();\r\n  }\r\n\r\n  handleClear() {\r\n    this._selectedDate = null;\r\n    this._selectedMonth = null;\r\n    this._selectedYear = null;\r\n    this._headerDate = null;\r\n    this._headerMonth = null;\r\n    this._headerYear = null;\r\n    this._removeCurrentSelectionStyles();\r\n    this._input.value = \"\";\r\n    this._setInitialDate();\r\n    this._changeView(\"days\");\r\n    this._updateHeaderDate(\r\n      this._activeDate,\r\n      this._options.monthsShort,\r\n      this._options.weekdaysShort\r\n    );\r\n  }\r\n\r\n  _removeCurrentSelectionStyles() {\r\n    const currentSelected = SelectorEngine.findOne(\r\n      \"[data-te-datepicker-cell-selected]\",\r\n      this.container\r\n    );\r\n\r\n    if (currentSelected) {\r\n      currentSelected.removeAttribute(\"data-te-datepicker-cell-selected\");\r\n    }\r\n  }\r\n\r\n  _removeCurrentFocusStyles() {\r\n    const currentFocused = SelectorEngine.findOne(\r\n      \"[data-te-datepicker-cell-focused]\",\r\n      this.container\r\n    );\r\n\r\n    if (currentFocused) {\r\n      currentFocused.removeAttribute(\"data-te-datepicker-cell-focused\");\r\n    }\r\n  }\r\n\r\n  formatDate(date) {\r\n    const d = getDate(date);\r\n    const dd = this._addLeadingZero(getDate(date));\r\n    const ddd = this._options.weekdaysShort[getDayNumber(date)];\r\n    const dddd = this._options.weekdaysFull[getDayNumber(date)];\r\n    const m = getMonth(date) + 1;\r\n    const mm = this._addLeadingZero(getMonth(date) + 1);\r\n    const mmm = this._options.monthsShort[getMonth(date)];\r\n    const mmmm = this._options.monthsFull[getMonth(date)];\r\n    const yy =\r\n      getYear(date).toString().length === 2\r\n        ? getYear(date)\r\n        : getYear(date).toString().slice(2, 4);\r\n    const yyyy = getYear(date);\r\n\r\n    const preformatted = this._options.format.split(\r\n      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g\r\n    );\r\n    let formatted = \"\";\r\n    preformatted.forEach((datePart) => {\r\n      switch (datePart) {\r\n        case \"dddd\":\r\n          datePart = datePart.replace(datePart, dddd);\r\n          break;\r\n        case \"ddd\":\r\n          datePart = datePart.replace(datePart, ddd);\r\n          break;\r\n        case \"dd\":\r\n          datePart = datePart.replace(datePart, dd);\r\n          break;\r\n        case \"d\":\r\n          datePart = datePart.replace(datePart, d);\r\n          break;\r\n        case \"mmmm\":\r\n          datePart = datePart.replace(datePart, mmmm);\r\n          break;\r\n        case \"mmm\":\r\n          datePart = datePart.replace(datePart, mmm);\r\n          break;\r\n        case \"mm\":\r\n          datePart = datePart.replace(datePart, mm);\r\n          break;\r\n        case \"m\":\r\n          datePart = datePart.replace(datePart, m);\r\n          break;\r\n        case \"yyyy\":\r\n          datePart = datePart.replace(datePart, yyyy);\r\n          break;\r\n        case \"yy\":\r\n          datePart = datePart.replace(datePart, yy);\r\n          break;\r\n        default:\r\n      }\r\n      formatted += datePart;\r\n    });\r\n\r\n    return formatted;\r\n  }\r\n\r\n  _addLeadingZero(value) {\r\n    return parseInt(value, 10) < 10 ? `0${value}` : value;\r\n  }\r\n\r\n  _pickDay(day, el) {\r\n    const date = convertStringToDate(day);\r\n    const { min, max, filter, disablePast, disableFuture } = this._options;\r\n\r\n    if (isDateDisabled(date, min, max, filter, disablePast, disableFuture)) {\r\n      return;\r\n    }\r\n\r\n    this._activeDate = date;\r\n    this._selectDate(date, el);\r\n  }\r\n\r\n  _pickYear(year) {\r\n    const { min, max, disablePast, disableFuture } = this._options;\r\n\r\n    if (isYearDisabled(year, min, max, disablePast, disableFuture)) {\r\n      return;\r\n    }\r\n\r\n    const newDate = createDate(year, this.activeMonth, this.activeDay);\r\n\r\n    this._activeDate = newDate;\r\n    this._selectedDate = newDate;\r\n    this._selectYear(year);\r\n  }\r\n\r\n  _pickMonth(month, year) {\r\n    const { min, max, disablePast, disableFuture } = this._options;\r\n\r\n    if (\r\n      isMonthDisabled(month, year, min, max, disablePast, disableFuture) ||\r\n      isYearDisabled(year, min, max, disablePast, disableFuture)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const newDate = createDate(year, month, this.activeDay);\r\n\r\n    this._activeDate = newDate;\r\n    this._selectMonth(month);\r\n  }\r\n\r\n  nextMonth() {\r\n    const nextMonth = addMonths(this._activeDate, 1);\r\n    const template = createDayViewTemplate(\r\n      nextMonth,\r\n      this._headerDate,\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this._activeDate = nextMonth;\r\n    this.viewChangeButton.textContent = `${\r\n      this._options.monthsFull[this.activeMonth]\r\n    } ${this.activeYear}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  previousMonth() {\r\n    const previousMonth = addMonths(this._activeDate, -1);\r\n    this._activeDate = previousMonth;\r\n    const template = createDayViewTemplate(\r\n      previousMonth,\r\n      this._headerDate,\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this.viewChangeButton.textContent = `${\r\n      this._options.monthsFull[this.activeMonth]\r\n    } ${this.activeYear}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  nextYear() {\r\n    const nextYear = addYears(this._activeDate, 1);\r\n    this._activeDate = nextYear;\r\n    this.viewChangeButton.textContent = `${this.activeYear}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    const template = createMonthViewTemplate(\r\n      this.activeYear,\r\n      this._selectedYear,\r\n      this._selectedMonth,\r\n      this._options,\r\n      MONTHS_IN_ROW,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  previousYear() {\r\n    const previousYear = addYears(this._activeDate, -1);\r\n    this._activeDate = previousYear;\r\n    this.viewChangeButton.textContent = `${this.activeYear}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    const template = createMonthViewTemplate(\r\n      this.activeYear,\r\n      this._selectedYear,\r\n      this._selectedMonth,\r\n      this._options,\r\n      MONTHS_IN_ROW,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  nextYears() {\r\n    const nextYear = addYears(this._activeDate, 24);\r\n    this._activeDate = nextYear;\r\n    const template = createYearViewTemplate(\r\n      nextYear,\r\n      this._selectedYear,\r\n      this._options,\r\n      YEARS_IN_VIEW,\r\n      YEARS_IN_ROW,\r\n      this._classes\r\n    );\r\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  previousYears() {\r\n    const previousYear = addYears(this._activeDate, -24);\r\n    this._activeDate = previousYear;\r\n    const template = createYearViewTemplate(\r\n      previousYear,\r\n      this._selectedYear,\r\n      this._options,\r\n      YEARS_IN_VIEW,\r\n      YEARS_IN_ROW,\r\n      this._classes\r\n    );\r\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;\r\n    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n      this._options,\r\n      this._classes\r\n    );\r\n    this.datesContainer.innerHTML = template;\r\n  }\r\n\r\n  _asyncChangeView(view) {\r\n    setTimeout(() => {\r\n      this._changeView(view);\r\n    }, 0);\r\n  }\r\n\r\n  _changeView(view) {\r\n    this._view = view;\r\n    // We need to add blur event here to reapply focus to\r\n    // dates container when switching from years to months\r\n    // view after selecting year\r\n    this.datesContainer.blur();\r\n\r\n    if (view === \"days\") {\r\n      this.datesContainer.innerHTML = createDayViewTemplate(\r\n        this._activeDate,\r\n        this._headerDate,\r\n        this._options,\r\n        this._classes\r\n      );\r\n    }\r\n\r\n    if (view === \"months\") {\r\n      this.datesContainer.innerHTML = createMonthViewTemplate(\r\n        this.activeYear,\r\n        this._selectedYear,\r\n        this._selectedMonth,\r\n        this._options,\r\n        MONTHS_IN_ROW,\r\n        this._classes\r\n      );\r\n    }\r\n\r\n    if (view === \"years\") {\r\n      this.datesContainer.innerHTML = createYearViewTemplate(\r\n        this._activeDate,\r\n        this._selectedYear,\r\n        this._options,\r\n        YEARS_IN_VIEW,\r\n        YEARS_IN_ROW,\r\n        this._classes\r\n      );\r\n    }\r\n\r\n    this.datesContainer.focus();\r\n    this._updateViewControlsAndAttributes(view);\r\n    this._updateControlsDisabledState();\r\n  }\r\n\r\n  _updateViewControlsAndAttributes(view) {\r\n    if (view === \"days\") {\r\n      this.viewChangeButton.textContent = `${\r\n        this._options.monthsFull[this.activeMonth]\r\n      } ${this.activeYear}`;\r\n      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n        this._options,\r\n        this._classes\r\n      );\r\n      this.viewChangeButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.switchToMultiYearViewLabel\r\n      );\r\n      this.previousButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.prevMonthLabel\r\n      );\r\n      this.nextButton.setAttribute(\"aria-label\", this._options.nextMonthLabel);\r\n    }\r\n\r\n    if (view === \"months\") {\r\n      this.viewChangeButton.textContent = `${this.activeYear}`;\r\n      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n        this._options,\r\n        this._classes\r\n      );\r\n      this.viewChangeButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.switchToDayViewLabel\r\n      );\r\n      this.previousButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.prevYearLabel\r\n      );\r\n      this.nextButton.setAttribute(\"aria-label\", this._options.nextYearLabel);\r\n    }\r\n\r\n    if (view === \"years\") {\r\n      this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;\r\n      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(\r\n        this._options,\r\n        this._classes\r\n      );\r\n      this.viewChangeButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.switchToMonthViewLabel\r\n      );\r\n      this.previousButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.prevMultiYearLabel\r\n      );\r\n      this.nextButton.setAttribute(\r\n        \"aria-label\",\r\n        this._options.nextMultiYearLabel\r\n      );\r\n    }\r\n  }\r\n\r\n  _updateControlsDisabledState() {\r\n    if (\r\n      isNextDateDisabled(\r\n        this._options.disableFuture,\r\n        this._activeDate,\r\n        this._view,\r\n        YEARS_IN_VIEW,\r\n        this._options.min,\r\n        this._options.max,\r\n        this.lastYearInView,\r\n        this.firstYearInView\r\n      )\r\n    ) {\r\n      this.nextButton.disabled = true;\r\n    } else {\r\n      this.nextButton.disabled = false;\r\n    }\r\n\r\n    if (\r\n      isPreviousDateDisabled(\r\n        this._options.disablePast,\r\n        this._activeDate,\r\n        this._view,\r\n        YEARS_IN_VIEW,\r\n        this._options.min,\r\n        this._options.max,\r\n        this.lastYearInView,\r\n        this.firstYearInView\r\n      )\r\n    ) {\r\n      this.previousButton.disabled = true;\r\n    } else {\r\n      this.previousButton.disabled = false;\r\n    }\r\n  }\r\n\r\n  _handleUserInput(input) {\r\n    const delimeters = this._getDelimeters(this._options.format);\r\n    const date = this._parseDate(input, this._options.format, delimeters);\r\n\r\n    if (isValidDate(date)) {\r\n      this._activeDate = date;\r\n      this._selectedDate = date;\r\n      this._selectedYear = getYear(date);\r\n      this._selectedMonth = getMonth(date);\r\n      this._headerDate = date;\r\n    } else {\r\n      this._activeDate = new Date();\r\n      this._selectedDate = null;\r\n      this._selectedMonth = null;\r\n      this._selectedYear = null;\r\n      this._headerDate = null;\r\n      this._headerMonth = null;\r\n      this._headerYear = null;\r\n    }\r\n  }\r\n\r\n  _getDelimeters(format) {\r\n    return format.match(/[^(dmy)]{1,}/g);\r\n  }\r\n\r\n  _parseDate(dateString, format, delimeters) {\r\n    let delimeterPattern;\r\n\r\n    if (delimeters[0] !== delimeters[1]) {\r\n      delimeterPattern = delimeters[0] + delimeters[1];\r\n    } else {\r\n      delimeterPattern = delimeters[0];\r\n    }\r\n\r\n    const regExp = new RegExp(`[${delimeterPattern}]`);\r\n    const dateParts = dateString.split(regExp);\r\n    const formatParts = format.split(regExp);\r\n    const isMonthString = format.indexOf(\"mmm\") !== -1;\r\n\r\n    const datesArray = [];\r\n\r\n    for (let i = 0; i < formatParts.length; i++) {\r\n      if (formatParts[i].indexOf(\"yy\") !== -1) {\r\n        datesArray[0] = { value: dateParts[i], format: formatParts[i] };\r\n      }\r\n      if (formatParts[i].indexOf(\"m\") !== -1) {\r\n        datesArray[1] = { value: dateParts[i], format: formatParts[i] };\r\n      }\r\n      if (formatParts[i].indexOf(\"d\") !== -1 && formatParts[i].length <= 2) {\r\n        datesArray[2] = { value: dateParts[i], format: formatParts[i] };\r\n      }\r\n    }\r\n\r\n    let monthsNames;\r\n\r\n    if (format.indexOf(\"mmmm\") !== -1) {\r\n      monthsNames = this._options.monthsFull;\r\n    } else {\r\n      monthsNames = this._options.monthsShort;\r\n    }\r\n\r\n    const year = Number(datesArray[0].value);\r\n    const month = isMonthString\r\n      ? this.getMonthNumberByMonthName(datesArray[1].value, monthsNames)\r\n      : Number(datesArray[1].value) - 1;\r\n    const day = Number(datesArray[2].value);\r\n\r\n    const parsedDate = createDate(year, month, day);\r\n    return parsedDate;\r\n  }\r\n\r\n  getMonthNumberByMonthName(monthValue, monthLabels) {\r\n    return monthLabels.findIndex((monthLabel) => monthLabel === monthValue);\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Datepicker;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nexport const getTimepickerTemplate = (\r\n  {\r\n    format24,\r\n    okLabel,\r\n    cancelLabel,\r\n    headID,\r\n    footerID,\r\n    bodyID,\r\n    pickerID,\r\n    clearLabel,\r\n    inline,\r\n    showClearBtn,\r\n    amLabel,\r\n    pmLabel,\r\n  },\r\n  classes\r\n) => {\r\n  const normalTemplate = `<div id='${pickerID}' class='${\r\n    classes.timepickerWrapper\r\n  }' data-te-timepicker-wrapper>\r\n      <div class=\"${classes.timepickerContainer}\">\r\n        <div class=\"${classes.timepickerElements}\">\r\n        <div id='${headID}' class='${\r\n    classes.timepickerHead\r\n  }' style='padding-right:${format24 ? 50 : 10}px'>\r\n        <div class='${classes.timepickerHeadContent}'>\r\n            <div class=\"${classes.timepickerCurrentWrapper}\">\r\n              <span class=\"${classes.timepickerCurrentButtonWrapper}\">\r\n                <button type='button' class='${\r\n                  classes.timepickerCurrentButton\r\n                }' tabindex=\"0\" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>\r\n              </span>\r\n              <button type='button' class='${\r\n                classes.timepickerDot\r\n              }' disabled>:</button>\r\n            <span class=\"${classes.timepickerCurrentButtonWrapper}\">\r\n              <button type='button' class='${\r\n                classes.timepickerCurrentButton\r\n              }' tabindex=\"0\" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>\r\n            </span>\r\n            </div>\r\n            ${\r\n              !format24\r\n                ? `<div class=\"${classes.timepickerModeWrapper}\">\r\n                  <button type='button' class=\"${classes.timepickerModeAm}\" tabindex=\"0\" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${amLabel}</button>\r\n                  <button class=\"${classes.timepickerModePm}\" tabindex=\"0\" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${pmLabel}</button>\r\n                </div>`\r\n                : \"\"\r\n            }\r\n        </div>\r\n      </div>\r\n      ${\r\n        !inline\r\n          ? `<div id='${bodyID}' class='${\r\n              classes.timepickerClockWrapper\r\n            }' data-te-timepicker-clock-wrapper>\r\n            <div class='${classes.timepickerClock}' data-te-timepicker-clock>\r\n              <span class='${\r\n                classes.timepickerMiddleDot\r\n              }' data-te-timepicker-middle-dot></span>\r\n              <div class='${\r\n                classes.timepickerHandPointer\r\n              }' data-te-timepicker-hand-pointer>\r\n                <div class='${\r\n                  classes.timepickerPointerCircle\r\n                }' data-te-timepicker-circle></div>\r\n              </div>\r\n              ${\r\n                format24\r\n                  ? '<div class=\"' +\r\n                    classes.timepickerClockInner +\r\n                    '\" data-te-timepicker-clock-inner></div>'\r\n                  : \"\"\r\n              }\r\n            </div>\r\n          </div>`\r\n          : \"\"\r\n      }\r\n    </div>\r\n    <div id='${footerID}' class='${classes.timepickerFooterWrapper}'>\r\n      <div class=\"${classes.timepickerFooter}\">\r\n        ${\r\n          showClearBtn\r\n            ? `<button type='button' class='${classes.timepickerFooterButton}' data-te-timepicker-clear tabindex=\"0\" data-te-ripple-init>${clearLabel}</button>`\r\n            : \"\"\r\n        }\r\n        <button type='button' class='${\r\n          classes.timepickerFooterButton\r\n        }' data-te-timepicker-cancel tabindex=\"0\" data-te-ripple-init>${cancelLabel}</button>\r\n        <button type='button' class='${\r\n          classes.timepickerFooterButton\r\n        }' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${okLabel}</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>`;\r\n\r\n  const inlineTemplate = `<div id='${pickerID}' class='${\r\n    classes.timepickerInlineWrapper\r\n  }' data-te-timepicker-wrapper>\r\n        <div class=\"${classes.timepickerInlineContainer}\">\r\n          <div class=\"${classes.timepickerInlineElements}\">\r\n          <div id='${headID}' class='${classes.timepickerInlineHead}'\r\n          style='padding-right:10px'>\r\n          <div class='${classes.timepickerInlineHeadContent}'>\r\n              <div class=\"${classes.timepickerCurrentWrapper}\">\r\n                <span class=\"${\r\n                  classes.timepickerInlineHourWrapper\r\n                }\" data-te-timepicker-inline-hour-icons>\r\n                  <span class=\"${\r\n                    classes.timepickerInlineIconUp\r\n                  }\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>\r\n                    <span class=\"${classes.timepickerInlineIconSvg}\">\r\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\r\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\r\n                      </svg>   \r\n                    </span>\r\n                  </span>\r\n                  <button type='button' class='${\r\n                    classes.timepickerInlineCurrentButton\r\n                  }' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\r\n                  <span class=\"${\r\n                    classes.timepickerInlineIconDown\r\n                  }\" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>\r\n                    <span class=\"${classes.timepickerInlineIconSvg}\">\r\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\r\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\r\n                      </svg>  \r\n                    </span>\r\n                  </span>\r\n                </span>\r\n                <button type='button' class='${\r\n                  classes.timepickerInlineDot\r\n                }' data-te-timepicker-current-inline disabled>:</button>\r\n              <span class=\"${classes.timepickerCurrentMinuteWrapper}\">\r\n                <span class=\"${\r\n                  classes.timepickerInlineIconUp\r\n                }\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>\r\n                  <span class=\"${classes.timepickerInlineIconSvg}\">\r\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\r\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\r\n                    </svg>\r\n                  </span>\r\n                </span>\r\n                <button type='button' class='${\r\n                  classes.timepickerInlineCurrentButton\r\n                }' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\r\n                <span class=\"${\r\n                  classes.timepickerInlineIconDown\r\n                }\" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>\r\n                  <span class=\"${classes.timepickerInlineIconSvg}\">\r\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\r\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\r\n                    </svg> \r\n                  </span>\r\n                </span>\r\n              </span>\r\n              </div>\r\n              ${\r\n                !format24\r\n                  ? `<div class=\"${classes.timepickerInlineModeWrapper}\">\r\n                      <button type='button' class=\"${classes.timepickerInlineModeAm}\" data-te-timepicker-am data-te-timepicker-hour-mode tabindex=\"0\" data-te-ripple-init>${amLabel}</button>\r\n                      <button class=\"${classes.timepickerInlineModePm}\" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex=\"0\" data-te-ripple-init>${pmLabel}</button>\r\n                      <button type='button' class='${classes.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${okLabel}</button>\r\n                    </div>`\r\n                  : \"\"\r\n              }\r\n              ${\r\n                format24\r\n                  ? `<button class='${classes.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${okLabel}</button>`\r\n                  : \"\"\r\n              }\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n</div>`;\r\n  return inline ? inlineTemplate : normalTemplate;\r\n};\r\n\r\nexport const getToggleButtonTemplate = (options, id, classes) => {\r\n  const { iconSVG } = options;\r\n\r\n  return `\r\n  <button id=\"${id}\" tabindex=\"0\" type=\"button\" class=\"${classes.timepickerToggleButton}\" data-te-toggle=\"timepicker\" data-te-timepicker-toggle-button data-te-timepicker-icon>\r\n    ${iconSVG}\r\n  </button>\r\n`;\r\n};\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\n/* eslint-disable consistent-return */\r\nimport EventHandler from \"../../dom/event-handler\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\n\r\nconst ATTR_TIMEPICKER_DISABLED = \"data-te-timepicker-disabled\";\r\nconst ATTR_TIMEPICKER_ACTIVE = \"data-te-timepicker-active\";\r\n\r\nconst formatToAmPm = (date) => {\r\n  if (date === \"\") return;\r\n  let hours;\r\n  let minutes;\r\n  let amOrPm;\r\n  let originalHours;\r\n\r\n  if (isValidDate(date)) {\r\n    hours = date.getHours();\r\n    originalHours = hours;\r\n    minutes = date.getMinutes();\r\n    hours %= 12;\r\n    if (originalHours === 0 && hours === 0) {\r\n      amOrPm = \"AM\";\r\n    }\r\n\r\n    hours = hours || 12;\r\n\r\n    if (amOrPm === undefined) {\r\n      amOrPm = Number(originalHours) >= 12 ? \"PM\" : \"AM\";\r\n    }\r\n\r\n    minutes = minutes < 10 ? `0${minutes}` : minutes;\r\n  } else {\r\n    [hours, minutes, amOrPm] = takeValue(date, false);\r\n    originalHours = hours;\r\n\r\n    hours %= 12;\r\n    if (originalHours === 0 && hours === 0) {\r\n      amOrPm = \"AM\";\r\n    }\r\n    hours = hours || 12;\r\n\r\n    if (amOrPm === undefined) {\r\n      amOrPm = Number(originalHours) >= 12 ? \"PM\" : \"AM\";\r\n    }\r\n  }\r\n\r\n  return {\r\n    hours,\r\n    minutes,\r\n    amOrPm,\r\n  };\r\n};\r\n\r\nconst isValidDate = (date) => {\r\n  return (\r\n    date &&\r\n    Object.prototype.toString.call(date) === \"[object Date]\" &&\r\n    !Number.isNaN(date)\r\n  );\r\n};\r\n\r\nconst formatNormalHours = (date) => {\r\n  if (date === \"\") return;\r\n\r\n  let hours;\r\n  let minutes;\r\n\r\n  if (!isValidDate(date)) {\r\n    [hours, minutes] = takeValue(date, false);\r\n  } else {\r\n    hours = date.getHours();\r\n    minutes = date.getMinutes();\r\n  }\r\n\r\n  minutes = Number(minutes) < 10 ? `0${Number(minutes)}` : minutes;\r\n\r\n  return {\r\n    hours,\r\n    minutes,\r\n  };\r\n};\r\n\r\nconst toggleClassHandler = (event, selector, classes) => {\r\n  return EventHandler.on(document, event, selector, ({ target }) => {\r\n    if (target.hasAttribute(ATTR_TIMEPICKER_ACTIVE)) return;\r\n\r\n    const allElements = document.querySelectorAll(selector);\r\n\r\n    allElements.forEach((element) => {\r\n      if (!element.hasAttribute(ATTR_TIMEPICKER_ACTIVE)) return;\r\n\r\n      Manipulator.removeClass(element, classes.opacity);\r\n      element.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n    });\r\n\r\n    Manipulator.addClass(target, classes.opacity);\r\n    target.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n  });\r\n};\r\n\r\nconst findMousePosition = (\r\n  { clientX, clientY, touches },\r\n  object,\r\n  isMobile = false\r\n) => {\r\n  const { left, top } = object.getBoundingClientRect();\r\n  let obj = {};\r\n  if (!isMobile || !touches) {\r\n    obj = {\r\n      x: clientX - left,\r\n      y: clientY - top,\r\n    };\r\n  } else if (isMobile && Object.keys(touches).length > 0) {\r\n    obj = {\r\n      x: touches[0].clientX - left,\r\n      y: touches[0].clientY - top,\r\n    };\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nconst checkBrowser = () => {\r\n  const isBrowserMatched =\r\n    (navigator.maxTouchPoints &&\r\n      navigator.maxTouchPoints > 2 &&\r\n      /MacIntel/.test(navigator.platform)) ||\r\n    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n      navigator.userAgent\r\n    );\r\n\r\n  return isBrowserMatched;\r\n};\r\n\r\nconst takeValue = (element, isInput = true) => {\r\n  if (isInput) return element.value.replace(/:/gi, \" \").split(\" \");\r\n\r\n  return element.replace(/:/gi, \" \").split(\" \");\r\n};\r\n\r\nconst compareTimes = (time1, time2) => {\r\n  const [time1Hour, time1Minutes, time1maxTimeFormat] = takeValue(time1, false);\r\n  const [time2Hour, time2Minutes, time2maxTimeFormat] = takeValue(time2, false);\r\n\r\n  const bothFormatsEqual = time1maxTimeFormat === time2maxTimeFormat;\r\n  const condition =\r\n    (time1maxTimeFormat === \"PM\" && time2maxTimeFormat === \"AM\") ||\r\n    (bothFormatsEqual && time1Hour > time2Hour) ||\r\n    time1Minutes > time2Minutes;\r\n\r\n  return condition;\r\n};\r\n\r\nconst getCurrentTime = () => {\r\n  const date = new Date();\r\n  const currentHours = date.getHours();\r\n  const currentMinutes = date.getMinutes();\r\n\r\n  const currentTime = `${currentHours}:${\r\n    currentMinutes < 10 ? `0${currentMinutes}` : currentMinutes\r\n  }`;\r\n\r\n  return currentTime;\r\n};\r\n\r\nconst setMinTime = (minTime, disabledPast, format12) => {\r\n  if (!disabledPast) {\r\n    return minTime;\r\n  }\r\n  let currentTime = getCurrentTime();\r\n\r\n  if (format12) {\r\n    currentTime = `${formatToAmPm(currentTime).hours}:${\r\n      formatToAmPm(currentTime).minutes\r\n    } ${formatToAmPm(currentTime).amOrPm}`;\r\n  }\r\n  if (\r\n    (minTime !== \"\" && compareTimes(currentTime, minTime)) ||\r\n    minTime === \"\"\r\n  ) {\r\n    minTime = currentTime;\r\n  }\r\n  return minTime;\r\n};\r\n\r\nconst setMaxTime = (maxTime, disabledFuture, format12) => {\r\n  if (!disabledFuture) return maxTime;\r\n\r\n  let currentTime = getCurrentTime();\r\n\r\n  if (format12) {\r\n    currentTime = `${formatToAmPm(currentTime).hours}:${\r\n      formatToAmPm(currentTime).minutes\r\n    } ${formatToAmPm(currentTime).amOrPm}`;\r\n  }\r\n\r\n  if (\r\n    (maxTime !== \"\" && !compareTimes(currentTime, maxTime)) ||\r\n    maxTime === \"\"\r\n  ) {\r\n    maxTime = currentTime;\r\n  }\r\n\r\n  return maxTime;\r\n};\r\n\r\nconst checkValueBeforeAccept = (\r\n  { format12, maxTime, minTime, disablePast, disableFuture },\r\n  input,\r\n  hourHeader\r\n) => {\r\n  const minute = takeValue(input)[1];\r\n\r\n  minTime = setMinTime(minTime, disablePast, format12);\r\n  maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n  const [maxTimeHour, maxTimeMin, maxTimeFormat] = takeValue(maxTime, false);\r\n  const [minTimeHour, minTimeMin, minTimeFormat] = takeValue(minTime, false);\r\n\r\n  if (maxTimeFormat !== undefined || minTimeFormat !== undefined)\r\n    return [hourHeader, minute];\r\n\r\n  if (\r\n    maxTimeHour !== \"\" &&\r\n    minTimeHour === \"\" &&\r\n    Number(hourHeader) > Number(maxTimeHour)\r\n  )\r\n    return;\r\n\r\n  if (\r\n    maxTimeHour === \"\" &&\r\n    minTimeHour !== \"\" &&\r\n    maxTimeMin === undefined &&\r\n    minTimeMin !== \"\" &&\r\n    Number(hourHeader) < Number(minTimeHour)\r\n  )\r\n    return;\r\n\r\n  return [hourHeader, minute];\r\n};\r\n\r\nconst _verifyMaxTimeHourAndAddDisabledClass = (\r\n  tips,\r\n  maxTimeHour,\r\n  classes,\r\n  format12\r\n) => {\r\n  tips.forEach((tip) => {\r\n    maxTimeHour = maxTimeHour === \"12\" && format12 ? \"0\" : maxTimeHour;\r\n    if (\r\n      tip.textContent === \"00\" ||\r\n      Number(tip.textContent === \"12\" && format12 ? \"0\" : tip.textContent) >\r\n        maxTimeHour\r\n    ) {\r\n      Manipulator.addClass(tip, classes.tipsDisabled);\r\n      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n    }\r\n  });\r\n};\r\n\r\nconst _verifyMinTimeHourAndAddDisabledClass = (\r\n  tips,\r\n  minTimeHour,\r\n  classes,\r\n  format12\r\n) => {\r\n  tips.forEach((tip) => {\r\n    minTimeHour = minTimeHour === \"12\" && format12 ? \"0\" : minTimeHour;\r\n    if (\r\n      tip.textContent !== \"00\" &&\r\n      Number(tip.textContent === \"12\" && format12 ? \"0\" : tip.textContent) <\r\n        Number(minTimeHour)\r\n    ) {\r\n      Manipulator.addClass(tip, classes.tipsDisabled);\r\n      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n    }\r\n  });\r\n};\r\n\r\nconst _isHourDisabled = (selectedHour, timeHour, format12, operator) => {\r\n  if (timeHour === \"12\" || timeHour === \"24\") {\r\n    return;\r\n  }\r\n\r\n  const hourChange = format12 ? 12 : 24;\r\n\r\n  if (operator === \"max\") {\r\n    return (\r\n      (Number(selectedHour) === hourChange ? 0 : Number(selectedHour)) >\r\n      Number(timeHour)\r\n    );\r\n  }\r\n  return (\r\n    (Number(selectedHour) === hourChange ? 0 : Number(selectedHour)) <\r\n    Number(timeHour)\r\n  );\r\n};\r\n\r\nconst _verifyMaxTimeMinutesTipsAndAddDisabledClass = (\r\n  tips,\r\n  maxMinutes,\r\n  maxHour,\r\n  currHour,\r\n  classes,\r\n  format12\r\n) => {\r\n  tips.forEach((tip) => {\r\n    if (\r\n      _isHourDisabled(currHour, maxHour, format12, \"max\") ||\r\n      (Number(tip.textContent) > maxMinutes &&\r\n        Number(currHour) === Number(maxHour))\r\n    ) {\r\n      Manipulator.addClass(tip, classes.tipsDisabled);\r\n      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n    }\r\n  });\r\n};\r\n\r\nconst _verifyMinTimeMinutesTipsAndAddDisabledClass = (\r\n  tips,\r\n  minMinutes,\r\n  minHour,\r\n  currHour,\r\n  classes,\r\n  format12\r\n) => {\r\n  tips.forEach((tip) => {\r\n    if (\r\n      _isHourDisabled(currHour, minHour, format12, \"min\") ||\r\n      (Number(tip.textContent) < minMinutes &&\r\n        Number(currHour) === Number(minHour))\r\n    ) {\r\n      Manipulator.addClass(tip, classes.tipsDisabled);\r\n      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n    }\r\n  });\r\n};\r\n\r\nconst _convertHourToNumber = (string) => {\r\n  if (string.startsWith(\"0\")) return Number(string.slice(1));\r\n\r\n  return Number(string);\r\n};\r\n\r\nexport {\r\n  checkBrowser,\r\n  findMousePosition,\r\n  formatNormalHours,\r\n  formatToAmPm,\r\n  toggleClassHandler,\r\n  checkValueBeforeAccept,\r\n  takeValue,\r\n  compareTimes,\r\n  setMinTime,\r\n  setMaxTime,\r\n  _verifyMinTimeHourAndAddDisabledClass,\r\n  _verifyMaxTimeMinutesTipsAndAddDisabledClass,\r\n  _verifyMinTimeMinutesTipsAndAddDisabledClass,\r\n  _verifyMaxTimeHourAndAddDisabledClass,\r\n  _convertHourToNumber,\r\n};\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\n/* eslint-disable consistent-return */\r\n/* eslint-disable no-else-return */\r\nimport { createPopper } from \"@popperjs/core\";\r\nimport { typeCheckConfig, element, getUID } from \"../../util/index\";\r\nimport { getTimepickerTemplate, getToggleButtonTemplate } from \"./templates\";\r\nimport Data from \"../../dom/data\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport EventHandler, { EventHandlerMulti } from \"../../dom/event-handler\";\r\nimport {\r\n  formatToAmPm,\r\n  toggleClassHandler,\r\n  checkBrowser,\r\n  findMousePosition,\r\n  takeValue,\r\n  formatNormalHours,\r\n  setMinTime,\r\n  setMaxTime,\r\n  _convertHourToNumber,\r\n  checkValueBeforeAccept,\r\n  _verifyMaxTimeHourAndAddDisabledClass,\r\n  _verifyMaxTimeMinutesTipsAndAddDisabledClass,\r\n  _verifyMinTimeHourAndAddDisabledClass,\r\n  _verifyMinTimeMinutesTipsAndAddDisabledClass,\r\n} from \"./utils\";\r\nimport ScrollBarHelper from \"../../util/scrollbar\";\r\nimport FocusTrap from \"../../util/focusTrap\";\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\nimport {\r\n  UP_ARROW,\r\n  DOWN_ARROW,\r\n  LEFT_ARROW,\r\n  RIGHT_ARROW,\r\n  ESCAPE,\r\n  ENTER,\r\n} from \"../../util/keycodes\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"timepicker\";\r\nconst ATTR_NAME = `data-te-${NAME}`;\r\nconst SELECTOR_DATA_TE_TOGGLE = \"[data-te-toggle]\";\r\n\r\nconst DATA_KEY = `te.${NAME}`;\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst DATA_API_KEY = \".data-api\";\r\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_MOUSEDOWN_DATA_API = `mousedown${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_MOUSEUP_DATA_API = `mouseup${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_MOUSEMOVE_DATA_API = `mousemove${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_MOUSELEAVE_DATA_API = `mouseleave${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_MOUSEOVER_DATA_API = `mouseover${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_TOUCHMOVE_DATA_API = `touchmove${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_TOUCHEND_DATA_API = `touchend${EVENT_KEY}${DATA_API_KEY}`;\r\nconst EVENT_TOUCHSTART_DATA_API = `touchstart${EVENT_KEY}${DATA_API_KEY}`;\r\n\r\nconst SELECTOR_ATTR_TIMEPICKER_AM = `[${ATTR_NAME}-am]`;\r\nconst SELECTOR_ATTR_TIMEPICKER_PM = `[${ATTR_NAME}-pm]`;\r\nconst SELECTOR_ATTR_TIMEPICKER_FORMAT24 = `[${ATTR_NAME}-format24]`;\r\nconst SELECTOR_ATTR_TIMEPICKER_CURRENT = `[${ATTR_NAME}-current]`;\r\nconst SELECTOR_ATTR_TIMEPICKER_HOUR_MODE = `[${ATTR_NAME}-hour-mode]`;\r\nconst SELECTOR_ATTR_TIMEPICKER_TOGGLE_BUTTON = `[${ATTR_NAME}-toggle-button]`;\r\n\r\nconst ATTR_TIMEPICKER_BUTTON_CANCEL = `${ATTR_NAME}-cancel`;\r\nconst ATTR_TIMEPICKER_BUTTON_CLEAR = `${ATTR_NAME}-clear`;\r\nconst ATTR_TIMEPICKER_BUTTON_SUBMIT = `${ATTR_NAME}-submit`;\r\nconst ATTR_TIMEPICKER_ICON = `${ATTR_NAME}-icon`;\r\nconst ATTR_TIMEPICKER_ICON_UP = `${ATTR_NAME}-icon-up`;\r\nconst ATTR_TIMEPICKER_ICON_DOWN = `${ATTR_NAME}-icon-down`;\r\nconst ATTR_TIMEPICKER_ICON_INLINE_HOUR = `${ATTR_NAME}-icon-inline-hour`;\r\nconst ATTR_TIMEPICKER_ICON_INLINE_MINUTE = `${ATTR_NAME}-icon-inline-minute`;\r\nconst ATTR_TIMEPICKER_ICONS_HOUR_INLINE = `${ATTR_NAME}-inline-hour-icons`;\r\nconst ATTR_TIMEPICKER_CURRENT_INLINE = `${ATTR_NAME}-current-inline`;\r\n\r\nconst ATTR_READONLY = \"readonly\";\r\nconst ATTR_TIMEPICKER_INVALID_FEEDBACK = `${ATTR_NAME}-invalid-feedback`;\r\nconst ATTR_TIMEPICKER_IS_INVALID = `${ATTR_NAME}-is-invalid`;\r\nconst ATTR_TIMEPICKER_DISABLED = `${ATTR_NAME}-disabled`;\r\nconst ATTR_TIMEPICKER_ACTIVE = `${ATTR_NAME}-active`;\r\n\r\nconst ATTR_TIMEPICKER_INPUT = `${ATTR_NAME}-input`;\r\nconst ATTR_TIMEPICKER_CLOCK = `${ATTR_NAME}-clock`;\r\nconst ATTR_TIMEPICKER_CLOCK_INNER = `${ATTR_NAME}-clock-inner`;\r\nconst ATTR_TIMEPICKER_WRAPPER = `${ATTR_NAME}-wrapper`;\r\nconst ATTR_TIMEPICKER_CLOCK_WRAPPER = `${ATTR_NAME}-clock-wrapper`;\r\nconst ATTR_TIMEPICKER_HOUR = `${ATTR_NAME}-hour`;\r\nconst ATTR_TIMEPICKER_MINUTE = `${ATTR_NAME}-minute`;\r\nconst ATTR_TIMEPICKER_TIPS_ELEMENT = `${ATTR_NAME}-tips-element`;\r\nconst ATTR_TIMEPICKER_TIPS_HOURS = `${ATTR_NAME}-tips-hours`;\r\nconst ATTR_TIMEPICKER_TIPS_MINUTES = `${ATTR_NAME}-tips-minutes`;\r\nconst ATTR_TIMEPICKER_INNER_HOURS = `${ATTR_NAME}-tips-inner`;\r\nconst ATTR_TIMEPICKER_TIPS_INNER_ELEMENT = `${ATTR_NAME}-tips-inner-element`;\r\nconst ATTR_TIMEPICKER_MIDDLE_DOT = `${ATTR_NAME}-middle-dot`;\r\nconst ATTR_TIMEPICKER_HAND_POINTER = `${ATTR_NAME}-hand-pointer`;\r\nconst ATTR_TIMEPICKER_CIRCLE = `${ATTR_NAME}-circle`;\r\nconst ATTR_TIMEPICKER_MODAL = `${ATTR_NAME}-modal`;\r\n\r\nconst defaultIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\r\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\r\n</svg>`;\r\n\r\nconst Default = {\r\n  appendValidationInfo: true,\r\n  bodyID: \"\",\r\n  cancelLabel: \"Cancel\",\r\n  clearLabel: \"Clear\",\r\n  closeModalOnBackdropClick: true,\r\n  closeModalOnMinutesClick: false,\r\n  container: \"body\",\r\n  defaultTime: \"\",\r\n  disabled: false,\r\n  disablePast: false,\r\n  disableFuture: false,\r\n  enableValidation: true,\r\n  focusInputAfterApprove: false,\r\n  footerID: \"\",\r\n  format12: true,\r\n  format24: false,\r\n  headID: \"\",\r\n  increment: false,\r\n  inline: false,\r\n  invalidLabel: \"Invalid Time Format\",\r\n  maxTime: \"\",\r\n  minTime: \"\",\r\n  modalID: \"\",\r\n  okLabel: \"Ok\",\r\n  overflowHidden: true,\r\n  pickerID: \"\",\r\n  readOnly: false,\r\n  showClearBtn: true,\r\n  switchHoursToMinutesOnClick: true,\r\n  iconSVG: defaultIcon,\r\n  withIcon: true,\r\n  pmLabel: \"PM\",\r\n  amLabel: \"AM\",\r\n  animations: true,\r\n};\r\n\r\nconst DefaultType = {\r\n  appendValidationInfo: \"boolean\",\r\n  bodyID: \"string\",\r\n  cancelLabel: \"string\",\r\n  clearLabel: \"string\",\r\n  closeModalOnBackdropClick: \"boolean\",\r\n  closeModalOnMinutesClick: \"boolean\",\r\n  container: \"string\",\r\n  disabled: \"boolean\",\r\n  disablePast: \"boolean\",\r\n  disableFuture: \"boolean\",\r\n  enableValidation: \"boolean\",\r\n  footerID: \"string\",\r\n  format12: \"boolean\",\r\n  format24: \"boolean\",\r\n  headID: \"string\",\r\n  increment: \"boolean\",\r\n  inline: \"boolean\",\r\n  invalidLabel: \"string\",\r\n  modalID: \"string\",\r\n  okLabel: \"string\",\r\n  overflowHidden: \"boolean\",\r\n  pickerID: \"string\",\r\n  readOnly: \"boolean\",\r\n  showClearBtn: \"boolean\",\r\n  switchHoursToMinutesOnClick: \"boolean\",\r\n  defaultTime: \"(string|date|number)\",\r\n  iconSVG: \"string\",\r\n  withIcon: \"boolean\",\r\n  pmLabel: \"string\",\r\n  amLabel: \"string\",\r\n  animations: \"boolean\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  tips: \"absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent\",\r\n  tipsActive: \"text-white bg-[#3b71ca] font-normal\",\r\n  tipsDisabled: \"text-[#b3afaf] pointer-events-none bg-transparent\",\r\n  transform: \"transition-[transform,height] ease-in-out duration-[400ms]\",\r\n  modal: \"z-[1065]\",\r\n  clockAnimation: \"animate-[show-up-clock_350ms_linear]\",\r\n  opacity: \"!opacity-100\",\r\n  timepickerWrapper:\r\n    \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed\",\r\n  timepickerContainer:\r\n    \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg\",\r\n  timepickerElements:\r\n    \"flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\r\n  timepickerHead:\r\n    \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center\",\r\n  timepickerHeadContent:\r\n    \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly\",\r\n  timepickerCurrentWrapper: \"[direction:ltr] rtl:[direction:rtl]\",\r\n  timepickerCurrentButtonWrapper: \"relative h-full\",\r\n  timepickerCurrentButton:\r\n    \"text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none \",\r\n  timepickerDot:\r\n    \"font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal\",\r\n  timepickerModeWrapper:\r\n    \"flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\r\n  timepickerModeAm:\r\n    \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\r\n  timepickerModePm:\r\n    \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\r\n  timepickerClockWrapper:\r\n    \"min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500\",\r\n  timepickerClock:\r\n    \"relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50\",\r\n  timepickerMiddleDot:\r\n    \"top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute\",\r\n  timepickerHandPointer:\r\n    \"bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute\",\r\n  timepickerPointerCircle:\r\n    \"-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute\",\r\n  timepickerClockInner:\r\n    \"absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]\",\r\n  timepickerFooterWrapper:\r\n    \"rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500\",\r\n  timepickerFooter: \"w-full flex justify-between\",\r\n  timepickerFooterButton:\r\n    \"text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none\",\r\n  timepickerInlineWrapper:\r\n    \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg\",\r\n  timepickerInlineContainer:\r\n    \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]\",\r\n  timepickerInlineElements:\r\n    \"flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\r\n  timepickerInlineHead:\r\n    \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg\",\r\n  timepickerInlineHeadContent:\r\n    \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center\",\r\n  timepickerInlineHourWrapper: \"relative h-full !opacity-100\",\r\n  timepickerCurrentMinuteWrapper: \"relative h-full\",\r\n  timepickerInlineIconUp:\r\n    \"absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\r\n  timepickerInlineIconSvg: \"h-4 w-4\",\r\n  timepickerInlineCurrentButton:\r\n    \"font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]\",\r\n  timepickerInlineIconDown:\r\n    \"absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\r\n  timepickerInlineDot:\r\n    \"font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]\",\r\n  timepickerInlineModeWrapper:\r\n    \"flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\r\n  timepickerInlineModeAm:\r\n    \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6\",\r\n  timepickerInlineModePm:\r\n    \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer\",\r\n  timepickerInlineSubmitButton:\r\n    \"hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0\",\r\n  timepickerToggleButton:\r\n    \"h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  tips: \"string\",\r\n  tipsActive: \"string\",\r\n  tipsDisabled: \"string\",\r\n  transform: \"string\",\r\n  modal: \"string\",\r\n  clockAnimation: \"string\",\r\n  opacity: \"string\",\r\n  timepickerWrapper: \"string\",\r\n  timepickerContainer: \"string\",\r\n  timepickerElements: \"string\",\r\n  timepickerHead: \"string\",\r\n  timepickerHeadContent: \"string\",\r\n  timepickerCurrentWrapper: \"string\",\r\n  timepickerCurrentButtonWrapper: \"string\",\r\n  timepickerCurrentButton: \"string\",\r\n  timepickerDot: \"string\",\r\n  timepickerModeWrapper: \"string\",\r\n  timepickerModeAm: \"string\",\r\n  timepickerModePm: \"string\",\r\n  timepickerClockWrapper: \"string\",\r\n  timepickerClock: \"string\",\r\n  timepickerMiddleDot: \"string\",\r\n  timepickerHandPointer: \"string\",\r\n  timepickerPointerCircle: \"string\",\r\n  timepickerClockInner: \"string\",\r\n  timepickerFooterWrapper: \"string\",\r\n  timepickerFooterButton: \"string\",\r\n  timepickerInlineWrapper: \"string\",\r\n  timepickerInlineContainer: \"string\",\r\n  timepickerInlineElements: \"string\",\r\n  timepickerInlineHead: \"string\",\r\n  timepickerInlineHeadContent: \"string\",\r\n  timepickerInlineHourWrapper: \"string\",\r\n  timepickerCurrentMinuteWrapper: \"string\",\r\n  timepickerInlineIconUp: \"string\",\r\n  timepickerInlineIconSvg: \"string\",\r\n  timepickerInlineCurrentButton: \"string\",\r\n  timepickerInlineIconDown: \"string\",\r\n  timepickerInlineDot: \"string\",\r\n  timepickerInlineModeWrapper: \"string\",\r\n  timepickerInlineModeAm: \"string\",\r\n  timepickerInlineModePm: \"string\",\r\n  timepickerInlineSubmitButton: \"string\",\r\n  timepickerToggleButton: \"string\",\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Timepicker {\r\n  constructor(element, options = {}, classes) {\r\n    this._element = element;\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n    }\r\n\r\n    this._document = document;\r\n    this._options = this._getConfig(options);\r\n    this._classes = this._getClasses(classes);\r\n    this._currentTime = null;\r\n    this._toggleButtonId = getUID(\"timepicker-toggle-\");\r\n\r\n    this.hoursArray = [\r\n      \"12\",\r\n      \"1\",\r\n      \"2\",\r\n      \"3\",\r\n      \"4\",\r\n      \"5\",\r\n      \"6\",\r\n      \"7\",\r\n      \"8\",\r\n      \"9\",\r\n      \"10\",\r\n      \"11\",\r\n    ];\r\n    this.innerHours = [\r\n      \"00\",\r\n      \"13\",\r\n      \"14\",\r\n      \"15\",\r\n      \"16\",\r\n      \"17\",\r\n      \"18\",\r\n      \"19\",\r\n      \"20\",\r\n      \"21\",\r\n      \"22\",\r\n      \"23\",\r\n    ];\r\n    this.minutesArray = [\r\n      \"00\",\r\n      \"05\",\r\n      \"10\",\r\n      \"15\",\r\n      \"20\",\r\n      \"25\",\r\n      \"30\",\r\n      \"35\",\r\n      \"40\",\r\n      \"45\",\r\n      \"50\",\r\n      \"55\",\r\n    ];\r\n\r\n    this.input = SelectorEngine.findOne(\"input\", this._element);\r\n    this.dataWithIcon = element.dataset.withIcon;\r\n    this.dataToggle = element.dataset.toggle;\r\n    this.customIcon = SelectorEngine.findOne(\r\n      SELECTOR_ATTR_TIMEPICKER_TOGGLE_BUTTON,\r\n      this._element\r\n    );\r\n\r\n    this._checkToggleButton();\r\n\r\n    this.inputFormatShow = SelectorEngine.findOne(\r\n      SELECTOR_ATTR_TIMEPICKER_FORMAT24,\r\n      this._element\r\n    );\r\n\r\n    this.inputFormat =\r\n      this.inputFormatShow === null\r\n        ? \"\"\r\n        : Object.values(this.inputFormatShow.dataset)[0];\r\n    this.elementToggle = SelectorEngine.findOne(\r\n      SELECTOR_DATA_TE_TOGGLE,\r\n      this._element\r\n    );\r\n    this.toggleElement = Object.values(\r\n      element.querySelector(SELECTOR_DATA_TE_TOGGLE).dataset\r\n    )[0];\r\n\r\n    this._hour = null;\r\n    this._minutes = null;\r\n    this._AM = null;\r\n    this._PM = null;\r\n    this._wrapper = null;\r\n    this._modal = null;\r\n    this._hand = null;\r\n    this._circle = null;\r\n    this._focusTrap = null;\r\n    this._popper = null;\r\n    this._interval = null;\r\n\r\n    this._inputValue =\r\n      this._options.defaultTime !== \"\"\r\n        ? this._options.defaultTime\r\n        : this.input.value;\r\n\r\n    if (this._options.format24) {\r\n      this._options.format12 = false;\r\n\r\n      this._currentTime = formatNormalHours(this._inputValue);\r\n    }\r\n\r\n    if (this._options.format12) {\r\n      this._options.format24 = false;\r\n\r\n      this._currentTime = formatToAmPm(this._inputValue);\r\n    }\r\n\r\n    if (this._options.readOnly) {\r\n      this.input.setAttribute(ATTR_READONLY, true);\r\n    }\r\n\r\n    if (this.inputFormat === \"true\" && this.inputFormat !== \"\") {\r\n      this._options.format12 = false;\r\n      this._options.format24 = true;\r\n      this._currentTime = formatNormalHours(this._inputValue);\r\n    }\r\n\r\n    this._animations =\r\n      !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches &&\r\n      this._options.animations;\r\n\r\n    this.init();\r\n\r\n    this._isHours = true;\r\n    this._isMinutes = false;\r\n    this._isInvalidTimeFormat = false;\r\n    this._isMouseMove = false;\r\n    this._isInner = false;\r\n    this._isAmEnabled = false;\r\n    this._isPmEnabled = false;\r\n\r\n    if (this._options.format12 && !this._options.defaultTime) {\r\n      this._isPmEnabled = true;\r\n    }\r\n\r\n    this._objWithDataOnChange = { degrees: null };\r\n\r\n    this._scrollBar = new ScrollBarHelper();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  init() {\r\n    const { format12, format24, enableValidation } = this._options;\r\n    let zero;\r\n    let hoursFormat;\r\n    let _amOrPm;\r\n\r\n    this.input.setAttribute(ATTR_TIMEPICKER_INPUT, \"\");\r\n\r\n    if (this._currentTime !== undefined) {\r\n      const { hours, minutes, amOrPm } = this._currentTime;\r\n\r\n      zero = Number(hours) < 10 ? 0 : \"\";\r\n      hoursFormat = `${zero}${Number(hours)}:${minutes}`;\r\n      _amOrPm = amOrPm;\r\n\r\n      if (format12) {\r\n        this.input.value = `${hoursFormat} ${_amOrPm}`;\r\n      } else if (format24) {\r\n        this.input.value = `${hoursFormat}`;\r\n      }\r\n    } else {\r\n      zero = \"\";\r\n      hoursFormat = \"\";\r\n      _amOrPm = \"\";\r\n\r\n      this.input.value = \"\";\r\n    }\r\n\r\n    if (this.input.value.length > 0 && this.input.value !== \"\") {\r\n      this.input.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n      EventHandler.trigger(this.input, \"input\");\r\n    }\r\n\r\n    if (this._options === null && this._element === null) return;\r\n\r\n    if (enableValidation) {\r\n      this._getValidate(\"keydown change blur focus\");\r\n    }\r\n\r\n    this._handleOpen();\r\n    this._listenToToggleKeydown();\r\n  }\r\n\r\n  dispose() {\r\n    this._removeModal();\r\n\r\n    if (this._element !== null) {\r\n      Data.removeData(this._element, DATA_KEY);\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this._element = null;\r\n      this._options = null;\r\n      this.input = null;\r\n      this._focusTrap = null;\r\n    }, 350);\r\n\r\n    EventHandler.off(\r\n      this._document,\r\n      \"click\",\r\n      `[data-te-toggle='${this.toggleElement}']`\r\n    );\r\n    EventHandler.off(\r\n      this._element,\r\n      \"keydown\",\r\n      `[data-te-toggle='${this.toggleElement}']`\r\n    );\r\n  }\r\n\r\n  update(options = {}) {\r\n    this._options = this._getConfig({ ...this._options, ...options });\r\n  }\r\n\r\n  // private\r\n\r\n  _checkToggleButton() {\r\n    if (this.customIcon !== null) return;\r\n\r\n    if (this.dataWithIcon !== undefined) {\r\n      this._options.withIcon = null;\r\n\r\n      if (this.dataWithIcon === \"true\") {\r\n        this._appendToggleButton(this._options);\r\n      }\r\n    }\r\n\r\n    if (this._options.withIcon) {\r\n      this._appendToggleButton(this._options);\r\n    }\r\n  }\r\n\r\n  _appendToggleButton() {\r\n    const toggleButton = getToggleButtonTemplate(\r\n      this._options,\r\n      this._toggleButtonId,\r\n      this._classes\r\n    );\r\n\r\n    this.input.insertAdjacentHTML(\"afterend\", toggleButton);\r\n  }\r\n\r\n  _getDomElements() {\r\n    this._hour = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_HOUR}]`);\r\n    this._minutes = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_MINUTE}]`);\r\n    this._AM = SelectorEngine.findOne(SELECTOR_ATTR_TIMEPICKER_AM);\r\n    this._PM = SelectorEngine.findOne(SELECTOR_ATTR_TIMEPICKER_PM);\r\n    this._wrapper = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_WRAPPER}]`);\r\n    this._modal = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_MODAL}]`);\r\n    this._hand = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_HAND_POINTER}]`);\r\n    this._circle = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_CIRCLE}]`);\r\n    this._clock = SelectorEngine.findOne(`[${ATTR_TIMEPICKER_CLOCK}]`);\r\n    this._clockInner = SelectorEngine.findOne(\r\n      `[${ATTR_TIMEPICKER_CLOCK_INNER}]`\r\n    );\r\n  }\r\n\r\n  _handlerMaxMinHoursOptions(\r\n    degrees,\r\n    maxHour,\r\n    minHour,\r\n    maxFormat,\r\n    minFormat,\r\n    e\r\n  ) {\r\n    if (!maxHour && !minHour) return true;\r\n\r\n    const { format24, format12, disablePast, disableFuture } = this._options;\r\n    const { _isAmEnabled, _isPmEnabled } = this;\r\n    const key = e.keyCode;\r\n\r\n    const _isMouseOnInnerClock =\r\n      e.target.hasAttribute(ATTR_TIMEPICKER_CLOCK_INNER) ||\r\n      e.target.hasAttribute(ATTR_TIMEPICKER_INNER_HOURS) ||\r\n      e.target.hasAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT);\r\n\r\n    minHour = setMinTime(minHour, disablePast, format12);\r\n    maxHour = setMaxTime(maxHour, disableFuture, format12);\r\n    typeof maxHour !== \"number\" && (maxHour = takeValue(maxHour, false)[0]);\r\n\r\n    const maxHourDegrees = maxHour !== \"\" ? maxHour * 30 : \"\";\r\n    const minHourDegrees = minHour !== \"\" ? minHour * 30 : \"\";\r\n\r\n    if (degrees < 0) {\r\n      degrees = 360 + degrees;\r\n    }\r\n\r\n    degrees = degrees === 360 ? 0 : degrees;\r\n\r\n    const _handleKeyboardEvents = () => {\r\n      const tips = document.querySelectorAll(\r\n        `[${ATTR_TIMEPICKER_TIPS_ELEMENT}]`\r\n      );\r\n      const innerTips = document.querySelectorAll(\r\n        `[${ATTR_TIMEPICKER_TIPS_INNER_ELEMENT}]`\r\n      );\r\n\r\n      const currentHour = _convertHourToNumber(this._hour.innerText);\r\n      let nextHourTip;\r\n      let numberToAdd;\r\n      let nextHour;\r\n\r\n      if (key === UP_ARROW) {\r\n        numberToAdd = 1;\r\n      } else if (key === DOWN_ARROW) {\r\n        numberToAdd = -1;\r\n      }\r\n\r\n      if (currentHour === 12 && key === UP_ARROW) {\r\n        nextHour = 1;\r\n      } else if (currentHour === 0 && key === UP_ARROW) {\r\n        nextHour = 13;\r\n      } else if (currentHour === 0 && key === DOWN_ARROW) {\r\n        nextHour = 23;\r\n      } else if (currentHour === 13 && key === DOWN_ARROW) {\r\n        nextHour = 0;\r\n      } else if (currentHour === 1 && key === DOWN_ARROW) {\r\n        nextHour = 12;\r\n      } else {\r\n        nextHour = currentHour + numberToAdd;\r\n      }\r\n\r\n      tips.forEach((tip) => {\r\n        if (Number(tip.textContent) === nextHour) {\r\n          nextHourTip = tip;\r\n        }\r\n      });\r\n      innerTips.forEach((innerTip) => {\r\n        if (Number(innerTip.textContent) === nextHour) {\r\n          nextHourTip = innerTip;\r\n        }\r\n      });\r\n\r\n      return !nextHourTip.parentElement.hasAttribute(ATTR_TIMEPICKER_DISABLED);\r\n    };\r\n\r\n    const _handle24FormatMouseEvents = () => {\r\n      const minInnerHourDegrees =\r\n        minHour !== \"\" && minHour > 12 ? (minHour - 12) * 30 : \"\";\r\n      const maxInnerHourDegrees =\r\n        maxHour !== \"\" && maxHour > 12 ? (maxHour - 12) * 30 : \"\";\r\n\r\n      if (\r\n        (minInnerHourDegrees && degrees < minInnerHourDegrees) ||\r\n        (maxInnerHourDegrees && degrees > maxInnerHourDegrees) ||\r\n        (maxHour && maxHour < 12)\r\n      ) {\r\n        return;\r\n      }\r\n      return true;\r\n    };\r\n\r\n    if (format24 && e.type !== \"keydown\" && _isMouseOnInnerClock) {\r\n      return _handle24FormatMouseEvents();\r\n    }\r\n    if (e.type === \"keydown\") {\r\n      return _handleKeyboardEvents(e);\r\n    }\r\n\r\n    const minFormatAndCurrentFormatEqual =\r\n      !minFormat ||\r\n      (minFormat === \"PM\" && _isPmEnabled) ||\r\n      (minHour !== \"\" && minFormat === \"AM\" && _isAmEnabled);\r\n\r\n    const maxFormatAndCurrentFormatEqual =\r\n      !maxFormat ||\r\n      (maxFormat === \"PM\" && _isPmEnabled) ||\r\n      (maxHour !== \"\" && maxFormat === \"AM\" && _isAmEnabled);\r\n\r\n    const isMinHourValid = () => {\r\n      const minDegrees =\r\n        minHourDegrees === 360 && format12 ? 0 : minHourDegrees;\r\n      if (!minHour) {\r\n        return true;\r\n      } else if (\r\n        (minFormat === \"PM\" && _isAmEnabled) ||\r\n        (minFormatAndCurrentFormatEqual && degrees < minDegrees)\r\n      ) {\r\n        return;\r\n      }\r\n      return true;\r\n    };\r\n\r\n    const isMaxHourValid = () => {\r\n      const maxDegrees =\r\n        maxHourDegrees === 360 && format12 ? 0 : maxHourDegrees;\r\n      if (!maxHour) {\r\n        return true;\r\n      } else if (\r\n        (maxFormat === \"AM\" && _isPmEnabled) ||\r\n        (maxFormatAndCurrentFormatEqual && degrees > maxDegrees)\r\n      ) {\r\n        return;\r\n      }\r\n      return true;\r\n    };\r\n\r\n    return isMinHourValid() && isMaxHourValid();\r\n  }\r\n\r\n  _handleKeyboard() {\r\n    EventHandler.on(this._document, EVENT_KEYDOWN_DATA_API, \"\", (e) => {\r\n      let hour;\r\n      let minute;\r\n      let innerHour;\r\n      const {\r\n        increment,\r\n        maxTime,\r\n        minTime,\r\n        format12,\r\n        disablePast,\r\n        disableFuture,\r\n      } = this._options;\r\n\r\n      let minHour = takeValue(minTime, false)[0];\r\n      let maxHour = takeValue(maxTime, false)[0];\r\n      const minFormat = takeValue(minTime, false)[2];\r\n      const maxFormat = takeValue(maxTime, false)[2];\r\n\r\n      minHour = setMinTime(minHour, disablePast, format12);\r\n      maxHour = setMaxTime(maxHour, disableFuture, format12);\r\n\r\n      typeof maxHour !== \"number\" && (maxHour = takeValue(maxHour, false)[0]);\r\n\r\n      const hoursView =\r\n        SelectorEngine.findOne(`[${ATTR_TIMEPICKER_TIPS_MINUTES}]`) === null;\r\n      const innerHoursExist =\r\n        SelectorEngine.findOne(`[${ATTR_TIMEPICKER_INNER_HOURS}]`) !== null;\r\n\r\n      const degrees = Number(this._hand.style.transform.replace(/[^\\d-]/g, \"\"));\r\n\r\n      const allTipsMinutes = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,\r\n        this._modal\r\n      );\r\n      const allTipsHours = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n        this._modal\r\n      );\r\n      const allInnerTips = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n        this._modal\r\n      );\r\n\r\n      let hourTime = this._makeHourDegrees(e.target, degrees, hour).hour;\r\n      const { degrees: hourObjDegrees, addDegrees } = this._makeHourDegrees(\r\n        e.target,\r\n        degrees,\r\n        hour\r\n      );\r\n\r\n      let { minute: minHourMinutes, degrees: minObjDegrees } =\r\n        this._makeMinutesDegrees(degrees, minute);\r\n      const addMinDegrees = this._makeMinutesDegrees(\r\n        degrees,\r\n        minute\r\n      ).addDegrees;\r\n\r\n      let { hour: innerHourDegrees } = this._makeInnerHoursDegrees(\r\n        degrees,\r\n        innerHour\r\n      );\r\n\r\n      if (e.keyCode === ESCAPE) {\r\n        const cancelBtn = SelectorEngine.findOne(\r\n          `[${ATTR_TIMEPICKER_BUTTON_CANCEL}]`,\r\n          this._modal\r\n        );\r\n        EventHandler.trigger(cancelBtn, \"click\");\r\n      } else if (hoursView) {\r\n        if (innerHoursExist) {\r\n          if (e.keyCode === RIGHT_ARROW) {\r\n            this._isInner = false;\r\n            Manipulator.addStyle(this._hand, {\r\n              height: \"calc(40% + 1px)\",\r\n            });\r\n            this._hour.textContent = this._setHourOrMinute(\r\n              hourTime > 12 ? 1 : hourTime\r\n            );\r\n            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);\r\n            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);\r\n          }\r\n\r\n          if (e.keyCode === LEFT_ARROW) {\r\n            this._isInner = true;\r\n            Manipulator.addStyle(this._hand, {\r\n              height: \"21.5%\",\r\n            });\r\n\r\n            this._hour.textContent = this._setHourOrMinute(\r\n              innerHourDegrees >= 24 || innerHourDegrees === \"00\"\r\n                ? 0\r\n                : innerHourDegrees\r\n            );\r\n            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);\r\n            this._toggleClassActive(\r\n              this.hoursArray,\r\n              this._hour - 1,\r\n              allTipsHours\r\n            );\r\n          }\r\n        }\r\n        if (e.keyCode === UP_ARROW) {\r\n          const isNextHourValid = this._handlerMaxMinHoursOptions(\r\n            hourObjDegrees + 30,\r\n            maxHour,\r\n            minHour,\r\n            maxFormat,\r\n            minFormat,\r\n            e\r\n          );\r\n\r\n          if (!isNextHourValid) return;\r\n\r\n          Manipulator.addStyle(this._hand, {\r\n            transform: `rotateZ(${hourObjDegrees + addDegrees}deg)`,\r\n          });\r\n\r\n          if (this._isInner) {\r\n            innerHourDegrees += 1;\r\n\r\n            if (innerHourDegrees === 24) {\r\n              innerHourDegrees = 0;\r\n            } else if (innerHourDegrees === 25 || innerHourDegrees === \"001\") {\r\n              innerHourDegrees = 13;\r\n            }\r\n\r\n            this._hour.textContent = this._setHourOrMinute(innerHourDegrees);\r\n            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);\r\n          } else {\r\n            hourTime += 1;\r\n            this._hour.textContent = this._setHourOrMinute(\r\n              hourTime > 12 ? 1 : hourTime\r\n            );\r\n            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);\r\n          }\r\n        }\r\n        if (e.keyCode === DOWN_ARROW) {\r\n          const isNextHourValid = this._handlerMaxMinHoursOptions(\r\n            hourObjDegrees - 30,\r\n            maxHour,\r\n            minHour,\r\n            maxFormat,\r\n            minFormat,\r\n            e\r\n          );\r\n\r\n          if (!isNextHourValid) return;\r\n\r\n          Manipulator.addStyle(this._hand, {\r\n            transform: `rotateZ(${hourObjDegrees - addDegrees}deg)`,\r\n          });\r\n\r\n          if (this._isInner) {\r\n            innerHourDegrees -= 1;\r\n\r\n            if (innerHourDegrees === 12) {\r\n              innerHourDegrees = 0;\r\n            } else if (innerHourDegrees === -1) {\r\n              innerHourDegrees = 23;\r\n            }\r\n\r\n            this._hour.textContent = this._setHourOrMinute(innerHourDegrees);\r\n            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);\r\n          } else {\r\n            hourTime -= 1;\r\n            this._hour.textContent = this._setHourOrMinute(\r\n              hourTime === 0 ? 12 : hourTime\r\n            );\r\n            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);\r\n          }\r\n        }\r\n      } else {\r\n        if (e.keyCode === UP_ARROW) {\r\n          minObjDegrees += addMinDegrees;\r\n          Manipulator.addStyle(this._hand, {\r\n            transform: `rotateZ(${minObjDegrees}deg)`,\r\n          });\r\n          minHourMinutes += 1;\r\n          if (increment) {\r\n            minHourMinutes += 4;\r\n\r\n            if (minHourMinutes === \"0014\") {\r\n              minHourMinutes = 5;\r\n            }\r\n          }\r\n\r\n          this._minutes.textContent = this._setHourOrMinute(\r\n            minHourMinutes > 59 ? 0 : minHourMinutes\r\n          );\r\n          this._toggleClassActive(\r\n            this.minutesArray,\r\n            this._minutes,\r\n            allTipsMinutes\r\n          );\r\n          this._toggleBackgroundColorCircle(\r\n            `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n          );\r\n        }\r\n        if (e.keyCode === DOWN_ARROW) {\r\n          minObjDegrees -= addMinDegrees;\r\n          Manipulator.addStyle(this._hand, {\r\n            transform: `rotateZ(${minObjDegrees}deg)`,\r\n          });\r\n          if (increment) {\r\n            minHourMinutes -= 5;\r\n          } else {\r\n            minHourMinutes -= 1;\r\n          }\r\n\r\n          if (minHourMinutes === -1) {\r\n            minHourMinutes = 59;\r\n          } else if (minHourMinutes === -5) {\r\n            minHourMinutes = 55;\r\n          }\r\n\r\n          this._minutes.textContent = this._setHourOrMinute(minHourMinutes);\r\n          this._toggleClassActive(\r\n            this.minutesArray,\r\n            this._minutes,\r\n            allTipsMinutes\r\n          );\r\n          this._toggleBackgroundColorCircle(\r\n            `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n          );\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _setActiveClassToTipsOnOpen(hour, ...rest) {\r\n    if (this._isInvalidTimeFormat) return;\r\n\r\n    if (!this._options.format24) {\r\n      [...rest].filter((e) => {\r\n        if (e === \"PM\") {\r\n          Manipulator.addClass(this._PM, this._classes.opacity);\r\n          this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n        } else if (e === \"AM\") {\r\n          Manipulator.addClass(this._AM, this._classes.opacity);\r\n          this._AM.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n        } else {\r\n          Manipulator.removeClass(this._AM, this._classes.opacity);\r\n          Manipulator.removeClass(this._PM, this._classes.opacity);\r\n          this._AM.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n          this._PM.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n        }\r\n\r\n        return e;\r\n      });\r\n\r\n      const allTipsHours = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n        this._modal\r\n      );\r\n      this._addActiveClassToTip(allTipsHours, hour);\r\n    } else {\r\n      const allTipsHours = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n        this._modal\r\n      );\r\n      const allInnerTips = SelectorEngine.find(\r\n        `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n        this._modal\r\n      );\r\n\r\n      this._addActiveClassToTip(allTipsHours, hour);\r\n      this._addActiveClassToTip(allInnerTips, hour);\r\n    }\r\n  }\r\n\r\n  _setTipsAndTimesDependOnInputValue(hour, minute) {\r\n    const { inline, format12 } = this._options;\r\n\r\n    if (!this._isInvalidTimeFormat) {\r\n      const rotateDegrees = hour > 12 ? hour * 30 - 360 : hour * 30;\r\n      this._hour.textContent = hour;\r\n      this._minutes.textContent = minute;\r\n\r\n      if (!inline) {\r\n        Manipulator.addStyle(this._hand, {\r\n          transform: `rotateZ(${rotateDegrees}deg)`,\r\n        });\r\n        Manipulator.addStyle(this._circle, {\r\n          backgroundColor: \"#1976d2\",\r\n        });\r\n\r\n        if (Number(hour) > 12 || hour === \"00\") {\r\n          Manipulator.addStyle(this._hand, {\r\n            height: \"21.5%\",\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      this._hour.textContent = \"12\";\r\n      this._minutes.textContent = \"00\";\r\n\r\n      if (!inline) {\r\n        Manipulator.addStyle(this._hand, {\r\n          transform: \"rotateZ(0deg)\",\r\n        });\r\n      }\r\n      if (format12) {\r\n        Manipulator.addClass(this._PM, this._classes.opacity);\r\n        this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n      }\r\n    }\r\n  }\r\n\r\n  _listenToToggleKeydown() {\r\n    EventHandler.on(\r\n      this._element,\r\n      \"keydown\",\r\n      `[data-te-toggle='${this.toggleElement}']`,\r\n      (e) => {\r\n        if (e.keyCode === ENTER) {\r\n          e.preventDefault();\r\n          EventHandler.trigger(this.elementToggle, \"click\");\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleOpen() {\r\n    const container = this._getContainer();\r\n    EventHandlerMulti.on(\r\n      this._element,\r\n      \"click\",\r\n      `[data-te-toggle='${this.toggleElement}']`,\r\n      (e) => {\r\n        if (this._options === null) return;\r\n\r\n        // Fix for input with open, if is not for settimeout input has incorrent jumping label\r\n        const fixForInput =\r\n          Manipulator.getDataAttribute(this.input, \"toggle\") !== null ? 200 : 0;\r\n\r\n        setTimeout(() => {\r\n          Manipulator.addStyle(this.elementToggle, {\r\n            pointerEvents: \"none\",\r\n          });\r\n\r\n          this.elementToggle.blur();\r\n\r\n          let checkInputValue;\r\n\r\n          if (takeValue(this.input)[0] === \"\") {\r\n            checkInputValue = [\"12\", \"00\", \"PM\"];\r\n          } else {\r\n            checkInputValue = takeValue(this.input);\r\n          }\r\n\r\n          const { modalID, inline, format12 } = this._options;\r\n          const [hour, minute, format] = checkInputValue;\r\n          const div = element(\"div\");\r\n\r\n          if (Number(hour) > 12 || hour === \"00\") {\r\n            this._isInner = true;\r\n          }\r\n\r\n          this.input.blur();\r\n          e.target.blur();\r\n\r\n          div.innerHTML = getTimepickerTemplate(this._options, this._classes);\r\n          Manipulator.addClass(div, this._classes.modal);\r\n          div.setAttribute(ATTR_TIMEPICKER_MODAL, \"\");\r\n\r\n          div.setAttribute(\"role\", \"dialog\");\r\n          div.setAttribute(\"tabIndex\", \"-1\");\r\n          div.setAttribute(\"id\", modalID);\r\n\r\n          if (!inline) {\r\n            container.appendChild(div);\r\n            this._scrollBar.hide();\r\n          } else {\r\n            this._popper = createPopper(this.input, div, {\r\n              placement: \"bottom-start\",\r\n            });\r\n\r\n            container.appendChild(div);\r\n          }\r\n\r\n          this._getDomElements();\r\n          if (this._animations) {\r\n            this._toggleBackdropAnimation();\r\n          } else {\r\n            Manipulator.addClass(this._wrapper, this._classes.opacity);\r\n          }\r\n          this._setActiveClassToTipsOnOpen(hour, minute, format);\r\n          this._appendTimes();\r\n          this._setActiveClassToTipsOnOpen(hour, minute, format);\r\n          this._setTipsAndTimesDependOnInputValue(hour, minute);\r\n\r\n          if (this.input.value === \"\") {\r\n            const allTipsHours = SelectorEngine.find(\r\n              `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n              this._modal\r\n            );\r\n\r\n            if (format12) {\r\n              Manipulator.addClass(this._PM, this._classes.opacity);\r\n              this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n            }\r\n\r\n            this._hour.textContent = \"12\";\r\n            this._minutes.textContent = \"00\";\r\n            this._addActiveClassToTip(\r\n              allTipsHours,\r\n              Number(this._hour.textContent)\r\n            );\r\n          }\r\n\r\n          this._handleSwitchTimeMode();\r\n          this._handleOkButton();\r\n          this._handleClose();\r\n\r\n          if (inline) {\r\n            this._handleHoverInlineBtn();\r\n            this._handleDocumentClickInline();\r\n            this._handleInlineClicks();\r\n          } else {\r\n            this._handleSwitchHourMinute();\r\n            this._handleClockClick();\r\n            this._handleKeyboard();\r\n\r\n            // initial opacity on hour/minute mode fix\r\n            const initActive = document.querySelector(\r\n              `${SELECTOR_ATTR_TIMEPICKER_CURRENT}[${ATTR_TIMEPICKER_ACTIVE}]`\r\n            );\r\n            Manipulator.addClass(initActive, this._classes.opacity);\r\n\r\n            Manipulator.addStyle(this._hour, {\r\n              pointerEvents: \"none\",\r\n            });\r\n            Manipulator.addStyle(this._minutes, {\r\n              pointerEvents: \"\",\r\n            });\r\n          }\r\n\r\n          this._focusTrap = new FocusTrap(this._wrapper, {\r\n            event: \"keydown\",\r\n            condition: ({ key }) => key === \"Tab\",\r\n          });\r\n          this._focusTrap.trap();\r\n        }, fixForInput);\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleInlineClicks() {\r\n    let selectedHour;\r\n    let minuteNumber;\r\n    const countMinutes = (count) => {\r\n      let minutes = count;\r\n\r\n      if (minutes > 59) {\r\n        minutes = 0;\r\n      } else if (minutes < 0) {\r\n        minutes = 59;\r\n      }\r\n\r\n      return minutes;\r\n    };\r\n\r\n    const countHours = (count) => {\r\n      let hour = count;\r\n\r\n      if (this._options.format24) {\r\n        if (hour > 24) {\r\n          hour = 1;\r\n        } else if (hour < 0) {\r\n          hour = 23;\r\n        }\r\n\r\n        if (hour > 23) {\r\n          hour = 0;\r\n        }\r\n      } else {\r\n        if (hour > 12) {\r\n          hour = 1;\r\n        } else if (hour < 1) {\r\n          hour = 12;\r\n        }\r\n\r\n        if (hour > 12) {\r\n          hour = 1;\r\n        }\r\n      }\r\n\r\n      return hour;\r\n    };\r\n\r\n    const incrementHours = (hour) => {\r\n      const counteredNumber = countHours(hour);\r\n      this._hour.textContent = this._setHourOrMinute(counteredNumber);\r\n    };\r\n    const incrementMinutes = (minutes) => {\r\n      const counteredNumber = countMinutes(minutes);\r\n      this._minutes.textContent = this._setHourOrMinute(counteredNumber);\r\n    };\r\n\r\n    const addHours = () => {\r\n      selectedHour += 1;\r\n      incrementHours(selectedHour);\r\n    };\r\n    const addMinutes = () => {\r\n      minuteNumber += 1;\r\n      incrementMinutes(minuteNumber);\r\n    };\r\n\r\n    const subHours = () => {\r\n      selectedHour -= 1;\r\n      incrementHours(selectedHour);\r\n    };\r\n\r\n    const subMinutes = () => {\r\n      minuteNumber -= 1;\r\n      incrementMinutes(minuteNumber);\r\n    };\r\n\r\n    const _clearAndSetThisInterval = (addHoursOrAddMinutes) => {\r\n      clearInterval(this._interval);\r\n      this._interval = setInterval(addHoursOrAddMinutes, 100);\r\n    };\r\n    EventHandlerMulti.on(\r\n      this._modal,\r\n      \"click mousedown mouseup touchstart touchend contextmenu\",\r\n      `[${ATTR_TIMEPICKER_ICON_UP}], [${ATTR_TIMEPICKER_ICON_DOWN}]`,\r\n      (e) => {\r\n        selectedHour = Number(this._hour.textContent);\r\n        minuteNumber = Number(this._minutes.textContent);\r\n        const { target, type } = e;\r\n        const isEventTypeMousedownOrTouchstart =\r\n          type === \"mousedown\" || type === \"touchstart\";\r\n\r\n        if (target.closest(`[${ATTR_TIMEPICKER_ICON_UP}]`)) {\r\n          if (\r\n            target\r\n              .closest(`[${ATTR_TIMEPICKER_ICON_UP}]`)\r\n              .parentNode.hasAttribute(ATTR_TIMEPICKER_ICONS_HOUR_INLINE)\r\n          ) {\r\n            if (isEventTypeMousedownOrTouchstart) {\r\n              _clearAndSetThisInterval(addHours);\r\n            } else if (\r\n              type === \"mouseup\" ||\r\n              type === \"touchend\" ||\r\n              type === \"contextmenu\"\r\n            ) {\r\n              clearInterval(this._interval);\r\n            } else {\r\n              addHours();\r\n            }\r\n          } else {\r\n            // eslint-disable-next-line no-lonely-if\r\n            if (isEventTypeMousedownOrTouchstart) {\r\n              _clearAndSetThisInterval(addMinutes);\r\n            } else if (\r\n              type === \"mouseup\" ||\r\n              type === \"touchend\" ||\r\n              type === \"contextmenu\"\r\n            ) {\r\n              clearInterval(this._interval);\r\n            } else {\r\n              addMinutes();\r\n            }\r\n          }\r\n        } else if (target.closest(`[${ATTR_TIMEPICKER_ICON_DOWN}]`)) {\r\n          if (\r\n            target\r\n              .closest(`[${ATTR_TIMEPICKER_ICON_DOWN}]`)\r\n              .parentNode.hasAttribute(ATTR_TIMEPICKER_ICONS_HOUR_INLINE)\r\n          ) {\r\n            if (isEventTypeMousedownOrTouchstart) {\r\n              _clearAndSetThisInterval(subHours);\r\n            } else if (type === \"mouseup\" || type === \"touchend\") {\r\n              clearInterval(this._interval);\r\n            } else {\r\n              subHours();\r\n            }\r\n          } else {\r\n            // eslint-disable-next-line no-lonely-if\r\n            if (isEventTypeMousedownOrTouchstart) {\r\n              _clearAndSetThisInterval(subMinutes);\r\n            } else if (type === \"mouseup\" || type === \"touchend\") {\r\n              clearInterval(this._interval);\r\n            } else {\r\n              subMinutes();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    );\r\n    EventHandler.on(window, EVENT_KEYDOWN_DATA_API, (e) => {\r\n      const key = e.code;\r\n      const isHourBtnFocused =\r\n        document.activeElement.hasAttribute(ATTR_TIMEPICKER_HOUR);\r\n      const isMinuteBtnFocused = document.activeElement.hasAttribute(\r\n        ATTR_TIMEPICKER_MINUTE\r\n      );\r\n      const isBodyFocused = document.activeElement === document.body;\r\n\r\n      selectedHour = Number(this._hour.textContent);\r\n      minuteNumber = Number(this._minutes.textContent);\r\n\r\n      switch (key) {\r\n        case \"ArrowUp\":\r\n          e.preventDefault();\r\n          if (isBodyFocused || isHourBtnFocused) {\r\n            this._hour.focus();\r\n            addHours();\r\n          } else if (isMinuteBtnFocused) {\r\n            addMinutes();\r\n          }\r\n          break;\r\n        case \"ArrowDown\":\r\n          e.preventDefault();\r\n          if (isBodyFocused || isHourBtnFocused) {\r\n            this._hour.focus();\r\n            subHours();\r\n          } else if (isMinuteBtnFocused) {\r\n            subMinutes();\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleClose() {\r\n    EventHandler.on(\r\n      this._modal,\r\n      \"click\",\r\n      `[${ATTR_TIMEPICKER_WRAPPER}], [${ATTR_TIMEPICKER_BUTTON_CANCEL}], [${ATTR_TIMEPICKER_BUTTON_CLEAR}]`,\r\n      ({ target }) => {\r\n        const { closeModalOnBackdropClick } = this._options;\r\n\r\n        const runRemoveFunction = () => {\r\n          Manipulator.addStyle(this.elementToggle, {\r\n            pointerEvents: \"auto\",\r\n          });\r\n\r\n          if (this._animations) {\r\n            this._toggleBackdropAnimation(true);\r\n          }\r\n\r\n          this._removeModal();\r\n          this._focusTrap?.disable();\r\n          this._focusTrap = null;\r\n\r\n          if (this.elementToggle) {\r\n            this.elementToggle.focus();\r\n          } else if (this.input) {\r\n            this.input.focus();\r\n          }\r\n        };\r\n\r\n        if (target.hasAttribute(ATTR_TIMEPICKER_BUTTON_CLEAR)) {\r\n          this._toggleAmPm(\"PM\");\r\n          this.input.value = \"\";\r\n          this.input.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n\r\n          let checkInputValue;\r\n\r\n          if (takeValue(this.input)[0] === \"\") {\r\n            checkInputValue = [\"12\", \"00\", \"PM\"];\r\n          } else {\r\n            checkInputValue = takeValue(this.input);\r\n          }\r\n\r\n          const [hour, minute, format] = checkInputValue;\r\n          this._setTipsAndTimesDependOnInputValue(\"12\", \"00\");\r\n          this._setActiveClassToTipsOnOpen(hour, minute, format);\r\n          this._hour.click();\r\n        } else if (\r\n          target.hasAttribute(ATTR_TIMEPICKER_BUTTON_CANCEL) ||\r\n          target.hasAttribute(ATTR_TIMEPICKER_BUTTON_SUBMIT)\r\n        ) {\r\n          runRemoveFunction();\r\n        } else if (\r\n          target.hasAttribute(ATTR_TIMEPICKER_WRAPPER) &&\r\n          closeModalOnBackdropClick\r\n        ) {\r\n          runRemoveFunction();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  showValueInput() {\r\n    return this.input.value;\r\n  }\r\n\r\n  _handleOkButton() {\r\n    EventHandlerMulti.on(\r\n      this._modal,\r\n      \"click\",\r\n      `[${ATTR_TIMEPICKER_BUTTON_SUBMIT}]`,\r\n      () => {\r\n        let { maxTime, minTime } = this._options;\r\n        const {\r\n          format12,\r\n          format24,\r\n          readOnly,\r\n          focusInputAfterApprove,\r\n          disablePast,\r\n          disableFuture,\r\n        } = this._options;\r\n        const hourModeActive = this._document.querySelector(\r\n          `${SELECTOR_ATTR_TIMEPICKER_HOUR_MODE}[${ATTR_TIMEPICKER_ACTIVE}]`\r\n        );\r\n\r\n        const currentValue = `${this._hour.textContent}:${this._minutes.textContent}`;\r\n        const selectedHourContent = Number(this._hour.textContent);\r\n        const selectedHour =\r\n          selectedHourContent === 12 && format12 ? 0 : selectedHourContent;\r\n        const selectedMinutes = Number(this._minutes.textContent);\r\n\r\n        minTime = setMinTime(minTime, disablePast, format12);\r\n        maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n        let [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(\r\n          maxTime,\r\n          false\r\n        );\r\n        let [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(\r\n          minTime,\r\n          false\r\n        );\r\n\r\n        minTimeHour = minTimeHour === \"12\" && format12 ? \"00\" : minTimeHour;\r\n        maxTimeHour = maxTimeHour === \"12\" && format12 ? \"00\" : maxTimeHour;\r\n\r\n        const isHourLessThanMinHour = selectedHour < Number(minTimeHour);\r\n        const isHourGreaterThanMaxHour = selectedHour > Number(maxTimeHour);\r\n        let maxFormatAndCurrentFormatEqual = true;\r\n        if (hourModeActive) {\r\n          maxFormatAndCurrentFormatEqual =\r\n            maxTimeFormat === hourModeActive.textContent;\r\n        }\r\n\r\n        let minFormatAndCurrentFormatEqual = true;\r\n        if (hourModeActive) {\r\n          minFormatAndCurrentFormatEqual =\r\n            minTimeFormat === hourModeActive.textContent;\r\n        }\r\n\r\n        const hourEqualToMaxAndMinutesGreaterThanMax =\r\n          selectedMinutes > maxTimeMinutes &&\r\n          selectedHour === Number(maxTimeHour);\r\n        const hourEqualToMinAndMinutesLessThanMin =\r\n          selectedMinutes < minTimeMinutes &&\r\n          selectedHour === Number(minTimeHour);\r\n\r\n        this.input.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n        Manipulator.addStyle(this.elementToggle, {\r\n          pointerEvents: \"auto\",\r\n        });\r\n\r\n        if (maxTime !== \"\") {\r\n          if (\r\n            maxFormatAndCurrentFormatEqual &&\r\n            (isHourGreaterThanMaxHour || hourEqualToMaxAndMinutesGreaterThanMax)\r\n          ) {\r\n            return;\r\n          } else if (\r\n            maxTimeFormat === \"AM\" &&\r\n            hourModeActive.textContent === \"PM\"\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n        if (minTime !== \"\") {\r\n          if (\r\n            minFormatAndCurrentFormatEqual &&\r\n            (isHourLessThanMinHour || hourEqualToMinAndMinutesLessThanMin)\r\n          ) {\r\n            return;\r\n          }\r\n          if (minTimeFormat === \"PM\" && hourModeActive.textContent === \"AM\") {\r\n            return;\r\n          }\r\n        }\r\n\r\n        if (\r\n          checkValueBeforeAccept(\r\n            this._options,\r\n            this.input,\r\n            this._hour.textContent\r\n          ) === undefined\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        if (this._isInvalidTimeFormat) {\r\n          this.input.removeAttribute(ATTR_TIMEPICKER_IS_INVALID);\r\n        }\r\n\r\n        if (!readOnly && focusInputAfterApprove) {\r\n          this.input.focus();\r\n        }\r\n\r\n        Manipulator.addStyle(this.elementToggle, {\r\n          pointerEvents: \"auto\",\r\n        });\r\n\r\n        if (format24) {\r\n          this.input.value = currentValue;\r\n        } else if (hourModeActive === null) {\r\n          this.input.value = `${currentValue} PM`;\r\n        } else {\r\n          this.input.value = `${currentValue} ${hourModeActive.textContent}`;\r\n        }\r\n\r\n        if (this._animations) {\r\n          this._toggleBackdropAnimation(true);\r\n        }\r\n\r\n        this._removeModal();\r\n\r\n        EventHandler.trigger(this.input, \"input.te.timepicker\");\r\n        EventHandler.trigger(this.input, \"input\");\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleHoverInlineBtn() {\r\n    EventHandlerMulti.on(\r\n      this._modal,\r\n      \"mouseover mouseleave\",\r\n      `[${ATTR_TIMEPICKER_CURRENT_INLINE}]`,\r\n      ({ type, target }) => {\r\n        const allIconsInlineHour = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_ICON_INLINE_HOUR}]`,\r\n          this._modal\r\n        );\r\n        const allIconsInlineMinute = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_ICON_INLINE_MINUTE}]`,\r\n          this._modal\r\n        );\r\n\r\n        const modifyIcons = (elements, shouldAdd) => {\r\n          return elements.forEach((icon) => {\r\n            if (shouldAdd) {\r\n              Manipulator.addClass(icon, this._classes.opacity);\r\n              icon.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n              return;\r\n            }\r\n\r\n            Manipulator.removeClass(icon, this._classes.opacity);\r\n            icon.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n          });\r\n        };\r\n\r\n        const pickerHasHourAttr = target.hasAttribute(ATTR_TIMEPICKER_HOUR);\r\n        const iconElements = pickerHasHourAttr\r\n          ? allIconsInlineHour\r\n          : allIconsInlineMinute;\r\n\r\n        modifyIcons(iconElements, type === \"mouseover\");\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleDocumentClickInline() {\r\n    EventHandler.on(document, EVENT_CLICK_DATA_API, ({ target }) => {\r\n      if (\r\n        this._modal &&\r\n        !this._modal.contains(target) &&\r\n        !target.hasAttribute(ATTR_TIMEPICKER_ICON)\r\n      ) {\r\n        clearInterval(this._interval);\r\n        Manipulator.addStyle(this.elementToggle, {\r\n          pointerEvents: \"auto\",\r\n        });\r\n        this._removeModal();\r\n\r\n        if (!this._animations) return;\r\n\r\n        this._toggleBackdropAnimation(true);\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleSwitchHourMinute() {\r\n    toggleClassHandler(\r\n      \"click\",\r\n      SELECTOR_ATTR_TIMEPICKER_CURRENT,\r\n      this._classes\r\n    );\r\n\r\n    EventHandler.on(\r\n      this._modal,\r\n      \"click\",\r\n      SELECTOR_ATTR_TIMEPICKER_CURRENT,\r\n      () => {\r\n        const { format24 } = this._options;\r\n        const current = SelectorEngine.find(\r\n          SELECTOR_ATTR_TIMEPICKER_CURRENT,\r\n          this._modal\r\n        );\r\n        const allTipsMinutes = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,\r\n          this._modal\r\n        );\r\n        const allTipsHours = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n          this._modal\r\n        );\r\n        const allInnerTips = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n          this._modal\r\n        );\r\n        const hourValue = Number(this._hour.textContent);\r\n        const minuteValue = Number(this._minutes.textContent);\r\n\r\n        const switchTips = (array, classes) => {\r\n          allTipsHours.forEach((tip) => tip.remove());\r\n          allTipsMinutes.forEach((tip) => tip.remove());\r\n          Manipulator.addClass(this._hand, this._classes.transform);\r\n\r\n          setTimeout(() => {\r\n            Manipulator.removeClass(this._hand, this._classes.transform);\r\n          }, 401);\r\n\r\n          this._getAppendClock(array, `[${ATTR_TIMEPICKER_CLOCK}]`, classes);\r\n\r\n          const toggleActiveClass = () => {\r\n            const allTipsHours = SelectorEngine.find(\r\n              `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n              this._modal\r\n            );\r\n            const allTipsMinutes = SelectorEngine.find(\r\n              `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,\r\n              this._modal\r\n            );\r\n\r\n            this._addActiveClassToTip(allTipsHours, hourValue);\r\n            this._addActiveClassToTip(allTipsMinutes, minuteValue);\r\n          };\r\n\r\n          if (!format24) {\r\n            setTimeout(() => {\r\n              toggleActiveClass();\r\n            }, 401);\r\n          } else {\r\n            const allTipsInnerHours = SelectorEngine.find(\r\n              `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n              this._modal\r\n            );\r\n\r\n            setTimeout(() => {\r\n              this._addActiveClassToTip(allTipsInnerHours, hourValue);\r\n              toggleActiveClass();\r\n            }, 401);\r\n          }\r\n        };\r\n\r\n        current.forEach((e) => {\r\n          if (e.hasAttribute(ATTR_TIMEPICKER_ACTIVE)) {\r\n            if (e.hasAttribute(ATTR_TIMEPICKER_MINUTE)) {\r\n              Manipulator.addClass(this._hand, this._classes.transform);\r\n\r\n              Manipulator.addStyle(this._hand, {\r\n                transform: `rotateZ(${this._minutes.textContent * 6}deg)`,\r\n                height: \"calc(40% + 1px)\",\r\n              });\r\n\r\n              if (format24 && allInnerTips.length > 0) {\r\n                allInnerTips.forEach((innerTip) => innerTip.remove());\r\n              }\r\n              switchTips(\r\n                this.minutesArray,\r\n                ATTR_TIMEPICKER_TIPS_MINUTES,\r\n                allTipsMinutes\r\n              );\r\n              this._hour.style.pointerEvents = \"\";\r\n              this._minutes.style.pointerEvents = \"none\";\r\n            } else if (e.hasAttribute(ATTR_TIMEPICKER_HOUR)) {\r\n              Manipulator.addStyle(this._hand, {\r\n                transform: `rotateZ(${this._hour.textContent * 30}deg)`,\r\n              });\r\n\r\n              if (Number(this._hour.textContent) > 12) {\r\n                Manipulator.addStyle(this._hand, {\r\n                  transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,\r\n                  height: \"21.5%\",\r\n                });\r\n\r\n                if (Number(this._hour.textContent) > 12) {\r\n                  Manipulator.addStyle(this._hand, {\r\n                    height: \"21.5%\",\r\n                  });\r\n                }\r\n              } else {\r\n                Manipulator.addStyle(this._hand, {\r\n                  height: \"calc(40% + 1px)\",\r\n                });\r\n              }\r\n\r\n              if (format24) {\r\n                this._getAppendClock(\r\n                  this.innerHours,\r\n                  `[${ATTR_TIMEPICKER_CLOCK_INNER}]`,\r\n                  ATTR_TIMEPICKER_INNER_HOURS\r\n                );\r\n              }\r\n\r\n              if (allInnerTips.length > 0) {\r\n                allInnerTips.forEach((innerTip) => innerTip.remove());\r\n              }\r\n\r\n              switchTips(\r\n                this.hoursArray,\r\n                ATTR_TIMEPICKER_TIPS_HOURS,\r\n                allTipsHours\r\n              );\r\n\r\n              Manipulator.addStyle(this._hour, {\r\n                pointerEvents: \"none\",\r\n              });\r\n              Manipulator.addStyle(this._minutes, {\r\n                pointerEvents: \"\",\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleDisablingTipsMaxTime(\r\n    selectedFormat,\r\n    maxTimeFormat,\r\n    maxTimeMinutes,\r\n    maxTimeHour\r\n  ) {\r\n    if (!this._options.maxTime && !this._options.disableFuture) {\r\n      return;\r\n    }\r\n\r\n    const outerHoursTips = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`\r\n    );\r\n    const innerHoursTips = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_INNER_HOURS}]`\r\n    );\r\n    const allTipsMinutes = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n    );\r\n\r\n    if (!maxTimeFormat || maxTimeFormat === selectedFormat) {\r\n      _verifyMaxTimeHourAndAddDisabledClass(\r\n        innerHoursTips,\r\n        maxTimeHour,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n      _verifyMaxTimeHourAndAddDisabledClass(\r\n        outerHoursTips,\r\n        maxTimeHour,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n      _verifyMaxTimeMinutesTipsAndAddDisabledClass(\r\n        allTipsMinutes,\r\n        maxTimeMinutes,\r\n        maxTimeHour,\r\n        this._hour.textContent,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n      return;\r\n    }\r\n    if (maxTimeFormat === \"AM\" && selectedFormat === \"PM\") {\r\n      outerHoursTips.forEach((tip) => {\r\n        Manipulator.addClass(tip, this._classes.tipsDisabled);\r\n        tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n      });\r\n      allTipsMinutes.forEach((tip) => {\r\n        Manipulator.addClass(tip, this._classes.tipsDisabled);\r\n        tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n      });\r\n    }\r\n  }\r\n\r\n  _handleDisablingTipsMinTime(\r\n    selectedFormat,\r\n    minTimeFormat,\r\n    minTimeMinutes,\r\n    minTimeHour\r\n  ) {\r\n    if (!this._options.minTime && !this._options.disablePast) {\r\n      return;\r\n    }\r\n\r\n    const outerHoursTips = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`\r\n    );\r\n    const innerHoursTips = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_INNER_HOURS}]`\r\n    );\r\n    const allTipsMinutes = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n    );\r\n\r\n    if (!minTimeFormat || minTimeFormat === selectedFormat) {\r\n      _verifyMinTimeHourAndAddDisabledClass(\r\n        outerHoursTips,\r\n        minTimeHour,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n      _verifyMinTimeHourAndAddDisabledClass(\r\n        innerHoursTips,\r\n        minTimeHour,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n      _verifyMinTimeMinutesTipsAndAddDisabledClass(\r\n        allTipsMinutes,\r\n        minTimeMinutes,\r\n        minTimeHour,\r\n        this._hour.textContent,\r\n        this._classes,\r\n        this._options.format12\r\n      );\r\n    } else if (minTimeFormat === \"PM\" && selectedFormat === \"AM\") {\r\n      outerHoursTips.forEach((tip) => {\r\n        Manipulator.addClass(tip, this._classes.tipsDisabled);\r\n        tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n      });\r\n      allTipsMinutes.forEach((tip) => {\r\n        Manipulator.addClass(tip, this._classes.tipsDisabled);\r\n        tip.setAttribute(ATTR_TIMEPICKER_DISABLED, \"\");\r\n      });\r\n    }\r\n  }\r\n\r\n  _toggleAmPm = (enabled) => {\r\n    if (enabled === \"PM\") {\r\n      this._isPmEnabled = true;\r\n      this._isAmEnabled = false;\r\n    } else if (enabled === \"AM\") {\r\n      this._isPmEnabled = false;\r\n      this._isAmEnabled = true;\r\n    }\r\n  };\r\n\r\n  _handleSwitchTimeMode() {\r\n    EventHandler.on(\r\n      document,\r\n      \"click\",\r\n      SELECTOR_ATTR_TIMEPICKER_HOUR_MODE,\r\n      ({ target }) => {\r\n        let { maxTime, minTime } = this._options;\r\n        const { disablePast, disableFuture, format12 } = this._options;\r\n\r\n        minTime = setMinTime(minTime, disablePast, format12);\r\n        maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n        const [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(\r\n          maxTime,\r\n          false\r\n        );\r\n        const [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(\r\n          minTime,\r\n          false\r\n        );\r\n\r\n        const allTipsHour = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_TIPS_HOURS}]`\r\n        );\r\n        const allTipsMinutes = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n        );\r\n\r\n        const clearDisabledClassForAllTips = () => {\r\n          allTipsHour.forEach((tip) => {\r\n            Manipulator.removeClass(tip, this._classes.tipsDisabled);\r\n            tip.removeAttribute(ATTR_TIMEPICKER_DISABLED);\r\n          });\r\n\r\n          allTipsMinutes.forEach((tip) => {\r\n            Manipulator.removeClass(tip, this._classes.tipsDisabled);\r\n            tip.removeAttribute(ATTR_TIMEPICKER_DISABLED);\r\n          });\r\n        };\r\n\r\n        clearDisabledClassForAllTips();\r\n        this._handleDisablingTipsMinTime(\r\n          target.textContent,\r\n          minTimeFormat,\r\n          minTimeMinutes,\r\n          minTimeHour\r\n        );\r\n        this._handleDisablingTipsMaxTime(\r\n          target.textContent,\r\n          maxTimeFormat,\r\n          maxTimeMinutes,\r\n          maxTimeHour\r\n        );\r\n        this._toggleAmPm(target.textContent);\r\n        if (!target.hasAttribute(ATTR_TIMEPICKER_ACTIVE)) {\r\n          const allHoursMode = SelectorEngine.find(\r\n            SELECTOR_ATTR_TIMEPICKER_HOUR_MODE\r\n          );\r\n\r\n          allHoursMode.forEach((element) => {\r\n            if (element.hasAttribute(ATTR_TIMEPICKER_ACTIVE)) {\r\n              Manipulator.removeClass(element, this._classes.opacity);\r\n              element.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n            }\r\n          });\r\n\r\n          Manipulator.addClass(target, this._classes.opacity);\r\n          target.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  _handleClockClick() {\r\n    let { maxTime, minTime } = this._options;\r\n    const { disablePast, disableFuture, format12 } = this._options;\r\n\r\n    minTime = setMinTime(minTime, disablePast, format12);\r\n    maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n    const maxTimeFormat = takeValue(maxTime, false)[2];\r\n    const minTimeFormat = takeValue(minTime, false)[2];\r\n\r\n    const maxTimeHour = takeValue(maxTime, false)[0];\r\n    const minTimeHour = takeValue(minTime, false)[0];\r\n\r\n    const clockWrapper = SelectorEngine.findOne(\r\n      `[${ATTR_TIMEPICKER_CLOCK_WRAPPER}]`\r\n    );\r\n    EventHandlerMulti.on(\r\n      document,\r\n      `${EVENT_MOUSEDOWN_DATA_API} ${EVENT_MOUSEUP_DATA_API} ${EVENT_MOUSEMOVE_DATA_API} ${EVENT_MOUSELEAVE_DATA_API} ${EVENT_MOUSEOVER_DATA_API} ${EVENT_TOUCHSTART_DATA_API} ${EVENT_TOUCHMOVE_DATA_API} ${EVENT_TOUCHEND_DATA_API}`,\r\n      \"\",\r\n      (e) => {\r\n        if (!checkBrowser()) {\r\n          e.preventDefault();\r\n        }\r\n\r\n        const { type, target } = e;\r\n        const { closeModalOnMinutesClick, switchHoursToMinutesOnClick } =\r\n          this._options;\r\n        const minutes =\r\n          SelectorEngine.findOne(\r\n            `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,\r\n            this._modal\r\n          ) !== null;\r\n        const hours =\r\n          SelectorEngine.findOne(\r\n            `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n            this._modal\r\n          ) !== null;\r\n        const innerHours =\r\n          SelectorEngine.findOne(\r\n            `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n            this._modal\r\n          ) !== null;\r\n\r\n        const allTipsMinutes = SelectorEngine.find(\r\n          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,\r\n          this._modal\r\n        );\r\n\r\n        const mouseClick = findMousePosition(e, clockWrapper);\r\n        const radius = clockWrapper.offsetWidth / 2;\r\n\r\n        let rds = Math.atan2(mouseClick.y - radius, mouseClick.x - radius);\r\n        if (checkBrowser()) {\r\n          const touchClick = findMousePosition(e, clockWrapper, true);\r\n          rds = Math.atan2(touchClick.y - radius, touchClick.x - radius);\r\n        }\r\n\r\n        let xPos = null;\r\n        let yPos = null;\r\n        let elFromPoint = null;\r\n\r\n        if (\r\n          type === \"mousedown\" ||\r\n          type === \"mousemove\" ||\r\n          type === \"touchmove\" ||\r\n          type === \"touchstart\"\r\n        ) {\r\n          if (\r\n            type === \"mousedown\" ||\r\n            type === \"touchstart\" ||\r\n            type === \"touchmove\"\r\n          ) {\r\n            if (\r\n              this._hasTargetInnerClass(target) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_CLOCK_WRAPPER) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_CLOCK) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_TIPS_MINUTES) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_TIPS_HOURS) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_CIRCLE) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_HAND_POINTER) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_MIDDLE_DOT) ||\r\n              target.hasAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT)\r\n            ) {\r\n              this._isMouseMove = true;\r\n\r\n              if (checkBrowser() && e.touches) {\r\n                xPos = e.touches[0].clientX;\r\n                yPos = e.touches[0].clientY;\r\n                elFromPoint = document.elementFromPoint(xPos, yPos);\r\n              }\r\n            }\r\n          }\r\n        } else if (type === \"mouseup\" || type === \"touchend\") {\r\n          this._isMouseMove = false;\r\n\r\n          if (\r\n            this._hasTargetInnerClass(target) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_CLOCK) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_TIPS_HOURS) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_CIRCLE) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_HAND_POINTER) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_MIDDLE_DOT) ||\r\n            target.hasAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT)\r\n          ) {\r\n            if ((hours || innerHours) && switchHoursToMinutesOnClick) {\r\n              const isHourlessThanMinOrGreaterThanMax =\r\n                Number(this._hour.textContent) > maxTimeHour ||\r\n                Number(this._hour.textContent) < minTimeHour;\r\n              if (\r\n                this._options.format24 &&\r\n                maxTimeHour !== \"\" &&\r\n                minTimeHour !== \"\" &&\r\n                isHourlessThanMinOrGreaterThanMax\r\n              ) {\r\n                return;\r\n              } else if (\r\n                this._options.format24 &&\r\n                minTimeHour !== \"\" &&\r\n                Number(this._hour.textContent) < minTimeHour\r\n              ) {\r\n                return;\r\n              }\r\n            }\r\n            EventHandler.trigger(this._minutes, \"click\");\r\n          }\r\n\r\n          if (minutes && closeModalOnMinutesClick) {\r\n            const submitBtn = SelectorEngine.findOne(\r\n              `[${ATTR_TIMEPICKER_BUTTON_SUBMIT}]`,\r\n              this._modal\r\n            );\r\n            EventHandler.trigger(submitBtn, \"click\");\r\n          }\r\n        }\r\n\r\n        if (minutes) {\r\n          let minute;\r\n\r\n          const degrees = Math.trunc((rds * 180) / Math.PI) + 90;\r\n\r\n          const { degrees: minDegrees, minute: minTimeObj } =\r\n            this._makeMinutesDegrees(degrees, minute);\r\n\r\n          if (\r\n            this._handlerMaxMinMinutesOptions(minDegrees, minTimeObj) ===\r\n            undefined\r\n          ) {\r\n            return;\r\n          }\r\n\r\n          const { degrees: _degrees, minute: minuteTimes } =\r\n            this._handlerMaxMinMinutesOptions(minDegrees, minTimeObj);\r\n\r\n          if (this._isMouseMove) {\r\n            Manipulator.addStyle(this._hand, {\r\n              transform: `rotateZ(${_degrees}deg)`,\r\n            });\r\n\r\n            if (minuteTimes === undefined) {\r\n              return;\r\n            }\r\n\r\n            const changeMinutes = () => {\r\n              return minuteTimes >= 10 || minuteTimes === \"00\"\r\n                ? minuteTimes\r\n                : `0${minuteTimes}`;\r\n            };\r\n\r\n            this._minutes.textContent = changeMinutes();\r\n\r\n            this._toggleClassActive(\r\n              this.minutesArray,\r\n              this._minutes,\r\n              allTipsMinutes\r\n            );\r\n            this._toggleBackgroundColorCircle(\r\n              `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`\r\n            );\r\n\r\n            this._objWithDataOnChange.degreesMinutes = _degrees;\r\n            this._objWithDataOnChange.minutes = minuteTimes;\r\n          }\r\n        }\r\n\r\n        if (hours || innerHours) {\r\n          let hour;\r\n\r\n          let degrees = Math.trunc((rds * 180) / Math.PI) + 90;\r\n          degrees = Math.round(degrees / 30) * 30;\r\n\r\n          Manipulator.addStyle(this._circle, {\r\n            backgroundColor: \"#1976d2\",\r\n          });\r\n          if (this._makeHourDegrees(target, degrees, hour) === undefined) {\r\n            return;\r\n          }\r\n          const makeDegrees = () => {\r\n            if (checkBrowser() && degrees && elFromPoint) {\r\n              const { degrees: touchDegrees, hour: touchHours } =\r\n                this._makeHourDegrees(elFromPoint, degrees, hour);\r\n\r\n              return this._handleMoveHand(\r\n                elFromPoint,\r\n                touchHours,\r\n                touchDegrees\r\n              );\r\n            } else {\r\n              const { degrees: movedDegrees, hour: movedHours } =\r\n                this._makeHourDegrees(target, degrees, hour);\r\n\r\n              return this._handleMoveHand(target, movedHours, movedDegrees);\r\n            }\r\n          };\r\n\r\n          this._objWithDataOnChange.degreesHours = degrees;\r\n\r\n          if (\r\n            this._handlerMaxMinHoursOptions(\r\n              degrees,\r\n              maxTimeHour,\r\n              minTimeHour,\r\n              maxTimeFormat,\r\n              minTimeFormat,\r\n              e\r\n            )\r\n          ) {\r\n            makeDegrees();\r\n          }\r\n        }\r\n\r\n        e.stopPropagation();\r\n      }\r\n    );\r\n  }\r\n\r\n  _hasTargetInnerClass(target) {\r\n    return (\r\n      target.hasAttribute(ATTR_TIMEPICKER_CLOCK_INNER) ||\r\n      target.hasAttribute(ATTR_TIMEPICKER_INNER_HOURS) ||\r\n      target.hasAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT)\r\n    );\r\n  }\r\n\r\n  _handleMoveHand(target, hour, degrees) {\r\n    const allTipsHours = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,\r\n      this._modal\r\n    );\r\n    const allTipsInner = SelectorEngine.find(\r\n      `[${ATTR_TIMEPICKER_INNER_HOURS}]`,\r\n      this._modal\r\n    );\r\n\r\n    if (!this._isMouseMove) return;\r\n\r\n    if (this._hasTargetInnerClass(target)) {\r\n      Manipulator.addStyle(this._hand, {\r\n        height: \"21.5%\",\r\n      });\r\n    } else {\r\n      Manipulator.addStyle(this._hand, {\r\n        height: \"calc(40% + 1px)\",\r\n      });\r\n    }\r\n\r\n    Manipulator.addStyle(this._hand, {\r\n      transform: `rotateZ(${degrees}deg)`,\r\n    });\r\n\r\n    this._hour.textContent = hour >= 10 || hour === \"00\" ? hour : `0${hour}`;\r\n\r\n    this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);\r\n    this._toggleClassActive(this.innerHours, this._hour, allTipsInner);\r\n\r\n    this._objWithDataOnChange.hour =\r\n      hour >= 10 || hour === \"00\" ? hour : `0${hour}`;\r\n  }\r\n\r\n  _handlerMaxMinMinutesOptions(degrees, minute) {\r\n    let { maxTime, minTime } = this._options;\r\n    const { format12, increment, disablePast, disableFuture } = this._options;\r\n\r\n    minTime = setMinTime(minTime, disablePast, format12);\r\n    maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n    const maxMin = takeValue(maxTime, false)[1];\r\n    const minMin = takeValue(minTime, false)[1];\r\n    const maxHourTimeValue = takeValue(maxTime, false)[0];\r\n    const minHourTimeValue = takeValue(minTime, false)[0];\r\n    const minHourTime =\r\n      minHourTimeValue === \"12\" && format12 ? \"0\" : minHourTimeValue;\r\n    const maxHourTime =\r\n      maxHourTimeValue === \"12\" && format12 ? \"0\" : maxHourTimeValue;\r\n\r\n    const maxTimeFormat = takeValue(maxTime, false)[2];\r\n    const minTimeFormat = takeValue(minTime, false)[2];\r\n\r\n    const maxMinDegrees = maxMin !== \"\" ? maxMin * 6 : \"\";\r\n    const minMinDegrees = minMin !== \"\" ? minMin * 6 : \"\";\r\n\r\n    const selectedHourContent = Number(this._hour.textContent);\r\n    const selectedHour =\r\n      selectedHourContent === 12 && format12 ? 0 : selectedHourContent;\r\n\r\n    if (!maxTimeFormat && !minTimeFormat) {\r\n      if (maxTime !== \"\" && minTime !== \"\") {\r\n        if (\r\n          (Number(maxHourTime) === selectedHour && degrees > maxMinDegrees) ||\r\n          (Number(minHourTime) === selectedHour && degrees < minMinDegrees)\r\n        ) {\r\n          return degrees;\r\n        }\r\n      } else if (minTime !== \"\" && selectedHour <= Number(minHourTime)) {\r\n        if (degrees <= minMinDegrees - 6) {\r\n          return degrees;\r\n        }\r\n      } else if (maxTime !== \"\" && selectedHour >= Number(maxHourTime)) {\r\n        if (degrees >= maxMinDegrees + 6) {\r\n          return degrees;\r\n        }\r\n      }\r\n    } else {\r\n      // eslint-disable-next-line no-lonely-if\r\n      if (minTime !== \"\") {\r\n        if (minTimeFormat === \"PM\" && this._isAmEnabled) {\r\n          return;\r\n        }\r\n\r\n        if (minTimeFormat === \"PM\" && this._isPmEnabled) {\r\n          if (selectedHour < Number(minHourTime)) {\r\n            return;\r\n          }\r\n\r\n          if (selectedHour <= Number(minHourTime)) {\r\n            if (degrees <= minMinDegrees - 6) {\r\n              return degrees;\r\n            }\r\n          }\r\n        } else if (minTimeFormat === \"AM\" && this._isAmEnabled) {\r\n          if (selectedHour < Number(minHourTime)) {\r\n            return;\r\n          }\r\n\r\n          if (selectedHour <= Number(minHourTime)) {\r\n            if (degrees <= minMinDegrees - 6) {\r\n              return degrees;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (maxTime !== \"\") {\r\n        if (maxTimeFormat === \"AM\" && this._isPmEnabled) {\r\n          return;\r\n        }\r\n\r\n        if (maxTimeFormat === \"PM\" && this._isPmEnabled) {\r\n          if (selectedHour >= Number(maxHourTime)) {\r\n            if (degrees >= maxMinDegrees + 6) {\r\n              return degrees;\r\n            }\r\n          }\r\n        } else if (maxTimeFormat === \"AM\" && this._isAmEnabled) {\r\n          if (selectedHour >= Number(maxHourTime)) {\r\n            if (degrees >= maxMinDegrees + 6) {\r\n              return degrees;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (increment) {\r\n      degrees = Math.round(degrees / 30) * 30;\r\n    }\r\n\r\n    if (degrees < 0) {\r\n      degrees = 360 + degrees;\r\n    } else if (degrees >= 360) {\r\n      degrees = 0;\r\n    }\r\n\r\n    return {\r\n      degrees,\r\n      minute,\r\n    };\r\n  }\r\n\r\n  _removeModal() {\r\n    if (this._animations) {\r\n      setTimeout(() => {\r\n        this._removeModalElements();\r\n        this._scrollBar.reset();\r\n      }, 300);\r\n    } else {\r\n      this._removeModalElements();\r\n      this._scrollBar.reset();\r\n    }\r\n\r\n    EventHandlerMulti.off(\r\n      this._document,\r\n      `${EVENT_CLICK_DATA_API} ${EVENT_KEYDOWN_DATA_API} ${EVENT_MOUSEDOWN_DATA_API} ${EVENT_MOUSEUP_DATA_API} ${EVENT_MOUSEMOVE_DATA_API} ${EVENT_MOUSELEAVE_DATA_API} ${EVENT_MOUSEOVER_DATA_API} ${EVENT_TOUCHSTART_DATA_API} ${EVENT_TOUCHMOVE_DATA_API} ${EVENT_TOUCHEND_DATA_API}`\r\n    );\r\n    EventHandler.off(window, EVENT_KEYDOWN_DATA_API);\r\n  }\r\n\r\n  _removeModalElements() {\r\n    if (this._modal) this._modal.remove();\r\n  }\r\n\r\n  _toggleBackdropAnimation(isToRemove = false) {\r\n    if (isToRemove) {\r\n      this._wrapper.classList.add(\"animate-[fade-out_350ms_ease-in-out]\");\r\n    } else {\r\n      this._wrapper.classList.add(\"animate-[fade-in_350ms_ease-in-out]\");\r\n\r\n      if (!this._options.inline)\r\n        Manipulator.addClass(this._clock, this._classes.clockAnimation);\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this._wrapper.classList.remove(\r\n        \"animate-[fade-out_350ms_ease-in-out]\",\r\n        \"animate-[fade-in_350ms_ease-in-out]\"\r\n      );\r\n    }, 351);\r\n  }\r\n\r\n  _toggleBackgroundColorCircle = (classes) => {\r\n    const tips =\r\n      this._modal.querySelector(`${classes}[${ATTR_TIMEPICKER_ACTIVE}]`) !==\r\n      null;\r\n    if (tips) {\r\n      Manipulator.addStyle(this._circle, {\r\n        backgroundColor: \"#1976d2\",\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    Manipulator.addStyle(this._circle, {\r\n      backgroundColor: \"transparent\",\r\n    });\r\n  };\r\n\r\n  _toggleClassActive = (array, { textContent }, tips) => {\r\n    const findInArray = [...array].find(\r\n      (e) => Number(e) === Number(textContent)\r\n    );\r\n\r\n    return tips.forEach((e) => {\r\n      if (e.hasAttribute(ATTR_TIMEPICKER_DISABLED)) return;\r\n\r\n      if (e.textContent === findInArray) {\r\n        Manipulator.addClass(e, this._classes.tipsActive);\r\n        e.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n        return;\r\n      }\r\n\r\n      Manipulator.removeClass(e, this._classes.tipsActive);\r\n      e.removeAttribute(ATTR_TIMEPICKER_ACTIVE);\r\n    });\r\n  };\r\n\r\n  _addActiveClassToTip(tips, value) {\r\n    tips.forEach((tip) => {\r\n      if (Number(tip.textContent) === Number(value)) {\r\n        Manipulator.addClass(tip, this._classes.tipsActive);\r\n        tip.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n      }\r\n    });\r\n  }\r\n\r\n  _makeMinutesDegrees = (degrees, minute) => {\r\n    const { increment } = this._options;\r\n\r\n    if (degrees < 0) {\r\n      minute = Math.round(360 + degrees / 6) % 60;\r\n      degrees = 360 + Math.round(degrees / 6) * 6;\r\n    } else {\r\n      minute = Math.round(degrees / 6) % 60;\r\n      degrees = Math.round(degrees / 6) * 6;\r\n    }\r\n\r\n    if (increment) {\r\n      degrees = Math.round(degrees / 30) * 30;\r\n      minute = (Math.round(degrees / 6) * 6) / 6;\r\n\r\n      if (minute === 60) {\r\n        minute = \"00\";\r\n      }\r\n    }\r\n\r\n    if (degrees >= 360) {\r\n      degrees = 0;\r\n    }\r\n\r\n    return {\r\n      degrees,\r\n      minute,\r\n      addDegrees: increment ? 30 : 6,\r\n    };\r\n  };\r\n\r\n  _makeHourDegrees = (target, degrees, hour) => {\r\n    if (!target) {\r\n      return;\r\n    }\r\n    if (this._hasTargetInnerClass(target)) {\r\n      if (degrees < 0) {\r\n        hour = Math.round(360 + degrees / 30) % 24;\r\n        degrees = 360 + degrees;\r\n      } else {\r\n        hour = Math.round(degrees / 30) + 12;\r\n        if (hour === 12) {\r\n          hour = \"00\";\r\n        }\r\n      }\r\n    } else if (degrees < 0) {\r\n      hour = Math.round(360 + degrees / 30) % 12;\r\n      degrees = 360 + degrees;\r\n    } else {\r\n      hour = Math.round(degrees / 30) % 12;\r\n      if (hour === 0 || hour > 12) {\r\n        hour = 12;\r\n      }\r\n    }\r\n\r\n    if (degrees >= 360) {\r\n      degrees = 0;\r\n    }\r\n\r\n    return {\r\n      degrees,\r\n      hour,\r\n      addDegrees: 30,\r\n    };\r\n  };\r\n\r\n  _makeInnerHoursDegrees = (degrees, hour) => {\r\n    if (degrees < 0) {\r\n      hour = Math.round(360 + degrees / 30) % 24;\r\n      degrees = 360 + degrees;\r\n    } else {\r\n      hour = Math.round(degrees / 30) + 12;\r\n      if (hour === 12) {\r\n        hour = \"00\";\r\n      }\r\n    }\r\n\r\n    return {\r\n      degrees,\r\n      hour,\r\n      addDegrees: 30,\r\n    };\r\n  };\r\n\r\n  _setHourOrMinute(number) {\r\n    return number < 10 ? `0${number}` : number;\r\n  }\r\n\r\n  _appendTimes() {\r\n    const { format24 } = this._options;\r\n\r\n    if (format24) {\r\n      this._getAppendClock(\r\n        this.hoursArray,\r\n        `[${ATTR_TIMEPICKER_CLOCK}]`,\r\n        ATTR_TIMEPICKER_TIPS_HOURS\r\n      );\r\n      this._getAppendClock(\r\n        this.innerHours,\r\n        `[${ATTR_TIMEPICKER_CLOCK_INNER}]`,\r\n        ATTR_TIMEPICKER_INNER_HOURS\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    this._getAppendClock(\r\n      this.hoursArray,\r\n      `[${ATTR_TIMEPICKER_CLOCK}]`,\r\n      ATTR_TIMEPICKER_TIPS_HOURS\r\n    );\r\n  }\r\n\r\n  _getAppendClock = (\r\n    array = [],\r\n    clockClass = `[${ATTR_TIMEPICKER_CLOCK}]`,\r\n    tipsClass\r\n  ) => {\r\n    let { minTime, maxTime } = this._options;\r\n    const { inline, format12, disablePast, disableFuture } = this._options;\r\n\r\n    minTime = setMinTime(minTime, disablePast, format12);\r\n    maxTime = setMaxTime(maxTime, disableFuture, format12);\r\n\r\n    const [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(\r\n      maxTime,\r\n      false\r\n    );\r\n    const [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(\r\n      minTime,\r\n      false\r\n    );\r\n\r\n    // fix for append clock for max/min if input has invalid  value\r\n    if (\r\n      !inline &&\r\n      format12 &&\r\n      this._isInvalidTimeFormat &&\r\n      !this._AM.hasAttribute(ATTR_TIMEPICKER_ACTIVE)\r\n    ) {\r\n      Manipulator.addClass(this._PM, this._classes.opacity);\r\n      this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE, \"\");\r\n    }\r\n\r\n    const clock = SelectorEngine.findOne(clockClass);\r\n\r\n    const elements = 360 / array.length;\r\n\r\n    function rad(el) {\r\n      return el * (Math.PI / 180);\r\n    }\r\n\r\n    if (clock === null) return;\r\n\r\n    const clockWidth = (clock.offsetWidth - 32) / 2;\r\n    const clockHeight = (clock.offsetHeight - 32) / 2;\r\n    const radius = clockWidth - 4;\r\n\r\n    setTimeout(() => {\r\n      let currentFormat;\r\n      if (format12) {\r\n        currentFormat = SelectorEngine.findOne(\r\n          `${SELECTOR_ATTR_TIMEPICKER_HOUR_MODE}[${ATTR_TIMEPICKER_ACTIVE}]`\r\n        ).textContent;\r\n      }\r\n      this._handleDisablingTipsMinTime(\r\n        currentFormat,\r\n        minTimeFormat,\r\n        minTimeMinutes,\r\n        minTimeHour\r\n      );\r\n      this._handleDisablingTipsMaxTime(\r\n        currentFormat,\r\n        maxTimeFormat,\r\n        maxTimeMinutes,\r\n        maxTimeHour\r\n      );\r\n    }, 0);\r\n\r\n    [...array].forEach((e, i) => {\r\n      const angle = rad(i * elements);\r\n\r\n      const span = element(\"span\");\r\n      const spanToTips = element(\"span\");\r\n\r\n      spanToTips.innerHTML = e;\r\n      Manipulator.addClass(span, this._classes.tips);\r\n      span.setAttribute(tipsClass, \"\");\r\n\r\n      const itemWidth = span.offsetWidth;\r\n      const itemHeight = span.offsetHeight;\r\n\r\n      Manipulator.addStyle(span, {\r\n        left: `${clockWidth + Math.sin(angle) * radius - itemWidth}px`,\r\n        bottom: `${clockHeight + Math.cos(angle) * radius - itemHeight}px`,\r\n      });\r\n\r\n      if (array.includes(\"05\")) {\r\n        span.setAttribute(ATTR_TIMEPICKER_TIPS_MINUTES, \"\");\r\n      }\r\n\r\n      if (array.includes(\"13\")) {\r\n        spanToTips.setAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT, \"\");\r\n      } else {\r\n        spanToTips.setAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT, \"\");\r\n      }\r\n\r\n      span.appendChild(spanToTips);\r\n      return clock.appendChild(span);\r\n    });\r\n  };\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getContainer() {\r\n    return SelectorEngine.findOne(this._options.container);\r\n  }\r\n\r\n  _getValidate(event) {\r\n    const { invalidLabel, format24, format12, appendValidationInfo } =\r\n      this._options;\r\n    let inValidDiv;\r\n\r\n    if (appendValidationInfo) {\r\n      inValidDiv = element(\"div\");\r\n      inValidDiv.setAttribute(ATTR_TIMEPICKER_INVALID_FEEDBACK, \"\");\r\n      inValidDiv.innerHTML = invalidLabel;\r\n    }\r\n\r\n    EventHandlerMulti.on(this.input, event, ({ target }) => {\r\n      if (this._options === null || this.input.value === \"\") return;\r\n\r\n      const regexAMFormat = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/;\r\n      const regexNormalFormat = /^([01]\\d|2[0-3])(:[0-5]\\d)$/;\r\n      const testedAMRegex = regexAMFormat.test(target.value);\r\n      const testedNormalRegex = regexNormalFormat.test(target.value);\r\n\r\n      if (\r\n        (testedNormalRegex !== true && format24) ||\r\n        (testedAMRegex !== true && format12)\r\n      ) {\r\n        if (appendValidationInfo) {\r\n          this.input.setAttribute(ATTR_TIMEPICKER_IS_INVALID, \"\");\r\n\r\n          this.input.parentNode.insertBefore(\r\n            inValidDiv,\r\n            this.input.nextSibling\r\n          );\r\n        }\r\n\r\n        Manipulator.addStyle(target, { marginBottom: 0 });\r\n        Manipulator.addStyle(inValidDiv, { bottom: \"-23px\" });\r\n\r\n        this._isInvalidTimeFormat = true;\r\n        return;\r\n      }\r\n\r\n      this.input.removeAttribute(ATTR_TIMEPICKER_IS_INVALID);\r\n      this._isInvalidTimeFormat = false;\r\n      const allInvalid = SelectorEngine.findOne(\r\n        `[${ATTR_TIMEPICKER_INVALID_FEEDBACK}]`\r\n      );\r\n\r\n      if (allInvalid === null) return;\r\n\r\n      allInvalid.remove();\r\n    });\r\n  }\r\n\r\n  // Static\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Timepicker;\r\n","/*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */\n\nfunction get(element) {\n  return getComputedStyle(element);\n}\n\nfunction set(element, obj) {\n  for (var key in obj) {\n    var val = obj[key];\n    if (typeof val === 'number') {\n      val = val + \"px\";\n    }\n    element.style[key] = val;\n  }\n  return element;\n}\n\nfunction div(className) {\n  var div = document.createElement('div');\n  div.className = className;\n  return div;\n}\n\nvar elMatches =\n  typeof Element !== 'undefined' &&\n  (Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector);\n\nfunction matches(element, query) {\n  if (!elMatches) {\n    throw new Error('No element matching method supported');\n  }\n\n  return elMatches.call(element, query);\n}\n\nfunction remove(element) {\n  if (element.remove) {\n    element.remove();\n  } else {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n}\n\nfunction queryChildren(element, selector) {\n  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }\n  );\n}\n\nvar cls = {\n  main: 'ps',\n  rtl: 'ps__rtl',\n  element: {\n    thumb: function (x) { return (\"ps__thumb-\" + x); },\n    rail: function (x) { return (\"ps__rail-\" + x); },\n    consuming: 'ps__child--consume',\n  },\n  state: {\n    focus: 'ps--focus',\n    clicking: 'ps--clicking',\n    active: function (x) { return (\"ps--active-\" + x); },\n    scrolling: function (x) { return (\"ps--scrolling-\" + x); },\n  },\n};\n\n/*\n * Helper methods\n */\nvar scrollingClassTimeout = { x: null, y: null };\n\nfunction addScrollingClass(i, x) {\n  var classList = i.element.classList;\n  var className = cls.state.scrolling(x);\n\n  if (classList.contains(className)) {\n    clearTimeout(scrollingClassTimeout[x]);\n  } else {\n    classList.add(className);\n  }\n}\n\nfunction removeScrollingClass(i, x) {\n  scrollingClassTimeout[x] = setTimeout(\n    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },\n    i.settings.scrollingThreshold\n  );\n}\n\nfunction setScrollingClassInstantly(i, x) {\n  addScrollingClass(i, x);\n  removeScrollingClass(i, x);\n}\n\nvar EventElement = function EventElement(element) {\n  this.element = element;\n  this.handlers = {};\n};\n\nvar prototypeAccessors = { isEmpty: { configurable: true } };\n\nEventElement.prototype.bind = function bind (eventName, handler) {\n  if (typeof this.handlers[eventName] === 'undefined') {\n    this.handlers[eventName] = [];\n  }\n  this.handlers[eventName].push(handler);\n  this.element.addEventListener(eventName, handler, false);\n};\n\nEventElement.prototype.unbind = function unbind (eventName, target) {\n    var this$1 = this;\n\n  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {\n    if (target && handler !== target) {\n      return true;\n    }\n    this$1.element.removeEventListener(eventName, handler, false);\n    return false;\n  });\n};\n\nEventElement.prototype.unbindAll = function unbindAll () {\n  for (var name in this.handlers) {\n    this.unbind(name);\n  }\n};\n\nprototypeAccessors.isEmpty.get = function () {\n    var this$1 = this;\n\n  return Object.keys(this.handlers).every(\n    function (key) { return this$1.handlers[key].length === 0; }\n  );\n};\n\nObject.defineProperties( EventElement.prototype, prototypeAccessors );\n\nvar EventManager = function EventManager() {\n  this.eventElements = [];\n};\n\nEventManager.prototype.eventElement = function eventElement (element) {\n  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];\n  if (!ee) {\n    ee = new EventElement(element);\n    this.eventElements.push(ee);\n  }\n  return ee;\n};\n\nEventManager.prototype.bind = function bind (element, eventName, handler) {\n  this.eventElement(element).bind(eventName, handler);\n};\n\nEventManager.prototype.unbind = function unbind (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  ee.unbind(eventName, handler);\n\n  if (ee.isEmpty) {\n    // remove\n    this.eventElements.splice(this.eventElements.indexOf(ee), 1);\n  }\n};\n\nEventManager.prototype.unbindAll = function unbindAll () {\n  this.eventElements.forEach(function (e) { return e.unbindAll(); });\n  this.eventElements = [];\n};\n\nEventManager.prototype.once = function once (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  var onceHandler = function (evt) {\n    ee.unbind(eventName, onceHandler);\n    handler(evt);\n  };\n  ee.bind(eventName, onceHandler);\n};\n\nfunction createEvent(name) {\n  if (typeof window.CustomEvent === 'function') {\n    return new CustomEvent(name);\n  } else {\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(name, false, false, undefined);\n    return evt;\n  }\n}\n\nfunction processScrollDiff(\n  i,\n  axis,\n  diff,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var fields;\n  if (axis === 'top') {\n    fields = [\n      'contentHeight',\n      'containerHeight',\n      'scrollTop',\n      'y',\n      'up',\n      'down' ];\n  } else if (axis === 'left') {\n    fields = [\n      'contentWidth',\n      'containerWidth',\n      'scrollLeft',\n      'x',\n      'left',\n      'right' ];\n  } else {\n    throw new Error('A proper axis should be provided');\n  }\n\n  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);\n}\n\nfunction processScrollDiff$1(\n  i,\n  diff,\n  ref,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  var contentHeight = ref[0];\n  var containerHeight = ref[1];\n  var scrollTop = ref[2];\n  var y = ref[3];\n  var up = ref[4];\n  var down = ref[5];\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var element = i.element;\n\n  // reset reach\n  i.reach[y] = null;\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] < 1) {\n    i.reach[y] = 'start';\n  }\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {\n    i.reach[y] = 'end';\n  }\n\n  if (diff) {\n    element.dispatchEvent(createEvent((\"ps-scroll-\" + y)));\n\n    if (diff < 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + up)));\n    } else if (diff > 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + down)));\n    }\n\n    if (useScrollingClass) {\n      setScrollingClassInstantly(i, y);\n    }\n  }\n\n  if (i.reach[y] && (diff || forceFireReachEvent)) {\n    element.dispatchEvent(createEvent((\"ps-\" + y + \"-reach-\" + (i.reach[y]))));\n  }\n}\n\nfunction toInt(x) {\n  return parseInt(x, 10) || 0;\n}\n\nfunction isEditable(el) {\n  return (\n    matches(el, 'input,[contenteditable]') ||\n    matches(el, 'select,[contenteditable]') ||\n    matches(el, 'textarea,[contenteditable]') ||\n    matches(el, 'button,[contenteditable]')\n  );\n}\n\nfunction outerWidth(element) {\n  var styles = get(element);\n  return (\n    toInt(styles.width) +\n    toInt(styles.paddingLeft) +\n    toInt(styles.paddingRight) +\n    toInt(styles.borderLeftWidth) +\n    toInt(styles.borderRightWidth)\n  );\n}\n\nvar env = {\n  isWebKit:\n    typeof document !== 'undefined' &&\n    'WebkitAppearance' in document.documentElement.style,\n  supportsTouch:\n    typeof window !== 'undefined' &&\n    ('ontouchstart' in window ||\n      ('maxTouchPoints' in window.navigator &&\n        window.navigator.maxTouchPoints > 0) ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)),\n  supportsIePointer:\n    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,\n  isChrome:\n    typeof navigator !== 'undefined' &&\n    /Chrome/i.test(navigator && navigator.userAgent),\n};\n\nfunction updateGeometry(i) {\n  var element = i.element;\n  var roundedScrollTop = Math.floor(element.scrollTop);\n  var rect = element.getBoundingClientRect();\n\n  i.containerWidth = Math.round(rect.width);\n  i.containerHeight = Math.round(rect.height);\n\n  i.contentWidth = element.scrollWidth;\n  i.contentHeight = element.scrollHeight;\n\n  if (!element.contains(i.scrollbarXRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarXRail);\n  }\n  if (!element.contains(i.scrollbarYRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarYRail);\n  }\n\n  if (\n    !i.settings.suppressScrollX &&\n    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth\n  ) {\n    i.scrollbarXActive = true;\n    i.railXWidth = i.containerWidth - i.railXMarginWidth;\n    i.railXRatio = i.containerWidth / i.railXWidth;\n    i.scrollbarXWidth = getThumbSize(\n      i,\n      toInt((i.railXWidth * i.containerWidth) / i.contentWidth)\n    );\n    i.scrollbarXLeft = toInt(\n      ((i.negativeScrollAdjustment + element.scrollLeft) *\n        (i.railXWidth - i.scrollbarXWidth)) /\n        (i.contentWidth - i.containerWidth)\n    );\n  } else {\n    i.scrollbarXActive = false;\n  }\n\n  if (\n    !i.settings.suppressScrollY &&\n    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight\n  ) {\n    i.scrollbarYActive = true;\n    i.railYHeight = i.containerHeight - i.railYMarginHeight;\n    i.railYRatio = i.containerHeight / i.railYHeight;\n    i.scrollbarYHeight = getThumbSize(\n      i,\n      toInt((i.railYHeight * i.containerHeight) / i.contentHeight)\n    );\n    i.scrollbarYTop = toInt(\n      (roundedScrollTop * (i.railYHeight - i.scrollbarYHeight)) /\n        (i.contentHeight - i.containerHeight)\n    );\n  } else {\n    i.scrollbarYActive = false;\n  }\n\n  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {\n    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;\n  }\n  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {\n    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;\n  }\n\n  updateCss(element, i);\n\n  if (i.scrollbarXActive) {\n    element.classList.add(cls.state.active('x'));\n  } else {\n    element.classList.remove(cls.state.active('x'));\n    i.scrollbarXWidth = 0;\n    i.scrollbarXLeft = 0;\n    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;\n  }\n  if (i.scrollbarYActive) {\n    element.classList.add(cls.state.active('y'));\n  } else {\n    element.classList.remove(cls.state.active('y'));\n    i.scrollbarYHeight = 0;\n    i.scrollbarYTop = 0;\n    element.scrollTop = 0;\n  }\n}\n\nfunction getThumbSize(i, thumbSize) {\n  if (i.settings.minScrollbarLength) {\n    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);\n  }\n  if (i.settings.maxScrollbarLength) {\n    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);\n  }\n  return thumbSize;\n}\n\nfunction updateCss(element, i) {\n  var xRailOffset = { width: i.railXWidth };\n  var roundedScrollTop = Math.floor(element.scrollTop);\n\n  if (i.isRtl) {\n    xRailOffset.left =\n      i.negativeScrollAdjustment +\n      element.scrollLeft +\n      i.containerWidth -\n      i.contentWidth;\n  } else {\n    xRailOffset.left = element.scrollLeft;\n  }\n  if (i.isScrollbarXUsingBottom) {\n    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;\n  } else {\n    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;\n  }\n  set(i.scrollbarXRail, xRailOffset);\n\n  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };\n  if (i.isScrollbarYUsingRight) {\n    if (i.isRtl) {\n      yRailOffset.right =\n        i.contentWidth -\n        (i.negativeScrollAdjustment + element.scrollLeft) -\n        i.scrollbarYRight -\n        i.scrollbarYOuterWidth -\n        9;\n    } else {\n      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;\n    }\n  } else {\n    if (i.isRtl) {\n      yRailOffset.left =\n        i.negativeScrollAdjustment +\n        element.scrollLeft +\n        i.containerWidth * 2 -\n        i.contentWidth -\n        i.scrollbarYLeft -\n        i.scrollbarYOuterWidth;\n    } else {\n      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;\n    }\n  }\n  set(i.scrollbarYRail, yRailOffset);\n\n  set(i.scrollbarX, {\n    left: i.scrollbarXLeft,\n    width: i.scrollbarXWidth - i.railBorderXWidth,\n  });\n  set(i.scrollbarY, {\n    top: i.scrollbarYTop,\n    height: i.scrollbarYHeight - i.railBorderYWidth,\n  });\n}\n\nfunction clickRail(i) {\n  var element = i.element;\n\n  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {\n    var positionTop =\n      e.pageY -\n      window.pageYOffset -\n      i.scrollbarYRail.getBoundingClientRect().top;\n    var direction = positionTop > i.scrollbarYTop ? 1 : -1;\n\n    i.element.scrollTop += direction * i.containerHeight;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n\n  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {\n    var positionLeft =\n      e.pageX -\n      window.pageXOffset -\n      i.scrollbarXRail.getBoundingClientRect().left;\n    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;\n\n    i.element.scrollLeft += direction * i.containerWidth;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n}\n\nfunction dragThumb(i) {\n  bindMouseScrollHandler(i, [\n    'containerWidth',\n    'contentWidth',\n    'pageX',\n    'railXWidth',\n    'scrollbarX',\n    'scrollbarXWidth',\n    'scrollLeft',\n    'x',\n    'scrollbarXRail' ]);\n  bindMouseScrollHandler(i, [\n    'containerHeight',\n    'contentHeight',\n    'pageY',\n    'railYHeight',\n    'scrollbarY',\n    'scrollbarYHeight',\n    'scrollTop',\n    'y',\n    'scrollbarYRail' ]);\n}\n\nfunction bindMouseScrollHandler(\n  i,\n  ref\n) {\n  var containerHeight = ref[0];\n  var contentHeight = ref[1];\n  var pageY = ref[2];\n  var railYHeight = ref[3];\n  var scrollbarY = ref[4];\n  var scrollbarYHeight = ref[5];\n  var scrollTop = ref[6];\n  var y = ref[7];\n  var scrollbarYRail = ref[8];\n\n  var element = i.element;\n\n  var startingScrollTop = null;\n  var startingMousePageY = null;\n  var scrollBy = null;\n\n  function mouseMoveHandler(e) {\n    if (e.touches && e.touches[0]) {\n      e[pageY] = e.touches[0].pageY;\n    }\n    element[scrollTop] =\n      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);\n    addScrollingClass(i, y);\n    updateGeometry(i);\n\n    e.stopPropagation();\n    if (e.type.startsWith('touch') && e.changedTouches.length > 1) {\n      e.preventDefault();\n    }\n  }\n\n  function mouseUpHandler() {\n    removeScrollingClass(i, y);\n    i[scrollbarYRail].classList.remove(cls.state.clicking);\n    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n  }\n\n  function bindMoves(e, touchMode) {\n    startingScrollTop = element[scrollTop];\n    if (touchMode && e.touches) {\n      e[pageY] = e.touches[0].pageY;\n    }\n    startingMousePageY = e[pageY];\n    scrollBy =\n      (i[contentHeight] - i[containerHeight]) /\n      (i[railYHeight] - i[scrollbarYHeight]);\n    if (!touchMode) {\n      i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n      i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);\n      e.preventDefault();\n    } else {\n      i.event.bind(i.ownerDocument, 'touchmove', mouseMoveHandler);\n    }\n\n    i[scrollbarYRail].classList.add(cls.state.clicking);\n\n    e.stopPropagation();\n  }\n\n  i.event.bind(i[scrollbarY], 'mousedown', function (e) {\n    bindMoves(e);\n  });\n  i.event.bind(i[scrollbarY], 'touchstart', function (e) {\n    bindMoves(e, true);\n  });\n}\n\nfunction keyboard(i) {\n  var element = i.element;\n\n  var elementHovered = function () { return matches(element, ':hover'); };\n  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    if (deltaX === 0) {\n      if (!i.scrollbarYActive) {\n        return false;\n      }\n      if (\n        (scrollTop === 0 && deltaY > 0) ||\n        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n\n    var scrollLeft = element.scrollLeft;\n    if (deltaY === 0) {\n      if (!i.scrollbarXActive) {\n        return false;\n      }\n      if (\n        (scrollLeft === 0 && deltaX < 0) ||\n        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n    return true;\n  }\n\n  i.event.bind(i.ownerDocument, 'keydown', function (e) {\n    if (\n      (e.isDefaultPrevented && e.isDefaultPrevented()) ||\n      e.defaultPrevented\n    ) {\n      return;\n    }\n\n    if (!elementHovered() && !scrollbarFocused()) {\n      return;\n    }\n\n    var activeElement = document.activeElement\n      ? document.activeElement\n      : i.ownerDocument.activeElement;\n    if (activeElement) {\n      if (activeElement.tagName === 'IFRAME') {\n        activeElement = activeElement.contentDocument.activeElement;\n      } else {\n        // go deeper if element is a webcomponent\n        while (activeElement.shadowRoot) {\n          activeElement = activeElement.shadowRoot.activeElement;\n        }\n      }\n      if (isEditable(activeElement)) {\n        return;\n      }\n    }\n\n    var deltaX = 0;\n    var deltaY = 0;\n\n    switch (e.which) {\n      case 37: // left\n        if (e.metaKey) {\n          deltaX = -i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = -i.containerWidth;\n        } else {\n          deltaX = -30;\n        }\n        break;\n      case 38: // up\n        if (e.metaKey) {\n          deltaY = i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = 30;\n        }\n        break;\n      case 39: // right\n        if (e.metaKey) {\n          deltaX = i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = i.containerWidth;\n        } else {\n          deltaX = 30;\n        }\n        break;\n      case 40: // down\n        if (e.metaKey) {\n          deltaY = -i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = -i.containerHeight;\n        } else {\n          deltaY = -30;\n        }\n        break;\n      case 32: // space bar\n        if (e.shiftKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = -i.containerHeight;\n        }\n        break;\n      case 33: // page up\n        deltaY = i.containerHeight;\n        break;\n      case 34: // page down\n        deltaY = -i.containerHeight;\n        break;\n      case 36: // home\n        deltaY = i.contentHeight;\n        break;\n      case 35: // end\n        deltaY = -i.contentHeight;\n        break;\n      default:\n        return;\n    }\n\n    if (i.settings.suppressScrollX && deltaX !== 0) {\n      return;\n    }\n    if (i.settings.suppressScrollY && deltaY !== 0) {\n      return;\n    }\n\n    element.scrollTop -= deltaY;\n    element.scrollLeft += deltaX;\n    updateGeometry(i);\n\n    if (shouldPreventDefault(deltaX, deltaY)) {\n      e.preventDefault();\n    }\n  });\n}\n\nfunction wheel(i) {\n  var element = i.element;\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var roundedScrollTop = Math.floor(element.scrollTop);\n    var isTop = element.scrollTop === 0;\n    var isBottom =\n      roundedScrollTop + element.offsetHeight === element.scrollHeight;\n    var isLeft = element.scrollLeft === 0;\n    var isRight =\n      element.scrollLeft + element.offsetWidth === element.scrollWidth;\n\n    var hitsBound;\n\n    // pick axis with primary direction\n    if (Math.abs(deltaY) > Math.abs(deltaX)) {\n      hitsBound = isTop || isBottom;\n    } else {\n      hitsBound = isLeft || isRight;\n    }\n\n    return hitsBound ? !i.settings.wheelPropagation : true;\n  }\n\n  function getDeltaFromEvent(e) {\n    var deltaX = e.deltaX;\n    var deltaY = -1 * e.deltaY;\n\n    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {\n      // OS X Safari\n      deltaX = (-1 * e.wheelDeltaX) / 6;\n      deltaY = e.wheelDeltaY / 6;\n    }\n\n    if (e.deltaMode && e.deltaMode === 1) {\n      // Firefox in deltaMode 1: Line scrolling\n      deltaX *= 10;\n      deltaY *= 10;\n    }\n\n    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {\n      // IE in some mouse drivers\n      deltaX = 0;\n      deltaY = e.wheelDelta;\n    }\n\n    if (e.shiftKey) {\n      // reverse axis with shift key\n      return [-deltaY, -deltaX];\n    }\n    return [deltaX, deltaY];\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    // FIXME: this is a workaround for <select> issue in FF and IE #571\n    if (!env.isWebKit && element.querySelector('select:focus')) {\n      return true;\n    }\n\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n\n      // if deltaY && vertical scrollable\n      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            (cursor.scrollTop > 0 && deltaY < 0) ||\n            (cursor.scrollTop < maxScrollTop && deltaY > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n      // if deltaX && horizontal scrollable\n      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {\n        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            (cursor.scrollLeft > 0 && deltaX < 0) ||\n            (cursor.scrollLeft < maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function mousewheelHandler(e) {\n    var ref = getDeltaFromEvent(e);\n    var deltaX = ref[0];\n    var deltaY = ref[1];\n\n    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {\n      return;\n    }\n\n    var shouldPrevent = false;\n    if (!i.settings.useBothWheelAxes) {\n      // deltaX will only be used for horizontal scrolling and deltaY will\n      // only be used for vertical scrolling - this is the default\n      element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      element.scrollLeft += deltaX * i.settings.wheelSpeed;\n    } else if (i.scrollbarYActive && !i.scrollbarXActive) {\n      // only vertical scrollbar is active and useBothWheelAxes option is\n      // active, so let's scroll vertical bar using both mouse wheel axes\n      if (deltaY) {\n        element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      } else {\n        element.scrollTop += deltaX * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    } else if (i.scrollbarXActive && !i.scrollbarYActive) {\n      // useBothWheelAxes and only horizontal bar is active, so use both\n      // wheel axes for horizontal bar\n      if (deltaX) {\n        element.scrollLeft += deltaX * i.settings.wheelSpeed;\n      } else {\n        element.scrollLeft -= deltaY * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    }\n\n    updateGeometry(i);\n\n    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);\n    if (shouldPrevent && !e.ctrlKey) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  }\n\n  if (typeof window.onwheel !== 'undefined') {\n    i.event.bind(element, 'wheel', mousewheelHandler);\n  } else if (typeof window.onmousewheel !== 'undefined') {\n    i.event.bind(element, 'mousewheel', mousewheelHandler);\n  }\n}\n\nfunction touch(i) {\n  if (!env.supportsTouch && !env.supportsIePointer) {\n    return;\n  }\n\n  var element = i.element;\n\n  function shouldPrevent(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    var scrollLeft = element.scrollLeft;\n    var magnitudeX = Math.abs(deltaX);\n    var magnitudeY = Math.abs(deltaY);\n\n    if (magnitudeY > magnitudeX) {\n      // user is perhaps trying to swipe up/down the page\n\n      if (\n        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||\n        (deltaY > 0 && scrollTop === 0)\n      ) {\n        // set prevent for mobile Chrome refresh\n        return window.scrollY === 0 && deltaY > 0 && env.isChrome;\n      }\n    } else if (magnitudeX > magnitudeY) {\n      // user is perhaps trying to swipe left/right across the page\n\n      if (\n        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||\n        (deltaX > 0 && scrollLeft === 0)\n      ) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function applyTouchMove(differenceX, differenceY) {\n    element.scrollTop -= differenceY;\n    element.scrollLeft -= differenceX;\n\n    updateGeometry(i);\n  }\n\n  var startOffset = {};\n  var startTime = 0;\n  var speed = {};\n  var easingLoop = null;\n\n  function getTouch(e) {\n    if (e.targetTouches) {\n      return e.targetTouches[0];\n    } else {\n      // Maybe IE pointer\n      return e;\n    }\n  }\n\n  function shouldHandle(e) {\n    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {\n      return false;\n    }\n    if (e.targetTouches && e.targetTouches.length === 1) {\n      return true;\n    }\n    if (\n      e.pointerType &&\n      e.pointerType !== 'mouse' &&\n      e.pointerType !== e.MSPOINTER_TYPE_MOUSE\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  function touchStart(e) {\n    if (!shouldHandle(e)) {\n      return;\n    }\n\n    var touch = getTouch(e);\n\n    startOffset.pageX = touch.pageX;\n    startOffset.pageY = touch.pageY;\n\n    startTime = new Date().getTime();\n\n    if (easingLoop !== null) {\n      clearInterval(easingLoop);\n    }\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n\n      // if deltaY && vertical scrollable\n      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            (cursor.scrollTop > 0 && deltaY < 0) ||\n            (cursor.scrollTop < maxScrollTop && deltaY > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n      // if deltaX && horizontal scrollable\n      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {\n        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            (cursor.scrollLeft > 0 && deltaX < 0) ||\n            (cursor.scrollLeft < maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function touchMove(e) {\n    if (shouldHandle(e)) {\n      var touch = getTouch(e);\n\n      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };\n\n      var differenceX = currentOffset.pageX - startOffset.pageX;\n      var differenceY = currentOffset.pageY - startOffset.pageY;\n\n      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {\n        return;\n      }\n\n      applyTouchMove(differenceX, differenceY);\n      startOffset = currentOffset;\n\n      var currentTime = new Date().getTime();\n\n      var timeGap = currentTime - startTime;\n      if (timeGap > 0) {\n        speed.x = differenceX / timeGap;\n        speed.y = differenceY / timeGap;\n        startTime = currentTime;\n      }\n\n      if (shouldPrevent(differenceX, differenceY)) {\n        e.preventDefault();\n      }\n    }\n  }\n  function touchEnd() {\n    if (i.settings.swipeEasing) {\n      clearInterval(easingLoop);\n      easingLoop = setInterval(function() {\n        if (i.isInitialized) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (!speed.x && !speed.y) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (!i.element) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        applyTouchMove(speed.x * 30, speed.y * 30);\n\n        speed.x *= 0.8;\n        speed.y *= 0.8;\n      }, 10);\n    }\n  }\n\n  if (env.supportsTouch) {\n    i.event.bind(element, 'touchstart', touchStart);\n    i.event.bind(element, 'touchmove', touchMove);\n    i.event.bind(element, 'touchend', touchEnd);\n  } else if (env.supportsIePointer) {\n    if (window.PointerEvent) {\n      i.event.bind(element, 'pointerdown', touchStart);\n      i.event.bind(element, 'pointermove', touchMove);\n      i.event.bind(element, 'pointerup', touchEnd);\n    } else if (window.MSPointerEvent) {\n      i.event.bind(element, 'MSPointerDown', touchStart);\n      i.event.bind(element, 'MSPointerMove', touchMove);\n      i.event.bind(element, 'MSPointerUp', touchEnd);\n    }\n  }\n}\n\nvar defaultSettings = function () { return ({\n  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],\n  maxScrollbarLength: null,\n  minScrollbarLength: null,\n  scrollingThreshold: 1000,\n  scrollXMarginOffset: 0,\n  scrollYMarginOffset: 0,\n  suppressScrollX: false,\n  suppressScrollY: false,\n  swipeEasing: true,\n  useBothWheelAxes: false,\n  wheelPropagation: true,\n  wheelSpeed: 1,\n}); };\n\nvar handlers = {\n  'click-rail': clickRail,\n  'drag-thumb': dragThumb,\n  keyboard: keyboard,\n  wheel: wheel,\n  touch: touch,\n};\n\nvar PerfectScrollbar = function PerfectScrollbar(element, userSettings) {\n  var this$1 = this;\n  if ( userSettings === void 0 ) userSettings = {};\n\n  if (typeof element === 'string') {\n    element = document.querySelector(element);\n  }\n\n  if (!element || !element.nodeName) {\n    throw new Error('no element is specified to initialize PerfectScrollbar');\n  }\n\n  this.element = element;\n\n  element.classList.add(cls.main);\n\n  this.settings = defaultSettings();\n  for (var key in userSettings) {\n    this.settings[key] = userSettings[key];\n  }\n\n  this.containerWidth = null;\n  this.containerHeight = null;\n  this.contentWidth = null;\n  this.contentHeight = null;\n\n  var focus = function () { return element.classList.add(cls.state.focus); };\n  var blur = function () { return element.classList.remove(cls.state.focus); };\n\n  this.isRtl = get(element).direction === 'rtl';\n  if (this.isRtl === true) {\n    element.classList.add(cls.rtl);\n  }\n  this.isNegativeScroll = (function () {\n    var originalScrollLeft = element.scrollLeft;\n    var result = null;\n    element.scrollLeft = -1;\n    result = element.scrollLeft < 0;\n    element.scrollLeft = originalScrollLeft;\n    return result;\n  })();\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? element.scrollWidth - element.clientWidth\n    : 0;\n  this.event = new EventManager();\n  this.ownerDocument = element.ownerDocument || document;\n\n  this.scrollbarXRail = div(cls.element.rail('x'));\n  element.appendChild(this.scrollbarXRail);\n  this.scrollbarX = div(cls.element.thumb('x'));\n  this.scrollbarXRail.appendChild(this.scrollbarX);\n  this.scrollbarX.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarX, 'focus', focus);\n  this.event.bind(this.scrollbarX, 'blur', blur);\n  this.scrollbarXActive = null;\n  this.scrollbarXWidth = null;\n  this.scrollbarXLeft = null;\n  var railXStyle = get(this.scrollbarXRail);\n  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);\n  if (isNaN(this.scrollbarXBottom)) {\n    this.isScrollbarXUsingBottom = false;\n    this.scrollbarXTop = toInt(railXStyle.top);\n  } else {\n    this.isScrollbarXUsingBottom = true;\n  }\n  this.railBorderXWidth =\n    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);\n  // Set rail to display:block to calculate margins\n  set(this.scrollbarXRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);\n  set(this.scrollbarXRail, { display: '' });\n  this.railXWidth = null;\n  this.railXRatio = null;\n\n  this.scrollbarYRail = div(cls.element.rail('y'));\n  element.appendChild(this.scrollbarYRail);\n  this.scrollbarY = div(cls.element.thumb('y'));\n  this.scrollbarYRail.appendChild(this.scrollbarY);\n  this.scrollbarY.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarY, 'focus', focus);\n  this.event.bind(this.scrollbarY, 'blur', blur);\n  this.scrollbarYActive = null;\n  this.scrollbarYHeight = null;\n  this.scrollbarYTop = null;\n  var railYStyle = get(this.scrollbarYRail);\n  this.scrollbarYRight = parseInt(railYStyle.right, 10);\n  if (isNaN(this.scrollbarYRight)) {\n    this.isScrollbarYUsingRight = false;\n    this.scrollbarYLeft = toInt(railYStyle.left);\n  } else {\n    this.isScrollbarYUsingRight = true;\n  }\n  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;\n  this.railBorderYWidth =\n    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railYMarginHeight =\n    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);\n  set(this.scrollbarYRail, { display: '' });\n  this.railYHeight = null;\n  this.railYRatio = null;\n\n  this.reach = {\n    x:\n      element.scrollLeft <= 0\n        ? 'start'\n        : element.scrollLeft >= this.contentWidth - this.containerWidth\n        ? 'end'\n        : null,\n    y:\n      element.scrollTop <= 0\n        ? 'start'\n        : element.scrollTop >= this.contentHeight - this.containerHeight\n        ? 'end'\n        : null,\n  };\n\n  this.isAlive = true;\n\n  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });\n\n  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only\n  this.lastScrollLeft = element.scrollLeft; // for onScroll only\n  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });\n  updateGeometry(this);\n};\n\nPerfectScrollbar.prototype.update = function update () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  // Recalcuate negative scrollLeft adjustment\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? this.element.scrollWidth - this.element.clientWidth\n    : 0;\n\n  // Recalculate rail margins\n  set(this.scrollbarXRail, { display: 'block' });\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(get(this.scrollbarXRail).marginLeft) +\n    toInt(get(this.scrollbarXRail).marginRight);\n  this.railYMarginHeight =\n    toInt(get(this.scrollbarYRail).marginTop) +\n    toInt(get(this.scrollbarYRail).marginBottom);\n\n  // Hide scrollbars not to affect scrollWidth and scrollHeight\n  set(this.scrollbarXRail, { display: 'none' });\n  set(this.scrollbarYRail, { display: 'none' });\n\n  updateGeometry(this);\n\n  processScrollDiff(this, 'top', 0, false, true);\n  processScrollDiff(this, 'left', 0, false, true);\n\n  set(this.scrollbarXRail, { display: '' });\n  set(this.scrollbarYRail, { display: '' });\n};\n\nPerfectScrollbar.prototype.onScroll = function onScroll (e) {\n  if (!this.isAlive) {\n    return;\n  }\n\n  updateGeometry(this);\n  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);\n  processScrollDiff(\n    this,\n    'left',\n    this.element.scrollLeft - this.lastScrollLeft\n  );\n\n  this.lastScrollTop = Math.floor(this.element.scrollTop);\n  this.lastScrollLeft = this.element.scrollLeft;\n};\n\nPerfectScrollbar.prototype.destroy = function destroy () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  this.event.unbindAll();\n  remove(this.scrollbarX);\n  remove(this.scrollbarY);\n  remove(this.scrollbarXRail);\n  remove(this.scrollbarYRail);\n  this.removePsClasses();\n\n  // unset elements\n  this.element = null;\n  this.scrollbarX = null;\n  this.scrollbarY = null;\n  this.scrollbarXRail = null;\n  this.scrollbarYRail = null;\n\n  this.isAlive = false;\n};\n\nPerfectScrollbar.prototype.removePsClasses = function removePsClasses () {\n  this.element.className = this.element.className\n    .split(' ')\n    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })\n    .join(' ');\n};\n\nexport default PerfectScrollbar;\n//# sourceMappingURL=perfect-scrollbar.esm.js.map\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport EventHandler from \"../../dom/event-handler\";\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  threshold: 10,\r\n  direction: \"all\",\r\n};\r\n\r\nclass Swipe {\r\n  constructor(element, options) {\r\n    this._element = element;\r\n    this._startPosition = null;\r\n    this._options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options,\r\n    };\r\n  }\r\n\r\n  handleTouchStart(e) {\r\n    this._startPosition = this._getCoordinates(e);\r\n  }\r\n\r\n  handleTouchMove(e) {\r\n    if (!this._startPosition) return;\r\n\r\n    const position = this._getCoordinates(e);\r\n    const displacement = {\r\n      x: position.x - this._startPosition.x,\r\n      y: position.y - this._startPosition.y,\r\n    };\r\n\r\n    const swipe = this._getDirection(displacement);\r\n\r\n    if (this._options.direction === \"all\") {\r\n      if (\r\n        swipe.y.value < this._options.threshold &&\r\n        swipe.x.value < this._options.threshold\r\n      ) {\r\n        return;\r\n      }\r\n      const direction =\r\n        swipe.y.value > swipe.x.value ? swipe.y.direction : swipe.x.direction;\r\n      EventHandler.trigger(this._element, `swipe${direction}`);\r\n      EventHandler.trigger(this._element, \"swipe\", { direction });\r\n      this._startPosition = null;\r\n      return;\r\n    }\r\n\r\n    const axis =\r\n      this._options.direction === \"left\" || this._options === \"right\"\r\n        ? \"x\"\r\n        : \"y\";\r\n\r\n    if (\r\n      swipe[axis].direction === this._options.direction &&\r\n      swipe[axis].value > this._options.threshold\r\n    ) {\r\n      EventHandler.trigger(this._element, `swipe${swipe[axis].direction}`);\r\n      this._startPosition = null;\r\n    }\r\n  }\r\n\r\n  handleTouchEnd() {\r\n    this._startPosition = null;\r\n  }\r\n\r\n  _getCoordinates(e) {\r\n    const [touch] = e.touches;\r\n    return {\r\n      x: touch.clientX,\r\n      y: touch.clientY,\r\n    };\r\n  }\r\n\r\n  _getDirection(displacement) {\r\n    return {\r\n      x: {\r\n        direction: displacement.x < 0 ? \"left\" : \"right\",\r\n        value: Math.abs(displacement.x),\r\n      },\r\n      y: {\r\n        direction: displacement.y < 0 ? \"up\" : \"down\",\r\n        value: Math.abs(displacement.y),\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nexport default Swipe;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Swipe from \"./swipe\";\r\n\r\nclass Touch {\r\n  constructor(element, event = \"swipe\", options = {}) {\r\n    this._element = element;\r\n    this._event = event;\r\n\r\n    // events\r\n\r\n    this.swipe = new Swipe(element, options);\r\n\r\n    // handlers\r\n\r\n    this._touchStartHandler = this._handleTouchStart.bind(this);\r\n    this._touchMoveHandler = this._handleTouchMove.bind(this);\r\n    this._touchEndHandler = this._handleTouchEnd.bind(this);\r\n  }\r\n\r\n  dispose() {\r\n    this._element.removeEventListener(\"touchstart\", this._touchStartHandler);\r\n    this._element.removeEventListener(\"touchmove\", this._touchMoveHandler);\r\n    window.removeEventListener(\"touchend\", this._touchEndHandler);\r\n  }\r\n\r\n  init() {\r\n    // istanbul ignore next\r\n    this._element.addEventListener(\"touchstart\", (e) =>\r\n      this._handleTouchStart(e)\r\n    );\r\n    // istanbul ignore next\r\n    this._element.addEventListener(\"touchmove\", (e) =>\r\n      this._handleTouchMove(e)\r\n    );\r\n    // istanbul ignore next\r\n    window.addEventListener(\"touchend\", (e) => this._handleTouchEnd(e));\r\n  }\r\n\r\n  _handleTouchStart(e) {\r\n    this[this._event].handleTouchStart(e);\r\n  }\r\n\r\n  _handleTouchMove(e) {\r\n    this[this._event].handleTouchMove(e);\r\n  }\r\n\r\n  _handleTouchEnd(e) {\r\n    this[this._event].handleTouchEnd(e);\r\n  }\r\n}\r\n\r\nexport default Touch;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\n\r\nconst psClasses =\r\n  \"group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none\";\r\n\r\nconst railXClasses =\r\n  \"group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\";\r\nconst railXThumbClasses =\r\n  \"absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none\";\r\n\r\nconst railYClasses =\r\n  \"group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none\";\r\nconst railYThumbClasses =\r\n  \"absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none\";\r\n\r\nconst addPerfectScrollbarStyles = (container = document) => {\r\n  const classes = [\r\n    { ps: \"ps__rail-x\", te: railXClasses },\r\n    { ps: \"ps__rail-y\", te: railYClasses },\r\n    { ps: \"ps__thumb-x\", te: railXThumbClasses },\r\n    { ps: \"ps__thumb-y\", te: railYThumbClasses },\r\n  ];\r\n\r\n  classes.forEach((item) => {\r\n    Manipulator.addClass(\r\n      SelectorEngine.findOne(`.${item.ps}`, container),\r\n      item.te\r\n    );\r\n    Manipulator.removeClass(\r\n      SelectorEngine.findOne(`.${item.ps}`, container),\r\n      item.ps\r\n    );\r\n  });\r\n  Manipulator.addClass(container, psClasses);\r\n  Manipulator.removeClass(container, \"ps\");\r\n};\r\n\r\nexport default addPerfectScrollbarStyles;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport PerfectScrollbar from \"perfect-scrollbar\";\r\nimport {\r\n  array,\r\n  isVisible,\r\n  typeCheckConfig,\r\n  isRTL,\r\n  getUID,\r\n} from \"../util/index\";\r\nimport FocusTrap from \"../util/focusTrap\";\r\nimport { ENTER, TAB, ESCAPE } from \"../util/keycodes\";\r\nimport Touch from \"../util/touch/index\";\r\nimport Collapse from \"../components/collapse\";\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport Ripple from \"../methods/ripple\";\r\nimport Backdrop from \"../util/backdrop\";\r\nimport addPerfectScrollbarStyles from \"../util/add-perfect-scrollbar-styles\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"sidenav\";\r\nconst DATA_KEY = \"te.sidenav\";\r\nconst ARROW_DATA = \"data-te-sidenav-rotate-icon-ref\";\r\nconst SELECTOR_TOGGLE = \"[data-te-sidenav-toggle-ref]\";\r\n\r\nconst SELECTOR_TOGGLE_COLLAPSE = \"[data-te-collapse-init]\";\r\n\r\nconst SELECTOR_SHOW_SLIM = '[data-te-sidenav-slim=\"true\"]';\r\nconst SELECTOR_HIDE_SLIM = '[data-te-sidenav-slim=\"false\"]';\r\n\r\nconst SELECTOR_NAVIGATION = \"[data-te-sidenav-menu-ref]\";\r\nconst SELECTOR_COLLAPSE = \"[data-te-sidenav-collapse-ref]\";\r\nconst SELECTOR_LINK = \"[data-te-sidenav-link-ref]\";\r\n\r\nconst TRANSLATION_LEFT = isRTL() ? 100 : -100;\r\nconst TRANSLATION_RIGHT = isRTL() ? -100 : 100;\r\n\r\nconst OPTIONS_TYPE = {\r\n  sidenavAccordion: \"(boolean)\",\r\n  sidenavBackdrop: \"(boolean)\",\r\n  sidenavBackdropClass: \"(null|string)\",\r\n  sidenavCloseOnEsc: \"(boolean)\",\r\n  sidenavColor: \"(string)\",\r\n  sidenavContent: \"(null|string)\",\r\n  sidenavExpandable: \"(boolean)\",\r\n  sidenavExpandOnHover: \"(boolean)\",\r\n  sidenavFocusTrap: \"(boolean)\",\r\n  sidenavHidden: \"(boolean)\",\r\n  sidenavMode: \"(string)\",\r\n  sidenavModeBreakpointOver: \"(null|string|number)\",\r\n  sidenavModeBreakpointSide: \"(null|string|number)\",\r\n  sidenavModeBreakpointPush: \"(null|string|number)\",\r\n  sidenavBreakpointSm: \"(number)\",\r\n  sidenavBreakpointMd: \"(number)\",\r\n  sidenavBreakpointLg: \"(number)\",\r\n  sidenavBreakpointXl: \"(number)\",\r\n  sidenavBreakpoint2xl: \"(number)\",\r\n  sidenavScrollContainer: \"(null|string)\",\r\n  sidenavSlim: \"(boolean)\",\r\n  sidenavSlimCollapsed: \"(boolean)\",\r\n  sidenavSlimWidth: \"(number)\",\r\n  sidenavPosition: \"(string)\",\r\n  sidenavRight: \"(boolean)\",\r\n  sidenavTransitionDuration: \"(number)\",\r\n  sidenavWidth: \"(number)\",\r\n};\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  sidenavAccordion: false,\r\n  sidenavBackdrop: true,\r\n  sidenavBackdropClass: null,\r\n  sidenavCloseOnEsc: true,\r\n  sidenavColor: \"primary\",\r\n  sidenavContent: null,\r\n  sidenavExpandable: true,\r\n  sidenavExpandOnHover: false,\r\n  sidenavFocusTrap: true,\r\n  sidenavHidden: true,\r\n  sidenavMode: \"over\",\r\n  sidenavModeBreakpointOver: null,\r\n  sidenavModeBreakpointSide: null,\r\n  sidenavModeBreakpointPush: null,\r\n  sidenavBreakpointSm: 640,\r\n  sidenavBreakpointMd: 768,\r\n  sidenavBreakpointLg: 1024,\r\n  sidenavBreakpointXl: 1280,\r\n  sidenavBreakpoint2xl: 1536,\r\n  sidenavScrollContainer: null,\r\n  sidenavSlim: false,\r\n  sidenavSlimCollapsed: false,\r\n  sidenavSlimWidth: 77,\r\n  sidenavPosition: \"fixed\",\r\n  sidenavRight: false,\r\n  sidenavTransitionDuration: 300,\r\n  sidenavWidth: 240,\r\n};\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nClass Definition\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nclass Sidenav {\r\n  constructor(node, options = {}) {\r\n    this._element = node;\r\n    this._options = options;\r\n\r\n    this._ID = getUID(\"\");\r\n\r\n    this._content = null;\r\n    this._initialContentStyle = null;\r\n    this._slimCollapsed = false;\r\n\r\n    this._activeNode = null;\r\n\r\n    this._tempSlim = false;\r\n    this._backdrop = this._initializeBackDrop();\r\n\r\n    this._focusTrap = null;\r\n    this._perfectScrollbar = null;\r\n    this._touch = null;\r\n\r\n    this._setModeFromBreakpoints();\r\n\r\n    this.escHandler = (e) => {\r\n      if (e.keyCode === ESCAPE && this.toggler && isVisible(this.toggler)) {\r\n        this._update(false);\r\n\r\n        EventHandler.off(window, \"keydown\", this.escHandler);\r\n      }\r\n    };\r\n\r\n    this.hashHandler = () => {\r\n      this._setActiveElements();\r\n    };\r\n\r\n    if (node) {\r\n      Data.setData(node, DATA_KEY, this);\r\n\r\n      this._setup();\r\n    }\r\n\r\n    if (\r\n      this.options.sidenavBackdrop &&\r\n      !this.options.sidenavHidden &&\r\n      this.options.sidenavMode === \"over\"\r\n    ) {\r\n      EventHandler.on(this._element, \"transitionend\", this._addBackdropOnInit);\r\n    }\r\n\r\n    this._didInit = false;\r\n    this._init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get container() {\r\n    if (this.options.sidenavPosition === \"fixed\") {\r\n      return SelectorEngine.findOne(\"body\");\r\n    }\r\n\r\n    const findContainer = (el) => {\r\n      if (!el.parentNode || el.parentNode === document) {\r\n        return el;\r\n      }\r\n      if (\r\n        el.parentNode.style.position === \"relative\" ||\r\n        el.parentNode.classList.contains(\"relative\")\r\n      ) {\r\n        return el.parentNode;\r\n      }\r\n      return findContainer(el.parentNode);\r\n    };\r\n\r\n    return findContainer(this._element);\r\n  }\r\n\r\n  get isVisible() {\r\n    let containerStart = 0;\r\n    let containerEnd = window.innerWidth;\r\n\r\n    if (this.options.sidenavPosition !== \"fixed\") {\r\n      const boundry = this.container.getBoundingClientRect();\r\n      containerStart = boundry.x;\r\n      containerEnd = boundry.x + boundry.width;\r\n    }\r\n\r\n    const { x } = this._element.getBoundingClientRect();\r\n\r\n    if (this.options.sidenavRight) {\r\n      return Math.abs(x - containerEnd) > 10;\r\n    }\r\n\r\n    return Math.abs(x - containerStart) < 10;\r\n  }\r\n\r\n  get links() {\r\n    return SelectorEngine.find(SELECTOR_LINK, this._element);\r\n  }\r\n\r\n  get navigation() {\r\n    return SelectorEngine.find(SELECTOR_NAVIGATION, this._element);\r\n  }\r\n\r\n  get options() {\r\n    const config = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...this._options,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, OPTIONS_TYPE);\r\n\r\n    return config;\r\n  }\r\n\r\n  get sidenavStyle() {\r\n    return {\r\n      width: `${this.width}px`,\r\n      height: this.options.sidenavPosition === \"fixed\" ? \"100vh\" : \"100%\",\r\n      position: this.options.sidenavPosition,\r\n      transition: `all ${this.transitionDuration} linear`,\r\n    };\r\n  }\r\n\r\n  get toggler() {\r\n    const toggleElement = SelectorEngine.find(SELECTOR_TOGGLE).find(\r\n      (toggler) => {\r\n        const target = Manipulator.getDataAttribute(toggler, \"target\");\r\n        return SelectorEngine.findOne(target) === this._element;\r\n      }\r\n    );\r\n    return toggleElement;\r\n  }\r\n\r\n  get transitionDuration() {\r\n    return `${this.options.sidenavTransitionDuration / 1000}s`;\r\n  }\r\n\r\n  get translation() {\r\n    return this.options.sidenavRight ? TRANSLATION_RIGHT : TRANSLATION_LEFT;\r\n  }\r\n\r\n  get width() {\r\n    return this._slimCollapsed\r\n      ? this.options.sidenavSlimWidth\r\n      : this.options.sidenavWidth;\r\n  }\r\n\r\n  get isBackdropVisible() {\r\n    return Boolean(this._backdrop._element);\r\n  }\r\n\r\n  // Public\r\n\r\n  changeMode(mode) {\r\n    this._setMode(mode);\r\n  }\r\n\r\n  dispose() {\r\n    EventHandler.off(window, \"keydown\", this.escHandler);\r\n    this.options.sidenavBackdrop && this._backdrop.dispose();\r\n\r\n    EventHandler.off(window, \"hashchange\", this.hashHandler);\r\n\r\n    this._touch.dispose();\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n\r\n    this._element = null;\r\n  }\r\n\r\n  hide() {\r\n    this._emitEvents(false);\r\n    this._update(false);\r\n    this._options.sidenavBackdrop &&\r\n      this.isBackdropVisible &&\r\n      this._backdrop.hide();\r\n  }\r\n\r\n  show() {\r\n    this._emitEvents(true);\r\n    this._update(true);\r\n    this._options.sidenavBackdrop &&\r\n      this._options.sidenavMode === \"over\" &&\r\n      this._backdrop.show();\r\n  }\r\n\r\n  toggle() {\r\n    this._emitEvents(!this.isVisible);\r\n    this._update(!this.isVisible);\r\n  }\r\n\r\n  toggleSlim() {\r\n    this._setSlim(!this._slimCollapsed);\r\n  }\r\n\r\n  update(options) {\r\n    this._options = options;\r\n\r\n    this._setup();\r\n  }\r\n\r\n  getBreakpoint(prefix) {\r\n    return this._transformBreakpointValuesToObject()[prefix];\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    if (this._didInit) {\r\n      return;\r\n    }\r\n    EventHandler.on(\r\n      document,\r\n      \"click\",\r\n      SELECTOR_TOGGLE,\r\n      Sidenav.toggleSidenav()\r\n    );\r\n    this._didInit = true;\r\n  }\r\n\r\n  _transformBreakpointValuesToObject() {\r\n    return {\r\n      sm: this.options.sidenavBreakpointSm,\r\n      md: this.options.sidenavBreakpointMd,\r\n      lg: this.options.sidenavBreakpointLg,\r\n      xl: this.options.sidenavBreakpointXl,\r\n      \"2xl\": this.options.sidenavBreakpoint2xl,\r\n    };\r\n  }\r\n\r\n  _setModeFromBreakpoints() {\r\n    const innerWidth = window.innerWidth;\r\n    const breakpointsList = this._transformBreakpointValuesToObject();\r\n\r\n    if (innerWidth === undefined || !breakpointsList) {\r\n      return;\r\n    }\r\n\r\n    const overCalculated =\r\n      typeof this.options.sidenavModeBreakpointOver === \"number\"\r\n        ? innerWidth - this.options.sidenavModeBreakpointOver\r\n        : innerWidth - breakpointsList[this.options.sidenavModeBreakpointOver];\r\n\r\n    const sideCalculated =\r\n      typeof this.options.sidenavModeBreakpointSide === \"number\"\r\n        ? innerWidth - this.options.sidenavModeBreakpointSide\r\n        : innerWidth - breakpointsList[this.options.sidenavModeBreakpointSide];\r\n\r\n    const pushCalculated =\r\n      typeof this.options.sidenavModeBreakpointPush === \"number\"\r\n        ? innerWidth - this.options.sidenavModeBreakpointPush\r\n        : innerWidth - breakpointsList[this.options.sidenavModeBreakpointPush];\r\n\r\n    const sortAsc = (a, b) => {\r\n      if (a - b < 0) return -1;\r\n      if (b - a < 0) return 1;\r\n      return 0;\r\n    };\r\n\r\n    const closestPositive = [overCalculated, sideCalculated, pushCalculated]\r\n      .filter((value) => value != null && value >= 0)\r\n      .sort(sortAsc)[0];\r\n\r\n    if (overCalculated > 0 && overCalculated === closestPositive) {\r\n      this._options.sidenavMode = \"over\";\r\n      this._options.sidenavHidden = true;\r\n    } else if (sideCalculated > 0 && sideCalculated === closestPositive) {\r\n      this._options.sidenavMode = \"side\";\r\n    } else if (pushCalculated > 0 && pushCalculated === closestPositive) {\r\n      this._options.sidenavMode = \"push\";\r\n    }\r\n  }\r\n\r\n  _collapseItems() {\r\n    this.navigation.forEach((menu) => {\r\n      const collapseElements = SelectorEngine.find(SELECTOR_COLLAPSE, menu);\r\n      collapseElements.forEach((el) => {\r\n        Collapse.getInstance(el).hide();\r\n      });\r\n    });\r\n  }\r\n\r\n  _getOffsetValue(show, { index, property, offsets }) {\r\n    const initialValue = this._getPxValue(\r\n      this._initialContentStyle[index][offsets[property].property]\r\n    );\r\n\r\n    const offset = show ? offsets[property].value : 0;\r\n    return initialValue + offset;\r\n  }\r\n\r\n  _getProperty(...args) {\r\n    return args\r\n      .map((arg, i) => {\r\n        if (i === 0) {\r\n          return arg;\r\n        }\r\n        return arg[0].toUpperCase().concat(arg.slice(1));\r\n      })\r\n      .join(\"\");\r\n  }\r\n\r\n  _getPxValue(property) {\r\n    if (!property) {\r\n      return 0;\r\n    }\r\n    return parseFloat(property);\r\n  }\r\n\r\n  _handleSwipe(e, inverseDirecion) {\r\n    if (\r\n      inverseDirecion &&\r\n      this._slimCollapsed &&\r\n      this.options.sidenavSlim &&\r\n      this.options.sidenavExpandable\r\n    ) {\r\n      this.toggleSlim();\r\n    } else if (!inverseDirecion) {\r\n      if (\r\n        this._slimCollapsed ||\r\n        !this.options.sidenavSlim ||\r\n        !this.options.sidenavExpandable\r\n      ) {\r\n        if (this.toggler && isVisible(this.toggler)) {\r\n          this.toggle();\r\n        }\r\n      } else {\r\n        this.toggleSlim();\r\n      }\r\n    }\r\n  }\r\n\r\n  _isActive(link, reference) {\r\n    if (reference) {\r\n      return reference === link;\r\n    }\r\n\r\n    if (link.attributes.href) {\r\n      return new URL(link, window.location.href).href === window.location.href;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _isAllToBeCollapsed() {\r\n    const collapseElements = SelectorEngine.find(\r\n      SELECTOR_TOGGLE_COLLAPSE,\r\n      this._element\r\n    );\r\n    const collapseElementsExpanded = collapseElements.filter(\r\n      (collapsible) => collapsible.getAttribute(\"aria-expanded\") === \"true\"\r\n    );\r\n    return collapseElementsExpanded.length === 0;\r\n  }\r\n\r\n  _isAllCollapsed() {\r\n    return (\r\n      SelectorEngine.find(SELECTOR_COLLAPSE, this._element).filter((el) =>\r\n        isVisible(el)\r\n      ).length === 0\r\n    );\r\n  }\r\n\r\n  _initializeBackDrop() {\r\n    if (!this.options.sidenavBackdrop) {\r\n      return;\r\n    }\r\n    const backdropClasses = this.options.sidenavBackdropClass\r\n      ? this.options.sidenavBackdropClass.split(\" \")\r\n      : this.options.sidenavPosition\r\n      ? [\r\n          \"opacity-50\",\r\n          \"transition-all\",\r\n          \"duration-300\",\r\n          \"ease-in-out\",\r\n          this.options.sidenavPosition,\r\n          \"top-0\",\r\n          \"left-0\",\r\n          \"z-50\",\r\n          \"bg-black/10\",\r\n          \"dark:bg-black-60\",\r\n          \"w-full\",\r\n          \"h-full\",\r\n          this._element.id,\r\n        ]\r\n      : null;\r\n\r\n    return new Backdrop({\r\n      isVisible: this.options.sidenavBackdrop,\r\n      isAnimated: true,\r\n      rootElement: this._element.parentNode,\r\n      backdropClasses,\r\n      clickCallback: () => this.hide(),\r\n    });\r\n  }\r\n\r\n  _updateBackdrop(show) {\r\n    if (this.options.sidenavMode === \"over\") {\r\n      show\r\n        ? this._backdrop.show()\r\n        : this.isBackdropVisible && this._backdrop.hide();\r\n      return;\r\n    }\r\n    this.isBackdropVisible && this._backdrop.hide();\r\n  }\r\n\r\n  _setup() {\r\n    // Touch events\r\n    this._setupTouch();\r\n\r\n    // Focus trap\r\n\r\n    if (this.options.sidenavFocusTrap) {\r\n      this._setupFocusTrap();\r\n    }\r\n\r\n    // Collapse\r\n\r\n    this._setupCollapse();\r\n\r\n    // Slim\r\n\r\n    if (this.options.sidenavSlim) {\r\n      this._setupSlim();\r\n    }\r\n\r\n    // Initial position\r\n\r\n    this._setupInitialStyling();\r\n\r\n    // Perfect Scrollbar\r\n\r\n    this._setupScrolling();\r\n\r\n    // Content\r\n\r\n    if (this.options.sidenavContent) {\r\n      this._setupContent();\r\n    }\r\n\r\n    // Active link\r\n\r\n    this._setupActiveState();\r\n\r\n    // Ripple\r\n\r\n    this._setupRippleEffect();\r\n\r\n    // Shown on init\r\n\r\n    if (!this.options.sidenavHidden) {\r\n      this._updateOffsets(true, true);\r\n    }\r\n\r\n    if (this.options.sidenavMode === \"over\") {\r\n      this._setTabindex(true);\r\n    }\r\n  }\r\n\r\n  _setupActiveState() {\r\n    this._setActiveElements();\r\n\r\n    this.links.forEach((link) => {\r\n      EventHandler.on(link, \"click\", () => this._setActiveElements(link));\r\n      EventHandler.on(link, \"keydown\", (e) => {\r\n        if (e.keyCode === ENTER) {\r\n          this._setActiveElements(link);\r\n        }\r\n      });\r\n    });\r\n\r\n    EventHandler.on(window, \"hashchange\", this.hashHandler);\r\n  }\r\n\r\n  _setupCollapse() {\r\n    this.navigation.forEach((menu, menuIndex) => {\r\n      const categories = SelectorEngine.find(SELECTOR_COLLAPSE, menu);\r\n      categories.forEach((list, index) =>\r\n        this._setupCollapseList({ list, index, menu, menuIndex })\r\n      );\r\n    });\r\n  }\r\n\r\n  _generateCollpaseID(index, menuIndex) {\r\n    return `sidenav-collapse-${this._ID}-${menuIndex}-${index}`;\r\n  }\r\n\r\n  _setupCollapseList({ list, index, menu, menuIndex }) {\r\n    const ID = this._generateCollpaseID(index, menuIndex);\r\n\r\n    list.setAttribute(\"id\", ID);\r\n    list.setAttribute(\"data-te-collapse-item\", \"\");\r\n\r\n    const [toggler] = SelectorEngine.prev(list, SELECTOR_LINK);\r\n\r\n    Manipulator.setDataAttribute(toggler, \"collapse-init\", \"\");\r\n    toggler.setAttribute(\"href\", `#${ID}`);\r\n    toggler.setAttribute(\"role\", \"button\");\r\n\r\n    const instance =\r\n      Collapse.getInstance(list) ||\r\n      new Collapse(list, {\r\n        toggle: false,\r\n        parent: this.options.sidenavAccordion ? menu : list,\r\n      });\r\n\r\n    // Arrow\r\n\r\n    if (\r\n      list.dataset.teSidenavStateShow === \"\" ||\r\n      list.dataset.teCollapseShow === \"\"\r\n    ) {\r\n      this._rotateArrow(toggler, false);\r\n    }\r\n\r\n    // Event listeners\r\n\r\n    EventHandler.on(toggler, \"click\", (e) => {\r\n      this._toggleCategory(e, instance, list);\r\n      if (this._tempSlim && this._isAllToBeCollapsed()) {\r\n        this._setSlim(true);\r\n\r\n        this._tempSlim = false;\r\n      }\r\n\r\n      if (this.options.sidenavMode === \"over\" && this._focusTrap) {\r\n        this._focusTrap.update();\r\n      }\r\n    });\r\n\r\n    EventHandler.on(list, \"show.te.collapse\", () =>\r\n      this._rotateArrow(toggler, false)\r\n    );\r\n\r\n    EventHandler.on(list, \"hide.te.collapse\", () =>\r\n      this._rotateArrow(toggler, true)\r\n    );\r\n\r\n    EventHandler.on(list, \"shown.te.collapse\", () => {\r\n      if (this.options.sidenavMode === \"over\" && this._focusTrap) {\r\n        this._focusTrap.update();\r\n      }\r\n    });\r\n\r\n    EventHandler.on(list, \"hidden.te.collapse\", () => {\r\n      if (this._tempSlim && this._isAllCollapsed()) {\r\n        this._setSlim(true);\r\n\r\n        this._tempSlim = false;\r\n      }\r\n      if (this.options.sidenavMode === \"over\" && this._focusTrap) {\r\n        this._focusTrap.update();\r\n      }\r\n    });\r\n  }\r\n\r\n  _setupContent() {\r\n    this._content = SelectorEngine.find(this.options.sidenavContent);\r\n\r\n    this._content.forEach((el) => {\r\n      const searchFor = [\r\n        \"!p\",\r\n        \"!m\",\r\n        \"!px\",\r\n        \"!pl\",\r\n        \"!pr\",\r\n        \"!mx\",\r\n        \"!ml\",\r\n        \"!mr\",\r\n        \"!-p\",\r\n        \"!-m\",\r\n        \"!-px\",\r\n        \"!-pl\",\r\n        \"!-pr\",\r\n        \"!-mx\",\r\n        \"!-ml\",\r\n        \"!-mr\",\r\n      ];\r\n      const classesToRemove = [...el.classList].filter(\r\n        (singleClass) =>\r\n          searchFor.findIndex((el) => singleClass.includes(el)) >= 0\r\n      );\r\n      classesToRemove.forEach((remove) => el.classList.remove(remove));\r\n    });\r\n\r\n    this._initialContentStyle = this._content.map((el) => {\r\n      const { paddingLeft, paddingRight, marginLeft, marginRight, transition } =\r\n        window.getComputedStyle(el);\r\n      return { paddingLeft, paddingRight, marginLeft, marginRight, transition };\r\n    });\r\n  }\r\n\r\n  _setupFocusTrap() {\r\n    this._focusTrap = new FocusTrap(\r\n      this._element,\r\n      {\r\n        event: \"keydown\",\r\n        condition: (e) => e.keyCode === TAB,\r\n        onlyVisible: true,\r\n      },\r\n      this.toggler\r\n    );\r\n  }\r\n\r\n  _setupInitialStyling() {\r\n    this._setColor();\r\n    Manipulator.style(this._element, this.sidenavStyle);\r\n  }\r\n\r\n  _setupScrolling() {\r\n    let container = this._element;\r\n\r\n    if (this.options.sidenavScrollContainer) {\r\n      container = SelectorEngine.findOne(\r\n        this.options.sidenavScrollContainer,\r\n        this._element\r\n      );\r\n\r\n      const siblings = array(container.parentNode.children).filter(\r\n        (el) => el !== container\r\n      );\r\n\r\n      const siblingsHeight = siblings.reduce((a, b) => {\r\n        return a + b.clientHeight;\r\n      }, 0);\r\n\r\n      Manipulator.style(container, {\r\n        maxHeight: `calc(100% - ${siblingsHeight}px)`,\r\n        position: \"relative\",\r\n      });\r\n    }\r\n\r\n    this._perfectScrollbar = new PerfectScrollbar(container, {\r\n      suppressScrollX: true,\r\n      handlers: [\"click-rail\", \"drag-thumb\", \"wheel\", \"touch\"],\r\n    });\r\n\r\n    addPerfectScrollbarStyles(container);\r\n  }\r\n\r\n  _setupSlim() {\r\n    this._slimCollapsed = this.options.sidenavSlimCollapsed;\r\n\r\n    this._toggleSlimDisplay(this._slimCollapsed);\r\n\r\n    if (this.options.sidenavExpandOnHover) {\r\n      this._element.addEventListener(\"mouseenter\", () => {\r\n        if (this._slimCollapsed) {\r\n          this._setSlim(false);\r\n        }\r\n      });\r\n\r\n      this._element.addEventListener(\"mouseleave\", () => {\r\n        if (!this._slimCollapsed) {\r\n          this._setSlim(true);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _setupRippleEffect() {\r\n    this.links.forEach((link) => {\r\n      let wave = Ripple.getInstance(link);\r\n      let color = this.options.sidenavColor;\r\n\r\n      if (wave && wave._options.sidenavColor !== this.options.sidenavColor) {\r\n        wave.dispose();\r\n      } else if (wave) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        localStorage.theme === \"dark\" ||\r\n        (!(\"theme\" in localStorage) &&\r\n          window.matchMedia(\"(prefers-color-scheme: dark)\").matches)\r\n      ) {\r\n        color = \"white\";\r\n      }\r\n\r\n      wave = new Ripple(link, { rippleColor: color });\r\n    });\r\n  }\r\n\r\n  _setupTouch() {\r\n    this._touch = new Touch(this._element, \"swipe\", { threshold: 20 });\r\n    this._touch.init();\r\n\r\n    EventHandler.on(this._element, \"swipeleft\", (e) =>\r\n      this._handleSwipe(e, this.options.sidenavRight)\r\n    );\r\n\r\n    EventHandler.on(this._element, \"swiperight\", (e) =>\r\n      this._handleSwipe(e, !this.options.sidenavRight)\r\n    );\r\n  }\r\n\r\n  _setActive(link, reference) {\r\n    // Link\r\n    link.setAttribute(\"data-te-sidebar-state-active\", \"\");\r\n\r\n    if (this._activeNode) {\r\n      link.removeAttribute(\"data-te-sidebar-state-active\");\r\n    }\r\n    this._activeNode = link;\r\n\r\n    // Collapse\r\n\r\n    const [collapse] = SelectorEngine.parents(\r\n      this._activeNode,\r\n      SELECTOR_COLLAPSE\r\n    );\r\n\r\n    if (!collapse) {\r\n      this._setActiveCategory();\r\n      return;\r\n    }\r\n\r\n    // Category\r\n\r\n    const [category] = SelectorEngine.prev(collapse, SELECTOR_LINK);\r\n    this._setActiveCategory(category);\r\n\r\n    // Expand active collapse\r\n\r\n    if (!reference && !this._slimCollapsed) {\r\n      Collapse.getInstance(collapse).show();\r\n    }\r\n  }\r\n\r\n  _setActiveCategory(el) {\r\n    this.navigation.forEach((menu) => {\r\n      const categories = SelectorEngine.find(SELECTOR_COLLAPSE, menu);\r\n\r\n      categories.forEach((collapse) => {\r\n        const [collapseToggler] = SelectorEngine.prev(collapse, SELECTOR_LINK);\r\n\r\n        if (collapseToggler !== el) {\r\n          collapseToggler.removeAttribute(\"data-te-sidenav-state-active\");\r\n        } else {\r\n          collapseToggler.setAttribute(\"data-te-sidenav-state-active\", \"\");\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _setActiveElements(reference) {\r\n    this.navigation.forEach((menu) => {\r\n      const links = SelectorEngine.find(SELECTOR_LINK, menu);\r\n      links\r\n        .filter((link) => {\r\n          return SelectorEngine.next(link, SELECTOR_COLLAPSE).length === 0;\r\n        })\r\n        .forEach((link) => {\r\n          if (this._isActive(link, reference) && link !== this._activeNode) {\r\n            this._setActive(link, reference);\r\n          }\r\n        });\r\n    });\r\n    reference && this._updateFocus(this.isVisible);\r\n  }\r\n\r\n  _setColor() {\r\n    const colors = [\r\n      \"primary\",\r\n      \"secondary\",\r\n      \"success\",\r\n      \"info\",\r\n      \"warning\",\r\n      \"danger\",\r\n      \"light\",\r\n      \"dark\",\r\n    ];\r\n    const { sidenavColor: optionColor } = this.options;\r\n    const color = colors.includes(optionColor) ? optionColor : \"primary\";\r\n\r\n    colors.forEach((color) => {\r\n      this._element.classList.remove(`sidenav-${color}`);\r\n    });\r\n\r\n    Manipulator.addClass(this._element, `sidenav-${color}`);\r\n  }\r\n\r\n  _setContentOffsets(show, offsets, initial) {\r\n    this._content.forEach((el, i) => {\r\n      const padding = this._getOffsetValue(show, {\r\n        index: i,\r\n        property: \"padding\",\r\n        offsets,\r\n      });\r\n      const margin = this._getOffsetValue(show, {\r\n        index: i,\r\n        property: \"margin\",\r\n        offsets,\r\n      });\r\n\r\n      const style = {};\r\n\r\n      if (!initial) {\r\n        style.transition = `all ${this.transitionDuration} linear`;\r\n      }\r\n\r\n      style[offsets.padding.property] = `${padding}px`;\r\n\r\n      style[offsets.margin.property] = `${margin}px`;\r\n\r\n      Manipulator.style(el, style);\r\n\r\n      if (!show) {\r\n        return;\r\n      }\r\n\r\n      if (initial) {\r\n        Manipulator.style(el, {\r\n          transition: this._initialContentStyle[i].transition,\r\n        });\r\n        return;\r\n      }\r\n\r\n      EventHandler.on(el, \"transitionend\", () => {\r\n        Manipulator.style(el, {\r\n          transition: this._initialContentStyle[i].transition,\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  _setMode(mode) {\r\n    if (this.options.sidenavMode === mode) {\r\n      return;\r\n    }\r\n\r\n    this._options.sidenavMode = mode;\r\n\r\n    this._update(this.isVisible);\r\n  }\r\n\r\n  _setSlim(isSlimCollapsed) {\r\n    const events = isSlimCollapsed\r\n      ? [\"collapse\", \"collapsed\"]\r\n      : [\"expand\", \"expanded\"];\r\n    this._triggerEvents(...events);\r\n\r\n    if (isSlimCollapsed) {\r\n      this._collapseItems();\r\n    }\r\n\r\n    this._slimCollapsed = isSlimCollapsed;\r\n\r\n    this._toggleSlimDisplay(isSlimCollapsed);\r\n\r\n    Manipulator.style(this._element, { width: `${this.width}px` });\r\n\r\n    this._updateOffsets(this.isVisible);\r\n  }\r\n\r\n  _setTabindex(tabIndexValue) {\r\n    this.links.forEach((link) => {\r\n      link.tabIndex = tabIndexValue ? 0 : -1;\r\n    });\r\n  }\r\n\r\n  _emitEvents(show) {\r\n    const events = show ? [\"show\", \"shown\"] : [\"hide\", \"hidden\"];\r\n    this._triggerEvents(...events);\r\n  }\r\n\r\n  _rotateArrow(toggler, collapsed) {\r\n    const [arrow] = SelectorEngine.children(toggler, `[${ARROW_DATA}]`);\r\n\r\n    if (!arrow) {\r\n      return;\r\n    }\r\n\r\n    collapsed\r\n      ? Manipulator.removeClass(arrow, \"rotate-180\")\r\n      : Manipulator.addClass(arrow, \"rotate-180\");\r\n  }\r\n\r\n  _toggleCategory(e, instance) {\r\n    e.preventDefault();\r\n\r\n    instance.toggle();\r\n\r\n    if (this._slimCollapsed && this.options.sidenavExpandable) {\r\n      this._tempSlim = true;\r\n\r\n      this._setSlim(false);\r\n    }\r\n  }\r\n\r\n  _toggleSlimDisplay(slim) {\r\n    const slimCollapsedElements = SelectorEngine.find(\r\n      SELECTOR_SHOW_SLIM,\r\n      this._element\r\n    );\r\n    const fullWidthElements = SelectorEngine.find(\r\n      SELECTOR_HIDE_SLIM,\r\n      this._element\r\n    );\r\n\r\n    const toggleElements = () => {\r\n      slimCollapsedElements.forEach((el) => {\r\n        Manipulator.style(el, {\r\n          display: this._slimCollapsed ? \"unset\" : \"none\",\r\n        });\r\n      });\r\n\r\n      fullWidthElements.forEach((el) => {\r\n        Manipulator.style(el, {\r\n          display: this._slimCollapsed ? \"none\" : \"unset\",\r\n        });\r\n      });\r\n    };\r\n\r\n    if (slim) {\r\n      setTimeout(\r\n        () => toggleElements(true),\r\n        this.options.sidenavTransitionDuration\r\n      );\r\n    } else {\r\n      toggleElements();\r\n    }\r\n  }\r\n\r\n  async _triggerEvents(startEvent, completeEvent) {\r\n    EventHandler.trigger(this._element, `${startEvent}.te.sidenav`);\r\n\r\n    if (completeEvent) {\r\n      await setTimeout(() => {\r\n        EventHandler.trigger(this._element, `${completeEvent}.te.sidenav`);\r\n      }, this.options.sidenavTransitionDuration + 5);\r\n    }\r\n  }\r\n\r\n  _update(show) {\r\n    if (this.toggler) {\r\n      this._updateTogglerAria(show);\r\n    }\r\n\r\n    this._updateDisplay(show);\r\n\r\n    if (this.options.sidenavBackdrop) {\r\n      this._updateBackdrop(show);\r\n    }\r\n\r\n    this._updateOffsets(show);\r\n\r\n    if (\r\n      show &&\r\n      this.options.sidenavCloseOnEsc &&\r\n      this.options.sidenavMode !== \"side\"\r\n    ) {\r\n      EventHandler.on(window, \"keydown\", this.escHandler);\r\n    }\r\n\r\n    if (this.options.sidenavFocusTrap) {\r\n      this._updateFocus(show);\r\n    }\r\n  }\r\n\r\n  _updateDisplay(show) {\r\n    const translation = show ? 0 : this.translation;\r\n    Manipulator.style(this._element, {\r\n      transform: `translateX(${translation}%)`,\r\n    });\r\n  }\r\n\r\n  _updateFocus(show) {\r\n    this._setTabindex(show);\r\n\r\n    if (this.options.sidenavMode === \"over\" && this.options.sidenavFocusTrap) {\r\n      if (show) {\r\n        this._focusTrap.trap();\r\n        return;\r\n      }\r\n\r\n      this._focusTrap.disable();\r\n    }\r\n\r\n    this._focusTrap.disable();\r\n  }\r\n\r\n  _updateOffsets(show, initial = false) {\r\n    const [paddingPosition, marginPosition] = this.options.sidenavRight\r\n      ? [\"right\", \"left\"]\r\n      : [\"left\", \"right\"];\r\n\r\n    const padding = {\r\n      property: this._getProperty(\"padding\", paddingPosition),\r\n      value: this.options.sidenavMode === \"over\" ? 0 : this.width,\r\n    };\r\n\r\n    const margin = {\r\n      property: this._getProperty(\"margin\", marginPosition),\r\n      value: this.options.sidenavMode === \"push\" ? -1 * this.width : 0,\r\n    };\r\n\r\n    EventHandler.trigger(this._element, \"update.te.sidenav\", {\r\n      margin,\r\n      padding,\r\n    });\r\n\r\n    if (!this._content) {\r\n      return;\r\n    }\r\n    this._content.className = \"\";\r\n\r\n    this._setContentOffsets(show, { padding, margin }, initial);\r\n  }\r\n\r\n  _updateTogglerAria(show) {\r\n    this.toggler.setAttribute(\"aria-expanded\", show);\r\n  }\r\n\r\n  _addBackdropOnInit = () => {\r\n    if (this._options.sidenavHidden) {\r\n      return;\r\n    }\r\n    this._backdrop.show();\r\n    EventHandler.off(this._element, \"transitionend\", this._addBackdropOnInit);\r\n  };\r\n\r\n  // Static\r\n\r\n  static toggleSidenav() {\r\n    return function (e) {\r\n      const toggler = SelectorEngine.closest(e.target, SELECTOR_TOGGLE);\r\n\r\n      const elementSelector = Manipulator.getDataAttributes(toggler).target;\r\n      SelectorEngine.find(elementSelector).forEach((element) => {\r\n        const instance = Sidenav.getInstance(element) || new Sidenav(element);\r\n        instance.toggle();\r\n      });\r\n    };\r\n  }\r\n\r\n  static jQueryInterface(config, options) {\r\n    return this.each(function () {\r\n      let data = Data.getData(this, DATA_KEY);\r\n      const _config = typeof config === \"object\" && config;\r\n\r\n      if (!data && /dispose/.test(config)) {\r\n        return;\r\n      }\r\n\r\n      if (!data) {\r\n        data = new Sidenav(this, _config);\r\n      }\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config](options);\r\n      }\r\n    });\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Sidenav;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Data from \"../dom/data\";\r\nimport EventHandler from \"../dom/event-handler\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport Manipulator from \"../dom/manipulator\";\r\nimport { typeCheckConfig } from \"../util/index\";\r\nimport {\r\n  LEFT_ARROW,\r\n  RIGHT_ARROW,\r\n  UP_ARROW,\r\n  DOWN_ARROW,\r\n  HOME,\r\n  END,\r\n  ENTER,\r\n  SPACE,\r\n  TAB,\r\n} from \"../util/keycodes\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"stepper\";\r\nconst DATA_KEY = \"te.stepper\";\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst REF = `data-te-${NAME}`;\r\n\r\nconst STEPPER_HORIZONTAL = \"horizontal\";\r\nconst STEPPER_VERTICAL = \"vertical\";\r\n\r\nconst DefaultType = {\r\n  stepperType: \"string\",\r\n  stepperLinear: \"boolean\",\r\n  stepperNoEditable: \"boolean\",\r\n  stepperActive: \"string\",\r\n  stepperCompleted: \"string\",\r\n  stepperInvalid: \"string\",\r\n  stepperDisabled: \"string\",\r\n  stepperVerticalBreakpoint: \"number\",\r\n  stepperMobileBreakpoint: \"number\",\r\n  stepperMobileBarBreakpoint: \"number\",\r\n};\r\n\r\nconst Default = {\r\n  stepperType: STEPPER_HORIZONTAL,\r\n  stepperLinear: false,\r\n  stepperNoEditable: false,\r\n  stepperActive: \"\",\r\n  stepperCompleted: \"\",\r\n  stepperInvalid: \"\",\r\n  stepperDisabled: \"\",\r\n  stepperVerticalBreakpoint: 0,\r\n  stepperMobileBreakpoint: 0,\r\n  stepperMobileBarBreakpoint: 4,\r\n};\r\n\r\nconst EVENT_MOUSEDOWN = `mousedown${EVENT_KEY}`;\r\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY}`;\r\nconst EVENT_KEYUP = `keyup${EVENT_KEY}`;\r\nconst EVENT_RESIZE = `resize${EVENT_KEY}`;\r\n\r\nconst STEP_REF = `[${REF}-step-ref]`;\r\nconst HEAD_REF = `[${REF}-head-ref]`;\r\nconst HEAD_TEXT_REF = `[${REF}-head-text-ref]`;\r\nconst HEAD_ICON_REF = `[${REF}-head-icon-ref]`;\r\nconst CONTENT_REF = `[${REF}-content-ref]`;\r\n\r\nclass Stepper {\r\n  constructor(element, options) {\r\n    this._element = element;\r\n    this._options = this._getConfig(options);\r\n    this._elementHeight = 0;\r\n    this._steps = SelectorEngine.find(`${STEP_REF}`, this._element);\r\n    this._currentView = \"\";\r\n    this._activeStepIndex = 0;\r\n    this._verticalStepperStyles = [];\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n      this._init();\r\n    }\r\n  }\r\n\r\n  // Getters\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get activeStep() {\r\n    return this._steps[this._activeStepIndex];\r\n  }\r\n\r\n  get activeStepIndex() {\r\n    return this._activeStepIndex;\r\n  }\r\n\r\n  // Public\r\n\r\n  dispose() {\r\n    this._steps.forEach((el) => {\r\n      EventHandler.off(el, EVENT_MOUSEDOWN);\r\n      EventHandler.off(el, EVENT_KEYDOWN);\r\n    });\r\n\r\n    EventHandler.off(window, EVENT_RESIZE);\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n    this._element = null;\r\n  }\r\n\r\n  changeStep(index) {\r\n    this._toggleStep(index);\r\n  }\r\n\r\n  nextStep() {\r\n    this._toggleStep(this._activeStepIndex + 1);\r\n  }\r\n\r\n  previousStep() {\r\n    this._toggleStep(this._activeStepIndex - 1);\r\n  }\r\n\r\n  // Private\r\n  _init() {\r\n    const activeStep = SelectorEngine.find(`${STEP_REF}`, this._element)[\r\n      this._activeStepIndex\r\n    ].setAttribute(\"data-te\", \"active-step\");\r\n    const stepperHeadText = SelectorEngine.find(\r\n      `${HEAD_TEXT_REF}`,\r\n      this._element\r\n    );\r\n    const stepperHeadIcon = SelectorEngine.find(\r\n      `${HEAD_ICON_REF}`,\r\n      this._element\r\n    );\r\n\r\n    if (activeStep) {\r\n      this._activeStepIndex = this._steps.indexOf(activeStep);\r\n      this._toggleStepClass(\r\n        this._activeStepIndex,\r\n        \"add\",\r\n        this._options.stepperActive\r\n      );\r\n\r\n      stepperHeadText[this._activeStepIndex].classList.add(\"font-medium\");\r\n      stepperHeadIcon[this._activeStepIndex].classList.add(\"!bg-primary-100\");\r\n      stepperHeadIcon[this._activeStepIndex].classList.add(\"!text-primary-700\");\r\n    } else {\r\n      stepperHeadText[this._activeStepIndex].classList.add(\"font-medium\");\r\n      stepperHeadIcon[this._activeStepIndex].classList.add(\"!bg-primary-100\");\r\n      stepperHeadIcon[this._activeStepIndex].classList.add(\"!text-primary-700\");\r\n      this._toggleStepClass(\r\n        this._activeStepIndex,\r\n        \"add\",\r\n        this._options.stepperActive\r\n      );\r\n    }\r\n\r\n    this._bindMouseDown();\r\n    this._bindKeysNavigation();\r\n\r\n    switch (this._options.stepperType) {\r\n      case STEPPER_VERTICAL:\r\n        this._toggleVertical();\r\n        break;\r\n      default:\r\n        this._toggleHorizontal();\r\n        break;\r\n    }\r\n\r\n    if (\r\n      this._options.stepperVerticalBreakpoint ||\r\n      this._options.stepperMobileBreakpoint\r\n    ) {\r\n      this._toggleStepperView();\r\n    }\r\n\r\n    this._bindResize();\r\n  }\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _bindMouseDown() {\r\n    this._steps.forEach((el) => {\r\n      const stepHead = SelectorEngine.findOne(`${HEAD_REF}`, el);\r\n\r\n      EventHandler.on(stepHead, EVENT_MOUSEDOWN, (e) => {\r\n        const step = SelectorEngine.parents(e.target, `${STEP_REF}`)[0];\r\n        const stepIndex = this._steps.indexOf(step);\r\n\r\n        e.preventDefault();\r\n        this._toggleStep(stepIndex);\r\n      });\r\n    });\r\n  }\r\n\r\n  _bindResize() {\r\n    EventHandler.on(window, EVENT_RESIZE, () => {\r\n      if (this._currentView === STEPPER_VERTICAL) {\r\n        this._setSingleStepHeight(this.activeStep);\r\n      }\r\n\r\n      if (this._currentView === STEPPER_HORIZONTAL) {\r\n        this._setHeight(this.activeStep);\r\n      }\r\n\r\n      if (\r\n        this._options.stepperVerticalBreakpoint ||\r\n        this._options.stepperMobileBreakpoint\r\n      ) {\r\n        this._toggleStepperView();\r\n      }\r\n    });\r\n  }\r\n\r\n  _toggleStepperView() {\r\n    const shouldBeHorizontal =\r\n      this._options.stepperVerticalBreakpoint < window.innerWidth;\r\n    const shouldBeVertical =\r\n      this._options.stepperVerticalBreakpoint > window.innerWidth;\r\n    const shouldBeMobile =\r\n      this._options.stepperMobileBreakpoint > window.innerWidth;\r\n\r\n    if (shouldBeHorizontal && this._currentView !== STEPPER_HORIZONTAL) {\r\n      this._toggleHorizontal();\r\n    }\r\n\r\n    if (\r\n      shouldBeVertical &&\r\n      !shouldBeMobile &&\r\n      this._currentView !== STEPPER_VERTICAL\r\n    ) {\r\n      this._steps.forEach((el) => {\r\n        const stepContent = SelectorEngine.findOne(`${CONTENT_REF}`, el);\r\n\r\n        this._resetStepperHeight();\r\n        this._showElement(stepContent);\r\n      });\r\n\r\n      this._toggleVertical();\r\n    }\r\n  }\r\n\r\n  _toggleStep(index) {\r\n    if (this._activeStepIndex === index) {\r\n      return;\r\n    }\r\n\r\n    if (this._options.stepperNoEditable) {\r\n      this._toggleDisabled();\r\n    }\r\n\r\n    this._showElement(\r\n      SelectorEngine.findOne(`${CONTENT_REF}`, this._steps[index])\r\n    );\r\n    this._toggleActive(index);\r\n\r\n    if (index > this._activeStepIndex) {\r\n      this._toggleCompleted(this._activeStepIndex);\r\n    }\r\n\r\n    if (this._currentView === STEPPER_HORIZONTAL) {\r\n      this._animateHorizontalStep(index);\r\n    } else {\r\n      this._animateVerticalStep(index);\r\n      this._setSingleStepHeight(this._steps[index]);\r\n    }\r\n\r\n    this._toggleStepTabIndex(\r\n      SelectorEngine.findOne(`${HEAD_REF}`, this.activeStep),\r\n      SelectorEngine.findOne(`${HEAD_REF}`, this._steps[index])\r\n    );\r\n\r\n    this._activeStepIndex = index;\r\n\r\n    this._steps[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\");\r\n    this._steps.forEach((step, index) => {\r\n      if (step[this._activeStepIndex] !== index) {\r\n        step.removeAttribute(\"data-te\");\r\n      }\r\n    });\r\n  }\r\n\r\n  _resetStepperHeight() {\r\n    this._element.style.height = \"\";\r\n  }\r\n\r\n  _setStepsHeight() {\r\n    this._steps.forEach((el) => {\r\n      const stepContent = SelectorEngine.findOne(`${CONTENT_REF}`, el);\r\n      const stepComputed = window.getComputedStyle(stepContent);\r\n      this._verticalStepperStyles.push({\r\n        paddingTop: parseFloat(stepComputed.paddingTop),\r\n        paddingBottom: parseFloat(stepComputed.paddingBottom),\r\n      });\r\n      const stepHeight = stepContent.scrollHeight;\r\n      stepContent.style.height = `${stepHeight}px`;\r\n    });\r\n  }\r\n\r\n  _setSingleStepHeight(step) {\r\n    const stepContent = SelectorEngine.findOne(`${CONTENT_REF}`, step);\r\n    const isActiveStep = this.activeStep === step;\r\n    const stepIndex = this._steps.indexOf(step);\r\n    let stepContentHeight;\r\n\r\n    if (!isActiveStep) {\r\n      stepContentHeight =\r\n        stepContent.scrollHeight +\r\n        this._verticalStepperStyles[stepIndex].paddingTop +\r\n        this._verticalStepperStyles[stepIndex].paddingBottom;\r\n    } else {\r\n      stepContent.style.height = \"\";\r\n      stepContentHeight = stepContent.scrollHeight;\r\n    }\r\n\r\n    stepContent.style.height = `${stepContentHeight}px`;\r\n  }\r\n\r\n  _toggleVertical() {\r\n    this._currentView = STEPPER_VERTICAL;\r\n\r\n    this._setStepsHeight();\r\n    this._hideInactiveSteps();\r\n  }\r\n\r\n  _toggleHorizontal() {\r\n    this._currentView = STEPPER_HORIZONTAL;\r\n\r\n    this._setHeight(this.activeStep);\r\n    this._hideInactiveSteps();\r\n  }\r\n\r\n  _toggleStepperClass() {\r\n    const vertical = SelectorEngine.findOne(\r\n      \"[data-te-stepper-type]\",\r\n      this._element\r\n    );\r\n\r\n    if (vertical !== null) {\r\n      this._steps.forEach((el) => {\r\n        SelectorEngine.findOne(`${CONTENT_REF}`, el).classList.remove(\"!my-0\");\r\n        SelectorEngine.findOne(`${CONTENT_REF}`, el).classList.remove(\"!py-0\");\r\n        SelectorEngine.findOne(`${CONTENT_REF}`, el).classList.remove(\"!h-0\");\r\n      });\r\n    }\r\n  }\r\n\r\n  _toggleStepClass(index, action, className) {\r\n    // condition to prevent errors if the user has not set any custom classes like active, disabled etc.\r\n    if (className) {\r\n      this._steps[index].classList[action](className);\r\n    }\r\n  }\r\n\r\n  _bindKeysNavigation() {\r\n    this._toggleStepTabIndex(\r\n      false,\r\n      SelectorEngine.findOne(`${HEAD_REF}`, this.activeStep)\r\n    );\r\n\r\n    this._steps.forEach((el) => {\r\n      const stepHead = SelectorEngine.findOne(`${HEAD_REF}`, el);\r\n\r\n      EventHandler.on(stepHead, EVENT_KEYDOWN, (e) => {\r\n        const focusedStep = SelectorEngine.parents(\r\n          e.currentTarget,\r\n          `${STEP_REF}`\r\n        )[0];\r\n        const nextStep = SelectorEngine.next(focusedStep, `${STEP_REF}`)[0];\r\n        const prevStep = SelectorEngine.prev(focusedStep, `${STEP_REF}`)[0];\r\n        const focusedStepHead = SelectorEngine.findOne(\r\n          `${HEAD_REF}`,\r\n          focusedStep\r\n        );\r\n        const activeStepHead = SelectorEngine.findOne(\r\n          `${HEAD_REF}`,\r\n          this.activeStep\r\n        );\r\n        let nextStepHead = null;\r\n        let prevStepHead = null;\r\n\r\n        if (nextStep) {\r\n          nextStepHead = SelectorEngine.findOne(`${HEAD_REF}`, nextStep);\r\n        }\r\n\r\n        if (prevStep) {\r\n          prevStepHead = SelectorEngine.findOne(`${HEAD_REF}`, prevStep);\r\n        }\r\n\r\n        if (\r\n          e.keyCode === LEFT_ARROW &&\r\n          this._currentView !== STEPPER_VERTICAL\r\n        ) {\r\n          if (prevStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, prevStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, prevStepHead);\r\n\r\n            prevStepHead.focus();\r\n          } else if (nextStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, nextStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, nextStepHead);\r\n\r\n            nextStepHead.focus();\r\n          }\r\n        }\r\n\r\n        if (\r\n          e.keyCode === RIGHT_ARROW &&\r\n          this._currentView !== STEPPER_VERTICAL\r\n        ) {\r\n          if (nextStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, nextStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, nextStepHead);\r\n\r\n            nextStepHead.focus();\r\n          } else if (prevStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, prevStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, prevStepHead);\r\n\r\n            prevStepHead.focus();\r\n          }\r\n        }\r\n\r\n        if (\r\n          e.keyCode === DOWN_ARROW &&\r\n          this._currentView === STEPPER_VERTICAL\r\n        ) {\r\n          e.preventDefault();\r\n\r\n          if (nextStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, nextStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, nextStepHead);\r\n\r\n            nextStepHead.focus();\r\n          }\r\n        }\r\n\r\n        if (e.keyCode === UP_ARROW && this._currentView === STEPPER_VERTICAL) {\r\n          e.preventDefault();\r\n\r\n          if (prevStepHead) {\r\n            this._toggleStepTabIndex(focusedStepHead, prevStepHead);\r\n            this._toggleOutlineStyles(focusedStepHead, prevStepHead);\r\n\r\n            prevStepHead.focus();\r\n          }\r\n        }\r\n\r\n        if (e.keyCode === HOME) {\r\n          const firstStepHead = SelectorEngine.findOne(\r\n            `${HEAD_REF}`,\r\n            this._steps[0]\r\n          );\r\n\r\n          this._toggleStepTabIndex(focusedStepHead, firstStepHead);\r\n          this._toggleOutlineStyles(focusedStepHead, firstStepHead);\r\n\r\n          firstStepHead.focus();\r\n        }\r\n\r\n        if (e.keyCode === END) {\r\n          const lastStep = this._steps[this._steps.length - 1];\r\n          const lastStepHead = SelectorEngine.findOne(`${HEAD_REF}`, lastStep);\r\n          this._toggleStepTabIndex(focusedStepHead, lastStepHead);\r\n          this._toggleOutlineStyles(focusedStepHead, lastStepHead);\r\n\r\n          lastStepHead.focus();\r\n        }\r\n\r\n        if (e.keyCode === ENTER || e.keyCode === SPACE) {\r\n          e.preventDefault();\r\n\r\n          this.changeStep(this._steps.indexOf(focusedStep));\r\n        }\r\n\r\n        if (e.keyCode === TAB) {\r\n          this._toggleStepTabIndex(focusedStepHead, activeStepHead);\r\n          this._toggleOutlineStyles(focusedStepHead, false);\r\n\r\n          activeStepHead.focus();\r\n        }\r\n      });\r\n\r\n      EventHandler.on(stepHead, EVENT_KEYUP, (e) => {\r\n        const focusedStep = SelectorEngine.parents(\r\n          e.currentTarget,\r\n          `${STEP_REF}`\r\n        )[0];\r\n        const focusedStepHead = SelectorEngine.findOne(\r\n          `${HEAD_REF}`,\r\n          focusedStep\r\n        );\r\n        const activeStepHead = SelectorEngine.findOne(\r\n          `${HEAD_REF}`,\r\n          this.activeStep\r\n        );\r\n\r\n        if (e.keyCode === TAB) {\r\n          this._toggleStepTabIndex(focusedStepHead, activeStepHead);\r\n          this._toggleOutlineStyles(false, activeStepHead);\r\n\r\n          activeStepHead.focus();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _toggleStepTabIndex(focusedElement, newTarget) {\r\n    if (focusedElement) {\r\n      focusedElement.setAttribute(\"tabIndex\", -1);\r\n    }\r\n\r\n    if (newTarget) {\r\n      newTarget.setAttribute(\"tabIndex\", 0);\r\n    }\r\n  }\r\n\r\n  _toggleOutlineStyles(focusedElement, newTarget) {\r\n    if (focusedElement) {\r\n      focusedElement.style.outline = \"\";\r\n    }\r\n\r\n    if (newTarget) {\r\n      newTarget.style.outline = \"revert\";\r\n    }\r\n  }\r\n\r\n  _toggleDisabled() {\r\n    const stepperHead = SelectorEngine.find(`${HEAD_REF}`, this._element);\r\n    const stepperHeadIcon = SelectorEngine.find(\r\n      `${HEAD_ICON_REF}`,\r\n      this._element\r\n    );\r\n\r\n    stepperHead[this._activeStepIndex].classList.add(\"color-[#858585]\");\r\n    stepperHead[this._activeStepIndex].classList.add(\"cursor-default\");\r\n    stepperHeadIcon[this._activeStepIndex].classList.add(\"!bg-[#858585]\");\r\n    this._toggleStepClass(\r\n      this._activeStepIndex,\r\n      \"add\",\r\n      this._options.stepperDisabled\r\n    );\r\n  }\r\n\r\n  _toggleActive(index) {\r\n    const stepperHeadText = SelectorEngine.find(\r\n      `${HEAD_TEXT_REF}`,\r\n      this._element\r\n    );\r\n    const stepperHeadIcon = SelectorEngine.find(\r\n      `${HEAD_ICON_REF}`,\r\n      this._element\r\n    );\r\n\r\n    stepperHeadText[index].classList.add(\"font-medium\");\r\n    stepperHeadIcon[index].classList.add(\"!bg-primary-100\");\r\n    stepperHeadIcon[index].classList.add(\"!text-primary-700\");\r\n    stepperHeadIcon[index].classList.remove(\"!bg-success-100\");\r\n    stepperHeadIcon[index].classList.remove(\"!text-success-700\");\r\n\r\n    stepperHeadText[this._activeStepIndex].classList.remove(\"font-medium\");\r\n    stepperHeadIcon[this._activeStepIndex].classList.remove(\"!bg-primary-100\");\r\n    stepperHeadIcon[this._activeStepIndex].classList.remove(\r\n      \"!text-primary-700\"\r\n    );\r\n\r\n    this._toggleStepClass(index, \"add\", this._options.stepperActive);\r\n    this._toggleStepClass(\r\n      this._activeStepIndex,\r\n      \"remove\",\r\n      this._options.stepperActive\r\n    );\r\n  }\r\n\r\n  _toggleCompleted(index) {\r\n    const stepperHeadIcon = SelectorEngine.find(\r\n      `${HEAD_ICON_REF}`,\r\n      this._element\r\n    );\r\n    stepperHeadIcon[index].classList.add(\"!bg-success-100\");\r\n    stepperHeadIcon[index].classList.add(\"!text-success-700\");\r\n    stepperHeadIcon[index].classList.remove(\"!bg-danger-100\");\r\n    stepperHeadIcon[index].classList.remove(\"!text-danger-700\");\r\n\r\n    this._toggleStepClass(index, \"add\", this._options.stepperCompleted);\r\n    this._toggleStepClass(index, \"remove\", this._options.stepperInvalid);\r\n  }\r\n\r\n  _hideInactiveSteps() {\r\n    this._steps.forEach((el) => {\r\n      if (!el.getAttribute(\"data-te\")) {\r\n        this._hideElement(SelectorEngine.findOne(`${CONTENT_REF}`, el));\r\n      }\r\n    });\r\n  }\r\n\r\n  _setHeight(stepElement) {\r\n    const stepContent = SelectorEngine.findOne(`${CONTENT_REF}`, stepElement);\r\n    const contentStyle = getComputedStyle(stepContent);\r\n    const stepHead = SelectorEngine.findOne(`${HEAD_REF}`, stepElement);\r\n\r\n    const headStyle = getComputedStyle(stepHead);\r\n    const stepContentHeight =\r\n      stepContent.offsetHeight +\r\n      parseFloat(contentStyle.marginTop) +\r\n      parseFloat(contentStyle.marginBottom);\r\n\r\n    const stepHeadHeight =\r\n      stepHead.offsetHeight +\r\n      parseFloat(headStyle.marginTop) +\r\n      parseFloat(headStyle.marginBottom);\r\n\r\n    this._element.style.height = `${stepHeadHeight + stepContentHeight}px`;\r\n  }\r\n\r\n  _hideElement(stepContent) {\r\n    const isActive = SelectorEngine.parents(\r\n      stepContent,\r\n      `${STEP_REF}`\r\n    )[0].getAttribute(\"data-te\");\r\n\r\n    // prevent hiding during a quick step change\r\n    if (!isActive && this._currentView !== STEPPER_VERTICAL) {\r\n      // stepContent.style.display = 'none';\r\n    } else {\r\n      stepContent.classList.add(\"!my-0\");\r\n      stepContent.classList.add(\"!py-0\");\r\n      stepContent.classList.add(\"!h-0\");\r\n    }\r\n  }\r\n\r\n  _showElement(stepContent) {\r\n    if (this._currentView === STEPPER_VERTICAL) {\r\n      stepContent.classList.remove(\"!my-0\");\r\n      stepContent.classList.remove(\"!py-0\");\r\n      stepContent.classList.remove(\"!h-0\");\r\n    } else {\r\n      stepContent.style.display = \"block\";\r\n    }\r\n  }\r\n\r\n  _animateHorizontalStep(index) {\r\n    const isForward = index > this._activeStepIndex;\r\n    const nextStepContent = SelectorEngine.findOne(\r\n      `${CONTENT_REF}`,\r\n      this._steps[index]\r\n    );\r\n    const activeStepContent = SelectorEngine.findOne(\r\n      `${CONTENT_REF}`,\r\n      this.activeStep\r\n    );\r\n\r\n    let nextStepAnimation;\r\n    let activeStepAnimation;\r\n\r\n    this._steps.forEach((el, i) => {\r\n      const stepContent = SelectorEngine.findOne(`${CONTENT_REF}`, el);\r\n\r\n      if (i !== index && i !== this._activeStepIndex) {\r\n        this._hideElement(stepContent);\r\n      }\r\n    });\r\n\r\n    const CLASS_NAME_SLIDE_RIGHT = \"translate-x-[150%]\";\r\n    const CLASS_NAME_SLIDE_LEFT = \"-translate-x-[150%]\";\r\n    const CLASS_NAME_SLIDE_IN = \"translate-0\";\r\n\r\n    if (isForward) {\r\n      activeStepAnimation = CLASS_NAME_SLIDE_LEFT;\r\n      nextStepAnimation = CLASS_NAME_SLIDE_IN;\r\n      nextStepContent.classList.remove(\"translate-x-[150%]\");\r\n      nextStepContent.classList.remove(\"-translate-x-[150%]\");\r\n    } else {\r\n      activeStepAnimation = CLASS_NAME_SLIDE_RIGHT;\r\n      nextStepAnimation = CLASS_NAME_SLIDE_IN;\r\n      nextStepContent.classList.remove(\"-translate-x-[150%]\");\r\n      nextStepContent.classList.remove(\"translate-x-[150%]\");\r\n    }\r\n\r\n    activeStepContent.classList.add(activeStepAnimation);\r\n    nextStepContent.classList.add(nextStepAnimation);\r\n\r\n    this._setHeight(this._steps[index]);\r\n  }\r\n\r\n  _animateVerticalStep(index) {\r\n    const nextStepContent = SelectorEngine.findOne(\r\n      `${CONTENT_REF}`,\r\n      this._steps[index]\r\n    );\r\n    const activeStepContent = SelectorEngine.findOne(\r\n      `${CONTENT_REF}`,\r\n      this.activeStep\r\n    );\r\n\r\n    this._hideElement(activeStepContent);\r\n    this._showElement(nextStepContent);\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Stepper;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\n\r\nconst DATA_ACTIVE = \"data-te-input-state-active\";\r\nconst DATA_SELECTED = \"data-te-input-selected\";\r\nconst DATA_MULTIPLE_ACTIVE = \"data-te-input-multiple-active\";\r\n\r\nconst SELECTOR_FORM_CHECK_INPUT = \"[data-te-form-check-input]\";\r\n\r\nclass SelectOption {\r\n  constructor(\r\n    id,\r\n    nativeOption,\r\n    multiple,\r\n    value,\r\n    label,\r\n    selected,\r\n    disabled,\r\n    hidden,\r\n    secondaryText,\r\n    groupId,\r\n    icon\r\n  ) {\r\n    this.id = id;\r\n    this.nativeOption = nativeOption;\r\n    this.multiple = multiple;\r\n    this.value = value;\r\n    this.label = label;\r\n    this.selected = selected;\r\n    this.disabled = disabled;\r\n    this.hidden = hidden;\r\n    this.secondaryText = secondaryText;\r\n    this.groupId = groupId;\r\n    this.icon = icon;\r\n    this.node = null;\r\n    this.active = false;\r\n  }\r\n\r\n  select() {\r\n    if (this.multiple) {\r\n      this._selectMultiple();\r\n    } else {\r\n      this._selectSingle();\r\n    }\r\n  }\r\n\r\n  _selectSingle() {\r\n    if (!this.selected) {\r\n      this.node.setAttribute(DATA_SELECTED, \"\");\r\n      this.node.setAttribute(\"aria-selected\", true);\r\n      this.selected = true;\r\n\r\n      if (this.nativeOption) {\r\n        this.nativeOption.selected = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  _selectMultiple() {\r\n    if (!this.selected) {\r\n      const checkbox = SelectorEngine.findOne(\r\n        SELECTOR_FORM_CHECK_INPUT,\r\n        this.node\r\n      );\r\n      checkbox.checked = true;\r\n      this.node.setAttribute(DATA_SELECTED, \"\");\r\n\r\n      this.node.setAttribute(\"aria-selected\", true);\r\n      this.selected = true;\r\n\r\n      if (this.nativeOption) {\r\n        this.nativeOption.selected = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  deselect() {\r\n    if (this.multiple) {\r\n      this._deselectMultiple();\r\n    } else {\r\n      this._deselectSingle();\r\n    }\r\n  }\r\n\r\n  _deselectSingle() {\r\n    if (this.selected) {\r\n      this.node.removeAttribute(DATA_SELECTED);\r\n\r\n      this.node.setAttribute(\"aria-selected\", false);\r\n      this.selected = false;\r\n\r\n      if (this.nativeOption) {\r\n        this.nativeOption.selected = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  _deselectMultiple() {\r\n    if (this.selected) {\r\n      const checkbox = SelectorEngine.findOne(\r\n        SELECTOR_FORM_CHECK_INPUT,\r\n        this.node\r\n      );\r\n      checkbox.checked = false;\r\n      this.node.removeAttribute(DATA_SELECTED);\r\n\r\n      this.node.setAttribute(\"aria-selected\", false);\r\n      this.selected = false;\r\n\r\n      if (this.nativeOption) {\r\n        this.nativeOption.selected = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  setNode(node) {\r\n    this.node = node;\r\n  }\r\n\r\n  setActiveStyles() {\r\n    if (!this.active) {\r\n      if (this.multiple) {\r\n        this.node.setAttribute(DATA_MULTIPLE_ACTIVE, \"\");\r\n        return;\r\n      }\r\n      this.active = true;\r\n      this.node.setAttribute(DATA_ACTIVE, \"\");\r\n    }\r\n  }\r\n\r\n  removeActiveStyles() {\r\n    if (this.active) {\r\n      this.active = false;\r\n      this.node.removeAttribute(DATA_ACTIVE);\r\n    }\r\n    if (this.multiple) {\r\n      this.node.removeAttribute(DATA_MULTIPLE_ACTIVE);\r\n    }\r\n  }\r\n}\r\n\r\nexport default SelectOption;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nclass SelectionModel {\r\n  constructor(multiple = false) {\r\n    this._multiple = multiple;\r\n    this._selections = [];\r\n  }\r\n\r\n  select(option) {\r\n    if (this._multiple) {\r\n      this._selections.push(option);\r\n    } else {\r\n      this._selections = [option];\r\n    }\r\n  }\r\n\r\n  deselect(option) {\r\n    if (this._multiple) {\r\n      const optionIndex = this._selections.findIndex(\r\n        (selection) => option === selection\r\n      );\r\n      this._selections.splice(optionIndex, 1);\r\n    } else {\r\n      this._selections = [];\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this._selections = [];\r\n  }\r\n\r\n  get selection() {\r\n    return this._selections[0];\r\n  }\r\n\r\n  get selections() {\r\n    return this._selections;\r\n  }\r\n\r\n  get label() {\r\n    return this._selections[0] && this.selection.label;\r\n  }\r\n\r\n  get labels() {\r\n    return this._selections.map((selection) => selection.label).join(\", \");\r\n  }\r\n\r\n  get value() {\r\n    return this.selections[0] && this.selection.value;\r\n  }\r\n\r\n  get values() {\r\n    return this._selections.map((selection) => selection.value);\r\n  }\r\n}\r\n\r\nexport default SelectionModel;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nexport default function allOptionsSelected(options) {\r\n  return options\r\n    .filter((option) => !option.disabled)\r\n    .every((option) => {\r\n      return option.selected;\r\n    });\r\n}\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { element } from \"../../util/index\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport allOptionsSelected from \"./util\";\r\n\r\nconst DATA_FORM_OUTLINE = \"data-te-select-form-outline-ref\";\r\nconst DATA_SELECT_WRAPPER = \"data-te-select-wrapper-ref\";\r\nconst DATA_SELECT_INPUT = \"data-te-select-input-ref\";\r\nconst DATA_CLEAR_BUTTON = \"data-te-select-clear-btn-ref\";\r\nconst DATA_SELECT_DROPDOWN_CONTAINER = \"data-te-select-dropdown-container-ref\";\r\nconst DATA_DROPDOWN = \"data-te-select-dropdown-ref\";\r\nconst DATA_OPTIONS_WRAPPER = \"data-te-select-options-wrapper-ref\";\r\nconst DATA_OPTIONS_LIST = \"data-te-select-options-list-ref\";\r\nconst DATA_FILTER_INPUT = \"data-te-select-input-filter-ref\";\r\nconst DATA_OPTION = \"data-te-select-option-ref\";\r\nconst DATA_OPTION_ALL = \"data-te-select-option-all-ref\";\r\nconst DATA_SELECT_OPTION_TEXT = \"data-te-select-option-text-ref\";\r\nconst DATA_FORM_CHECK_INPUT = \"data-te-form-check-input\";\r\nconst DATA_SELECT_OPTION_GROUP = \"data-te-select-option-group-ref\";\r\nconst DATA_SELECT_OPTION_GROUP_LABEL = \"data-te-select-option-group-label-ref\";\r\n\r\nconst DATA_SELECTED = \"data-te-select-selected\";\r\n\r\nconst iconSVGTemplate = `\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\r\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\r\n</svg>\r\n`;\r\n\r\nconst preventKeydown = (event) => {\r\n  if (event.code === \"Tab\" || event.code === \"Esc\") {\r\n    return;\r\n  }\r\n\r\n  event.preventDefault();\r\n};\r\n\r\nfunction _setSizeClasses(element, config, defaultSize, smSize, lgSize) {\r\n  if (config.selectSize === \"default\") {\r\n    Manipulator.addClass(element, defaultSize);\r\n  }\r\n\r\n  if (config.selectSize === \"sm\") {\r\n    Manipulator.addClass(element, smSize);\r\n  }\r\n\r\n  if (config.selectSize === \"lg\") {\r\n    Manipulator.addClass(element, lgSize);\r\n  }\r\n}\r\n\r\nexport function getWrapperTemplate(id, config, label, classes) {\r\n  const wrapper = document.createElement(\"div\");\r\n  wrapper.setAttribute(\"id\", id);\r\n  wrapper.setAttribute(DATA_SELECT_WRAPPER, \"\");\r\n\r\n  const formOutline = element(\"div\");\r\n  formOutline.setAttribute(DATA_FORM_OUTLINE, \"\");\r\n  Manipulator.addClass(formOutline, classes.formOutline);\r\n\r\n  const input = element(\"input\");\r\n  const role = config.selectFilter ? \"combobox\" : \"listbox\";\r\n  const multiselectable = config.multiple ? \"true\" : \"false\";\r\n  const disabled = config.disabled ? \"true\" : \"false\";\r\n  input.setAttribute(DATA_SELECT_INPUT, \"\");\r\n  Manipulator.addClass(input, classes.selectInput);\r\n\r\n  _setSizeClasses(\r\n    input,\r\n    config,\r\n    classes.selectInputSizeDefault,\r\n    classes.selectInputSizeSm,\r\n    classes.selectInputSizeLg\r\n  );\r\n\r\n  if (config.selectFormWhite) {\r\n    Manipulator.addClass(input, classes.selectInputWhite);\r\n  }\r\n\r\n  input.setAttribute(\"type\", \"text\");\r\n  input.setAttribute(\"role\", role);\r\n  input.setAttribute(\"aria-multiselectable\", multiselectable);\r\n  input.setAttribute(\"aria-disabled\", disabled);\r\n  input.setAttribute(\"aria-haspopup\", \"true\");\r\n  input.setAttribute(\"aria-expanded\", false);\r\n\r\n  if (config.tabIndex) {\r\n    input.setAttribute(\"tabIndex\", config.tabIndex);\r\n  }\r\n\r\n  if (config.disabled) {\r\n    input.setAttribute(\"disabled\", \"\");\r\n  }\r\n\r\n  if (config.selectPlaceholder !== \"\") {\r\n    input.setAttribute(\"placeholder\", config.selectPlaceholder);\r\n  }\r\n\r\n  if (config.selectValidation) {\r\n    Manipulator.addStyle(input, {\r\n      \"pointer-events\": \"none\",\r\n      \"caret-color\": \"transparent\",\r\n    });\r\n    Manipulator.addStyle(formOutline, { cursor: \"pointer\" });\r\n  } else {\r\n    input.setAttribute(\"readonly\", \"true\");\r\n  }\r\n\r\n  if (config.selectValidation) {\r\n    input.setAttribute(\"required\", \"true\");\r\n    input.setAttribute(\"aria-required\", \"true\");\r\n    input.addEventListener(\"keydown\", preventKeydown);\r\n  }\r\n\r\n  const validFeedback = element(\"div\");\r\n  Manipulator.addClass(validFeedback, classes.selectValidationValid);\r\n\r\n  const validFeedBackText = document.createTextNode(\r\n    `${config.selectValidFeedback}`\r\n  );\r\n  validFeedback.appendChild(validFeedBackText);\r\n\r\n  const invalidFeedback = element(\"div\");\r\n  Manipulator.addClass(invalidFeedback, classes.selectValidationInvalid);\r\n\r\n  const invalidFeedBackText = document.createTextNode(\r\n    `${config.selectInvalidFeedback}`\r\n  );\r\n  invalidFeedback.appendChild(invalidFeedBackText);\r\n\r\n  const clearBtn = element(\"span\");\r\n  clearBtn.setAttribute(DATA_CLEAR_BUTTON, \"\");\r\n\r\n  Manipulator.addClass(clearBtn, classes.selectClearBtn);\r\n\r\n  _setSizeClasses(\r\n    clearBtn,\r\n    config,\r\n    classes.selectClearBtnDefault,\r\n    classes.selectClearBtnSm,\r\n    classes.selectClearBtnLg\r\n  );\r\n\r\n  if (config.selectFormWhite) {\r\n    Manipulator.addClass(clearBtn, classes.selectClearBtnWhite);\r\n  }\r\n\r\n  const clearBtnText = document.createTextNode(\"\\u2715\");\r\n  clearBtn.appendChild(clearBtnText);\r\n  clearBtn.setAttribute(\"tabindex\", \"0\");\r\n\r\n  const arrow = element(\"span\");\r\n  Manipulator.addClass(arrow, classes.selectArrow);\r\n\r\n  _setSizeClasses(\r\n    arrow,\r\n    config,\r\n    classes.selectArrowDefault,\r\n    classes.selectArrowSm,\r\n    classes.selectArrowLg\r\n  );\r\n\r\n  if (config.selectFormWhite) {\r\n    Manipulator.addClass(arrow, classes.selectArrowWhite);\r\n  }\r\n\r\n  arrow.innerHTML = iconSVGTemplate;\r\n\r\n  formOutline.appendChild(input);\r\n\r\n  if (label) {\r\n    Manipulator.addClass(label, classes.selectLabel);\r\n\r\n    _setSizeClasses(\r\n      label,\r\n      config,\r\n      classes.selectLabelSizeDefault,\r\n      classes.selectLabelSizeSm,\r\n      classes.selectLabelSizeLg\r\n    );\r\n\r\n    if (config.selectFormWhite) {\r\n      Manipulator.addClass(label, classes.selectLabelWhite);\r\n    }\r\n\r\n    formOutline.appendChild(label);\r\n  }\r\n\r\n  if (config.selectValidation) {\r\n    formOutline.appendChild(validFeedback);\r\n    formOutline.appendChild(invalidFeedback);\r\n  }\r\n\r\n  if (config.selectClearButton) {\r\n    formOutline.appendChild(clearBtn);\r\n  }\r\n\r\n  formOutline.appendChild(arrow);\r\n\r\n  wrapper.appendChild(formOutline);\r\n  return wrapper;\r\n}\r\n\r\nexport function getDropdownTemplate(\r\n  id,\r\n  config,\r\n  width,\r\n  height,\r\n  selectAllOption,\r\n  options,\r\n  customContent,\r\n  classes\r\n) {\r\n  const dropdownContainer = document.createElement(\"div\");\r\n  dropdownContainer.setAttribute(DATA_SELECT_DROPDOWN_CONTAINER, \"\");\r\n  Manipulator.addClass(dropdownContainer, classes.selectDropdownContainer);\r\n\r\n  dropdownContainer.setAttribute(\"id\", `${id}`);\r\n  dropdownContainer.style.width = `${width}px`;\r\n\r\n  const dropdown = document.createElement(\"div\");\r\n  dropdown.setAttribute(\"tabindex\", 0);\r\n  dropdown.setAttribute(DATA_DROPDOWN, \"\");\r\n  Manipulator.addClass(dropdown, classes.dropdown);\r\n\r\n  const optionsWrapper = element(\"div\");\r\n  optionsWrapper.setAttribute(DATA_OPTIONS_WRAPPER, \"\");\r\n  Manipulator.addClass(optionsWrapper, classes.optionsWrapper);\r\n  Manipulator.addClass(optionsWrapper, classes.optionsWrapperScrollbar);\r\n  optionsWrapper.style.maxHeight = `${height}px`;\r\n\r\n  const optionsList = getOptionsListTemplate(\r\n    options,\r\n    selectAllOption,\r\n    config,\r\n    classes\r\n  );\r\n\r\n  optionsWrapper.appendChild(optionsList);\r\n\r\n  if (config.selectFilter) {\r\n    dropdown.appendChild(\r\n      getFilterTemplate(config.selectSearchPlaceholder, classes)\r\n    );\r\n  }\r\n\r\n  dropdown.appendChild(optionsWrapper);\r\n  if (customContent) {\r\n    dropdown.appendChild(customContent);\r\n  }\r\n\r\n  dropdownContainer.appendChild(dropdown);\r\n\r\n  return dropdownContainer;\r\n}\r\n\r\nexport function getOptionsListTemplate(\r\n  options,\r\n  selectAllOption,\r\n  config,\r\n  classes\r\n) {\r\n  const optionsList = element(\"div\");\r\n  optionsList.setAttribute(DATA_OPTIONS_LIST, \"\");\r\n  Manipulator.addClass(optionsList, classes.optionsList);\r\n\r\n  let optionsNodes;\r\n\r\n  if (config.multiple) {\r\n    optionsNodes = getMultipleOptionsNodes(\r\n      options,\r\n      selectAllOption,\r\n      config,\r\n      classes\r\n    );\r\n  } else {\r\n    optionsNodes = getSingleOptionsNodes(options, config, classes);\r\n  }\r\n\r\n  optionsNodes.forEach((node) => {\r\n    optionsList.appendChild(node);\r\n  });\r\n\r\n  return optionsList;\r\n}\r\n\r\nexport function getFilterTemplate(placeholder, classes) {\r\n  const inputGroup = element(\"div\");\r\n  Manipulator.addClass(inputGroup, classes.inputGroup);\r\n\r\n  const input = element(\"input\");\r\n\r\n  input.setAttribute(DATA_FILTER_INPUT, \"\");\r\n  Manipulator.addClass(input, classes.selectFilterInput);\r\n  input.placeholder = placeholder;\r\n  input.setAttribute(\"role\", \"searchbox\");\r\n  input.setAttribute(\"type\", \"text\");\r\n\r\n  inputGroup.appendChild(input);\r\n\r\n  return inputGroup;\r\n}\r\n\r\nfunction getSingleOptionsNodes(options, config, classes) {\r\n  const nodes = getOptionsNodes(options, config, classes);\r\n  return nodes;\r\n}\r\n\r\nfunction getMultipleOptionsNodes(options, selectAllOption, config, classes) {\r\n  let selectAllNode = null;\r\n\r\n  if (config.selectAll) {\r\n    selectAllNode = createSelectAllNode(\r\n      selectAllOption,\r\n      options,\r\n      config,\r\n      classes\r\n    );\r\n  }\r\n  const optionsNodes = getOptionsNodes(options, config, classes);\r\n  const nodes = selectAllNode ? [selectAllNode, ...optionsNodes] : optionsNodes;\r\n  return nodes;\r\n}\r\n\r\nfunction getOptionsNodes(options, config, classes) {\r\n  const nodes = [];\r\n\r\n  options.forEach((option) => {\r\n    const isOptionGroup = Object.prototype.hasOwnProperty.call(\r\n      option,\r\n      \"options\"\r\n    );\r\n    if (isOptionGroup) {\r\n      const group = createOptionGroupTemplate(option, config, classes);\r\n      nodes.push(group);\r\n    } else {\r\n      nodes.push(createOptionTemplate(option, config, classes));\r\n    }\r\n  });\r\n\r\n  return nodes;\r\n}\r\n\r\nfunction createSelectAllNode(option, options, config, classes) {\r\n  const isSelected = allOptionsSelected(options);\r\n  const optionNode = element(\"div\");\r\n  optionNode.setAttribute(DATA_OPTION, \"\");\r\n  Manipulator.addClass(optionNode, classes.selectOption);\r\n  optionNode.setAttribute(DATA_OPTION_ALL, \"\");\r\n  Manipulator.addStyle(optionNode, {\r\n    height: `${config.selectOptionHeight}px`,\r\n  });\r\n  optionNode.setAttribute(\"role\", \"option\");\r\n  optionNode.setAttribute(\"aria-selected\", isSelected);\r\n\r\n  if (isSelected) {\r\n    optionNode.setAttribute(DATA_SELECTED, \"\");\r\n  }\r\n\r\n  optionNode.appendChild(getOptionContentTemplate(option, config, classes));\r\n  option.setNode(optionNode);\r\n\r\n  return optionNode;\r\n}\r\n\r\nfunction createOptionTemplate(option, config, classes) {\r\n  if (option.node) {\r\n    return option.node;\r\n  }\r\n  const optionNode = element(\"div\");\r\n  optionNode.setAttribute(DATA_OPTION, \"\");\r\n  Manipulator.addClass(optionNode, classes.selectOption);\r\n\r\n  Manipulator.addStyle(optionNode, {\r\n    height: `${config.selectOptionHeight}px`,\r\n  });\r\n  Manipulator.setDataAttribute(optionNode, \"id\", option.id);\r\n  optionNode.setAttribute(\"role\", \"option\");\r\n  optionNode.setAttribute(\"aria-selected\", option.selected);\r\n  optionNode.setAttribute(\"aria-disabled\", option.disabled);\r\n\r\n  if (option.selected) {\r\n    optionNode.setAttribute(DATA_SELECTED, \"\");\r\n  }\r\n\r\n  if (option.disabled) {\r\n    optionNode.setAttribute(\"data-te-select-option-disabled\", true);\r\n  }\r\n\r\n  if (option.hidden) {\r\n    Manipulator.addClass(optionNode, \"hidden\");\r\n  }\r\n\r\n  optionNode.appendChild(getOptionContentTemplate(option, config, classes));\r\n\r\n  if (option.icon) {\r\n    optionNode.appendChild(getOptionIconTemplate(option, classes));\r\n  }\r\n\r\n  option.setNode(optionNode);\r\n\r\n  return optionNode;\r\n}\r\n\r\nfunction getOptionContentTemplate(option, config, classes) {\r\n  const content = element(\"span\");\r\n  content.setAttribute(DATA_SELECT_OPTION_TEXT, \"\");\r\n  Manipulator.addClass(content, classes.selectOptionText);\r\n\r\n  const label = document.createTextNode(option.label);\r\n\r\n  if (config.multiple) {\r\n    content.appendChild(getCheckboxTemplate(option, classes));\r\n  }\r\n\r\n  content.appendChild(label);\r\n  if (option.secondaryText || typeof option.secondaryText === \"number\") {\r\n    content.appendChild(\r\n      getSecondaryTextTemplate(option.secondaryText, classes)\r\n    );\r\n  }\r\n\r\n  return content;\r\n}\r\n\r\nfunction getSecondaryTextTemplate(text, classes) {\r\n  const span = element(\"span\");\r\n  Manipulator.addClass(span, classes.selectOptionSecondaryText);\r\n  const textContent = document.createTextNode(text);\r\n  span.appendChild(textContent);\r\n  return span;\r\n}\r\n\r\nfunction getCheckboxTemplate(option, classes) {\r\n  const checkbox = element(\"input\");\r\n  checkbox.setAttribute(\"type\", \"checkbox\");\r\n  Manipulator.addClass(checkbox, classes.formCheckInput);\r\n  checkbox.setAttribute(DATA_FORM_CHECK_INPUT, \"\");\r\n\r\n  const label = element(\"label\");\r\n\r\n  if (option.selected) {\r\n    checkbox.setAttribute(\"checked\", true);\r\n  }\r\n\r\n  if (option.disabled) {\r\n    checkbox.setAttribute(\"disabled\", true);\r\n  }\r\n\r\n  checkbox.appendChild(label);\r\n  return checkbox;\r\n}\r\n\r\nfunction getOptionIconTemplate(option, classes) {\r\n  const container = element(\"span\");\r\n  const image = element(\"img\");\r\n  Manipulator.addClass(image, classes.selectOptionIcon);\r\n\r\n  image.src = option.icon;\r\n\r\n  container.appendChild(image);\r\n  return container;\r\n}\r\n\r\nfunction createOptionGroupTemplate(optionGroup, config, classes) {\r\n  const group = element(\"div\");\r\n\r\n  group.setAttribute(DATA_SELECT_OPTION_GROUP, \"\");\r\n  Manipulator.addClass(group, classes.selectOptionGroup);\r\n\r\n  group.setAttribute(\"role\", \"group\");\r\n  group.setAttribute(\"id\", optionGroup.id);\r\n\r\n  if (optionGroup.hidden) {\r\n    Manipulator.addClass(group, \"hidden\");\r\n  }\r\n\r\n  const label = element(\"label\");\r\n  label.setAttribute(DATA_SELECT_OPTION_GROUP_LABEL, \"\");\r\n  Manipulator.addClass(label, classes.selectOptionGroupLabel);\r\n\r\n  Manipulator.addStyle(label, { height: `${config.selectOptionHeight}px` });\r\n  label.setAttribute(\"for\", optionGroup.id);\r\n  label.textContent = optionGroup.label;\r\n\r\n  group.appendChild(label);\r\n\r\n  optionGroup.options.forEach((option) => {\r\n    group.appendChild(createOptionTemplate(option, config, classes));\r\n  });\r\n\r\n  return group;\r\n}\r\n\r\nexport function getFakeValueTemplate(value, classes) {\r\n  const fakeValue = element(\"div\");\r\n  fakeValue.innerHTML = value;\r\n  Manipulator.addClass(fakeValue, classes.selectLabel);\r\n\r\n  Manipulator.addClass(fakeValue, classes.selectFakeValue);\r\n\r\n  return fakeValue;\r\n}\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { createPopper } from \"@popperjs/core\";\r\nimport Data from \"../../dom/data\";\r\nimport EventHandler from \"../../dom/event-handler\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\nimport { typeCheckConfig, getUID } from \"../../util/index\";\r\nimport Input from \"../input\";\r\nimport SelectOption from \"./select-option\";\r\nimport SelectionModel from \"./selection-model\";\r\nimport {\r\n  ESCAPE,\r\n  ENTER,\r\n  DOWN_ARROW,\r\n  UP_ARROW,\r\n  HOME,\r\n  END,\r\n  TAB,\r\n} from \"../../util/keycodes\";\r\nimport allOptionsSelected from \"./util\";\r\nimport {\r\n  getWrapperTemplate,\r\n  getDropdownTemplate,\r\n  getOptionsListTemplate,\r\n  getFakeValueTemplate,\r\n} from \"./templates\";\r\n\r\nconst NAME = \"select\";\r\nconst DATA_KEY = \"te.select\";\r\n\r\nconst EVENT_KEY = `.${DATA_KEY}`;\r\nconst EVENT_CLOSE = `close${EVENT_KEY}`;\r\nconst EVENT_OPEN = `open${EVENT_KEY}`;\r\nconst EVENT_SELECT = `optionSelect${EVENT_KEY}`;\r\nconst EVENT_DESELECT = `optionDeselect${EVENT_KEY}`;\r\nconst EVENT_VALUE_CHANGE = `valueChange${EVENT_KEY}`;\r\nconst EVENT_CHANGE = \"change\";\r\n\r\nconst DATA_SELECT_INIT = \"data-te-select-init\";\r\nconst DATA_NO_RESULT = \"data-te-select-no-results-ref\";\r\nconst DATA_OPEN = \"data-te-select-open\";\r\nconst DATA_ACTIVE = \"data-te-input-state-active\";\r\nconst DATA_FOCUSED = \"data-te-input-focused\";\r\nconst DATA_DISABLED = \"data-te-input-disabled\";\r\nconst DATA_SELECT_OPTION_GROUP_LABEL = \"data-te-select-option-group-label-ref\";\r\nconst DATA_OPTION_ALL = \"data-te-select-option-all-ref\";\r\nconst DATA_SELECTED = \"data-te-select-selected\";\r\n\r\nconst SELECTOR_LABEL = \"[data-te-select-label-ref]\";\r\nconst SELECTOR_INPUT = \"[data-te-select-input-ref]\";\r\nconst SELECTOR_FILTER_INPUT = \"[data-te-select-input-filter-ref]\";\r\nconst SELECTOR_DROPDOWN = \"[data-te-select-dropdown-ref]\";\r\nconst SELECTOR_OPTIONS_WRAPPER = \"[data-te-select-options-wrapper-ref]\";\r\nconst SELECTOR_OPTIONS_LIST = \"[data-te-select-options-list-ref]\";\r\nconst SELECTOR_OPTION = \"[data-te-select-option-ref]\";\r\nconst SELECTOR_CLEAR_BUTTON = \"[data-te-select-clear-btn-ref]\";\r\nconst SELECTOR_CUSTOM_CONTENT = \"[data-te-select-custom-content-ref]\";\r\nconst SELECTOR_NO_RESULTS = `[${DATA_NO_RESULT}]`;\r\nconst SELECTOR_FORM_OUTLINE = \"[data-te-select-form-outline-ref]\";\r\nconst SELECTOR_TOGGLE = \"[data-te-select-toggle]\";\r\nconst SELECTOR_NOTCH = \"[data-te-input-notch-ref]\";\r\n\r\nconst ANIMATION_TRANSITION_TIME = 200;\r\n\r\nconst Default = {\r\n  selectAutoSelect: false,\r\n  selectContainer: \"body\",\r\n  selectClearButton: false,\r\n  disabled: false,\r\n  selectDisplayedLabels: 5,\r\n  selectFormWhite: false,\r\n  multiple: false,\r\n  selectOptionsSelectedLabel: \"options selected\",\r\n  selectOptionHeight: 38,\r\n  selectAll: true,\r\n  selectAllLabel: \"Select all\",\r\n  selectSearchPlaceholder: \"Search...\",\r\n  selectSize: \"default\",\r\n  selectVisibleOptions: 5,\r\n  selectFilter: false,\r\n  selectFilterDebounce: 300,\r\n  selectNoResultText: \"No results\",\r\n  selectValidation: false,\r\n  selectValidFeedback: \"Valid\",\r\n  selectInvalidFeedback: \"Invalid\",\r\n  selectPlaceholder: \"\",\r\n};\r\n\r\nconst DefaultType = {\r\n  selectAutoSelect: \"boolean\",\r\n  selectContainer: \"string\",\r\n  selectClearButton: \"boolean\",\r\n  disabled: \"boolean\",\r\n  selectDisplayedLabels: \"number\",\r\n  selectFormWhite: \"boolean\",\r\n  multiple: \"boolean\",\r\n  selectOptionsSelectedLabel: \"string\",\r\n  selectOptionHeight: \"number\",\r\n  selectAll: \"boolean\",\r\n  selectAllLabel: \"string\",\r\n  selectSearchPlaceholder: \"string\",\r\n  selectSize: \"string\",\r\n  selectVisibleOptions: \"number\",\r\n  selectFilter: \"boolean\",\r\n  selectFilterDebounce: \"number\",\r\n  selectNoResultText: \"string\",\r\n  selectValidation: \"boolean\",\r\n  selectValidFeedback: \"string\",\r\n  selectInvalidFeedback: \"string\",\r\n  selectPlaceholder: \"string\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  dropdown:\r\n    \"relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700\",\r\n  formCheckInput:\r\n    \"relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent\",\r\n  formOutline: \"relative\",\r\n  initialized: \"hidden\",\r\n  inputGroup:\r\n    \"flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200\",\r\n  noResult: \"flex items-center px-4\",\r\n  optionsList: \"list-none m-0 p-0\",\r\n  optionsWrapper: \"overflow-y-auto\",\r\n  optionsWrapperScrollbar:\r\n    \"[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded\",\r\n  selectArrow:\r\n    \"absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5\",\r\n  selectArrowWhite:\r\n    \"text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white\",\r\n  selectArrowDefault: \"top-2\",\r\n  selectArrowLg: \"top-[13px]\",\r\n  selectArrowSm: \"top-1\",\r\n  selectClearBtn:\r\n    \"absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200\",\r\n  selectClearBtnWhite: \"!text-gray-50\",\r\n  selectClearBtnDefault: \"top-2 text-base\",\r\n  selectClearBtnLg: \"top-[11px] text-base\",\r\n  selectClearBtnSm: \"top-1 text-[0.8rem]\",\r\n  selectDropdownContainer: \"z-[1070]\",\r\n  selectFakeValue: \"transform-none hidden data-[te-input-state-active]:block\",\r\n  selectFilterInput:\r\n    \"relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200\",\r\n  selectInput:\r\n    \"peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600\",\r\n  selectInputWhite: \"!text-gray-50\",\r\n  selectInputSizeDefault: \"py-[0.32rem] px-3 leading-[1.6]\",\r\n  selectInputSizeLg: \"py-[0.32rem] px-3 leading-[2.15]\",\r\n  selectInputSizeSm: \"py-[0.33rem] px-3 text-xs leading-[1.5]\",\r\n  selectLabel:\r\n    \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary\",\r\n  selectLabelWhite: \"!text-gray-50\",\r\n  selectLabelSizeDefault:\r\n    \"pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]\",\r\n  selectLabelSizeLg:\r\n    \"pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]\",\r\n  selectLabelSizeSm:\r\n    \"pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]\",\r\n  selectOption:\r\n    \"flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30\",\r\n  selectOptionGroup: \"group/opt\",\r\n  selectOptionGroupLabel:\r\n    \"flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300\",\r\n  selectOptionIcon: \"w-7 h-7 rounded-full\",\r\n  selectOptionSecondaryText:\r\n    \"block text-[0.8rem] text-gray-500 dark:text-gray-300\",\r\n  selectOptionText: \"group\",\r\n  selectValidationValid:\r\n    \"hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block\",\r\n  selectValidationInvalid:\r\n    \"hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  dropdown: \"string\",\r\n  formCheckInput: \"string\",\r\n  formOutline: \"string\",\r\n  initialized: \"string\",\r\n  inputGroup: \"string\",\r\n  noResult: \"string\",\r\n  optionsList: \"string\",\r\n  optionsWrapper: \"string\",\r\n  optionsWrapperScrollbar: \"string\",\r\n  selectArrow: \"string\",\r\n  selectArrowDefault: \"string\",\r\n  selectArrowLg: \"string\",\r\n  selectArrowSm: \"string\",\r\n  selectClearBtn: \"string\",\r\n  selectClearBtnDefault: \"string\",\r\n  selectClearBtnLg: \"string\",\r\n  selectClearBtnSm: \"string\",\r\n  selectDropdownContainer: \"string\",\r\n  selectFakeValue: \"string\",\r\n  selectFilterInput: \"string\",\r\n  selectInput: \"string\",\r\n  selectInputSizeDefault: \"string\",\r\n  selectInputSizeLg: \"string\",\r\n  selectInputSizeSm: \"string\",\r\n  selectLabel: \"string\",\r\n  selectLabelSizeDefault: \"string\",\r\n  selectLabelSizeLg: \"string\",\r\n  selectLabelSizeSm: \"string\",\r\n  selectOption: \"string\",\r\n  selectOptionGroup: \"string\",\r\n  selectOptionGroupLabel: \"string\",\r\n  selectOptionIcon: \"string\",\r\n  selectOptionSecondaryText: \"string\",\r\n  selectOptionText: \"string\",\r\n};\r\n\r\nclass Select {\r\n  constructor(element, config, classes) {\r\n    this._element = element;\r\n    this._config = this._getConfig(config);\r\n    this._classes = this._getClasses(classes);\r\n\r\n    this._optionsToRender = this._getOptionsToRender(element);\r\n\r\n    // optionsToRender may contain option groups and nested options, in this case\r\n    // we need a list of plain options to manage selections and keyboard navigation\r\n    this._plainOptions = this._getPlainOptions(this._optionsToRender);\r\n    this._filteredOptionsList = null;\r\n\r\n    this._selectionModel = new SelectionModel(this.multiple);\r\n\r\n    this._activeOptionIndex = -1;\r\n    this._activeOption = null;\r\n\r\n    this._wrapperId = getUID(\"select-wrapper-\");\r\n    this._dropdownContainerId = getUID(\"select-dropdown-container-\");\r\n    this._selectAllId = getUID(\"select-all-\");\r\n    this._debounceTimeoutId = null;\r\n\r\n    this._dropdownHeight =\r\n      this._config.selectOptionHeight * this._config.selectVisibleOptions;\r\n\r\n    this._popper = null;\r\n    this._input = null;\r\n    this._label = SelectorEngine.next(this._element, SELECTOR_LABEL)[0];\r\n    this._notch = null;\r\n    this._fakeValue = null;\r\n    this._isFakeValueActive = false;\r\n\r\n    this._customContent = SelectorEngine.next(\r\n      element,\r\n      SELECTOR_CUSTOM_CONTENT\r\n    )[0];\r\n\r\n    this._toggleButton = null;\r\n    this._elementToggle = null;\r\n\r\n    this._wrapper = null;\r\n    this._inputEl = null;\r\n    this._dropdownContainer = null;\r\n    this._container = null;\r\n    this._selectAllOption = null;\r\n\r\n    this._init();\r\n\r\n    this._mutationObserver = null;\r\n    this._isOpen = false;\r\n\r\n    this._addMutationObserver();\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n    }\r\n  }\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get filterInput() {\r\n    return SelectorEngine.findOne(\r\n      SELECTOR_FILTER_INPUT,\r\n      this._dropdownContainer\r\n    );\r\n  }\r\n\r\n  get dropdown() {\r\n    return SelectorEngine.findOne(SELECTOR_DROPDOWN, this._dropdownContainer);\r\n  }\r\n\r\n  get optionsList() {\r\n    return SelectorEngine.findOne(\r\n      SELECTOR_OPTIONS_LIST,\r\n      this._dropdownContainer\r\n    );\r\n  }\r\n\r\n  get optionsWrapper() {\r\n    return SelectorEngine.findOne(\r\n      SELECTOR_OPTIONS_WRAPPER,\r\n      this._dropdownContainer\r\n    );\r\n  }\r\n\r\n  get clearButton() {\r\n    return SelectorEngine.findOne(SELECTOR_CLEAR_BUTTON, this._wrapper);\r\n  }\r\n\r\n  get options() {\r\n    return this._filteredOptionsList\r\n      ? this._filteredOptionsList\r\n      : this._plainOptions;\r\n  }\r\n\r\n  get value() {\r\n    return this.multiple\r\n      ? this._selectionModel.values\r\n      : this._selectionModel.value;\r\n  }\r\n\r\n  get multiple() {\r\n    return this._config.multiple;\r\n  }\r\n\r\n  get hasSelectAll() {\r\n    return this.multiple && this._config.selectAll;\r\n  }\r\n\r\n  get hasSelection() {\r\n    return (\r\n      this._selectionModel.selection ||\r\n      this._selectionModel.selections.length > 0\r\n    );\r\n  }\r\n\r\n  _getConfig(config) {\r\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n\r\n    config = {\r\n      ...Default,\r\n      ...dataAttributes,\r\n      ...config,\r\n    };\r\n\r\n    if (this._element.hasAttribute(\"multiple\")) {\r\n      config.multiple = true;\r\n    }\r\n\r\n    if (this._element.hasAttribute(\"disabled\")) {\r\n      config.disabled = true;\r\n    }\r\n\r\n    if (this._element.tabIndex) {\r\n      config.tabIndex = this._element.getAttribute(\"tabIndex\");\r\n    }\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  _getOptionsToRender(select) {\r\n    const options = [];\r\n\r\n    const nodes = select.childNodes;\r\n\r\n    nodes.forEach((node) => {\r\n      if (node.nodeName === \"OPTGROUP\") {\r\n        const optionGroup = {\r\n          id: getUID(\"group-\"),\r\n          label: node.label,\r\n          disabled: node.hasAttribute(\"disabled\"),\r\n          hidden: node.hasAttribute(\"hidden\"),\r\n          options: [],\r\n        };\r\n        const groupOptions = node.childNodes;\r\n        groupOptions.forEach((option) => {\r\n          if (option.nodeName === \"OPTION\") {\r\n            optionGroup.options.push(\r\n              this._createOptionObject(option, optionGroup)\r\n            );\r\n          }\r\n        });\r\n        options.push(optionGroup);\r\n      } else if (node.nodeName === \"OPTION\") {\r\n        options.push(this._createOptionObject(node));\r\n      }\r\n    });\r\n    return options;\r\n  }\r\n\r\n  _getPlainOptions(optionsToRender) {\r\n    const hasOptionGroup = SelectorEngine.findOne(\"optgroup\", this._element);\r\n\r\n    if (!hasOptionGroup) {\r\n      return optionsToRender;\r\n    }\r\n\r\n    const options = [];\r\n\r\n    optionsToRender.forEach((option) => {\r\n      const isOptionGroup = Object.prototype.hasOwnProperty.call(\r\n        option,\r\n        \"options\"\r\n      );\r\n\r\n      if (isOptionGroup) {\r\n        option.options.forEach((nestedOption) => {\r\n          options.push(nestedOption);\r\n        });\r\n      } else {\r\n        options.push(option);\r\n      }\r\n    });\r\n\r\n    return options;\r\n  }\r\n\r\n  _createOptionObject(nativeOption, group = {}) {\r\n    const id = getUID(\"option-\");\r\n    const groupId = group.id ? group.id : null;\r\n    const groupDisabled = group.disabled ? group.disabled : false;\r\n    const selected =\r\n      nativeOption.selected || nativeOption.hasAttribute(DATA_SELECTED);\r\n    const disabled = nativeOption.hasAttribute(\"disabled\") || groupDisabled;\r\n    const hidden =\r\n      nativeOption.hasAttribute(\"hidden\") || (group && group.hidden);\r\n    const multiple = this.multiple;\r\n    const value = nativeOption.value;\r\n    const label = nativeOption.label;\r\n    const secondaryText = Manipulator.getDataAttribute(\r\n      nativeOption,\r\n      \"selectSecondaryText\"\r\n    );\r\n    const icon = Manipulator.getDataAttribute(nativeOption, \"select-icon\");\r\n    return new SelectOption(\r\n      id,\r\n      nativeOption,\r\n      multiple,\r\n      value,\r\n      label,\r\n      selected,\r\n      disabled,\r\n      hidden,\r\n      secondaryText,\r\n      groupId,\r\n      icon\r\n    );\r\n  }\r\n\r\n  _getNavigationOptions() {\r\n    const availableOptions = this.options.filter((option) => !option.hidden);\r\n\r\n    return this.hasSelectAll\r\n      ? [this._selectAllOption, ...availableOptions]\r\n      : availableOptions;\r\n  }\r\n\r\n  _init() {\r\n    this._renderMaterialWrapper();\r\n\r\n    this._wrapper = SelectorEngine.findOne(`#${this._wrapperId}`);\r\n    this._input = SelectorEngine.findOne(SELECTOR_INPUT, this._wrapper);\r\n    this._config.disabled && this._input.setAttribute(DATA_DISABLED, \"\");\r\n\r\n    const containerSelector = this._config.selectContainer;\r\n\r\n    if (containerSelector === \"body\") {\r\n      this._container = document.body;\r\n    } else {\r\n      this._container = SelectorEngine.findOne(containerSelector);\r\n    }\r\n\r\n    this._initOutlineInput();\r\n    this._setDefaultSelections();\r\n    this._updateInputValue();\r\n    this._appendFakeValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n\r\n    this._bindComponentEvents();\r\n\r\n    if (this.hasSelectAll) {\r\n      this._selectAllOption = this._createSelectAllOption();\r\n    }\r\n\r\n    this._dropdownContainer = getDropdownTemplate(\r\n      this._dropdownContainerId,\r\n      this._config,\r\n      this._input.offsetWidth,\r\n      this._dropdownHeight,\r\n      this._selectAllOption,\r\n      this._optionsToRender,\r\n      this._customContent,\r\n      this._classes\r\n    );\r\n\r\n    this._setFirstActiveOption();\r\n    this._listenToFocusChange();\r\n  }\r\n\r\n  _renderMaterialWrapper() {\r\n    const template = getWrapperTemplate(\r\n      this._wrapperId,\r\n      this._config,\r\n      this._label,\r\n      this._classes\r\n    );\r\n    this._element.parentNode.insertBefore(template, this._element);\r\n    Manipulator.addClass(this._element, this._classes.initialized);\r\n    template.appendChild(this._element);\r\n  }\r\n\r\n  _initOutlineInput() {\r\n    const inputWrapper = SelectorEngine.findOne(\r\n      SELECTOR_FORM_OUTLINE,\r\n      this._wrapper\r\n    );\r\n    const outlineInput = new Input(inputWrapper, {\r\n      inputFormWhite: this._config.selectFormWhite,\r\n    });\r\n    outlineInput.init();\r\n    this._notch = SelectorEngine.findOne(SELECTOR_NOTCH, this._wrapper);\r\n  }\r\n\r\n  _bindComponentEvents() {\r\n    this._listenToComponentKeydown();\r\n    this._listenToWrapperClick();\r\n    this._listenToClearBtnClick();\r\n    this._listenToClearBtnKeydown();\r\n  }\r\n\r\n  _setDefaultSelections() {\r\n    this.options.forEach((option) => {\r\n      if (option.selected) {\r\n        this._selectionModel.select(option);\r\n      }\r\n    });\r\n  }\r\n\r\n  _listenToComponentKeydown() {\r\n    EventHandler.on(this._wrapper, \"keydown\", this._handleKeydown.bind(this));\r\n  }\r\n\r\n  _handleKeydown(event) {\r\n    if (this._isOpen && !this._config.selectFilter) {\r\n      this._handleOpenKeydown(event);\r\n    } else {\r\n      this._handleClosedKeydown(event);\r\n    }\r\n  }\r\n\r\n  _handleOpenKeydown(event) {\r\n    const key = event.keyCode;\r\n    const isCloseKey =\r\n      key === ESCAPE || (key === UP_ARROW && event.altKey) || key === TAB;\r\n\r\n    if (key === TAB && this._config.selectAutoSelect && !this.multiple) {\r\n      this._handleAutoSelection(this._activeOption);\r\n    }\r\n\r\n    if (isCloseKey) {\r\n      this.close();\r\n      this._input.focus();\r\n      return;\r\n    }\r\n\r\n    switch (key) {\r\n      case DOWN_ARROW:\r\n        this._setNextOptionActive();\r\n        this._scrollToOption(this._activeOption);\r\n        break;\r\n      case UP_ARROW:\r\n        this._setPreviousOptionActive();\r\n        this._scrollToOption(this._activeOption);\r\n        break;\r\n      case HOME:\r\n        this._setFirstOptionActive();\r\n        this._scrollToOption(this._activeOption);\r\n        break;\r\n      case END:\r\n        this._setLastOptionActive();\r\n        this._scrollToOption(this._activeOption);\r\n        break;\r\n      case ENTER:\r\n        event.preventDefault();\r\n        if (this._activeOption) {\r\n          if (this.hasSelectAll && this._activeOptionIndex === 0) {\r\n            this._handleSelectAll();\r\n          } else {\r\n            this._handleSelection(this._activeOption);\r\n          }\r\n        }\r\n        return;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    event.preventDefault();\r\n  }\r\n\r\n  _handleClosedKeydown(event) {\r\n    const key = event.keyCode;\r\n    if (key === ENTER) {\r\n      event.preventDefault();\r\n    }\r\n    const isOpenKey =\r\n      key === ENTER ||\r\n      (key === DOWN_ARROW && event.altKey) ||\r\n      (key === DOWN_ARROW && this.multiple);\r\n\r\n    if (isOpenKey) {\r\n      this.open();\r\n    }\r\n\r\n    if (!this.multiple) {\r\n      switch (key) {\r\n        case DOWN_ARROW:\r\n          this._setNextOptionActive();\r\n          this._handleSelection(this._activeOption);\r\n          break;\r\n        case UP_ARROW:\r\n          this._setPreviousOptionActive();\r\n          this._handleSelection(this._activeOption);\r\n          break;\r\n        case HOME:\r\n          this._setFirstOptionActive();\r\n          this._handleSelection(this._activeOption);\r\n          break;\r\n        case END:\r\n          this._setLastOptionActive();\r\n          this._handleSelection(this._activeOption);\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    } else {\r\n      switch (key) {\r\n        case DOWN_ARROW:\r\n          this.open();\r\n          break;\r\n        case UP_ARROW:\r\n          this.open();\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    }\r\n\r\n    event.preventDefault();\r\n  }\r\n\r\n  _scrollToOption(option) {\r\n    if (!option) {\r\n      return;\r\n    }\r\n\r\n    let optionIndex;\r\n\r\n    const visibleOptions = this.options.filter((option) => !option.hidden);\r\n\r\n    if (this.hasSelectAll) {\r\n      optionIndex = visibleOptions.indexOf(option) + 1;\r\n    } else {\r\n      optionIndex = visibleOptions.indexOf(option);\r\n    }\r\n\r\n    const groupsNumber = this._getNumberOfGroupsBeforeOption(optionIndex);\r\n\r\n    const scrollToIndex = optionIndex + groupsNumber;\r\n\r\n    const list = this.optionsWrapper;\r\n    const listHeight = list.offsetHeight;\r\n    const optionHeight = this._config.selectOptionHeight;\r\n    const scrollTop = list.scrollTop;\r\n\r\n    if (optionIndex > -1) {\r\n      const optionOffset = scrollToIndex * optionHeight;\r\n      const isBelow = optionOffset + optionHeight > scrollTop + listHeight;\r\n      const isAbove = optionOffset < scrollTop;\r\n\r\n      if (isAbove) {\r\n        list.scrollTop = optionOffset;\r\n      } else if (isBelow) {\r\n        list.scrollTop = optionOffset - listHeight + optionHeight;\r\n      } else {\r\n        list.scrollTop = scrollTop;\r\n      }\r\n    }\r\n  }\r\n\r\n  _getNumberOfGroupsBeforeOption(optionIndex) {\r\n    const optionsList = this.options.filter((option) => !option.hidden);\r\n    const groupsList = this._optionsToRender.filter((group) => !group.hidden);\r\n    const index = this.hasSelectAll ? optionIndex - 1 : optionIndex;\r\n    let groupsNumber = 0;\r\n\r\n    for (let i = 0; i <= index; i++) {\r\n      if (\r\n        optionsList[i].groupId &&\r\n        groupsList[groupsNumber] &&\r\n        groupsList[groupsNumber].id &&\r\n        optionsList[i].groupId === groupsList[groupsNumber].id\r\n      ) {\r\n        groupsNumber++;\r\n      }\r\n    }\r\n\r\n    return groupsNumber;\r\n  }\r\n\r\n  _setNextOptionActive() {\r\n    let index = this._activeOptionIndex + 1;\r\n    const options = this._getNavigationOptions();\r\n\r\n    if (!options[index]) {\r\n      return;\r\n    }\r\n\r\n    while (options[index].disabled) {\r\n      index += 1;\r\n\r\n      if (!options[index]) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this._updateActiveOption(options[index], index);\r\n  }\r\n\r\n  _setPreviousOptionActive() {\r\n    let index = this._activeOptionIndex - 1;\r\n    const options = this._getNavigationOptions();\r\n\r\n    if (!options[index]) {\r\n      return;\r\n    }\r\n\r\n    while (options[index].disabled) {\r\n      index -= 1;\r\n\r\n      if (!options[index]) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this._updateActiveOption(options[index], index);\r\n  }\r\n\r\n  _setFirstOptionActive() {\r\n    const index = 0;\r\n    const options = this._getNavigationOptions();\r\n\r\n    this._updateActiveOption(options[index], index);\r\n  }\r\n\r\n  _setLastOptionActive() {\r\n    const options = this._getNavigationOptions();\r\n    const index = options.length - 1;\r\n\r\n    this._updateActiveOption(options[index], index);\r\n  }\r\n\r\n  _updateActiveOption(newActiveOption, index) {\r\n    const currentActiveOption = this._activeOption;\r\n\r\n    if (currentActiveOption) {\r\n      currentActiveOption.removeActiveStyles();\r\n    }\r\n\r\n    newActiveOption.setActiveStyles();\r\n    this._activeOptionIndex = index;\r\n    this._activeOption = newActiveOption;\r\n  }\r\n\r\n  _listenToWrapperClick() {\r\n    EventHandler.on(this._wrapper, \"click\", () => {\r\n      this.toggle();\r\n    });\r\n  }\r\n\r\n  _listenToClearBtnClick() {\r\n    EventHandler.on(this.clearButton, \"click\", (event) => {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      this._handleClear();\r\n    });\r\n  }\r\n\r\n  _listenToClearBtnKeydown() {\r\n    EventHandler.on(this.clearButton, \"keydown\", (event) => {\r\n      if (event.keyCode === ENTER) {\r\n        this._handleClear();\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleClear() {\r\n    if (this.multiple) {\r\n      this._selectionModel.clear();\r\n      this._deselectAllOptions(this.options);\r\n\r\n      if (this.hasSelectAll) {\r\n        this._updateSelectAllState();\r\n      }\r\n    } else {\r\n      const selected = this._selectionModel.selection;\r\n      this._selectionModel.clear();\r\n      selected.deselect();\r\n    }\r\n    this._updateInputValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n\r\n    this._emitValueChangeEvent(null);\r\n    this._emitNativeChangeEvent();\r\n  }\r\n\r\n  _listenToOptionsClick() {\r\n    EventHandler.on(this.optionsWrapper, \"click\", (event) => {\r\n      const optionGroupLabel = event.target.hasAttribute(\r\n        DATA_SELECT_OPTION_GROUP_LABEL\r\n      );\r\n\r\n      if (optionGroupLabel) {\r\n        return;\r\n      }\r\n\r\n      const target =\r\n        event.target.nodeName === \"DIV\"\r\n          ? event.target\r\n          : SelectorEngine.closest(event.target, SELECTOR_OPTION);\r\n\r\n      const selectAllOption = target.hasAttribute(DATA_OPTION_ALL);\r\n\r\n      if (selectAllOption) {\r\n        this._handleSelectAll();\r\n        return;\r\n      }\r\n\r\n      const id = target.dataset.teId;\r\n      const option = this.options.find((option) => option.id === id);\r\n\r\n      if (option && !option.disabled) {\r\n        this._handleSelection(option);\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleSelectAll() {\r\n    const selected = this._selectAllOption.selected;\r\n\r\n    if (selected) {\r\n      this._deselectAllOptions(this.options);\r\n      this._selectAllOption.deselect();\r\n    } else {\r\n      this._selectAllOptions(this.options);\r\n      this._selectAllOption.select();\r\n    }\r\n\r\n    this._updateInputValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n\r\n    this._emitValueChangeEvent(this.value);\r\n    this._emitNativeChangeEvent();\r\n  }\r\n\r\n  _selectAllOptions(options) {\r\n    options.forEach((option) => {\r\n      if (!option.selected && !option.disabled) {\r\n        this._selectionModel.select(option);\r\n        option.select();\r\n      }\r\n    });\r\n  }\r\n\r\n  _deselectAllOptions(options) {\r\n    options.forEach((option) => {\r\n      if (option.selected && !option.disabled) {\r\n        this._selectionModel.deselect(option);\r\n        option.deselect();\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleSelection(option) {\r\n    if (this.multiple) {\r\n      this._handleMultiSelection(option);\r\n\r\n      if (this.hasSelectAll) {\r\n        this._updateSelectAllState();\r\n      }\r\n    } else {\r\n      this._handleSingleSelection(option);\r\n    }\r\n\r\n    this._updateInputValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n  }\r\n\r\n  _handleAutoSelection(option) {\r\n    this._singleOptionSelect(option);\r\n    this._updateInputValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n  }\r\n\r\n  _handleSingleSelection(option) {\r\n    this._singleOptionSelect(option);\r\n    this.close();\r\n    this._input.focus();\r\n  }\r\n\r\n  _singleOptionSelect(option) {\r\n    const currentSelected = this._selectionModel.selections[0];\r\n\r\n    if (currentSelected && currentSelected !== option) {\r\n      this._selectionModel.deselect(currentSelected);\r\n      currentSelected.deselect();\r\n      currentSelected.node.setAttribute(DATA_SELECTED, false);\r\n      EventHandler.trigger(this._element, EVENT_DESELECT, {\r\n        value: currentSelected.value,\r\n      });\r\n    }\r\n\r\n    if (!currentSelected || (currentSelected && option !== currentSelected)) {\r\n      this._selectionModel.select(option);\r\n      option.select();\r\n      option.node.setAttribute(DATA_SELECTED, true);\r\n      EventHandler.trigger(this._element, EVENT_SELECT, {\r\n        value: option.value,\r\n      });\r\n      this._emitValueChangeEvent(this.value);\r\n      this._emitNativeChangeEvent();\r\n    }\r\n  }\r\n\r\n  _handleMultiSelection(option) {\r\n    if (option.selected) {\r\n      this._selectionModel.deselect(option);\r\n      option.deselect();\r\n      option.node.setAttribute(DATA_SELECTED, false);\r\n      EventHandler.trigger(this._element, EVENT_DESELECT, {\r\n        value: option.value,\r\n      });\r\n    } else {\r\n      this._selectionModel.select(option);\r\n      option.select();\r\n      option.node.setAttribute(DATA_SELECTED, true);\r\n      EventHandler.trigger(this._element, EVENT_SELECT, {\r\n        value: option.value,\r\n      });\r\n    }\r\n\r\n    this._emitValueChangeEvent(this.value);\r\n    this._emitNativeChangeEvent();\r\n  }\r\n\r\n  _emitValueChangeEvent(value) {\r\n    EventHandler.trigger(this._element, EVENT_VALUE_CHANGE, { value });\r\n  }\r\n\r\n  _emitNativeChangeEvent() {\r\n    EventHandler.trigger(this._element, EVENT_CHANGE);\r\n  }\r\n\r\n  _updateInputValue() {\r\n    const labels = this.multiple\r\n      ? this._selectionModel.labels\r\n      : this._selectionModel.label;\r\n    let value;\r\n\r\n    if (\r\n      this.multiple &&\r\n      this._config.selectDisplayedLabels !== -1 &&\r\n      this._selectionModel.selections.length >\r\n        this._config.selectDisplayedLabels\r\n    ) {\r\n      value = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}`;\r\n    } else {\r\n      value = labels;\r\n    }\r\n\r\n    if (\r\n      !this.multiple &&\r\n      !this._isSelectionValid(this._selectionModel.selection)\r\n    ) {\r\n      this._input.value = \"\";\r\n    } else if (this._isLabelEmpty(this._selectionModel.selection)) {\r\n      this._input.value = \" \";\r\n    } else if (value) {\r\n      this._input.value = value;\r\n    } else {\r\n      // prettier-ignore\r\n      // eslint-disable-next-line\r\n      this.multiple || !this._optionsToRender[0] ? (this._input.value = '') : (this._input.value = this._optionsToRender[0].label);\r\n    }\r\n  }\r\n\r\n  _isSelectionValid(selection) {\r\n    if (selection && (selection.disabled || selection.value === \"\")) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _isLabelEmpty(selection) {\r\n    if (selection && selection.label === \"\") {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _appendFakeValue() {\r\n    if (!this._selectionModel.selection || this._selectionModel._multiple) {\r\n      return;\r\n    }\r\n\r\n    const value = this._selectionModel.selection.label;\r\n    this._fakeValue = getFakeValueTemplate(value, this._classes);\r\n    const inputWrapper = SelectorEngine.findOne(\r\n      SELECTOR_FORM_OUTLINE,\r\n      this._wrapper\r\n    );\r\n    inputWrapper.appendChild(this._fakeValue);\r\n  }\r\n\r\n  _updateLabelPosition() {\r\n    const isInitialized = this._element.hasAttribute(DATA_SELECT_INIT);\r\n\r\n    const isValueEmpty = this._input.value !== \"\";\r\n    if (!this._label) {\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isInitialized &&\r\n      (isValueEmpty || this._isOpen || this._isFakeValueActive)\r\n    ) {\r\n      this._label.setAttribute(DATA_ACTIVE, \"\");\r\n      this._notch.setAttribute(DATA_ACTIVE, \"\");\r\n    } else {\r\n      this._label.removeAttribute(DATA_ACTIVE);\r\n      this._notch.removeAttribute(DATA_ACTIVE, \"\");\r\n    }\r\n  }\r\n\r\n  _updateLabelPositionWhileClosing() {\r\n    if (!this._label) {\r\n      return;\r\n    }\r\n\r\n    if (this._input.value !== \"\" || this._isFakeValueActive) {\r\n      this._label.setAttribute(DATA_ACTIVE, \"\");\r\n      this._notch.setAttribute(DATA_ACTIVE, \"\");\r\n    } else {\r\n      this._label.removeAttribute(DATA_ACTIVE);\r\n      this._notch.removeAttribute(DATA_ACTIVE);\r\n    }\r\n  }\r\n\r\n  _updateFakeLabelPosition() {\r\n    if (!this._fakeValue) {\r\n      return;\r\n    }\r\n\r\n    if (this._input.value === \"\" && this._fakeValue.innerHTML !== \"\") {\r\n      this._isFakeValueActive = true;\r\n      this._fakeValue.setAttribute(DATA_ACTIVE, \"\");\r\n    } else {\r\n      this._isFakeValueActive = false;\r\n      this._fakeValue.removeAttribute(DATA_ACTIVE);\r\n    }\r\n  }\r\n\r\n  _updateClearButtonVisibility() {\r\n    if (!this.clearButton) {\r\n      return;\r\n    }\r\n\r\n    const hasSelection =\r\n      this._selectionModel.selection ||\r\n      this._selectionModel.selections.length > 0;\r\n\r\n    if (hasSelection) {\r\n      Manipulator.addStyle(this.clearButton, { display: \"block\" });\r\n    } else {\r\n      Manipulator.addStyle(this.clearButton, { display: \"none\" });\r\n    }\r\n  }\r\n\r\n  _updateSelectAllState() {\r\n    const selectAllSelected = this._selectAllOption.selected;\r\n    const allSelected = allOptionsSelected(this.options);\r\n    if (!allSelected && selectAllSelected) {\r\n      this._selectAllOption.deselect();\r\n    } else if (allSelected && !selectAllSelected) {\r\n      this._selectAllOption.select();\r\n    }\r\n  }\r\n\r\n  toggle() {\r\n    if (this._isOpen) {\r\n      this.close();\r\n    } else {\r\n      this.open();\r\n    }\r\n  }\r\n\r\n  open() {\r\n    const isDisabled = this._config.disabled;\r\n    const openEvent = EventHandler.trigger(this._element, EVENT_OPEN);\r\n\r\n    if (this._isOpen || isDisabled || openEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this._openDropdown();\r\n    this._updateDropdownWidth();\r\n    this._setFirstActiveOption();\r\n    this._scrollToOption(this._activeOption);\r\n\r\n    if (this._config.selectFilter) {\r\n      // We need to wait for popper initialization, otherwise\r\n      // dates container will be focused before popper position\r\n      // update which can change the scroll position on the page\r\n      setTimeout(() => {\r\n        this.filterInput.focus();\r\n      }, 0);\r\n\r\n      this._listenToSelectSearch();\r\n\r\n      // New listener for dropdown navigation is needed, because\r\n      // we focus search input inside dropdown template, wchich is\r\n      // appended to the body. In this case listener attached to the\r\n      // select wrapper won't work\r\n      this._listenToDropdownKeydown();\r\n    }\r\n\r\n    this._listenToOptionsClick();\r\n    this._listenToOutsideClick();\r\n    this._listenToWindowResize();\r\n\r\n    this._isOpen = true;\r\n\r\n    this._updateLabelPosition();\r\n    this._setInputActiveStyles();\r\n  }\r\n\r\n  _openDropdown() {\r\n    this._popper = createPopper(this._input, this._dropdownContainer, {\r\n      placement: \"bottom-start\",\r\n      modifiers: [\r\n        {\r\n          name: \"offset\",\r\n          options: {\r\n            offset: [0, 1],\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this._container.appendChild(this._dropdownContainer);\r\n\r\n    // We need to add delay to wait for the popper initialization\r\n    // and position update\r\n    setTimeout(() => {\r\n      this.dropdown.setAttribute(DATA_OPEN, \"\");\r\n    }, 0);\r\n  }\r\n\r\n  _updateDropdownWidth() {\r\n    const inputWidth = this._input.offsetWidth;\r\n    Manipulator.addStyle(this._dropdownContainer, { width: `${inputWidth}px` });\r\n  }\r\n\r\n  _setFirstActiveOption() {\r\n    const options = this._getNavigationOptions();\r\n    const currentActive = this._activeOption;\r\n\r\n    if (currentActive) {\r\n      currentActive.removeActiveStyles();\r\n    }\r\n\r\n    const firstSelected = this.multiple\r\n      ? this._selectionModel.selections[0]\r\n      : this._selectionModel.selection;\r\n\r\n    if (firstSelected) {\r\n      this._activeOption = firstSelected;\r\n      firstSelected.setActiveStyles();\r\n      this._activeOptionIndex = options.findIndex(\r\n        (option) => option === firstSelected\r\n      );\r\n    } else {\r\n      this._activeOption = null;\r\n      this._activeOptionIndex = -1;\r\n    }\r\n  }\r\n\r\n  _setInputActiveStyles() {\r\n    this._input.setAttribute(DATA_FOCUSED, \"\");\r\n    SelectorEngine.findOne(SELECTOR_NOTCH, this._wrapper).setAttribute(\r\n      DATA_FOCUSED,\r\n      \"\"\r\n    );\r\n  }\r\n\r\n  _listenToWindowResize() {\r\n    EventHandler.on(window, \"resize\", this._handleWindowResize.bind(this));\r\n  }\r\n\r\n  _handleWindowResize() {\r\n    if (this._dropdownContainer) {\r\n      this._updateDropdownWidth();\r\n    }\r\n  }\r\n\r\n  _listenToSelectSearch() {\r\n    this.filterInput.addEventListener(\"input\", (event) => {\r\n      const searchTerm = event.target.value;\r\n      const debounceTime = this._config.selectFilterDebounce;\r\n      this._debounceFilter(searchTerm, debounceTime);\r\n    });\r\n  }\r\n\r\n  _debounceFilter(searchTerm, debounceTime) {\r\n    if (this._debounceTimeoutId) {\r\n      clearTimeout(this._debounceTimeoutId);\r\n    }\r\n\r\n    this._debounceTimeoutId = setTimeout(() => {\r\n      this._filterOptions(searchTerm);\r\n    }, debounceTime);\r\n  }\r\n\r\n  _filterOptions(searchTerm) {\r\n    const filtered = [];\r\n\r\n    this._optionsToRender.forEach((option) => {\r\n      const isOptionGroup = Object.prototype.hasOwnProperty.call(\r\n        option,\r\n        \"options\"\r\n      );\r\n\r\n      const isValidOption =\r\n        !isOptionGroup &&\r\n        option.label.toLowerCase().includes(searchTerm.toLowerCase());\r\n      const group = {};\r\n\r\n      if (isOptionGroup) {\r\n        group.label = option.label;\r\n        group.options = this._filter(searchTerm, option.options);\r\n\r\n        if (group.options.length > 0) {\r\n          filtered.push(group);\r\n        }\r\n      }\r\n\r\n      if (isValidOption) {\r\n        filtered.push(option);\r\n      }\r\n    });\r\n\r\n    const hasNoResultsText = this._config.selectNoResultText !== \"\";\r\n    const hasFilteredOptions = filtered.length !== 0;\r\n\r\n    if (hasFilteredOptions) {\r\n      this._updateOptionsListTemplate(filtered);\r\n      this._popper.forceUpdate();\r\n      this._filteredOptionsList = this._getPlainOptions(filtered);\r\n\r\n      if (this.hasSelectAll) {\r\n        this._updateSelectAllState();\r\n      }\r\n\r\n      this._setFirstActiveOption();\r\n    } else if (!hasFilteredOptions && hasNoResultsText) {\r\n      const noResultsTemplate = this._getNoResultTemplate();\r\n      this.optionsWrapper.innerHTML = noResultsTemplate;\r\n    }\r\n  }\r\n\r\n  _updateOptionsListTemplate(optionsToRender) {\r\n    const optionsWrapperContent =\r\n      SelectorEngine.findOne(SELECTOR_OPTIONS_LIST, this._dropdownContainer) ||\r\n      SelectorEngine.findOne(SELECTOR_NO_RESULTS, this._dropdownContainer);\r\n\r\n    const optionsListTemplate = getOptionsListTemplate(\r\n      optionsToRender,\r\n      this._selectAllOption,\r\n      this._config,\r\n      this._classes\r\n    );\r\n\r\n    this.optionsWrapper.removeChild(optionsWrapperContent);\r\n    this.optionsWrapper.appendChild(optionsListTemplate);\r\n  }\r\n\r\n  _getNoResultTemplate() {\r\n    return `<div class=\"${this._classes.noResult}\" ${DATA_NO_RESULT} style=\"height: ${this._config.selectOptionHeight}px\">${this._config.selectNoResultText}</div>`;\r\n  }\r\n\r\n  _filter(value, options) {\r\n    const filterValue = value.toLowerCase();\r\n    return options.filter((option) =>\r\n      option.label.toLowerCase().includes(filterValue)\r\n    );\r\n  }\r\n\r\n  _listenToDropdownKeydown() {\r\n    EventHandler.on(\r\n      this.dropdown,\r\n      \"keydown\",\r\n      this._handleOpenKeydown.bind(this)\r\n    );\r\n  }\r\n\r\n  _listenToOutsideClick() {\r\n    this._outsideClick = this._handleOutSideClick.bind(this);\r\n    EventHandler.on(document, \"click\", this._outsideClick);\r\n  }\r\n\r\n  _listenToFocusChange(add = true) {\r\n    if (add === false) {\r\n      EventHandler.remove(this._input, \"focus\", () =>\r\n        this._notch.setAttribute(DATA_FOCUSED, \"\")\r\n      );\r\n\r\n      EventHandler.remove(this._input, \"blur\", () =>\r\n        this._notch.removeAttribute(DATA_FOCUSED)\r\n      );\r\n      return;\r\n    }\r\n    EventHandler.on(this._input, \"focus\", () =>\r\n      this._notch.setAttribute(DATA_FOCUSED, \"\")\r\n    );\r\n\r\n    EventHandler.on(this._input, \"blur\", () =>\r\n      this._notch.removeAttribute(DATA_FOCUSED)\r\n    );\r\n  }\r\n\r\n  _handleOutSideClick(event) {\r\n    const isSelectContent =\r\n      this._wrapper && this._wrapper.contains(event.target);\r\n    const isDropdown = event.target === this._dropdownContainer;\r\n    const isDropdownContent =\r\n      this._dropdownContainer && this._dropdownContainer.contains(event.target);\r\n\r\n    let isButton;\r\n    if (!this._toggleButton) {\r\n      this._elementToggle = SelectorEngine.find(SELECTOR_TOGGLE);\r\n    }\r\n    if (this._elementToggle) {\r\n      this._elementToggle.forEach((button) => {\r\n        const attributes = Manipulator.getDataAttribute(\r\n          button,\r\n          \"select-toggle\"\r\n        );\r\n        if (\r\n          attributes === this._element.id ||\r\n          this._element.classList.contains(attributes)\r\n        ) {\r\n          this._toggleButton = button;\r\n          isButton = this._toggleButton.contains(event.target);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!isSelectContent && !isDropdown && !isDropdownContent && !isButton) {\r\n      this.close();\r\n    }\r\n  }\r\n\r\n  close() {\r\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\r\n\r\n    if (!this._isOpen || closeEvent.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this._config.selectFilter && this.hasSelectAll) {\r\n      this._resetFilterState();\r\n      this._updateOptionsListTemplate(this._optionsToRender);\r\n      if (this._config.multiple) {\r\n        this._updateSelectAllState();\r\n      }\r\n    }\r\n\r\n    this._removeDropdownEvents();\r\n\r\n    this.dropdown.removeAttribute(DATA_OPEN);\r\n\r\n    setTimeout(() => {\r\n      this._input.removeAttribute(DATA_FOCUSED);\r\n      this._input.blur();\r\n\r\n      SelectorEngine.findOne(SELECTOR_NOTCH, this._wrapper).removeAttribute(\r\n        DATA_FOCUSED\r\n      );\r\n      if (this._label && !this.hasSelection) {\r\n        this._label.removeAttribute(DATA_ACTIVE);\r\n        this._notch.setAttribute(DATA_ACTIVE, \"\");\r\n\r\n        this._input.removeAttribute(DATA_ACTIVE);\r\n        this._notch.removeAttribute(DATA_ACTIVE);\r\n      }\r\n      this._updateLabelPositionWhileClosing();\r\n    }, 0);\r\n\r\n    setTimeout(() => {\r\n      if (\r\n        this._container &&\r\n        this._dropdownContainer.parentNode === this._container\r\n      ) {\r\n        this._container.removeChild(this._dropdownContainer);\r\n      }\r\n      this._popper.destroy();\r\n      this._isOpen = false;\r\n      EventHandler.off(this.dropdown, \"transitionend\");\r\n    }, ANIMATION_TRANSITION_TIME);\r\n  }\r\n\r\n  _resetFilterState() {\r\n    this.filterInput.value = \"\";\r\n    this._filteredOptionsList = null;\r\n  }\r\n\r\n  _removeDropdownEvents() {\r\n    EventHandler.off(document, \"click\", this._outsideClick);\r\n\r\n    if (this._config.selectFilter) {\r\n      EventHandler.off(this.dropdown, \"keydown\");\r\n    }\r\n\r\n    EventHandler.off(this.optionsWrapper, \"click\");\r\n  }\r\n\r\n  _addMutationObserver() {\r\n    this._mutationObserver = new MutationObserver(() => {\r\n      if (this._wrapper) {\r\n        this._updateSelections();\r\n        this._updateDisabledState();\r\n      }\r\n    });\r\n\r\n    this._observeMutationObserver();\r\n  }\r\n\r\n  _updateSelections() {\r\n    this._optionsToRender = this._getOptionsToRender(this._element);\r\n    this._plainOptions = this._getPlainOptions(this._optionsToRender);\r\n    this._selectionModel.clear();\r\n    this._setDefaultSelections();\r\n    this._updateInputValue();\r\n    this._updateFakeLabelPosition();\r\n    this._updateLabelPosition();\r\n    this._updateClearButtonVisibility();\r\n\r\n    if (this.hasSelectAll) {\r\n      this._updateSelectAllState();\r\n    }\r\n\r\n    const hasFilterValue =\r\n      this._config.filter && this.filterInput && this.filterInput.value;\r\n\r\n    if (this._isOpen && !hasFilterValue) {\r\n      this._updateOptionsListTemplate(this._optionsToRender);\r\n      this._setFirstActiveOption();\r\n    } else if (this._isOpen && hasFilterValue) {\r\n      this._filterOptions(this.filterInput.value);\r\n      this._setFirstActiveOption();\r\n    } else {\r\n      this._dropdownContainer = getDropdownTemplate(\r\n        this._dropdownContainerId,\r\n        this._config,\r\n        this._input.offsetWidth,\r\n        this._dropdownHeight,\r\n        this._selectAllOption,\r\n        this._optionsToRender,\r\n        this._customContent,\r\n        this._classes\r\n      );\r\n    }\r\n  }\r\n\r\n  _updateDisabledState() {\r\n    const input = SelectorEngine.findOne(SELECTOR_INPUT, this._wrapper);\r\n\r\n    if (this._element.hasAttribute(\"disabled\")) {\r\n      this._config.disabled = true;\r\n      input.setAttribute(\"disabled\", \"\");\r\n      input.setAttribute(DATA_DISABLED, \"\");\r\n    } else {\r\n      this._config.disabled = false;\r\n      input.removeAttribute(\"disabled\");\r\n      input.removeAttribute(DATA_DISABLED);\r\n    }\r\n  }\r\n\r\n  _observeMutationObserver() {\r\n    if (!this._mutationObserver) {\r\n      return;\r\n    }\r\n\r\n    this._mutationObserver.observe(this._element, {\r\n      attributes: true,\r\n      childList: true,\r\n      characterData: true,\r\n      subtree: true,\r\n    });\r\n  }\r\n\r\n  _disconnectMutationObserver() {\r\n    if (this.mutationObserver) {\r\n      this._mutationObserver.disconnect();\r\n      this._mutationObserver = null;\r\n    }\r\n  }\r\n\r\n  _createSelectAllOption() {\r\n    const id = this._selectAllId;\r\n    const nativeOption = null;\r\n    const multiple = true;\r\n    const value = \"select-all\";\r\n    const label = this._config.selectAllLabel;\r\n    const selected = allOptionsSelected(this.options);\r\n    const disabled = false;\r\n    const hidden = false;\r\n    const secondaryText = null;\r\n    const groupId = null;\r\n    const icon = null;\r\n\r\n    return new SelectOption(\r\n      id,\r\n      nativeOption,\r\n      multiple,\r\n      value,\r\n      label,\r\n      selected,\r\n      disabled,\r\n      hidden,\r\n      secondaryText,\r\n      groupId,\r\n      icon\r\n    );\r\n  }\r\n\r\n  dispose() {\r\n    this._removeComponentEvents();\r\n\r\n    this._destroyMaterialSelect();\r\n    this._listenToFocusChange(false);\r\n\r\n    Data.removeData(this._element, DATA_KEY);\r\n  }\r\n\r\n  _removeComponentEvents() {\r\n    EventHandler.off(this.input, \"click\");\r\n    EventHandler.off(this.wrapper, this._handleKeydown.bind(this));\r\n    EventHandler.off(this.clearButton, \"click\");\r\n    EventHandler.off(this.clearButton, \"keydown\");\r\n    EventHandler.off(window, \"resize\", this._handleWindowResize.bind(this));\r\n  }\r\n\r\n  _destroyMaterialSelect() {\r\n    if (this._isOpen) {\r\n      this.close();\r\n    }\r\n\r\n    this._destroyMaterialTemplate();\r\n  }\r\n\r\n  _destroyMaterialTemplate() {\r\n    const wrapperParent = this._wrapper.parentNode;\r\n    const labels = SelectorEngine.find(\"label\", this._wrapper);\r\n\r\n    wrapperParent.appendChild(this._element);\r\n    labels.forEach((label) => {\r\n      wrapperParent.appendChild(label);\r\n    });\r\n\r\n    labels.forEach((label) => {\r\n      label.removeAttribute(DATA_ACTIVE);\r\n    });\r\n    Manipulator.removeClass(this._element, this._classes.initialized);\r\n    this._element.removeActiveStyles(DATA_SELECT_INIT);\r\n\r\n    wrapperParent.removeChild(this._wrapper);\r\n  }\r\n\r\n  setValue(value) {\r\n    this.options\r\n      .filter((option) => option.selected)\r\n      .forEach((selection) => (selection.nativeOption.selected = false));\r\n\r\n    const isMultipleValue = Array.isArray(value);\r\n\r\n    if (isMultipleValue) {\r\n      value.forEach((selectionValue) => {\r\n        this._selectByValue(selectionValue);\r\n      });\r\n    } else {\r\n      this._selectByValue(value);\r\n    }\r\n\r\n    this._updateSelections();\r\n  }\r\n\r\n  _selectByValue(value) {\r\n    const correspondingOption = this.options.find(\r\n      (option) => option.value === value\r\n    );\r\n    if (!correspondingOption) {\r\n      return false;\r\n    }\r\n    correspondingOption.nativeOption.selected = true;\r\n    return true;\r\n  }\r\n\r\n  static jQueryInterface(config, options) {\r\n    return this.each(function () {\r\n      let data = Data.getData(this, DATA_KEY);\r\n      const _config = typeof config === \"object\" && config;\r\n\r\n      if (!data && /dispose/.test(config)) {\r\n        return;\r\n      }\r\n\r\n      if (!data) {\r\n        data = new Select(this, _config);\r\n      }\r\n\r\n      if (typeof config === \"string\") {\r\n        if (typeof data[config] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n\r\n        data[config](options);\r\n      }\r\n    });\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Select;\r\n","import { getjQuery, onDOMContentLoaded } from \"../util/index\";\r\n\r\nconst jqueryInit = (plugin) => {\r\n  onDOMContentLoaded(() => {\r\n    const $ = getjQuery();\r\n\r\n    if ($) {\r\n      const name = plugin.NAME;\r\n      const JQUERY_NO_CONFLICT = $.fn[name];\r\n      $.fn[name] = plugin.jQueryInterface;\r\n      $.fn[name].Constructor = plugin;\r\n      $.fn[name].noConflict = () => {\r\n        $.fn[name] = JQUERY_NO_CONFLICT;\r\n        return plugin.jQueryInterface;\r\n      };\r\n    }\r\n  });\r\n};\r\n\r\nexport default jqueryInit;\r\n","import EventHandler from \"../dom/event-handler\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport {\r\n  isDisabled,\r\n  getElementFromSelector,\r\n  isVisible,\r\n  getSelectorFromElement,\r\n} from \"../util\";\r\n\r\nconst dropdownCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}`,\r\n    initSelector,\r\n    function (event) {\r\n      event.preventDefault();\r\n      component.getOrCreateInstance(this).toggle();\r\n    }\r\n  );\r\n};\r\n\r\nconst tabCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}.data-api`,\r\n    initSelector,\r\n    function (event) {\r\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      if (isDisabled(this)) {\r\n        return;\r\n      }\r\n\r\n      const data = component.getOrCreateInstance(this);\r\n      data.show();\r\n    }\r\n  );\r\n};\r\n\r\nconst offcanvasCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}.data-api`,\r\n    initSelector,\r\n    function (event) {\r\n      const target = getElementFromSelector(this);\r\n\r\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      if (isDisabled(this)) {\r\n        return;\r\n      }\r\n\r\n      EventHandler.one(target, component.EVENT_HIDDEN, () => {\r\n        // focus on trigger when it is closed\r\n        if (isVisible(this)) {\r\n          this.focus();\r\n        }\r\n      });\r\n\r\n      // avoid conflict when clicking a toggler of an offcanvas, while another is open\r\n      const allReadyOpen = SelectorEngine.findOne(component.OPEN_SELECTOR);\r\n      if (allReadyOpen && allReadyOpen !== target) {\r\n        component.getInstance(allReadyOpen).hide();\r\n      }\r\n\r\n      const data = component.getOrCreateInstance(target);\r\n      data.toggle(this);\r\n    }\r\n  );\r\n};\r\n\r\nconst buttonCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}`,\r\n    initSelector,\r\n    (event) => {\r\n      event.preventDefault();\r\n\r\n      const button = event.target.closest(initSelector);\r\n      const data = component.getOrCreateInstance(button);\r\n\r\n      data.toggle();\r\n    }\r\n  );\r\n};\r\n\r\nconst modalCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}`,\r\n    initSelector,\r\n    function (event) {\r\n      const target = getElementFromSelector(this);\r\n\r\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      EventHandler.one(target, component.EVENT_SHOW, (showEvent) => {\r\n        if (showEvent.defaultPrevented) {\r\n          // only register focus restorer if modal will actually get shown\r\n          return;\r\n        }\r\n\r\n        EventHandler.one(target, component.EVENT_HIDDEN, () => {\r\n          if (isVisible(this)) {\r\n            this.focus();\r\n          }\r\n        });\r\n      });\r\n\r\n      // avoid conflict when clicking moddal toggler while another one is open\r\n      const allReadyOpen = SelectorEngine.findOne(\r\n        `[${component.OPEN_SELECTOR}=\"true\"]`\r\n      );\r\n      if (allReadyOpen) {\r\n        component.getInstance(allReadyOpen).hide();\r\n      }\r\n\r\n      const data = component.getOrCreateInstance(target);\r\n\r\n      data.toggle(this);\r\n    }\r\n  );\r\n};\r\n\r\nconst rippleCallback = (component, initSelector) => {\r\n  EventHandler.one(\r\n    document,\r\n    \"mousedown\",\r\n    initSelector,\r\n    component.autoInitial(new component())\r\n  );\r\n};\r\n\r\nconst collapseCallback = (component, initSelector) => {\r\n  EventHandler.on(\r\n    document,\r\n    `click.te.${component.NAME}.data-api`,\r\n    initSelector,\r\n    function (event) {\r\n      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\r\n      if (\r\n        event.target.tagName === \"A\" ||\r\n        (event.delegateTarget && event.delegateTarget.tagName === \"A\")\r\n      ) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      const selector = getSelectorFromElement(this);\r\n      const selectorElements = SelectorEngine.find(selector);\r\n\r\n      selectorElements.forEach((element) => {\r\n        component.getOrCreateInstance(element, { toggle: false }).toggle();\r\n      });\r\n    }\r\n  );\r\n};\r\n\r\nexport {\r\n  dropdownCallback,\r\n  tabCallback,\r\n  offcanvasCallback,\r\n  buttonCallback,\r\n  modalCallback,\r\n  rippleCallback,\r\n  collapseCallback,\r\n};\r\n","// Default options\r\nconst DEFAULT_LEGEND_COLOR = {\r\n  plugins: {\r\n    legend: {\r\n      labels: {\r\n        color: \"rgb(102,102,102)\",\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\nexport const DEFAULT_OPTIONS = {\r\n  line: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        line: {\r\n          backgroundColor: \"rgba(59, 112, 202, 0.0)\",\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          borderWidth: 2,\r\n          tension: 0.0,\r\n        },\r\n        point: {\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          backgroundColor: \"rgb(59, 112, 202)\",\r\n        },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n      tooltips: {\r\n        intersect: false,\r\n        mode: \"index\",\r\n      },\r\n      datasets: {\r\n        borderColor: \"red\",\r\n      },\r\n      scales: {\r\n        x: {\r\n          stacked: true,\r\n          grid: {\r\n            display: false,\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n        y: {\r\n          stacked: false,\r\n          grid: {\r\n            borderDash: [2],\r\n            drawBorder: false,\r\n            zeroLineColor: \"rgba(0,0,0,0)\",\r\n            zeroLineBorderDash: [2],\r\n            zeroLineBorderDashOffset: [2],\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n      },\r\n    },\r\n  },\r\n  bar: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      backgroundColor: \"rgb(59, 112, 202)\",\r\n      borderWidth: 0,\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n      tooltips: {\r\n        intersect: false,\r\n        mode: \"index\",\r\n      },\r\n      scales: {\r\n        x: {\r\n          stacked: true,\r\n          grid: {\r\n            display: false,\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n        y: {\r\n          stacked: true,\r\n          grid: {\r\n            borderDash: [2],\r\n            drawBorder: false,\r\n            zeroLineColor: \"rgba(0,0,0,0)\",\r\n            zeroLineBorderDash: [2],\r\n            zeroLineBorderDashOffset: [2],\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n      },\r\n    },\r\n  },\r\n  pie: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n    },\r\n  },\r\n  doughnut: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n    },\r\n  },\r\n  polarArea: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        arc: { backgroundColor: \"rgba(59, 112, 202, 0.5)\" },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n    },\r\n  },\r\n  radar: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        line: {\r\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          borderWidth: 2,\r\n        },\r\n        point: {\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          backgroundColor: \"rgb(59, 112, 202)\",\r\n        },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n    },\r\n  },\r\n  scatter: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        line: {\r\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          borderWidth: 2,\r\n          tension: 0.0,\r\n        },\r\n        point: {\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\r\n        },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n      tooltips: {\r\n        intersect: false,\r\n        mode: \"index\",\r\n      },\r\n      datasets: {\r\n        borderColor: \"red\",\r\n      },\r\n      scales: {\r\n        x: {\r\n          stacked: true,\r\n          grid: {\r\n            display: false,\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n        y: {\r\n          stacked: false,\r\n          grid: {\r\n            borderDash: [2],\r\n            drawBorder: false,\r\n            zeroLineColor: \"rgba(0,0,0,0)\",\r\n            zeroLineBorderDash: [2],\r\n            zeroLineBorderDashOffset: [2],\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n      },\r\n    },\r\n  },\r\n  bubble: {\r\n    options: {\r\n      ...DEFAULT_LEGEND_COLOR,\r\n      elements: {\r\n        point: {\r\n          borderColor: \"rgb(59, 112, 202)\",\r\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\r\n        },\r\n      },\r\n      responsive: true,\r\n      legend: {\r\n        display: true,\r\n      },\r\n      scales: {\r\n        x: {\r\n          grid: {\r\n            display: false,\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n        y: {\r\n          grid: {\r\n            borderDash: [2],\r\n            drawBorder: false,\r\n            zeroLineColor: \"rgba(0,0,0,0)\",\r\n            zeroLineBorderDash: [2],\r\n            zeroLineBorderDashOffset: [2],\r\n          },\r\n          ticks: {\r\n            fontColor: \"rgba(0,0,0, 0.5)\",\r\n          },\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n","import SelectorEngine from \"../dom/selector-engine\";\r\nimport jqueryInit from \"./jqueryInit\";\r\nimport {\r\n  dropdownCallback,\r\n  offcanvasCallback,\r\n  tabCallback,\r\n  buttonCallback,\r\n  modalCallback,\r\n  rippleCallback,\r\n  collapseCallback,\r\n} from \"./autoinitCallbacks\";\r\n\r\nimport { chartsCallback } from \"./chartsInit\";\r\n\r\nconst defaultInitSelectors = {\r\n  alert: {\r\n    name: \"Alert\",\r\n    selector: \"[data-te-alert-init]\",\r\n    isToggler: false,\r\n  },\r\n  animation: {\r\n    name: \"Animate\",\r\n    selector: \"[data-te-animation-init]\",\r\n    isToggler: false,\r\n  },\r\n  carousel: {\r\n    name: \"Carousel\",\r\n    selector: \"[data-te-carousel-init]\",\r\n    isToggler: false,\r\n  },\r\n  chips: {\r\n    name: \"ChipsInput\",\r\n    selector: \"[data-te-chips-init]\",\r\n    isToggler: false,\r\n  },\r\n  chip: {\r\n    name: \"Chip\",\r\n    selector: \"[data-te-chip-init]\",\r\n    isToggler: false,\r\n  },\r\n  datepicker: {\r\n    name: \"Datepicker\",\r\n    selector: \"[data-te-datepicker-init]\",\r\n    isToggler: false,\r\n  },\r\n  input: {\r\n    name: \"Input\",\r\n    selector: \"[data-te-input-wrapper-init]\",\r\n    isToggler: false,\r\n  },\r\n  scrollspy: {\r\n    name: \"ScrollSpy\",\r\n    selector: \"[data-te-spy='scroll']\",\r\n    isToggler: false,\r\n  },\r\n  select: {\r\n    name: \"Select\",\r\n    selector: \"[data-te-select-init]\",\r\n    isToggler: false,\r\n  },\r\n  sidenav: {\r\n    name: \"Sidenav\",\r\n    selector: \"[data-te-sidenav-init]\",\r\n    isToggler: false,\r\n  },\r\n  stepper: {\r\n    name: \"Stepper\",\r\n    selector: \"[data-te-stepper-init]\",\r\n    isToggler: false,\r\n  },\r\n  timepicker: {\r\n    name: \"Timepicker\",\r\n    selector: \"[data-te-timepicker-init]\",\r\n    isToggler: false,\r\n  },\r\n  toast: {\r\n    name: \"Toast\",\r\n    selector: \"[data-te-toast-init]\",\r\n    isToggler: false,\r\n  },\r\n\r\n  // advancedInits\r\n  chart: {\r\n    name: \"Chart\",\r\n    selector: \"[data-te-chart]\",\r\n    isToggler: false,\r\n    advanced: chartsCallback,\r\n  },\r\n\r\n  // togglers\r\n  button: {\r\n    name: \"Button\",\r\n    selector: \"[data-te-toggle='button']\",\r\n    isToggler: true,\r\n    callback: buttonCallback,\r\n  },\r\n  collapse: {\r\n    name: \"Collapse\",\r\n    selector: \"[data-te-collapse-init]\",\r\n    isToggler: true,\r\n    callback: collapseCallback,\r\n  },\r\n  dropdown: {\r\n    name: \"Dropdown\",\r\n    selector: \"[data-te-dropdown-toggle-ref]\",\r\n    isToggler: true,\r\n    callback: dropdownCallback,\r\n  },\r\n  modal: {\r\n    name: \"Modal\",\r\n    selector: \"[data-te-toggle='modal']\",\r\n    isToggler: true,\r\n    callback: modalCallback,\r\n  },\r\n  ripple: {\r\n    name: \"Ripple\",\r\n    selector: \"[data-te-ripple-init]\",\r\n    isToggler: true,\r\n    callback: rippleCallback,\r\n  },\r\n  offcanvas: {\r\n    name: \"Offcanvas\",\r\n    selector: \"[data-te-offcanvas-toggle]\",\r\n    isToggler: true,\r\n    callback: offcanvasCallback,\r\n  },\r\n  tab: {\r\n    name: \"Tab\",\r\n    selector:\r\n      \"[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']\",\r\n    isToggler: true,\r\n    callback: tabCallback,\r\n  },\r\n};\r\n\r\nconst getComponentData = (component) => {\r\n  return defaultInitSelectors[component.NAME] || null;\r\n};\r\n\r\nconst initComponent = (component) => {\r\n  if (!component || initiatedComponents?.includes(component.NAME)) {\r\n    return;\r\n  }\r\n  initiatedComponents?.push(component.NAME);\r\n\r\n  const thisComponent = getComponentData(component);\r\n  const isToggler = thisComponent?.isToggler || false;\r\n\r\n  jqueryInit(component);\r\n\r\n  if (thisComponent?.advanced) {\r\n    thisComponent?.advanced(component, thisComponent?.selector);\r\n    return;\r\n  }\r\n\r\n  if (isToggler) {\r\n    thisComponent?.callback(component, thisComponent?.selector);\r\n\r\n    return;\r\n  }\r\n\r\n  SelectorEngine.find(thisComponent?.selector).forEach((element) => {\r\n    let instance = component.getInstance(element);\r\n    if (!instance) {\r\n      instance = new component(element);\r\n    }\r\n  });\r\n};\r\n\r\nconst init = (components) => {\r\n  components.forEach((component) => initComponent(component));\r\n};\r\n\r\nconst initTE = (components, checkOtherImports = false) => {\r\n  const componentList = Object.keys(defaultInitSelectors).map((element) => {\r\n    const requireAutoinit = Boolean(\r\n      document.body.querySelector(defaultInitSelectors[element].selector)\r\n    );\r\n    if (requireAutoinit) {\r\n      const component = components[defaultInitSelectors[element].name];\r\n      if (\r\n        !component &&\r\n        !initiatedComponents?.includes(element) &&\r\n        checkOtherImports\r\n      ) {\r\n        console.warn(\r\n          `Please import ${defaultInitSelectors[element].name} from \"tw-elements\" package and add it to a object parameter inside \"initTE\" function`\r\n        );\r\n      }\r\n      return component;\r\n    }\r\n  });\r\n\r\n  init(componentList);\r\n};\r\n\r\nexport default initTE;\r\n","import Manipulator from \"../dom/manipulator\";\r\nimport SelectorEngine from \"../dom/selector-engine\";\r\nimport { DEFAULT_OPTIONS } from \"../data/chart/chartDefaults\";\r\n\r\nconst chartsCallback = (component, initSelector) => {\r\n  // eslint-disable-next-line consistent-return\r\n  const IS_COMPLEX = (data) => {\r\n    return (\r\n      (data[0] === \"{\" && data[data.length - 1] === \"}\") ||\r\n      (data[0] === \"[\" && data[data.length - 1] === \"]\")\r\n    );\r\n  };\r\n\r\n  const CONVERT_DATA_TYPE = (data) => {\r\n    if (typeof data !== \"string\") return data;\r\n    if (IS_COMPLEX(data)) {\r\n      return JSON.parse(data.replace(/'/g, '\"'));\r\n    }\r\n    return data;\r\n  };\r\n\r\n  const PARSE_DATA = (data) => {\r\n    const dataset = {};\r\n    Object.keys(data).forEach((property) => {\r\n      if (property.match(/dataset.*/)) {\r\n        const chartProperty = property\r\n          .slice(7, 8)\r\n          .toLowerCase()\r\n          .concat(property.slice(8));\r\n        dataset[chartProperty] = CONVERT_DATA_TYPE(data[property]);\r\n      }\r\n    });\r\n    return dataset;\r\n  };\r\n\r\n  SelectorEngine.find(initSelector).forEach((el) => {\r\n    if (\r\n      Manipulator.getDataAttribute(el, \"chart\") !== \"bubble\" &&\r\n      Manipulator.getDataAttribute(el, \"chart\") !== \"scatter\"\r\n    ) {\r\n      const dataSet = Manipulator.getDataAttributes(el);\r\n      const dataAttr = {\r\n        data: {\r\n          datasets: [PARSE_DATA(dataSet)],\r\n        },\r\n      };\r\n      if (dataSet.chart) {\r\n        dataAttr.type = dataSet.chart;\r\n      }\r\n      if (dataSet.labels) {\r\n        dataAttr.data.labels = JSON.parse(dataSet.labels.replace(/'/g, '\"'));\r\n      }\r\n      return new component(el, {\r\n        ...dataAttr,\r\n        ...DEFAULT_OPTIONS[dataAttr.type],\r\n      });\r\n    }\r\n    return null;\r\n  });\r\n};\r\n\r\nexport { chartsCallback };\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport initTE from \"../../autoinit/index\";\r\nimport Input from \"../../forms/input\";\r\n\r\nexport const getInputField = ({ inputID, labelText }, classes) => {\r\n  initTE({ Input }, false);\r\n  return `<div data-te-chips-input-wrapper data-te-input-wrapper-init class=\"${classes.chipsInputWrapper}\">\r\n      <input\r\n          type=\"text\"\r\n          class=\"${classes.chipsInput}\"\r\n          id=\"${inputID}\"\r\n          placeholder=\"Example label\" />\r\n        <label\r\n          for=\"${inputID}\"\r\n          class=\"${classes.chipsLabel}\"\r\n          >${labelText}\r\n        </label>\r\n\r\n        <div data-te-input-notch-ref class=\"${classes.chipsNotchesWrapper}\">\r\n        <div class=\"${classes.chipsNotchesLeading}\" data-te-input-notch-leading-ref style=\"width: 9px;\"></div>\r\n        <div class=\"${classes.chipsNotchesMiddle}\" data-te-input-notch-middle-ref style=\"width: 87.2px;\"></div>\r\n        <div class=\"${classes.chipsNotchesTrailing}\" data-te-input-notch-trailing-ref></div>\r\n      </div>\r\n    </div>`;\r\n};\r\n\r\nexport const getChip = ({ text, iconSVG }, classes) => {\r\n  return `<div data-te-chip-init data-te-ripple-init class=\"${classes.chipElement}\">\r\n    <span data-te-chip-text>${text}</span> \r\n      <span data-te-chip-close class=\"${classes.chipCloseIcon}\">\r\n        ${iconSVG}\r\n      </span>\r\n  </div>`;\r\n};\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { element, typeCheckConfig } from \"../../util/index\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\nimport Data from \"../../dom/data\";\r\nimport EventHandler from \"../../dom/event-handler\";\r\nimport { getChip } from \"./templates\";\r\n\r\n/**\r\n *\r\n * ------------------------------------------------------------------------\r\n * Constants\r\n * ------------------------------------------------------------------------\r\n */\r\n\r\nconst NAME = \"chip\";\r\nconst DATA_KEY = `te.${NAME}`;\r\n\r\nconst ATTR_CHIP_CLOSE = \"data-te-chip-close\";\r\n\r\nconst ATTR_SELECTOR_CHIP_CLOSE = `[${ATTR_CHIP_CLOSE}]`;\r\n\r\nconst EVENT_DELETE = \"delete.te.chips\";\r\nconst EVENT_SELECT = \"select.te.chip\";\r\n\r\nconst defaultIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-3 h-3\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" /></svg>`;\r\n\r\nconst DefaultType = {\r\n  text: \"string\",\r\n  closeIcon: \"boolean\",\r\n  img: \"object\",\r\n  iconSVG: \"string\",\r\n};\r\n\r\nconst Default = {\r\n  text: \"\",\r\n  closeIcon: false,\r\n  img: { path: \"\", alt: \"\" },\r\n  iconSVG: defaultIcon,\r\n};\r\n\r\nconst DefaultClasses = {\r\n  icon: \"float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out\",\r\n  chipElement:\r\n    \"flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded\",\r\n  chipCloseIcon:\r\n    \"w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  icon: \"string\",\r\n  chipElement: \"string\",\r\n  chipCloseIcon: \"string\",\r\n};\r\n\r\nclass Chip {\r\n  constructor(element, data = {}, classes) {\r\n    this._element = element;\r\n    this._options = this._getConfig(data);\r\n    this._classes = this._getClasses(classes);\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  // Public\r\n\r\n  init() {\r\n    this._appendCloseIcon();\r\n    this._handleDelete();\r\n    this._handleTextChip();\r\n    this._handleClickOnChip();\r\n  }\r\n\r\n  dispose() {\r\n    this._element = null;\r\n    this._options = null;\r\n    EventHandler.off(this._element, \"click\");\r\n  }\r\n\r\n  appendChip() {\r\n    const { text, closeIcon, iconSVG } = this._options;\r\n    const chip = getChip({ text, closeIcon, iconSVG }, this._classes);\r\n\r\n    return chip;\r\n  }\r\n\r\n  // Private\r\n\r\n  _appendCloseIcon(el = this._element) {\r\n    if (SelectorEngine.find(ATTR_SELECTOR_CHIP_CLOSE, this._element).length > 0)\r\n      return;\r\n\r\n    if (this._options.closeIcon) {\r\n      const createIcon = element(\"span\");\r\n\r\n      createIcon.classList = this._classes.icon;\r\n      createIcon.setAttribute(ATTR_CHIP_CLOSE);\r\n      createIcon.innerHTML = this._options.iconSVG;\r\n\r\n      el.insertAdjacentElement(\"beforeend\", createIcon);\r\n    }\r\n  }\r\n\r\n  _handleClickOnChip() {\r\n    EventHandler.on(this._element, \"click\", (event) => {\r\n      const { textContent } = event.target;\r\n      const obj = {};\r\n\r\n      obj.tag = textContent.trim();\r\n\r\n      EventHandler.trigger(EVENT_SELECT, { event, obj });\r\n    });\r\n  }\r\n\r\n  _handleDelete() {\r\n    const deleteElement = SelectorEngine.find(\r\n      ATTR_SELECTOR_CHIP_CLOSE,\r\n      this._element\r\n    );\r\n\r\n    if (deleteElement.length === 0) return;\r\n\r\n    EventHandler.on(this._element, \"click\", ATTR_SELECTOR_CHIP_CLOSE, () => {\r\n      EventHandler.trigger(this._element, EVENT_DELETE);\r\n      this._element.remove();\r\n    });\r\n  }\r\n\r\n  _handleTextChip() {\r\n    if (this._element.innerText !== \"\") return;\r\n\r\n    this._element.innerText = this._options.text;\r\n  }\r\n\r\n  _getConfig(options) {\r\n    const config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...options,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Chip;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport { typeCheckConfig, element, getUID } from \"../../util/index\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport SelectorEngine from \"../../dom/selector-engine\";\r\nimport Chip from \"./chip\";\r\nimport Data from \"../../dom/data\";\r\nimport { getInputField } from \"./templates\";\r\nimport EventHandler from \"../../dom/event-handler\";\r\nimport {\r\n  LEFT_ARROW,\r\n  RIGHT_ARROW,\r\n  ENTER,\r\n  BACKSPACE,\r\n  UP_ARROW,\r\n  DOWN_ARROW,\r\n  DELETE,\r\n} from \"../../util/keycodes\";\r\n\r\n/*\r\n------------------------------------------------------------------------\r\nConstants\r\n------------------------------------------------------------------------\r\n*/\r\n\r\nconst NAME = \"chips\";\r\nconst ATTR_NAME = `data-te-${NAME}`;\r\n\r\nconst DATA_KEY = `te.${NAME}`;\r\n\r\nconst ATTR_CHIPS_INIT = `${ATTR_NAME}-init`;\r\nconst ATTR_CHIPS_ACTIVE = `${ATTR_NAME}-active`;\r\nconst ATTR_CHIPS_INITIAL = `${ATTR_NAME}-initial`;\r\nconst ATTR_CHIPS_PLACEHOLDER = `${ATTR_NAME}-placeholder`;\r\nconst ATTR_CHIPS_WRAPPER = `${ATTR_NAME}-input-wrapper`;\r\nconst ATTR_CHIP_INIT = \"data-te-chip-init\";\r\nconst ATTR_CHIP_CLOSE = \"data-te-chip-close\";\r\nconst ATTR_CHIP_TEXT = \"data-te-chip-text\";\r\n\r\nconst ATTR_SELECTOR_CHIPS_ACTIVE = `[${ATTR_CHIPS_ACTIVE}]`;\r\nconst ATTR_SELECTOR_CHIP_INIT = `[${ATTR_CHIP_INIT}]`;\r\nconst ATTR_SELECTOR_CHIP_ACTIVE = `${ATTR_SELECTOR_CHIP_INIT}${ATTR_SELECTOR_CHIPS_ACTIVE}`;\r\nconst ATTR_SELECTOR_CLOSE = `[${ATTR_CHIP_CLOSE}]`;\r\nconst ATTR_SELECTOR_CHIPS_WRAPPER = `[${ATTR_CHIPS_WRAPPER}]`;\r\nconst ATTR_SELECTOR_CHIP_TEXT = `[${ATTR_CHIP_TEXT}]`;\r\nconst ATTR_SELECTOR_CHIPS_PLACEHOLDER = `[${ATTR_CHIPS_PLACEHOLDER}]`;\r\n\r\nconst DATA_NOTCH_LEADING = \"data-te-input-notch-leading-ref\";\r\nconst DATA_NOTCH_MIDDLE = \"data-te-input-notch-middle-ref\";\r\nconst SELECTOR_NOTCH_LEADING = `[${DATA_NOTCH_LEADING}]`;\r\nconst SELECTOR_NOTCH_MIDDLE = `[${DATA_NOTCH_MIDDLE}]`;\r\n\r\n// input helpers\r\nconst ATTR_INPUT_STATE_ACTIVE = \"data-te-input-state-active\";\r\nconst ATTR_SELECTOR_INPUT_NOTCH_REF = \"[data-te-input-notch-ref]\";\r\n\r\nconst EVENT_ADD = \"add.te.chips\";\r\nconst EVENT_ARROW_DOWN = \"arrowDown.te.chips\";\r\nconst EVENT_ARROW_LEFT = \"arrowLeft.te.chips\";\r\nconst EVENT_ARROW_RIGHT = \"arrowRight.te.chips\";\r\nconst EVENT_ARROW_UP = \"arrowUp.te.chips\";\r\nconst EVENT_DELETE = \"delete.te.chips\";\r\nconst EVENT_SELECT = \"select.te.chips\";\r\n\r\nconst DefaultType = {\r\n  inputID: \"string\",\r\n  parentSelector: \"string\",\r\n  initialValues: \"array\",\r\n  editable: \"boolean\",\r\n  labelText: \"string\",\r\n};\r\n\r\nconst Default = {\r\n  inputID: getUID(\"chips-input-\"),\r\n  parentSelector: \"\",\r\n  initialValues: [{ tag: \"init1\" }, { tag: \"init2\" }],\r\n  editable: false,\r\n  labelText: \"Example label\",\r\n};\r\n\r\nconst DefaultClasses = {\r\n  opacity: \"opacity-0\",\r\n  inputWrapperPadding: \"p-[5px]\",\r\n  transition:\r\n    \"transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\r\n  contentEditable: \"outline-none !border-[3px] !border-solid !border-[#b2b3b4]\",\r\n  chipsInputWrapper:\r\n    \"relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\r\n  chipsInput:\r\n    \"peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0\",\r\n  chipsLabel:\r\n    \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200\",\r\n  chipsNotchesWrapper:\r\n    \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\r\n  chipsNotchesLeading:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n  chipsNotchesMiddle:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n  chipsNotchesTrailing:\r\n    \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\r\n};\r\n\r\nconst DefaultClassesType = {\r\n  opacity: \"string\",\r\n  inputWrapperPadding: \"string\",\r\n  transition: \"string\",\r\n  contentEditable: \"string\",\r\n  chipsInputWrapper: \"string\",\r\n  chipsInput: \"string\",\r\n  chipsLabel: \"string\",\r\n  chipsNotchesWrapper: \"string\",\r\n  chipsNotchesLeading: \"string\",\r\n  chipsNotchesMiddle: \"string\",\r\n  chipsNotchesTrailing: \"string\",\r\n};\r\n\r\nclass ChipsInput extends Chip {\r\n  constructor(element, data = {}, classes) {\r\n    super(element, data);\r\n    this._element = element;\r\n    this._label = null;\r\n    this._labelWidth = 0;\r\n    this._labelMarginLeft = 0;\r\n    this._notchLeading = null;\r\n    this._notchMiddle = null;\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n    }\r\n\r\n    this._options = this._getConfig(data);\r\n    this._classes = this._getClasses(classes);\r\n    this.numberClicks = 0;\r\n\r\n    this.init();\r\n  }\r\n\r\n  // Getters\r\n\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get activeChip() {\r\n    return SelectorEngine.findOne(ATTR_SELECTOR_CHIP_ACTIVE, this._element);\r\n  }\r\n\r\n  get input() {\r\n    return SelectorEngine.findOne(\"input\", this._element);\r\n  }\r\n\r\n  get allChips() {\r\n    return SelectorEngine.find(ATTR_SELECTOR_CHIP_INIT, this._element);\r\n  }\r\n\r\n  get chipsInputWrapper() {\r\n    return SelectorEngine.findOne(ATTR_SELECTOR_CHIPS_WRAPPER, this._element);\r\n  }\r\n\r\n  // Public\r\n\r\n  init() {\r\n    this._setChipsClass();\r\n    this._appendInputToElement(ATTR_CHIPS_PLACEHOLDER);\r\n    this._handleInitialValue();\r\n    this._handleInputText();\r\n    this._handleKeyboard();\r\n    this._handleChipsOnSelect();\r\n    this._handleEditable();\r\n    this._handleChipsFocus();\r\n    this._handleClicksOnChips();\r\n    this._getLabelData();\r\n    this._getLabelWidth();\r\n    this._getNotchData();\r\n    this._applyNotch();\r\n  }\r\n\r\n  dispose() {\r\n    this._element = null;\r\n    this._options = null;\r\n  }\r\n\r\n  // Private\r\n\r\n  _getNotchData() {\r\n    this._notchMiddle = SelectorEngine.findOne(\r\n      SELECTOR_NOTCH_MIDDLE,\r\n      this._element\r\n    );\r\n    this._notchLeading = SelectorEngine.findOne(\r\n      SELECTOR_NOTCH_LEADING,\r\n      this._element\r\n    );\r\n  }\r\n\r\n  _getLabelData() {\r\n    this._label = SelectorEngine.findOne(\"label\", this._element);\r\n  }\r\n\r\n  _getLabelWidth() {\r\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\r\n  }\r\n\r\n  _applyNotch() {\r\n    this._notchMiddle.style.width = `${this._labelWidth}px`;\r\n    this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`;\r\n\r\n    if (this._label === null) return;\r\n    this._label.style.marginLeft = `${this._labelMarginLeft}px`;\r\n  }\r\n\r\n  _setChipsClass() {\r\n    this._element.setAttribute(ATTR_CHIPS_INIT, \"\");\r\n  }\r\n\r\n  _handleDeleteEvents(event) {\r\n    const [last] = this.allChips.slice(-1);\r\n\r\n    if (this.activeChip === null) {\r\n      last.remove();\r\n\r\n      this._handleEvents(event, EVENT_DELETE);\r\n    } else {\r\n      const index = this.allChips.findIndex((chip) => chip === this.activeChip);\r\n      const activeChipAfter = this._handleActiveChipAfterRemove(index);\r\n      const arr = [];\r\n\r\n      if (this.activeChip === null) return;\r\n\r\n      this.activeChip.remove();\r\n      this._handleEvents(event, EVENT_DELETE);\r\n\r\n      this.numberClicks = index;\r\n\r\n      activeChipAfter.setAttribute(ATTR_CHIPS_ACTIVE, \"\");\r\n\r\n      this.allChips.forEach((chip) => {\r\n        if (chip.hasAttribute(ATTR_CHIPS_ACTIVE)) {\r\n          arr.push(chip);\r\n\r\n          if (arr.length > 1) {\r\n            this.allChips.forEach((chip) => chip.remove());\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _handleUpEvents(event) {\r\n    this.numberClicks += 1;\r\n\r\n    if (this.numberClicks === this.allChips.length + 1) this.numberClicks = 0;\r\n\r\n    this._handleRightKeyboardArrow(this.numberClicks);\r\n\r\n    this._handleEvents(event, EVENT_ARROW_RIGHT);\r\n    this._handleEvents(event, EVENT_ARROW_UP);\r\n  }\r\n\r\n  _handleDownEvents(event) {\r\n    this.numberClicks -= 1;\r\n\r\n    if (this.numberClicks <= 0) this.numberClicks = this.allChips.length;\r\n\r\n    this._handleLeftKeyboardArrow(this.numberClicks);\r\n\r\n    this._handleEvents(event, EVENT_ARROW_LEFT);\r\n    this._handleEvents(event, EVENT_ARROW_DOWN);\r\n  }\r\n\r\n  _keyboardEvents(event) {\r\n    const { target, keyCode, ctrlKey } = event;\r\n\r\n    if (target.value.length > 0 || this.allChips.length === 0) return;\r\n\r\n    if (keyCode === BACKSPACE || keyCode === DELETE) {\r\n      this._handleDeleteEvents(event);\r\n    } else if (keyCode === RIGHT_ARROW || keyCode === UP_ARROW) {\r\n      this._handleUpEvents(event);\r\n    } else if (keyCode === LEFT_ARROW || keyCode === DOWN_ARROW) {\r\n      this._handleDownEvents(event);\r\n    } else if (keyCode === 65 && ctrlKey) {\r\n      this._handleAddActiveClass();\r\n    }\r\n  }\r\n\r\n  _handleKeyboard() {\r\n    EventHandler.on(this.input, \"keydown\", (event) =>\r\n      this._keyboardEvents(event)\r\n    );\r\n  }\r\n\r\n  _handleEditable() {\r\n    const { editable } = this._options;\r\n\r\n    if (!editable) return;\r\n\r\n    this.allChips.forEach((chip) => {\r\n      EventHandler.on(chip, \"dblclick\", (e) => {\r\n        const close = SelectorEngine.findOne(ATTR_SELECTOR_CLOSE, chip);\r\n\r\n        chip.classList.add(...this._classes.contentEditable.split(\" \"));\r\n        chip.contentEditable = true;\r\n        chip.focus();\r\n\r\n        setTimeout(() => {\r\n          Manipulator.addStyle(close, { display: \"none\" });\r\n        }, 200);\r\n        close.classList.add(...this._classes.opacity.split(\" \"));\r\n\r\n        const obj = {};\r\n\r\n        obj.tag = e.target.textContent;\r\n\r\n        EventHandler.trigger(chip, EVENT_SELECT, {\r\n          event: e,\r\n          allChips: this.allChips,\r\n        });\r\n      });\r\n\r\n      EventHandler.on(document, \"click\", ({ target }) => {\r\n        const close = SelectorEngine.findOne(ATTR_SELECTOR_CLOSE, chip);\r\n        const chipText = SelectorEngine.findOne(ATTR_SELECTOR_CHIP_TEXT, chip);\r\n\r\n        const isContainer = target === chip;\r\n        const isContainerContent = chip && chip.contains(target);\r\n\r\n        if (!isContainer && !isContainerContent) {\r\n          chip.contentEditable = false;\r\n          chip.classList.remove(...this._classes.contentEditable.split(\" \"));\r\n\r\n          if (chipText.textContent !== \"\") {\r\n            setTimeout(() => {\r\n              Manipulator.addStyle(close, { display: \"block\" });\r\n              close.classList.remove(...this._classes.opacity.split(\" \"));\r\n            }, 160);\r\n          }\r\n        }\r\n\r\n        if (chipText.textContent === \"\") {\r\n          setTimeout(() => {\r\n            chip.classList.add(...this._classes.opacity.split(\" \"));\r\n          }, 200);\r\n\r\n          setTimeout(() => {\r\n            chip.remove();\r\n          }, 300);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _handleRemoveActiveClass() {\r\n    this.allChips.forEach((chip) => chip.removeAttribute(ATTR_CHIPS_ACTIVE));\r\n  }\r\n\r\n  _handleAddActiveClass() {\r\n    this.allChips.forEach((chip) => chip.setAttribute(ATTR_CHIPS_ACTIVE, \"\"));\r\n  }\r\n\r\n  _handleRightKeyboardArrow(num) {\r\n    this._handleRemoveActiveClass();\r\n\r\n    if (num === 0) num = 1;\r\n\r\n    this._handleAddActiveClassWithKebyboard(num);\r\n  }\r\n\r\n  _handleLeftKeyboardArrow(num) {\r\n    this._handleRemoveActiveClass();\r\n    this._handleAddActiveClassWithKebyboard(num);\r\n  }\r\n\r\n  _handleActiveChipAfterRemove(index) {\r\n    const chipIndex = index === 0 ? 1 : index - 1;\r\n\r\n    return this.allChips[chipIndex];\r\n  }\r\n\r\n  _handleClicksOnChips() {\r\n    EventHandler.on(this._element, \"click\", () => {\r\n      if (this.allChips.length === 0) {\r\n        this.chipsInputWrapper.classList.remove(\r\n          ...this._classes.inputWrapperPadding.split(\" \")\r\n        );\r\n        this.input.removeAttribute(ATTR_CHIPS_ACTIVE);\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleTextContent() {\r\n    const arr = [];\r\n\r\n    this.allChips.forEach((chip) => arr.push({ tag: chip.textContent.trim() }));\r\n\r\n    return arr;\r\n  }\r\n\r\n  _handleEvents(event, eventName) {\r\n    const arr = this._handleTextContent();\r\n\r\n    const filterActive = this.allChips.filter(\r\n      (chip) => chip.hasAttribute(ATTR_CHIPS_ACTIVE) && chip\r\n    );\r\n\r\n    EventHandler.trigger(this._element, eventName, {\r\n      event,\r\n      allChips: this.allChips,\r\n      arrOfObjects: arr,\r\n      active: filterActive,\r\n      activeObj: {\r\n        tag: filterActive.length <= 0 ? \"\" : filterActive[0].textContent.trim(),\r\n      },\r\n    });\r\n  }\r\n\r\n  _handleChipsFocus() {\r\n    EventHandler.on(this._element, \"click\", ({ target: { attributes } }) => {\r\n      const attrList = [...attributes];\r\n      if (\r\n        attrList.includes(ATTR_CHIP_INIT) ||\r\n        attrList.includes(ATTR_CHIP_CLOSE) ||\r\n        attrList.includes(ATTR_CHIP_TEXT)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      this.input.focus();\r\n    });\r\n  }\r\n\r\n  _handleInitialValue() {\r\n    this._appendInputToElement(ATTR_CHIPS_INITIAL);\r\n\r\n    if (this._element.hasAttribute(ATTR_CHIPS_INITIAL)) {\r\n      const { initialValues } = this._options;\r\n\r\n      initialValues.forEach(({ tag }) =>\r\n        this._handleCreateChip(this.input, tag)\r\n      );\r\n\r\n      SelectorEngine.findOne(\r\n        ATTR_SELECTOR_INPUT_NOTCH_REF,\r\n        this.input.parentNode\r\n      ).setAttribute(ATTR_INPUT_STATE_ACTIVE, \"\");\r\n      this.input.setAttribute(ATTR_CHIPS_ACTIVE, \"\");\r\n      this.input.setAttribute(ATTR_INPUT_STATE_ACTIVE, \"\");\r\n    }\r\n\r\n    if (this.allChips.length > 0) {\r\n      this.chipsInputWrapper.classList.add(\r\n        ...this._classes.inputWrapperPadding.split(\" \")\r\n      );\r\n      this.chipsInputWrapper.classList.add(\r\n        ...this._classes.transition.split(\" \")\r\n      );\r\n    }\r\n  }\r\n\r\n  _handleKeysInputToElement(event) {\r\n    const { keyCode, target } = event;\r\n\r\n    if (target.hasAttribute(ATTR_CHIP_INIT)) {\r\n      const close = SelectorEngine.findOne(ATTR_SELECTOR_CLOSE, target);\r\n\r\n      if (keyCode === ENTER) {\r\n        target.contentEditable = false;\r\n        target.classList.remove(...this._classes.contentEditable.split(\" \"));\r\n\r\n        if (target.textContent !== \"\") {\r\n          setTimeout(() => {\r\n            Manipulator.addStyle(close, { display: \"block\" });\r\n            close.classList.remove(...this._classes.opacity.split(\" \"));\r\n          }, 160);\r\n        } else if (target.textContent === \"\") {\r\n          setTimeout(() => {\r\n            target.classList.add(...this._classes.opacity.split(\" \"));\r\n          }, 200);\r\n\r\n          setTimeout(() => {\r\n            target.remove();\r\n          }, 300);\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (keyCode === ENTER) {\r\n      if (target.value === \"\") return;\r\n\r\n      this._handleCreateChip(target, target.value);\r\n\r\n      this._handleRemoveActiveClass();\r\n      this.numberClicks = this.allChips.length + 1;\r\n\r\n      this._handleEvents(event, EVENT_ADD);\r\n    }\r\n\r\n    if (this.allChips.length > 0) {\r\n      this.chipsInputWrapper.classList.add(\r\n        ...this._classes.inputWrapperPadding.split(\" \")\r\n      );\r\n      this.chipsInputWrapper.classList.add(\r\n        ...this._classes.transition.split(\" \")\r\n      );\r\n    } else {\r\n      this.chipsInputWrapper.classList.remove(\r\n        ...this._classes.inputWrapperPadding.split(\" \")\r\n      );\r\n    }\r\n  }\r\n\r\n  _handleBlurInput = ({ target }) => {\r\n    if (target.value.length > 0) {\r\n      this._handleCreateChip(target, target.value);\r\n    }\r\n\r\n    if (this.allChips.length > 0) {\r\n      target.setAttribute(ATTR_CHIPS_ACTIVE, \"\");\r\n      this.input.setAttribute(ATTR_INPUT_STATE_ACTIVE, \"\");\r\n      SelectorEngine.findOne(\r\n        ATTR_SELECTOR_INPUT_NOTCH_REF,\r\n        this.input.parentNode\r\n      ).setAttribute(ATTR_INPUT_STATE_ACTIVE, \"\");\r\n      this.chipsInputWrapper.classList.add(\r\n        ...this._classes.inputWrapperPadding.split(\" \")\r\n      );\r\n    } else {\r\n      target.removeAttribute(ATTR_CHIPS_ACTIVE);\r\n      this.input.removeAttribute(ATTR_INPUT_STATE_ACTIVE);\r\n      SelectorEngine.findOne(\r\n        ATTR_SELECTOR_INPUT_NOTCH_REF,\r\n        this.input.parentNode\r\n      ).removeAttribute(ATTR_INPUT_STATE_ACTIVE);\r\n      this.chipsInputWrapper.classList.remove(\r\n        ...this._classes.inputWrapperPadding.split(\" \")\r\n      );\r\n    }\r\n\r\n    this.allChips.forEach((chip) => chip.removeAttribute(ATTR_CHIPS_ACTIVE));\r\n  };\r\n\r\n  _handleInputText() {\r\n    const placeholder = SelectorEngine.findOne(\r\n      ATTR_SELECTOR_CHIPS_PLACEHOLDER,\r\n      this._element\r\n    );\r\n\r\n    EventHandler.on(this._element, \"keyup\", placeholder, (e) =>\r\n      this._handleKeysInputToElement(e)\r\n    );\r\n    EventHandler.on(this.input, \"blur\", (e) => this._handleBlurInput(e));\r\n  }\r\n\r\n  _appendInputToElement(selector) {\r\n    if (!this._element.hasAttribute(selector)) return;\r\n\r\n    const inputField = getInputField(this._options, this._classes);\r\n\r\n    this._element.insertAdjacentHTML(\"beforeend\", inputField);\r\n  }\r\n\r\n  _handleCreateChip(target, value) {\r\n    const divElement = element(\"div\");\r\n    const instance = Chip.getInstance(divElement);\r\n\r\n    const divWithChips = new Chip(instance, { text: value }, this._classes);\r\n\r\n    if (this._options.parentSelector !== \"\") {\r\n      const parent = document.querySelector(this._options.parentSelector);\r\n      parent.insertAdjacentHTML(\"beforeend\", divWithChips.appendChip());\r\n    } else {\r\n      target.insertAdjacentHTML(\"beforebegin\", divWithChips.appendChip());\r\n    }\r\n\r\n    target.value = \"\";\r\n\r\n    SelectorEngine.find(ATTR_SELECTOR_CHIP_INIT).forEach((chip) => {\r\n      let instance = Chip.getInstance(chip);\r\n      if (!instance) {\r\n        instance = new Chip(chip, {}, this._classes);\r\n      }\r\n      return instance.init();\r\n    });\r\n\r\n    this._handleEditable();\r\n  }\r\n\r\n  _handleChipsOnSelect() {\r\n    this.allChips.forEach((chip) => {\r\n      EventHandler.on(this._element, \"click\", (e) => {\r\n        EventHandler.trigger(chip, EVENT_SELECT, {\r\n          event: e,\r\n          allChips: this.allChips,\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  _handleAddActiveClassWithKebyboard(num) {\r\n    let chip;\r\n\r\n    if (this.allChips[num - 1] === undefined) {\r\n      chip = this.allChips[num - 2];\r\n    } else {\r\n      chip = this.allChips[num - 1];\r\n    }\r\n\r\n    chip.setAttribute(ATTR_CHIPS_ACTIVE);\r\n  }\r\n\r\n  _getConfig(options) {\r\n    const config = {\r\n      ...Default,\r\n      ...Manipulator.getDataAttributes(this._element),\r\n      ...options,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DefaultType);\r\n    return config;\r\n  }\r\n\r\n  _getClasses(classes) {\r\n    const dataAttributes = Manipulator.getDataClassAttributes(this._element);\r\n\r\n    classes = {\r\n      ...DefaultClasses,\r\n      ...dataAttributes,\r\n      ...classes,\r\n    };\r\n\r\n    typeCheckConfig(NAME, classes, DefaultClassesType);\r\n\r\n    return classes;\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default ChipsInput;\r\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","import { element, typeCheckConfig } from \"../../util/index\";\r\nimport Data from \"../../dom/data\";\r\nimport Manipulator from \"../../dom/manipulator\";\r\nimport { DEFAULT_OPTIONS } from \"./chartDefaults\";\r\n/**\r\n * ------------------------------------------------------------------------\r\n * Constants\r\n * ------------------------------------------------------------------------\r\n */\r\n\r\nimport merge from \"deepmerge\";\r\n\r\nconst NAME = \"chart\";\r\nconst DATA_KEY = \"te.chart\";\r\nconst CLASSNAME_CHARTS = \"chart\";\r\n\r\nconst GENERATE_DATA = (options, type, defaultType) => {\r\n  const mergeObjects = (target, source, options) => {\r\n    const destination = target.slice();\r\n    source.forEach((item, index) => {\r\n      if (typeof destination[index] === \"undefined\") {\r\n        destination[index] = options.cloneUnlessOtherwiseSpecified(\r\n          item,\r\n          options\r\n        );\r\n      } else if (options.isMergeableObject(item)) {\r\n        destination[index] = merge(target[index], item, options);\r\n      } else if (target.indexOf(item) === -1) {\r\n        destination.push(item);\r\n      }\r\n    });\r\n    return destination;\r\n  };\r\n  return merge(defaultType[type], options, {\r\n    arrayMerge: mergeObjects,\r\n  });\r\n};\r\n\r\nconst DEFAULT_DARK_OPTIONS = {\r\n  darkTicksColor: \"#fff\",\r\n  darkLabelColor: \"#fff\",\r\n  darkGridLinesColor: \"#555\",\r\n  darkmodeOff: \"undefined\",\r\n  darkBgColor: \"#262626\",\r\n  options: null,\r\n};\r\n\r\nconst DARK_OPTIONS_TYPE = {\r\n  darkTicksColor: \"string\",\r\n  darkLabelColor: \"string\",\r\n  darkGridLinesColor: \"string\",\r\n  darkmodeOff: \"(string|null)\",\r\n  darkBgColor: \"string\",\r\n  options: \"(object|null)\",\r\n};\r\n\r\n/**\r\n * ------------------------------------------------------------------------\r\n * Class Definition\r\n * ------------------------------------------------------------------------\r\n */\r\n//\r\n\r\nclass Chart {\r\n  constructor(element, data, options = {}, darkOptions = {}) {\r\n    this._waitForCharts(element, data, options, darkOptions);\r\n  }\r\n\r\n  async _getChartjs() {\r\n    const {\r\n      Chart: Chartjs,\r\n      ArcElement,\r\n      LineElement,\r\n      BarElement,\r\n      PointElement,\r\n      BarController,\r\n      BubbleController,\r\n      DoughnutController,\r\n      LineController,\r\n      PieController,\r\n      PolarAreaController,\r\n      RadarController,\r\n      ScatterController,\r\n      CategoryScale,\r\n      LinearScale,\r\n      LogarithmicScale,\r\n      RadialLinearScale,\r\n      TimeScale,\r\n      TimeSeriesScale,\r\n      Decimation,\r\n      Filler,\r\n      Legend,\r\n      Title,\r\n      Tooltip,\r\n      SubTitle,\r\n    } = await import(\"chart.js\");\r\n    Chartjs.register(\r\n      ArcElement,\r\n      LineElement,\r\n      BarElement,\r\n      PointElement,\r\n      BarController,\r\n      BubbleController,\r\n      DoughnutController,\r\n      LineController,\r\n      PieController,\r\n      PolarAreaController,\r\n      RadarController,\r\n      ScatterController,\r\n      CategoryScale,\r\n      LinearScale,\r\n      LogarithmicScale,\r\n      RadialLinearScale,\r\n      TimeScale,\r\n      TimeSeriesScale,\r\n      Decimation,\r\n      Filler,\r\n      Legend,\r\n      Title,\r\n      Tooltip,\r\n      SubTitle\r\n    );\r\n\r\n    return Chartjs;\r\n  }\r\n\r\n  async _getChartDataLabels() {\r\n    const { ChartDataLabels } = await import(\"chartjs-plugin-datalabels\");\r\n    return ChartDataLabels;\r\n  }\r\n\r\n  async _waitForCharts(element, data, options = {}, darkOptions = {}) {\r\n    this._Chartjs = await this._getChartjs();\r\n    this._ChartDataLabels = await this._getChartDataLabels();\r\n    this._element = element;\r\n    this._data = data;\r\n    this._options = options;\r\n    this._type = data.type;\r\n    this._canvas = null;\r\n    this._chart = null;\r\n\r\n    // handle mode change (dark- and lightmode)\r\n    this._darkOptions = this._getDarkConfig(darkOptions);\r\n    this._darkModeClassContainer = document.querySelector(\"html\");\r\n    this._prevConfig = null;\r\n    this._observer = null;\r\n\r\n    if (this._element) {\r\n      Data.setData(element, DATA_KEY, this);\r\n      Manipulator.addClass(this._element, CLASSNAME_CHARTS);\r\n      this._chartConstructor();\r\n    }\r\n\r\n    if (this._darkOptions.darkmodeOff !== null) {\r\n      // check mode on start\r\n      this._handleMode(this.systemColorMode);\r\n      // observe darkmode class container change\r\n      this._observer = new MutationObserver(this._observerCallback.bind(this));\r\n      this._observer.observe(this._darkModeClassContainer, {\r\n        attributes: true,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Getters\r\n  static get NAME() {\r\n    return NAME;\r\n  }\r\n\r\n  get systemColorMode() {\r\n    return (\r\n      localStorage.theme ||\r\n      (this._darkModeClassContainer.classList.contains(\"dark\")\r\n        ? \"dark\"\r\n        : \"light\")\r\n    );\r\n  }\r\n\r\n  // Public\r\n  dispose() {\r\n    this._observer.disconnect();\r\n    Data.removeData(this._element, DATA_KEY);\r\n    this._element = null;\r\n  }\r\n\r\n  update(data, config) {\r\n    if (data) {\r\n      this._data = { ...this._data, ...data };\r\n      this._chart.data = this._data;\r\n    }\r\n\r\n    this._prevConfig = this._chart.options;\r\n\r\n    this._options = { ...this._options, ...config };\r\n    this._chart.options = merge(this._chart.options, this._options);\r\n    this._chart.update();\r\n  }\r\n\r\n  // Private\r\n  _getDarkConfig(config) {\r\n    let dataAttributes = {};\r\n    const dataAttr = Manipulator.getDataAttributes(this._element);\r\n    Object.keys(dataAttr).forEach(\r\n      (key) => key.startsWith(\"dark\") && (dataAttributes[key] = dataAttr[key])\r\n    );\r\n\r\n    dataAttributes = {\r\n      ...DEFAULT_DARK_OPTIONS,\r\n      ...dataAttributes,\r\n    };\r\n\r\n    const xyScale = {\r\n      y: {\r\n        ticks: {\r\n          color: dataAttributes.darkTicksColor,\r\n        },\r\n        grid: {\r\n          color: dataAttributes.darkGridLinesColor,\r\n        },\r\n      },\r\n      x: {\r\n        ticks: {\r\n          color: dataAttributes.darkTicksColor,\r\n        },\r\n        grid: {\r\n          color: dataAttributes.darkGridLinesColor,\r\n        },\r\n      },\r\n    };\r\n\r\n    const rScale = {\r\n      r: {\r\n        ticks: {\r\n          color: dataAttributes.darkTicksColor,\r\n          backdropColor: dataAttributes.darkBgColor,\r\n        },\r\n        grid: {\r\n          color: dataAttributes.darkGridLinesColor,\r\n        },\r\n        pointLabels: {\r\n          color: dataAttributes.darkTicksColor,\r\n        },\r\n      },\r\n    };\r\n\r\n    const radials = [\"pie\", \"doughnut\", \"polarArea\", \"radar\"];\r\n\r\n    const scales = !radials.includes(this._type)\r\n      ? xyScale\r\n      : [\"polarArea\", \"radar\"].includes(this._type)\r\n      ? rScale\r\n      : {};\r\n\r\n    const opt = {\r\n      scales,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            color: dataAttributes.darkLabelColor,\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    // combine config\r\n    config = {\r\n      ...dataAttributes,\r\n      options: {\r\n        ...opt,\r\n      },\r\n      ...config,\r\n    };\r\n\r\n    typeCheckConfig(NAME, config, DARK_OPTIONS_TYPE);\r\n\r\n    return config;\r\n  }\r\n\r\n  _chartConstructor() {\r\n    if (this._data) {\r\n      this._createCanvas();\r\n\r\n      const options = GENERATE_DATA(this._options, this._type, DEFAULT_OPTIONS);\r\n      const plugins = [];\r\n\r\n      if (options.dataLabelsPlugin) {\r\n        plugins.push(this._ChartDataLabels);\r\n      }\r\n\r\n      this._chart = new this._Chartjs(this._canvas, {\r\n        ...this._data,\r\n        ...options,\r\n        plugins,\r\n      });\r\n    }\r\n  }\r\n\r\n  _createCanvas() {\r\n    if (this._canvas) return;\r\n    if (this._element.nodeName === \"CANVAS\") {\r\n      this._canvas = this._element;\r\n    } else {\r\n      this._canvas = element(\"canvas\");\r\n      this._element.appendChild(this._canvas);\r\n    }\r\n  }\r\n\r\n  _handleMode(systemColor) {\r\n    if (systemColor === \"dark\") {\r\n      this._changeDatasetBorderColor();\r\n      this.update(null, this._darkOptions.options);\r\n    } else {\r\n      this._changeDatasetBorderColor(false);\r\n      this._prevConfig && this.update(null, this._prevConfig);\r\n    }\r\n  }\r\n\r\n  _observerCallback(mutationList) {\r\n    for (const mutation of mutationList) {\r\n      if (mutation.type === \"attributes\") {\r\n        this._handleMode(this.systemColorMode);\r\n      }\r\n    }\r\n  }\r\n\r\n  _changeDatasetBorderColor(dark = true) {\r\n    [...this._data.data.datasets].forEach(\r\n      (set) =>\r\n        [\"pie\", \"doughnut\", \"polarArea\"].includes(this._type) &&\r\n        (set.borderColor = dark ? this._darkOptions.darkBgColor : \"#fff\")\r\n    );\r\n  }\r\n\r\n  static jQueryInterface(data, options, type) {\r\n    return this.each(function () {\r\n      let chartData = Data.getData(this, DATA_KEY);\r\n\r\n      if (!chartData && /dispose/.test(data)) {\r\n        return;\r\n      }\r\n\r\n      if (!chartData) {\r\n        const chartOptions = options\r\n          ? GENERATE_DATA(options, type, DEFAULT_OPTIONS)\r\n          : DEFAULT_OPTIONS[type];\r\n\r\n        chartData = new Chart(this, {\r\n          ...data,\r\n          ...chartOptions,\r\n        });\r\n      }\r\n\r\n      if (typeof data === \"string\") {\r\n        if (typeof chartData[data] === \"undefined\") {\r\n          throw new TypeError(`No method named \"${data}\"`);\r\n        }\r\n\r\n        chartData[data](options, type);\r\n      }\r\n    });\r\n  }\r\n\r\n  static getInstance(element) {\r\n    return Data.getData(element, DATA_KEY);\r\n  }\r\n\r\n  static getOrCreateInstance(element, config = {}) {\r\n    return (\r\n      this.getInstance(element) ||\r\n      new this(element, typeof config === \"object\" ? config : null)\r\n    );\r\n  }\r\n}\r\n\r\nexport default Chart;\r\n","/*\r\n--------------------------------------------------------------------------\r\nTailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\r\nCopyright  2023 MDBootstrap.com\r\n\r\nUnless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\nIn addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\r\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\nimport Button from \"./components/button\";\r\nimport Dropdown from \"./components/dropdown\";\r\nimport Collapse from \"./components/collapse\";\r\nimport Offcanvas from \"./components/offcanvas\";\r\nimport Alert from \"./components/alert\";\r\nimport Carousel from \"./components/carousel\";\r\nimport Modal from \"./components/modal\";\r\nimport Popover from \"./components/popover\";\r\nimport ScrollSpy from \"./navigation/scrollspy\";\r\nimport Tab from \"./navigation/tab\";\r\nimport Tooltip from \"./components/tooltip\";\r\nimport Toast from \"./components/toast\";\r\nimport Input from \"./forms/input\";\r\nimport Animate from \"./content-styles/animate\";\r\nimport Ripple from \"./methods/ripple\";\r\nimport Datepicker from \"./forms/datepicker\";\r\nimport Timepicker from \"./forms/timepicker\";\r\nimport Sidenav from \"./navigation/sidenav\";\r\nimport Stepper from \"./components/stepper\";\r\nimport Select from \"./forms/select\";\r\nimport ChipsInput from \"./components/chips\";\r\nimport Chip from \"./components/chips/chip\";\r\nimport Chart from \"./data/chart/charts\";\r\nimport initTE from \"./autoinit/index\";\r\n\r\nconst te = {\r\n  Animate,\r\n  Alert,\r\n  Button,\r\n  ChipsInput,\r\n  Chip,\r\n  Dropdown,\r\n  Carousel,\r\n  Collapse,\r\n  Offcanvas,\r\n  Modal,\r\n  Popover,\r\n  ScrollSpy,\r\n  Select,\r\n  Tab,\r\n  Toast,\r\n  Tooltip,\r\n  Ripple,\r\n  Datepicker,\r\n  Timepicker,\r\n  Sidenav,\r\n  Stepper,\r\n  Input,\r\n  Chart,\r\n};\r\n\r\ninitTE(te);\r\n\r\nexport {\r\n  Animate,\r\n  Alert,\r\n  Button,\r\n  ChipsInput,\r\n  Chip,\r\n  Dropdown,\r\n  Carousel,\r\n  Collapse,\r\n  Offcanvas,\r\n  Modal,\r\n  Popover,\r\n  ScrollSpy,\r\n  Select,\r\n  Tab,\r\n  Toast,\r\n  Tooltip,\r\n  Ripple,\r\n  Datepicker,\r\n  Timepicker,\r\n  Sidenav,\r\n  Stepper,\r\n  Input,\r\n  Chart,\r\n  initTE,\r\n};\r\n","/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst keyResolvers = {\n  '': v => v,\n  x: o => o.x,\n  y: o => o.y\n};\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction _splitKey(key) {\n  const parts = key.split('.');\n  const keys = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value, last) =>\n  _lookup(table, value, last\n    ? index => table[index][key] <= value\n    : index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    if (w) {\n      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n    } else {\n      ctx.arc(x, y, radius, 0, TAU);\n    }\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      width = w ? w / 2 : size;\n      ctx.rect(x - width, y - size, 2 * width, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = w ? w / 2 : Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n  if ('native' in evt) {\n    return evt;\n  }\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\nexport { _isPointInArea as $, _factorize as A, finiteOrDefault as B, callback as C, _addGrace as D, _limitValue as E, toDegrees as F, _measureText as G, HALF_PI as H, _int16Range as I, _alignPixel as J, toPadding as K, clipArea as L, renderText as M, unclipArea as N, toFont as O, PI as P, each as Q, _toLeftRightCenter as R, _alignStartEnd as S, TAU as T, overrides as U, merge as V, _capitalize as W, getRelativePosition as X, _rlookupByKey as Y, _lookupByKey as Z, _arrayUnique as _, resolve as a, toLineHeight as a$, getAngleFromPoint as a0, getMaximumSize as a1, _getParentNode as a2, readUsedSize as a3, throttled as a4, supportsEventListenerOptions as a5, _isDomSupported as a6, descriptors as a7, isFunction as a8, _attachContext as a9, getRtlAdapter as aA, overrideTextDirection as aB, _textX as aC, restoreTextDirection as aD, drawPointLegend as aE, noop as aF, distanceBetweenPoints as aG, _setMinAndMaxByKey as aH, niceNum as aI, almostWhole as aJ, almostEquals as aK, _decimalPlaces as aL, _longestText as aM, _filterBetween as aN, _lookup as aO, isPatternOrGradient as aP, getHoverColor as aQ, clone$1 as aR, _merger as aS, _mergerIf as aT, _deprecated as aU, _splitKey as aV, toFontString as aW, splineCurve as aX, splineCurveMonotone as aY, getStyle as aZ, fontString as a_, _createResolver as aa, _descriptors as ab, mergeIf as ac, uid as ad, debounce as ae, retinaScale as af, clearCanvas as ag, setsEqual as ah, _elementsEqual as ai, _isClickEvent as aj, _isBetween as ak, _readValueToProps as al, _updateBezierControlPoints as am, _computeSegments as an, _boundSegments as ao, _steppedInterpolation as ap, _bezierInterpolation as aq, _pointInLine as ar, _steppedLineTo as as, _bezierCurveTo as at, drawPoint as au, addRoundedRectPath as av, toTRBL as aw, toTRBLCorners as ax, _boundSegment as ay, _normalizeAngle as az, isArray as b, PITAU as b0, INFINITY as b1, RAD_PER_DEG as b2, QUARTER_PI as b3, TWO_THIRDS_PI as b4, _angleDiff as b5, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, createContext as h, isObject as i, defined as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, log10 as z };\n","/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, d as defaults, i as isObject, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as createContext, j as defined, s as sign, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as log10, A as _factorize, B as finiteOrDefault, C as callback, D as _addGrace, E as _limitValue, F as toDegrees, G as _measureText, I as _int16Range, J as _alignPixel, K as toPadding, L as clipArea, M as renderText, N as unclipArea, O as toFont, Q as each, R as _toLeftRightCenter, S as _alignStartEnd, U as overrides, V as merge, W as _capitalize, X as getRelativePosition, Y as _rlookupByKey, Z as _lookupByKey, $ as _isPointInArea, a0 as getAngleFromPoint, a1 as getMaximumSize, a2 as _getParentNode, a3 as readUsedSize, a4 as throttled, a5 as supportsEventListenerOptions, a6 as _isDomSupported, a7 as descriptors, a8 as isFunction, a9 as _attachContext, aa as _createResolver, ab as _descriptors, ac as mergeIf, ad as uid, ae as debounce, af as retinaScale, ag as clearCanvas, ah as setsEqual, ai as _elementsEqual, aj as _isClickEvent, ak as _isBetween, al as _readValueToProps, am as _updateBezierControlPoints, an as _computeSegments, ao as _boundSegments, ap as _steppedInterpolation, aq as _bezierInterpolation, ar as _pointInLine, as as _steppedLineTo, at as _bezierCurveTo, au as drawPoint, av as addRoundedRectPath, aw as toTRBL, ax as toTRBLCorners, ay as _boundSegment, az as _normalizeAngle, aA as getRtlAdapter, aB as overrideTextDirection, aC as _textX, aD as restoreTextDirection, aE as drawPointLegend, aF as noop, aG as distanceBetweenPoints, aH as _setMinAndMaxByKey, aI as niceNum, aJ as almostWhole, aK as almostEquals, aL as _decimalPlaces, aM as _longestText, aN as _filterBetween, aO as _lookup } from './chunks/helpers.segment.mjs';\nexport { d as defaults } from './chunks/helpers.segment.mjs';\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = color(from || transparent);\n    const c1 = c0.valid && color(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\ndefaults.describe('animations', {\n  _fallback: 'animation',\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\ndefaults.describe('scales', {\n  _fallback: 'scale',\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndex.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign: tickTextAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass ScatterController extends DatasetController {\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      const {dataset: line, _dataset} = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {showLine} = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = registry.getElement('line');\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  init(chartOptions) {}\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\ndefaults.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {plugins, localIds};\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {},\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.9.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      callback(options.onHover, [e, active, this], this);\n      if (isClick) {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n  circular: true,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n  let value;\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n\nfunction _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n\nfunction _getTarget(source) {\n  const {chart, fill, line} = source;\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n  if (isNumberFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nvar index = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!isNullOrUndef(backdropColor)) {\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      const backdropLeft = left - padding.left;\n      const backdropTop = top - padding.top;\n      const backdropWidth = right - left + padding.width;\n      const backdropHeight = bottom - top + padding.height;\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: backdropLeft,\n          y: backdropTop,\n          w: backdropWidth,\n          h: backdropHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n      }\n    }\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, elements, layouts, plugins, registerables, registry, scales };\n","/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */\nimport { isNullOrUndef, merge, toFont, resolve, toPadding, valueOrDefault, callback, isObject, each } from 'chart.js/helpers';\nimport { defaults as defaults$1, ArcElement, PointElement, BarElement } from 'chart.js';\n\nvar devicePixelRatio = (function() {\n  if (typeof window !== 'undefined') {\n    if (window.devicePixelRatio) {\n      return window.devicePixelRatio;\n    }\n\n    // devicePixelRatio is undefined on IE10\n    // https://stackoverflow.com/a/20204180/8837887\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85\n    var screen = window.screen;\n    if (screen) {\n      return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);\n    }\n  }\n\n  return 1;\n}());\n\nvar utils = {\n  // @todo move this in Chart.helpers.toTextLines\n  toTextLines: function(inputs) {\n    var lines = [];\n    var input;\n\n    inputs = [].concat(inputs);\n    while (inputs.length) {\n      input = inputs.pop();\n      if (typeof input === 'string') {\n        lines.unshift.apply(lines, input.split('\\n'));\n      } else if (Array.isArray(input)) {\n        inputs.push.apply(inputs, input);\n      } else if (!isNullOrUndef(inputs)) {\n        lines.unshift('' + input);\n      }\n    }\n\n    return lines;\n  },\n\n  // @todo move this in Chart.helpers.canvas.textSize\n  // @todo cache calls of measureText if font doesn't change?!\n  textSize: function(ctx, lines, font) {\n    var items = [].concat(lines);\n    var ilen = items.length;\n    var prev = ctx.font;\n    var width = 0;\n    var i;\n\n    ctx.font = font.string;\n\n    for (i = 0; i < ilen; ++i) {\n      width = Math.max(ctx.measureText(items[i]).width, width);\n    }\n\n    ctx.font = prev;\n\n    return {\n      height: ilen * font.lineHeight,\n      width: width\n    };\n  },\n\n  /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */\n  bound: function(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n  },\n\n  /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */\n  arrayDiff: function(a0, a1) {\n    var prev = a0.slice();\n    var updates = [];\n    var i, j, ilen, v;\n\n    for (i = 0, ilen = a1.length; i < ilen; ++i) {\n      v = a1[i];\n      j = prev.indexOf(v);\n\n      if (j === -1) {\n        updates.push([v, 1]);\n      } else {\n        prev.splice(j, 1);\n      }\n    }\n\n    for (i = 0, ilen = prev.length; i < ilen; ++i) {\n      updates.push([prev[i], -1]);\n    }\n\n    return updates;\n  },\n\n  /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */\n  rasterize: function(v) {\n    return Math.round(v * devicePixelRatio) / devicePixelRatio;\n  }\n};\n\nfunction orient(point, origin) {\n  var x0 = origin.x;\n  var y0 = origin.y;\n\n  if (x0 === null) {\n    return {x: 0, y: -1};\n  }\n  if (y0 === null) {\n    return {x: 1, y: 0};\n  }\n\n  var dx = point.x - x0;\n  var dy = point.y - y0;\n  var ln = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: ln ? dx / ln : 0,\n    y: ln ? dy / ln : -1\n  };\n}\n\nfunction aligned(x, y, vx, vy, align) {\n  switch (align) {\n  case 'center':\n    vx = vy = 0;\n    break;\n  case 'bottom':\n    vx = 0;\n    vy = 1;\n    break;\n  case 'right':\n    vx = 1;\n    vy = 0;\n    break;\n  case 'left':\n    vx = -1;\n    vy = 0;\n    break;\n  case 'top':\n    vx = 0;\n    vy = -1;\n    break;\n  case 'start':\n    vx = -vx;\n    vy = -vy;\n    break;\n  case 'end':\n    // keep natural orientation\n    break;\n  default:\n    // clockwise rotation (in degree)\n    align *= (Math.PI / 180);\n    vx = Math.cos(align);\n    vy = Math.sin(align);\n    break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    vx: vx,\n    vy: vy\n  };\n}\n\n// Line clipping (CohenSutherland algorithm)\n// https://en.wikipedia.org/wiki/CohenSutherland_algorithm\n\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\n\nfunction region(x, y, rect) {\n  var res = R_INSIDE;\n\n  if (x < rect.left) {\n    res |= R_LEFT;\n  } else if (x > rect.right) {\n    res |= R_RIGHT;\n  }\n  if (y < rect.top) {\n    res |= R_TOP;\n  } else if (y > rect.bottom) {\n    res |= R_BOTTOM;\n  }\n\n  return res;\n}\n\nfunction clipped(segment, area) {\n  var x0 = segment.x0;\n  var y0 = segment.y0;\n  var x1 = segment.x1;\n  var y1 = segment.y1;\n  var r0 = region(x0, y0, area);\n  var r1 = region(x1, y1, area);\n  var r, x, y;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!(r0 | r1) || (r0 & r1)) {\n      // both points inside or on the same side: no clipping\n      break;\n    }\n\n    // at least one point is outside\n    r = r0 || r1;\n\n    if (r & R_TOP) {\n      x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n      y = area.top;\n    } else if (r & R_BOTTOM) {\n      x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n      y = area.bottom;\n    } else if (r & R_RIGHT) {\n      y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n      x = area.right;\n    } else if (r & R_LEFT) {\n      y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n      x = area.left;\n    }\n\n    if (r === r0) {\n      x0 = x;\n      y0 = y;\n      r0 = region(x0, y0, area);\n    } else {\n      x1 = x;\n      y1 = y;\n      r1 = region(x1, y1, area);\n    }\n  }\n\n  return {\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1\n  };\n}\n\nfunction compute$1(range, config) {\n  var anchor = config.anchor;\n  var segment = range;\n  var x, y;\n\n  if (config.clamp) {\n    segment = clipped(segment, config.area);\n  }\n\n  if (anchor === 'start') {\n    x = segment.x0;\n    y = segment.y0;\n  } else if (anchor === 'end') {\n    x = segment.x1;\n    y = segment.y1;\n  } else {\n    x = (segment.x0 + segment.x1) / 2;\n    y = (segment.y0 + segment.y1) / 2;\n  }\n\n  return aligned(x, y, range.vx, range.vy, config.align);\n}\n\nvar positioners = {\n  arc: function(el, config) {\n    var angle = (el.startAngle + el.endAngle) / 2;\n    var vx = Math.cos(angle);\n    var vy = Math.sin(angle);\n    var r0 = el.innerRadius;\n    var r1 = el.outerRadius;\n\n    return compute$1({\n      x0: el.x + vx * r0,\n      y0: el.y + vy * r0,\n      x1: el.x + vx * r1,\n      y1: el.y + vy * r1,\n      vx: vx,\n      vy: vy\n    }, config);\n  },\n\n  point: function(el, config) {\n    var v = orient(el, config.origin);\n    var rx = v.x * el.options.radius;\n    var ry = v.y * el.options.radius;\n\n    return compute$1({\n      x0: el.x - rx,\n      y0: el.y - ry,\n      x1: el.x + rx,\n      y1: el.y + ry,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  bar: function(el, config) {\n    var v = orient(el, config.origin);\n    var x = el.x;\n    var y = el.y;\n    var sx = 0;\n    var sy = 0;\n\n    if (el.horizontal) {\n      x = Math.min(el.x, el.base);\n      sx = Math.abs(el.base - el.x);\n    } else {\n      y = Math.min(el.y, el.base);\n      sy = Math.abs(el.base - el.y);\n    }\n\n    return compute$1({\n      x0: x,\n      y0: y + sy,\n      x1: x + sx,\n      y1: y,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  fallback: function(el, config) {\n    var v = orient(el, config.origin);\n\n    return compute$1({\n      x0: el.x,\n      y0: el.y,\n      x1: el.x + (el.width || 0),\n      y1: el.y + (el.height || 0),\n      vx: v.x,\n      vy: v.y\n    }, config);\n  }\n};\n\nvar rasterize = utils.rasterize;\n\nfunction boundingRects(model) {\n  var borderWidth = model.borderWidth || 0;\n  var padding = model.padding;\n  var th = model.size.height;\n  var tw = model.size.width;\n  var tx = -tw / 2;\n  var ty = -th / 2;\n\n  return {\n    frame: {\n      x: tx - padding.left - borderWidth,\n      y: ty - padding.top - borderWidth,\n      w: tw + padding.width + borderWidth * 2,\n      h: th + padding.height + borderWidth * 2\n    },\n    text: {\n      x: tx,\n      y: ty,\n      w: tw,\n      h: th\n    }\n  };\n}\n\nfunction getScaleOrigin(el, context) {\n  var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n\n  if (!scale) {\n    return null;\n  }\n\n  if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n    return {x: scale.xCenter, y: scale.yCenter};\n  }\n\n  var pixel = scale.getBasePixel();\n  return el.horizontal ?\n    {x: pixel, y: null} :\n    {x: null, y: pixel};\n}\n\nfunction getPositioner(el) {\n  if (el instanceof ArcElement) {\n    return positioners.arc;\n  }\n  if (el instanceof PointElement) {\n    return positioners.point;\n  }\n  if (el instanceof BarElement) {\n    return positioners.bar;\n  }\n  return positioners.fallback;\n}\n\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n  var HALF_PI = Math.PI / 2;\n\n  if (radius) {\n    var r = Math.min(radius, h / 2, w / 2);\n    var left = x + r;\n    var top = y + r;\n    var right = x + w - r;\n    var bottom = y + h - r;\n\n    ctx.moveTo(x, top);\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, 0);\n      ctx.arc(left, bottom, r, 0, Math.PI);\n    } else {\n      ctx.arc(left, top, r, -Math.PI, Math.PI);\n    }\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, w, h);\n  }\n}\n\nfunction drawFrame(ctx, rect, model) {\n  var bgColor = model.backgroundColor;\n  var borderColor = model.borderColor;\n  var borderWidth = model.borderWidth;\n\n  if (!bgColor && (!borderColor || !borderWidth)) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  drawRoundedRect(\n    ctx,\n    rasterize(rect.x) + borderWidth / 2,\n    rasterize(rect.y) + borderWidth / 2,\n    rasterize(rect.w) - borderWidth,\n    rasterize(rect.h) - borderWidth,\n    model.borderRadius);\n\n  ctx.closePath();\n\n  if (bgColor) {\n    ctx.fillStyle = bgColor;\n    ctx.fill();\n  }\n\n  if (borderColor && borderWidth) {\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = 'miter';\n    ctx.stroke();\n  }\n}\n\nfunction textGeometry(rect, align, font) {\n  var h = font.lineHeight;\n  var w = rect.w;\n  var x = rect.x;\n  var y = rect.y + h / 2;\n\n  if (align === 'center') {\n    x += w / 2;\n  } else if (align === 'end' || align === 'right') {\n    x += w;\n  }\n\n  return {\n    h: h,\n    w: w,\n    x: x,\n    y: y\n  };\n}\n\nfunction drawTextLine(ctx, text, cfg) {\n  var shadow = ctx.shadowBlur;\n  var stroked = cfg.stroked;\n  var x = rasterize(cfg.x);\n  var y = rasterize(cfg.y);\n  var w = rasterize(cfg.w);\n\n  if (stroked) {\n    ctx.strokeText(text, x, y, w);\n  }\n\n  if (cfg.filled) {\n    if (shadow && stroked) {\n      // Prevent drawing shadow on both the text stroke and fill, so\n      // if the text is stroked, remove the shadow for the text fill.\n      ctx.shadowBlur = 0;\n    }\n\n    ctx.fillText(text, x, y, w);\n\n    if (shadow && stroked) {\n      ctx.shadowBlur = shadow;\n    }\n  }\n}\n\nfunction drawText(ctx, lines, rect, model) {\n  var align = model.textAlign;\n  var color = model.color;\n  var filled = !!color;\n  var font = model.font;\n  var ilen = lines.length;\n  var strokeColor = model.textStrokeColor;\n  var strokeWidth = model.textStrokeWidth;\n  var stroked = strokeColor && strokeWidth;\n  var i;\n\n  if (!ilen || (!filled && !stroked)) {\n    return;\n  }\n\n  // Adjust coordinates based on text alignment and line height\n  rect = textGeometry(rect, align, font);\n\n  ctx.font = font.string;\n  ctx.textAlign = align;\n  ctx.textBaseline = 'middle';\n  ctx.shadowBlur = model.textShadowBlur;\n  ctx.shadowColor = model.textShadowColor;\n\n  if (filled) {\n    ctx.fillStyle = color;\n  }\n  if (stroked) {\n    ctx.lineJoin = 'round';\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = strokeColor;\n  }\n\n  for (i = 0, ilen = lines.length; i < ilen; ++i) {\n    drawTextLine(ctx, lines[i], {\n      stroked: stroked,\n      filled: filled,\n      w: rect.w,\n      x: rect.x,\n      y: rect.y + rect.h * i\n    });\n  }\n}\n\nvar Label = function(config, ctx, el, index) {\n  var me = this;\n\n  me._config = config;\n  me._index = index;\n  me._model = null;\n  me._rects = null;\n  me._ctx = ctx;\n  me._el = el;\n};\n\nmerge(Label.prototype, {\n  /**\n   * @private\n   */\n  _modelize: function(display, lines, config, context) {\n    var me = this;\n    var index = me._index;\n    var font = toFont(resolve([config.font, {}], context, index));\n    var color = resolve([config.color, defaults$1.color], context, index);\n\n    return {\n      align: resolve([config.align, 'center'], context, index),\n      anchor: resolve([config.anchor, 'center'], context, index),\n      area: context.chart.chartArea,\n      backgroundColor: resolve([config.backgroundColor, null], context, index),\n      borderColor: resolve([config.borderColor, null], context, index),\n      borderRadius: resolve([config.borderRadius, 0], context, index),\n      borderWidth: resolve([config.borderWidth, 0], context, index),\n      clamp: resolve([config.clamp, false], context, index),\n      clip: resolve([config.clip, false], context, index),\n      color: color,\n      display: display,\n      font: font,\n      lines: lines,\n      offset: resolve([config.offset, 4], context, index),\n      opacity: resolve([config.opacity, 1], context, index),\n      origin: getScaleOrigin(me._el, context),\n      padding: toPadding(resolve([config.padding, 4], context, index)),\n      positioner: getPositioner(me._el),\n      rotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),\n      size: utils.textSize(me._ctx, lines, font),\n      textAlign: resolve([config.textAlign, 'start'], context, index),\n      textShadowBlur: resolve([config.textShadowBlur, 0], context, index),\n      textShadowColor: resolve([config.textShadowColor, color], context, index),\n      textStrokeColor: resolve([config.textStrokeColor, color], context, index),\n      textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)\n    };\n  },\n\n  update: function(context) {\n    var me = this;\n    var model = null;\n    var rects = null;\n    var index = me._index;\n    var config = me._config;\n    var value, label, lines;\n\n    // We first resolve the display option (separately) to avoid computing\n    // other options in case the label is hidden (i.e. display: false).\n    var display = resolve([config.display, true], context, index);\n\n    if (display) {\n      value = context.dataset.data[index];\n      label = valueOrDefault(callback(config.formatter, [value, context]), value);\n      lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);\n\n      if (lines.length) {\n        model = me._modelize(display, lines, config, context);\n        rects = boundingRects(model);\n      }\n    }\n\n    me._model = model;\n    me._rects = rects;\n  },\n\n  geometry: function() {\n    return this._rects ? this._rects.frame : {};\n  },\n\n  rotation: function() {\n    return this._model ? this._model.rotation : 0;\n  },\n\n  visible: function() {\n    return this._model && this._model.opacity;\n  },\n\n  model: function() {\n    return this._model;\n  },\n\n  draw: function(chart, center) {\n    var me = this;\n    var ctx = chart.ctx;\n    var model = me._model;\n    var rects = me._rects;\n    var area;\n\n    if (!this.visible()) {\n      return;\n    }\n\n    ctx.save();\n\n    if (model.clip) {\n      area = model.area;\n      ctx.beginPath();\n      ctx.rect(\n        area.left,\n        area.top,\n        area.right - area.left,\n        area.bottom - area.top);\n      ctx.clip();\n    }\n\n    ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n    ctx.translate(rasterize(center.x), rasterize(center.y));\n    ctx.rotate(model.rotation);\n\n    drawFrame(ctx, rects.frame, model);\n    drawText(ctx, model.lines, rects.text, model);\n\n    ctx.restore();\n  }\n});\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nfunction projected(points, axis) {\n  var min = MAX_INTEGER;\n  var max = MIN_INTEGER;\n  var origin = axis.origin;\n  var i, pt, vx, vy, dp;\n\n  for (i = 0; i < points.length; ++i) {\n    pt = points[i];\n    vx = pt.x - origin.x;\n    vy = pt.y - origin.y;\n    dp = axis.vx * vx + axis.vy * vy;\n    min = Math.min(min, dp);\n    max = Math.max(max, dp);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction toAxis(p0, p1) {\n  var vx = p1.x - p0.x;\n  var vy = p1.y - p0.y;\n  var ln = Math.sqrt(vx * vx + vy * vy);\n\n  return {\n    vx: (p1.x - p0.x) / ln,\n    vy: (p1.y - p0.y) / ln,\n    origin: p0,\n    ln: ln\n  };\n}\n\nvar HitBox = function() {\n  this._rotation = 0;\n  this._rect = {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  };\n};\n\nmerge(HitBox.prototype, {\n  center: function() {\n    var r = this._rect;\n    return {\n      x: r.x + r.w / 2,\n      y: r.y + r.h / 2\n    };\n  },\n\n  update: function(center, rect, rotation) {\n    this._rotation = rotation;\n    this._rect = {\n      x: rect.x + center.x,\n      y: rect.y + center.y,\n      w: rect.w,\n      h: rect.h\n    };\n  },\n\n  contains: function(point) {\n    var me = this;\n    var margin = 1;\n    var rect = me._rect;\n\n    point = rotated(point, me.center(), -me._rotation);\n\n    return !(point.x < rect.x - margin\n      || point.y < rect.y - margin\n      || point.x > rect.x + rect.w + margin * 2\n      || point.y > rect.y + rect.h + margin * 2);\n  },\n\n  // Separating Axis Theorem\n  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n  intersects: function(other) {\n    var r0 = this._points();\n    var r1 = other._points();\n    var axes = [\n      toAxis(r0[0], r0[1]),\n      toAxis(r0[0], r0[3])\n    ];\n    var i, pr0, pr1;\n\n    if (this._rotation !== other._rotation) {\n      // Only separate with r1 axis if the rotation is different,\n      // else it's enough to separate r0 and r1 with r0 axis only!\n      axes.push(\n        toAxis(r1[0], r1[1]),\n        toAxis(r1[0], r1[3])\n      );\n    }\n\n    for (i = 0; i < axes.length; ++i) {\n      pr0 = projected(r0, axes[i]);\n      pr1 = projected(r1, axes[i]);\n\n      if (pr0.max < pr1.min || pr1.max < pr0.min) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @private\n   */\n  _points: function() {\n    var me = this;\n    var rect = me._rect;\n    var angle = me._rotation;\n    var center = me.center();\n\n    return [\n      rotated({x: rect.x, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),\n      rotated({x: rect.x, y: rect.y + rect.h}, center, angle)\n    ];\n  }\n});\n\nfunction coordinates(el, model, geometry) {\n  var point = model.positioner(el, model);\n  var vx = point.vx;\n  var vy = point.vy;\n\n  if (!vx && !vy) {\n    // if aligned center, we don't want to offset the center point\n    return {x: point.x, y: point.y};\n  }\n\n  var w = geometry.w;\n  var h = geometry.h;\n\n  // take in account the label rotation\n  var rotation = model.rotation;\n  var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n  var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n\n  // scale the unit vector (vx, vy) to get at least dx or dy equal to\n  // w or h respectively (else we would calculate the distance to the\n  // ellipse inscribed in the bounding rect)\n  var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n  dx *= vx * vs;\n  dy *= vy * vs;\n\n  // finally, include the explicit offset\n  dx += model.offset * vx;\n  dy += model.offset * vy;\n\n  return {\n    x: point.x + dx,\n    y: point.y + dy\n  };\n}\n\nfunction collide(labels, collider) {\n  var i, j, s0, s1;\n\n  // IMPORTANT Iterate in the reverse order since items at the end of the\n  // list have an higher weight/priority and thus should be less impacted\n  // by the overlapping strategy.\n\n  for (i = labels.length - 1; i >= 0; --i) {\n    s0 = labels[i].$layout;\n\n    for (j = i - 1; j >= 0 && s0._visible; --j) {\n      s1 = labels[j].$layout;\n\n      if (s1._visible && s0._box.intersects(s1._box)) {\n        collider(s0, s1);\n      }\n    }\n  }\n\n  return labels;\n}\n\nfunction compute(labels) {\n  var i, ilen, label, state, geometry, center, proxy;\n\n  // Initialize labels for overlap detection\n  for (i = 0, ilen = labels.length; i < ilen; ++i) {\n    label = labels[i];\n    state = label.$layout;\n\n    if (state._visible) {\n      // Chart.js 3 removed el._model in favor of getProps(), making harder to\n      // abstract reading values in positioners. Also, using string arrays to\n      // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n      // positioners inefficient in the normal case (i.e. not the final values)\n      // and the code a bit ugly, so let's use a Proxy instead.\n      proxy = new Proxy(label._el, {get: (el, p) => el.getProps([p], true)[p]});\n\n      geometry = label.geometry();\n      center = coordinates(proxy, label.model(), geometry);\n      state._box.update(center, geometry, label.rotation());\n    }\n  }\n\n  // Auto hide overlapping labels\n  return collide(labels, function(s0, s1) {\n    var h0 = s0._hidable;\n    var h1 = s1._hidable;\n\n    if ((h0 && h1) || h1) {\n      s1._visible = false;\n    } else if (h0) {\n      s0._visible = false;\n    }\n  });\n}\n\nvar layout = {\n  prepare: function(datasets) {\n    var labels = [];\n    var i, j, ilen, jlen, label;\n\n    for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n      for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {\n        label = datasets[i][j];\n        labels.push(label);\n        label.$layout = {\n          _box: new HitBox(),\n          _hidable: false,\n          _visible: true,\n          _set: i,\n          _idx: label._index\n        };\n      }\n    }\n\n    // TODO New `z` option: labels with a higher z-index are drawn\n    // of top of the ones with a lower index. Lowest z-index labels\n    // are also discarded first when hiding overlapping labels.\n    labels.sort(function(a, b) {\n      var sa = a.$layout;\n      var sb = b.$layout;\n\n      return sa._idx === sb._idx\n        ? sb._set - sa._set\n        : sb._idx - sa._idx;\n    });\n\n    this.update(labels);\n\n    return labels;\n  },\n\n  update: function(labels) {\n    var dirty = false;\n    var i, ilen, label, model, state;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      model = label.model();\n      state = label.$layout;\n      state._hidable = model && model.display === 'auto';\n      state._visible = label.visible();\n      dirty |= state._hidable;\n    }\n\n    if (dirty) {\n      compute(labels);\n    }\n  },\n\n  lookup: function(labels, point) {\n    var i, state;\n\n    // IMPORTANT Iterate in the reverse order since items at the end of\n    // the list have an higher z-index, thus should be picked first.\n\n    for (i = labels.length - 1; i >= 0; --i) {\n      state = labels[i].$layout;\n\n      if (state && state._visible && state._box.contains(point)) {\n        return labels[i];\n      }\n    }\n\n    return null;\n  },\n\n  draw: function(chart, labels) {\n    var i, ilen, label, state, geometry, center;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      state = label.$layout;\n\n      if (state._visible) {\n        geometry = label.geometry();\n        center = coordinates(label._el, label.model(), geometry);\n        state._box.update(center, geometry, label.rotation());\n        label.draw(chart, center);\n      }\n    }\n  }\n};\n\nvar formatter = function(value) {\n  if (isNullOrUndef(value)) {\n    return null;\n  }\n\n  var label = value;\n  var keys, klen, k;\n  if (isObject(value)) {\n    if (!isNullOrUndef(value.label)) {\n      label = value.label;\n    } else if (!isNullOrUndef(value.r)) {\n      label = value.r;\n    } else {\n      label = '';\n      keys = Object.keys(value);\n      for (k = 0, klen = keys.length; k < klen; ++k) {\n        label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];\n      }\n    }\n  }\n\n  return '' + label;\n};\n\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */\n\nvar defaults = {\n  align: 'center',\n  anchor: 'center',\n  backgroundColor: null,\n  borderColor: null,\n  borderRadius: 0,\n  borderWidth: 0,\n  clamp: false,\n  clip: false,\n  color: undefined,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: 1.2,\n    size: undefined,\n    style: undefined,\n    weight: null\n  },\n  formatter: formatter,\n  labels: undefined,\n  listeners: {},\n  offset: 4,\n  opacity: 1,\n  padding: {\n    top: 4,\n    right: 4,\n    bottom: 4,\n    left: 4\n  },\n  rotation: 0,\n  textAlign: 'start',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  textShadowBlur: 0,\n  textShadowColor: undefined\n};\n\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */\n\nvar EXPANDO_KEY = '$datalabels';\nvar DEFAULT_KEY = '$default';\n\nfunction configure(dataset, options) {\n  var override = dataset.datalabels;\n  var listeners = {};\n  var configs = [];\n  var labels, keys;\n\n  if (override === false) {\n    return null;\n  }\n  if (override === true) {\n    override = {};\n  }\n\n  options = merge({}, [options, override]);\n  labels = options.labels || {};\n  keys = Object.keys(labels);\n  delete options.labels;\n\n  if (keys.length) {\n    keys.forEach(function(key) {\n      if (labels[key]) {\n        configs.push(merge({}, [\n          options,\n          labels[key],\n          {_key: key}\n        ]));\n      }\n    });\n  } else {\n    // Default label if no \"named\" label defined.\n    configs.push(options);\n  }\n\n  // listeners: {<event-type>: {<label-key>: <fn>}}\n  listeners = configs.reduce(function(target, config) {\n    each(config.listeners || {}, function(fn, event) {\n      target[event] = target[event] || {};\n      target[event][config._key || DEFAULT_KEY] = fn;\n    });\n\n    delete config.listeners;\n    return target;\n  }, {});\n\n  return {\n    labels: configs,\n    listeners: listeners\n  };\n}\n\nfunction dispatchEvent(chart, listeners, label, event) {\n  if (!listeners) {\n    return;\n  }\n\n  var context = label.$context;\n  var groups = label.$groups;\n  var callback$1;\n\n  if (!listeners[groups._set]) {\n    return;\n  }\n\n  callback$1 = listeners[groups._set][groups._key];\n  if (!callback$1) {\n    return;\n  }\n\n  if (callback(callback$1, [context, event]) === true) {\n    // Users are allowed to tweak the given context by injecting values that can be\n    // used in scriptable options to display labels differently based on the current\n    // event (e.g. highlight an hovered label). That's why we update the label with\n    // the output context and schedule a new chart render by setting it dirty.\n    chart[EXPANDO_KEY]._dirty = true;\n    label.update(context);\n  }\n}\n\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n  var enter, leave;\n\n  if (!previous && !label) {\n    return;\n  }\n\n  if (!previous) {\n    enter = true;\n  } else if (!label) {\n    leave = true;\n  } else if (previous !== label) {\n    leave = enter = true;\n  }\n\n  if (leave) {\n    dispatchEvent(chart, listeners.leave, previous, event);\n  }\n  if (enter) {\n    dispatchEvent(chart, listeners.enter, label, event);\n  }\n}\n\nfunction handleMoveEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var listeners = expando._listeners;\n  var previous, label;\n\n  if (!listeners.enter && !listeners.leave) {\n    return;\n  }\n\n  if (event.type === 'mousemove') {\n    label = layout.lookup(expando._labels, event);\n  } else if (event.type !== 'mouseout') {\n    return;\n  }\n\n  previous = expando._hovered;\n  expando._hovered = label;\n  dispatchMoveEvents(chart, listeners, previous, label, event);\n}\n\nfunction handleClickEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var handlers = expando._listeners.click;\n  var label = handlers && layout.lookup(expando._labels, event);\n  if (label) {\n    dispatchEvent(chart, handlers, label, event);\n  }\n}\n\nvar plugin = {\n  id: 'datalabels',\n\n  defaults: defaults,\n\n  beforeInit: function(chart) {\n    chart[EXPANDO_KEY] = {\n      _actives: []\n    };\n  },\n\n  beforeUpdate: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    expando._listened = false;\n    expando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n    expando._datasets = [];      // per dataset labels: [Label[]]\n    expando._labels = [];        // layouted labels: Label[]\n  },\n\n  afterDatasetUpdate: function(chart, args, options) {\n    var datasetIndex = args.index;\n    var expando = chart[EXPANDO_KEY];\n    var labels = expando._datasets[datasetIndex] = [];\n    var visible = chart.isDatasetVisible(datasetIndex);\n    var dataset = chart.data.datasets[datasetIndex];\n    var config = configure(dataset, options);\n    var elements = args.meta.data || [];\n    var ctx = chart.ctx;\n    var i, j, ilen, jlen, cfg, key, el, label;\n\n    ctx.save();\n\n    for (i = 0, ilen = elements.length; i < ilen; ++i) {\n      el = elements[i];\n      el[EXPANDO_KEY] = [];\n\n      if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n        for (j = 0, jlen = config.labels.length; j < jlen; ++j) {\n          cfg = config.labels[j];\n          key = cfg._key;\n\n          label = new Label(cfg, ctx, el, i);\n          label.$groups = {\n            _set: datasetIndex,\n            _key: key || DEFAULT_KEY\n          };\n          label.$context = {\n            active: false,\n            chart: chart,\n            dataIndex: i,\n            dataset: dataset,\n            datasetIndex: datasetIndex\n          };\n\n          label.update(label.$context);\n          el[EXPANDO_KEY].push(label);\n          labels.push(label);\n        }\n      }\n    }\n\n    ctx.restore();\n\n    // Store listeners at the chart level and per event type to optimize\n    // cases where no listeners are registered for a specific event.\n    merge(expando._listeners, config.listeners, {\n      merger: function(event, target, source) {\n        target[event] = target[event] || {};\n        target[event][args.index] = source[event];\n        expando._listened = true;\n      }\n    });\n  },\n\n  afterUpdate: function(chart) {\n    chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n  },\n\n  // Draw labels on top of all dataset elements\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n  afterDatasetsDraw: function(chart) {\n    layout.draw(chart, chart[EXPANDO_KEY]._labels);\n  },\n\n  beforeEvent: function(chart, args) {\n    // If there is no listener registered for this chart, `listened` will be false,\n    // meaning we can immediately ignore the incoming event and avoid useless extra\n    // computation for users who don't implement label interactions.\n    if (chart[EXPANDO_KEY]._listened) {\n      var event = args.event;\n      switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, event);\n        break;\n      case 'click':\n        handleClickEvents(chart, event);\n        break;\n      }\n    }\n  },\n\n  afterEvent: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    var previous = expando._actives;\n    var actives = expando._actives = chart.getActiveElements();\n    var updates = utils.arrayDiff(previous, actives);\n    var i, ilen, j, jlen, update, label, labels;\n\n    for (i = 0, ilen = updates.length; i < ilen; ++i) {\n      update = updates[i];\n      if (update[1]) {\n        labels = update[0].element[EXPANDO_KEY] || [];\n        for (j = 0, jlen = labels.length; j < jlen; ++j) {\n          label = labels[j];\n          label.$context.active = (update[1] === 1);\n          label.update(label.$context);\n        }\n      }\n    }\n\n    if (expando._dirty || updates.length) {\n      layout.update(expando._labels);\n      chart.render();\n    }\n\n    delete expando._dirty;\n  }\n};\n\nexport { plugin as default };\n"],"names":["V","_t","exports","module","define","amd","globalThis","self","te","Wo","i","Dk","Object","defineProperty","Mk","P","enumerable","configurable","writable","value","Ee","t","set","e","s","n","key","id","get","delete","setData","getData","removeData","vr","Xp","toString","call","match","toLowerCase","se","Math","floor","random","document","getElementById","Il","getAttribute","includes","startsWith","split","trim","yr","querySelector","Ie","Gp","transitionDuration","transitionDelay","window","getComputedStyle","Number","parseFloat","Ll","dispatchEvent","Event","Mi","jquery","nodeType","Le","length","W","keys","forEach","o","r","RegExp","test","Error","toUpperCase","ne","getClientRects","style","parentNode","getPropertyValue","display","visibility","ei","Node","ELEMENT_NODE","classList","contains","disabled","hasAttribute","Pl","documentElement","attachShadow","getRootNode","ShadowRoot","Sn","Ii","offsetHeight","Rl","jQuery","body","xr","Nl","readyState","addEventListener","push","st","dir","qp","Array","from","z","createElement","ii","$l","target","a","removeEventListener","setTimeout","Bl","indexOf","max","min","Zp","Qp","Jp","Er","Hl","t_","mouseenter","mouseleave","e_","Fl","Set","Vl","uidEvent","Wl","zl","originalHandler","delegationSelector","jl","Kl","has","Yl","f","p","_","relatedTarget","delegateTarget","l","c","h","oneOff","d","replace","u","querySelectorAll","b","off","type","apply","Cr","on","one","n_","slice","trigger","isPropagationStopped","isImmediatePropagationStopped","isDefaultPrevented","createEvent","initEvent","CustomEvent","bubbles","cancelable","preventDefault","defaultPrevented","si","Xt","constructor","_element","DATA_KEY","dispose","EVENT_KEY","getOwnPropertyNames","_queueCallback","getInstance","getOrCreateInstance","VERSION","NAME","On","toggle","setAttribute","jQueryInterface","each","Ot","Dt","mt","bs","Li","ni","Ul","Tr","Ri","Xl","Ar","reduce","concat","wr","Gl","ql","Zl","Ql","Jl","tc","ec","ic","sc","Dn","oe","nodeName","Mt","ownerDocument","defaultView","oi","Element","It","HTMLElement","kr","Sr","name","enabled","phase","fn","state","elements","styles","attributes","assign","removeAttribute","effect","popper","position","options","strategy","left","top","margin","arrow","reference","hasOwnProperty","requires","Gt","ri","Mn","Ni","round","Or","navigator","userAgentData","brands","isArray","map","brand","version","join","userAgent","nc","$i","getBoundingClientRect","offsetWidth","width","height","visualViewport","offsetLeft","offsetTop","right","bottom","x","y","Dr","abs","oc","isSameNode","host","qt","Pe","In","assignedSlot","rc","offsetParent","vs","d_","transform","perspective","contain","willChange","filter","Mr","ys","ac","lc","cc","hc","modifiersData","popperOffsets","placement","padding","rects","m","clientHeight","clientWidth","C","T","A","w","centerOffset","element","NODE_ENV","console","error","requiresIfExists","Bi","g_","dc","L","popperRect","variation","offsets","gpuAcceleration","adaptive","roundOffsets","isFixed","E","S","k","D","O","M","devicePixelRatio","Ir","transitionProperty","some","warn","data","Ln","passive","Lr","instance","scroll","resize","scrollParents","update","y_","Pn","x_","start","end","uc","Pr","scrollLeft","pageXOffset","scrollTop","pageYOffset","Rr","Nr","overflow","overflowX","overflowY","xs","fc","$r","pc","E_","clientTop","clientLeft","scrollWidth","scrollHeight","direction","_c","Hi","boundary","rootBoundary","elementContext","altBoundary","contextElement","offset","X","I","gc","_skip","mainAxis","altAxis","fallbackPlacements","flipVariations","allowedAutoPlacements","S_","xe","Ut","sort","Map","F","Y","Yt","ee","every","ie","ti","Me","find","mr","Oi","Ol","Kt","ye","reset","mc","bc","vc","preventOverflow","referenceClippingOffsets","popperEscapeOffsets","isReferenceHidden","hasPopperEscaped","yc","Br","xc","tether","tetherOffset","Tk","Dl","Ak","Rp","wk","kk","Np","$p","Sk","Ok","Di","br","Bp","Hp","Ml","Fp","Vp","Wp","zp","Re","arguments","ai","Ec","Cc","Tc","modifiers","Ac","Rn","defaultModifiers","defaultOptions","orderedModifiers","setOptions","add","j_","String","marginTop","marginRight","marginBottom","marginLeft","forceUpdate","Promise","resolve","then","destroy","onFirstUpdate","X_","q_","Fi","wc","freeze","__proto__","afterMain","afterRead","afterWrite","applyStyles","auto","basePlacements","beforeMain","beforeRead","beforeWrite","clippingParents","computeStyles","createPopper","createPopperBase","createPopperLite","detectOverflow","eventListeners","flip","hide","main","modifierPhases","placements","popperGenerator","read","variationPlacements","viewport","write","Symbol","toStringTag","Hr","Fr","v","setDataAttribute","removeDataAttribute","getDataAttributes","dataset","charAt","getDataClassAttributes","getDataAttribute","toggleClass","Vr","remove","addClass","addStyle","removeClass","hasClass","g","closest","matches","prototype","findOne","children","parents","prev","previousElementSibling","next","nextElementSibling","focusableChildren","Wr","li","zr","Nn","kc","jr","$n","tg","eg","ig","sg","ng","og","Oc","rg","Ne","Bn","Yr","fg","pg","_g","gg","mg","bg","vg","opacity","yg","Hn","duration","iterations","easing","fill","xg","popperConfig","autoClose","dropdownAnimation","Eg","$t","_popper","_config","_getConfig","_menu","_getMenuElement","_inNavbar","_detectNavbar","_fadeOutAnimate","matchMedia","_animationCanPlay","_didInit","_init","Default","DefaultType","_isShown","show","getParentFromElement","_createPopper","focus","animate","_completeHide","dataApiKeydownHandler","clearMenus","playState","TypeError","_getPopperConfig","_getPlacement","teDropdownPosition","_getOffset","parseInt","_selectMenuItem","button","composedPath","tagName","clickEvent","stopPropagation","Kr","Dc","Fn","Mc","parent","Cg","Tg","Ag","wg","kg","Ur","Ic","Vn","Vi","Lc","Pc","Ig","visible","hidden","baseTransition","collapsing","collapsingHorizontal","Lg","re","_isTransitioning","_classes","_getClasses","_triggerArray","_selector","_initializeChildren","_addAriaAndCollapsedClass","_getDimension","Rc","Nc","Es","getWidth","innerWidth","_disableOverFlow","_setElementAttributes","_saveInitialAttribute","_applyManipulationCallback","_resetElementAttributes","removeProperty","isOverflowing","Pg","isVisible","isAnimated","rootElement","clickCallback","backdropClasses","Rg","$c","Bc","Xr","_isAppended","_append","_getElement","_emulateAnimation","className","append","Cs","_toggler","_event","event","_condition","condition","selector","_onlyVisible","onlyVisible","_focusableElements","_firstElement","_lastElement","handler","shiftKey","trap","_setElements","_setFocusTrap","disable","_filterVisible","Wn","Hc","Wi","Ng","Fc","backdrop","keyboard","Bg","Vc","Fg","Vg","Wg","zg","jg","zi","_backdrop","_initializeBackDrop","_focustrap","_initializeFocusTrap","_addEventListeners","blur","Gr","Wc","Yg","Kg","Ts","Ug","animation","autohide","delay","zc","Xg","fadeIn","fadeOut","Gg","As","close","_destroyElement","_setupAutohide","_timeout","clearTimeout","qr","Lt","jc","Yc","interval","slide","pause","wrap","touch","tm","em","pointer","block","invisible","slideRight","slideLeft","im","ci","hi","di","ws","sm","nm","Kc","om","rm","am","lm","cm","hm","dm","um","fm","pm","_m","ui","Zr","Uc","Qr","ji","Cm","ae","_items","_interval","_activeElement","_isPaused","_isSliding","touchTimeout","touchStartX","touchDeltaX","_indicatorsElement","_touchSupported","maxTouchPoints","_pointerEvent","PointerEvent","_setActiveElementClass","_slide","nextWhenVisible","cycle","clearInterval","_updateInterval","setInterval","visibilityState","bind","to","_getItemIndex","dataApiClickHandler","carouselInterface","_applyInitialClasses","_setActiveIndicatorElement","_handleSwipe","_keydown","_addTouchEventListeners","pointerType","clientX","touches","Qg","_getItemByOrder","_triggerSlideEvent","defaultInterval","_directionToOrder","_orderToDirection","carouselInit","Jr","Zt","Xc","Gc","Dm","Mm","static","staticProperties","Im","Lm","Pm","Rm","Nm","$m","qc","Zc","Qc","Bm","Jc","th","eh","ks","Ss","_dialog","_ignoreBackdropClick","_scrollBar","_isAnimated","_adjustDialog","_setEscapeEvent","_setResizeEvent","_showElement","_showBackdrop","_hideModal","handleUpdate","_triggerBackdropTransition","_resetAdjustments","currentTarget","paddingLeft","paddingRight","Fm","Wm","zm","jm","nodeValue","ih","DOMParser","parseFromString","innerHTML","sh","le","Um","Xm","template","title","html","container","customClass","sanitize","sanitizeFn","allowList","Gm","AUTO","TOP","RIGHT","BOTTOM","LEFT","qm","area","col","code","div","hr","h1","h2","h3","h4","h5","h6","img","ol","pre","small","span","sub","sup","strong","ul","Zm","HIDE","HIDDEN","SHOW","SHOWN","INSERTED","CLICK","FOCUSIN","FOCUSOUT","MOUSEENTER","MOUSELEAVE","ta","Os","nh","oh","rh","Ds","ia","Ms","jp","_isEnabled","_hoverState","_activeTrigger","tip","_setListeners","enable","toggleEnabled","_initializeOnDelegatedTarget","click","_isWithActiveTrigger","_enter","_leave","getTipElement","_hideModalHandler","_disposePopper","isWithContent","getTitle","_getAttachment","_addAttachmentClass","_resolvePossibleFunction","_cleanTipClass","setContent","_sanitizeAndSetContent","setElementContent","textContent","updateAttachment","_getDelegateConfig","_handlePopperPlacementChange","_getBasicClassPrefix","_fixTitle","content","ce","nb","ob","rb","zn","_getContent","sa","jn","ah","method","hb","db","active","ub","fb","pb","_b","na","lh","oa","ch","ra","hh","Is","_scrollElement","_offsets","_targets","_activeTarget","_scrollHeight","_process","refresh","_getScrollTop","_getScrollHeight","_getOffsetHeight","innerHeight","_activate","_clear","Yn","Eb","Cb","Tb","Ab","Yi","Kn","uh","Ob","fh","Ib","Lb","Un","_transitionComplete","aa","$e","Pb","Rb","Nb","$b","Bb","Hb","Fb","Vb","ph","la","Xn","Wb","_h","zb","jb","Ls","_hasMouseInteraction","_hasKeyboardInteraction","_clearTimeout","_maybeScheduleHide","teToastShow","_onInteraction","Z","initCustomEvent","detail","HTMLIFrameElement","contentDocument","head","identifier","base","css","media","sourceMap","references","updater","singleton","removeChild","nonce","insert","appendChild","Boolean","styleSheet","cssText","createTextNode","childNodes","insertBefore","btoa","unescape","encodeURIComponent","JSON","stringify","firstChild","all","atob","splice","__esModule","default","locals","animationName","inputType","ca","Gn","gh","mh","bh","vh","Be","yh","xh","fi","pi","Ki","Eh","Ch","Gb","inputFormWhite","qb","Zb","notch","notchLeading","notchLeadingNormal","notchLeadingWhite","notchMiddle","notchMiddleNormal","notchMiddleWhite","notchTrailing","notchTrailingNormal","notchTrailingWhite","counter","Qb","_label","_labelWidth","_labelMarginLeft","_notchLeading","_notchMiddle","_notchTrailing","_initiated","_helper","_counter","_counterElement","_maxLength","_leadingIcon","init","input","_getLabelData","_applyDivs","_applyNotch","_getHelper","_getCounter","_getEvents","_getNotchData","forceActive","forceInactive","_removeBorder","_showPlaceholder","_getLabelWidth","_getLabelPositionInInputGroup","_toggleDefaultDatePlaceholder","maxLength","_showCounter","activate","deactivate","href","_bindCounter","activeElement","_getElements","_deactivate","Th","ha","Jb","animationStart","animationShowOnLoad","onStart","onEnd","onHide","onShow","animationOnScroll","animationWindowHeight","animationOffset","animationDelay","animationReverse","animationInterval","animationRepeat","animationReset","tv","qn","_animateElement","_getAnimateElement","_isFirstScroll","_repeatAnimateOnScroll","_options","startAnimation","_startAnimation","stopAnimation","_clearAnimationClass","changeAnimationType","_bindHoverEvents","_bindScrollEvents","_bindClickEvents","_bindTriggerOnEndCallback","_bindResetAnimationAfterFinish","_animateOnScroll","_hideAnimateElement","_callback","_showAnimateElement","_addAnimatedClass","_setAnimationRepeat","_setAnimationReverse","_setAnimationDelay","animationDuration","_setAnimationDuration","_setAnimationInterval","animationIterationCount","animationDirection","Function","autoInit","da","Zn","iv","Qn","sv","gradientColor","nv","rippleCentered","rippleColor","rippleColorDark","rippleDuration","rippleRadius","rippleUnbound","ov","rv","ripple","rippleWave","unbound","av","Ui","_clickHandler","_createRipple","_rippleTimer","_isMinWidthSet","_initialClasses","_addClickEvent","_autoInit","minWidth","layerX","layerY","_durationToMsNumber","offsetX","offsetY","_getDiameter","_createHTMLRipple","wrapper","_removeHTMLRipple","_addColor","_toggleUnbound","_appendRipple","_addedNewRippleClasses","findIndex","sqrt","first","second","third","fourth","topLeft","topRight","bottomLeft","bottomRight","localStorage","theme","_colorToRGB","ev","backgroundImage","substr","color","autoInitial","bt","getDate","Jn","getDay","ot","getMonth","K","getFullYear","ua","cv","he","Xi","Date","Et","Ct","setDate","Gi","setFullYear","wh","qi","_i","setHours","getTime","eo","kh","fa","Ps","Sh","Oh","inline","datepickerMain","Mh","datepickerView","Dh","Sv","datepickerFooterBtn","okBtnLabel","okBtnText","cancelBtnLabel","cancelBtnText","datepickerClearBtn","clearBtnLabel","clearBtnText","datepickerFooter","removeClearBtn","removeCancelBtn","removeOkBtn","view","io","so","no","datepickerDateControls","datepickerViewChangeButton","switchToMultiYearViewLabel","monthsFull","de","datepickerArrowControls","datepickerPreviousButton","prevMonthLabel","changeMonthIconTemplate","datepickerNextButton","nextMonthLabel","datepickerViewChangeIcon","viewChangeIconTemplate","Ov","lv","startDay","date","currentMonth","isSelected","isToday","dayNumber","disablePast","disableFuture","weekdaysNarrow","datepickerDayHeading","weekdaysFull","datepickerCell","datepickerCellSmall","datepickerCellContent","datepickerCellContentSmall","datepickerTable","Dv","monthsShort","datepickerCellLarge","datepickerCellContentLarge","Mv","ga","co","ho","Nv","$v","Bv","uo","Ih","Lh","fo","Hv","Fv","O0","weekdaysShort","nextYearLabel","prevYearLabel","nextMultiYearLabel","prevMultiYearLabel","switchToMonthViewLabel","switchToDayViewLabel","startDate","format","toggleButton","disableToggleButton","disableInput","animations","confirmDateOnSelect","D0","M0","fadeInShort","fadeOutShort","modalContainer","datepickerBackdrop","datepickerHeader","datepickerTitle","datepickerTitleText","datepickerDate","datepickerDateText","datepickerToggleButton","datepickerDropdownContainer","I0","Ph","_input","_activeDate","_selectedDate","_selectedYear","_selectedMonth","_headerDate","_headerYear","_headerMonth","_view","_focusTrap","_isOpen","_toggleButtonId","_animations","disableToggle","activeCell","_getActiveDayCell","_getActiveMonthCell","_getActiveYearCell","activeDay","activeMonth","activeYear","firstYearInView","lastYearInView","viewChangeButton","previousButton","nextButton","okButton","cancelButton","clearButton","datesContainer","_getNewDaysOrderArray","_getContainer","_appendToggleButton","readOnly","pointerEvents","_listenToUserInput","_listenToToggleClick","_listenToToggleKeydown","insertAdjacentHTML","open","_setInitialDate","wv","Av","_openDropdown","_openModal","_listenToDateSelection","_addControlsListeners","_updateControlsDisabledState","_listenToEscapeClick","_listenToKeyboardNavigation","_listenToDatesContainerFocus","_listenToDatesContainerBlur","_asyncFocusDatesContainer","_updateViewControlsAndAttributes","_listenToOutsideClick","_handleUserInput","keyCode","_handleDateSelection","teDate","_pickDay","teMonth","teYear","_pickMonth","_pickYear","_updateHeaderDate","nextMonth","nextYears","nextYear","previousMonth","previousYears","previousYear","_changeView","_listenToFooterButtonsClick","handleOk","handleCancel","handleClear","_handleKeydown","_focusActiveCell","_removeCurrentFocusStyles","_handleDaysViewKeydown","_handleMonthsViewKeydown","_handleYearsViewKeydown","_selectDate","_removeHighlightFromCell","_selectMonth","_selectYear","_removeDatepickerListeners","_closeDropdown","_closeModal","_removeFocusTrap","_removePicker","_removeInputAndToggleListeners","_confirmSelection","_removeCurrentSelectionStyles","_addSelectedStyles","_asyncChangeView","_removeSelectedStyles","formatDate","_addLeadingZero","fv","pv","_getDelimeters","_parseDate","hv","isNaN","getMonthNumberByMonthName","L0","format24","okLabel","cancelLabel","headID","footerID","bodyID","pickerID","clearLabel","showClearBtn","amLabel","pmLabel","timepickerWrapper","timepickerContainer","timepickerElements","timepickerHead","timepickerHeadContent","timepickerCurrentWrapper","timepickerCurrentButtonWrapper","timepickerCurrentButton","timepickerDot","timepickerModeWrapper","timepickerModeAm","timepickerModePm","timepickerClockWrapper","timepickerClock","timepickerMiddleDot","timepickerHandPointer","timepickerPointerCircle","timepickerClockInner","timepickerFooterWrapper","timepickerFooter","timepickerFooterButton","timepickerInlineWrapper","timepickerInlineContainer","timepickerInlineElements","timepickerInlineHead","timepickerInlineHeadContent","timepickerInlineHourWrapper","timepickerInlineIconUp","timepickerInlineIconSvg","timepickerInlineCurrentButton","timepickerInlineIconDown","timepickerInlineDot","timepickerCurrentMinuteWrapper","timepickerInlineModeWrapper","timepickerInlineModeAm","timepickerInlineModePm","timepickerInlineSubmitButton","P0","iconSVG","timepickerToggleButton","po","_o","gi","Rh","getHours","getMinutes","j","hours","minutes","amOrPm","Nh","R0","$h","clientY","go","platform","Bh","Hh","He","Fe","N0","format12","maxTime","minTime","Fh","tipsDisabled","Vh","Wh","$0","B0","H0","Ns","H","zh","mo","ue","fe","jh","bo","Yh","Kh","Uh","Xh","Gh","qh","Zh","Qh","F0","V0","W0","vo","yo","z0","ma","Jh","ba","j0","va","ya","Y0","K0","td","U0","ed","xa","Ve","J","G0","mi","$s","Ea","xo","Ca","Eo","ft","vt","Rt","Co","sd","Ta","Aa","nd","q0","appendValidationInfo","closeModalOnBackdropClick","closeModalOnMinutesClick","defaultTime","enableValidation","focusInputAfterApprove","increment","invalidLabel","modalID","overflowHidden","switchHoursToMinutesOnClick","withIcon","Z0","Q0","tips","tipsActive","modal","clockAnimation","J0","od","_isPmEnabled","_isAmEnabled","_modal","_circle","backgroundColor","degrees","minute","addDegrees","_hasTargetInnerClass","hour","_isInvalidTimeFormat","_AM","_PM","_handleDisablingTipsMinTime","_handleDisablingTipsMaxTime","PI","sin","cos","_document","_currentTime","hoursArray","innerHours","minutesArray","dataWithIcon","dataToggle","customIcon","_checkToggleButton","inputFormatShow","inputFormat","values","elementToggle","toggleElement","_hour","_minutes","_wrapper","_hand","_inputValue","_isHours","_isMinutes","_isMouseMove","_isInner","_objWithDataOnChange","_getValidate","_handleOpen","_removeModal","_getDomElements","_clock","_clockInner","_handlerMaxMinHoursOptions","innerText","parentElement","_handleKeyboard","_makeHourDegrees","_makeMinutesDegrees","_makeInnerHoursDegrees","_setHourOrMinute","_toggleClassActive","_toggleBackgroundColorCircle","_setActiveClassToTipsOnOpen","_addActiveClassToTip","_setTipsAndTimesDependOnInputValue","_toggleBackdropAnimation","_appendTimes","_handleSwitchTimeMode","_handleOkButton","_handleClose","_handleHoverInlineBtn","_handleDocumentClickInline","_handleInlineClicks","_handleSwitchHourMinute","_handleClockClick","_toggleAmPm","showValueInput","_getAppendClock","atan2","elementFromPoint","trunc","_handlerMaxMinMinutesOptions","degreesMinutes","degreesHours","_handleMoveHand","_removeModalElements","nextSibling","pe","At","To","rd","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","We","es","ad","at","rtl","thumb","rail","consuming","clicking","scrolling","ld","cd","hd","isAlive","settings","scrollingThreshold","Bs","handlers","dd","isEmpty","unbind","unbindAll","defineProperties","is","eventElements","Ao","wo","reach","it","eventElement","once","ss","isWebKit","supportsTouch","DocumentTouch","supportsIePointer","msMaxTouchPoints","isChrome","Ce","containerWidth","containerHeight","contentWidth","contentHeight","scrollbarXRail","scrollbarYRail","suppressScrollX","scrollXMarginOffset","scrollbarXActive","railXWidth","railXMarginWidth","railXRatio","scrollbarXWidth","ud","scrollbarXLeft","negativeScrollAdjustment","suppressScrollY","scrollYMarginOffset","scrollbarYActive","railYHeight","railYMarginHeight","railYRatio","scrollbarYHeight","scrollbarYTop","isRtl","isScrollbarXUsingBottom","scrollbarXBottom","scrollbarXTop","isScrollbarYUsingRight","scrollbarYRight","scrollbarYOuterWidth","scrollbarYLeft","scrollbarX","railBorderXWidth","scrollbarY","railBorderYWidth","minScrollbarLength","maxScrollbarLength","fd","pageY","changedTouches","dy","pageX","shadowRoot","which","metaKey","altKey","wheelPropagation","wheel","deltaX","deltaY","wheelDeltaX","wheelDeltaY","deltaMode","wheelDelta","useBothWheelAxes","wheelSpeed","ctrlKey","onwheel","onmousewheel","MSPointerEvent","targetTouches","buttons","MSPOINTER_TYPE_MOUSE","scrollY","swipeEasing","isInitialized","Hs","isNegativeScroll","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","lastScrollTop","lastScrollLeft","onScroll","removePsClasses","uy","threshold","fy","_startPosition","handleTouchStart","_getCoordinates","handleTouchMove","_getDirection","handleTouchEnd","py","swipe","_touchStartHandler","_handleTouchStart","_touchMoveHandler","_handleTouchMove","_touchEndHandler","_handleTouchEnd","yy","ps","pd","ko","wa","ns","Fs","wy","ky","Sy","sidenavAccordion","sidenavBackdrop","sidenavBackdropClass","sidenavCloseOnEsc","sidenavColor","sidenavContent","sidenavExpandable","sidenavExpandOnHover","sidenavFocusTrap","sidenavHidden","sidenavMode","sidenavModeBreakpointOver","sidenavModeBreakpointSide","sidenavModeBreakpointPush","sidenavBreakpointSm","sidenavBreakpointMd","sidenavBreakpointLg","sidenavBreakpointXl","sidenavBreakpoint2xl","sidenavScrollContainer","sidenavSlim","sidenavSlimCollapsed","sidenavSlimWidth","sidenavPosition","sidenavRight","sidenavTransitionDuration","sidenavWidth","Oy","bi","_addBackdropOnInit","_ID","_content","_initialContentStyle","_slimCollapsed","_activeNode","_tempSlim","_perfectScrollbar","_touch","_setModeFromBreakpoints","escHandler","toggler","_update","hashHandler","_setActiveElements","_setup","links","navigation","sidenavStyle","transition","translation","isBackdropVisible","changeMode","_setMode","_emitEvents","toggleSlim","_setSlim","getBreakpoint","_transformBreakpointValuesToObject","toggleSidenav","md","lg","xl","_collapseItems","_getOffsetValue","index","property","_getPxValue","_getProperty","_isActive","URL","location","_isAllToBeCollapsed","_isAllCollapsed","_updateBackdrop","_setupTouch","_setupFocusTrap","_setupCollapse","_setupSlim","_setupInitialStyling","_setupScrolling","_setupContent","_setupActiveState","_setupRippleEffect","_updateOffsets","_setTabindex","_setupCollapseList","list","menu","menuIndex","_generateCollpaseID","teSidenavStateShow","teCollapseShow","_rotateArrow","_toggleCategory","_setColor","maxHeight","_toggleSlimDisplay","_setActive","_setActiveCategory","_updateFocus","_setContentOffsets","_triggerEvents","tabIndex","_updateTogglerAria","_updateDisplay","ka","So","Oo","Vs","Ws","_e","Dy","stepperType","stepperLinear","stepperNoEditable","stepperActive","stepperCompleted","stepperInvalid","stepperDisabled","stepperVerticalBreakpoint","stepperMobileBreakpoint","stepperMobileBarBreakpoint","My","_d","gd","Iy","ze","yt","bd","Do","wt","vd","_elementHeight","_steps","_currentView","_activeStepIndex","_verticalStepperStyles","activeStep","activeStepIndex","changeStep","_toggleStep","nextStep","previousStep","_toggleStepClass","_bindMouseDown","_bindKeysNavigation","_toggleVertical","_toggleHorizontal","_toggleStepperView","_bindResize","_setSingleStepHeight","_setHeight","_resetStepperHeight","_toggleDisabled","_toggleActive","_toggleCompleted","_animateHorizontalStep","_animateVerticalStep","_toggleStepTabIndex","_setStepsHeight","paddingTop","paddingBottom","_hideInactiveSteps","_toggleStepperClass","_toggleOutlineStyles","outline","_hideElement","yd","Mo","xd","Ed","Cd","nativeOption","multiple","label","selected","secondaryText","groupId","icon","node","select","_selectMultiple","_selectSingle","checked","deselect","_deselectMultiple","_deselectSingle","setNode","setActiveStyles","removeActiveStyles","Ly","_multiple","_selections","clear","selection","selections","labels","Sa","Td","Ad","Xy","Gy","Io","selectSize","wd","selectDropdownContainer","dropdown","optionsWrapper","optionsWrapperScrollbar","kd","selectFilter","Zy","inputGroup","selectFilterInput","placeholder","selectSearchPlaceholder","optionsList","Jy","selectAll","tx","selectOption","selectOptionHeight","Dd","Sd","nx","selectOptionGroup","selectOptionGroupLabel","Od","sx","selectOptionIcon","src","selectOptionText","ix","formCheckInput","ex","selectOptionSecondaryText","Oa","zs","js","rx","ax","Md","Id","lx","Ld","Pd","Rd","xt","je","Da","Ys","Nd","$d","vx","Bd","Ma","Ex","selectAutoSelect","selectContainer","selectClearButton","selectDisplayedLabels","selectFormWhite","selectOptionsSelectedLabel","selectAllLabel","selectVisibleOptions","selectFilterDebounce","selectNoResultText","selectValidation","selectValidFeedback","selectInvalidFeedback","selectPlaceholder","Cx","Tx","formOutline","initialized","noResult","selectArrow","selectArrowWhite","selectArrowDefault","selectArrowLg","selectArrowSm","selectClearBtn","selectClearBtnWhite","selectClearBtnDefault","selectClearBtnLg","selectClearBtnSm","selectFakeValue","selectInput","selectInputWhite","selectInputSizeDefault","selectInputSizeLg","selectInputSizeSm","selectLabel","selectLabelWhite","selectLabelSizeDefault","selectLabelSizeLg","selectLabelSizeSm","selectValidationValid","selectValidationInvalid","Ax","Lo","_optionsToRender","_getOptionsToRender","_plainOptions","_getPlainOptions","_filteredOptionsList","_selectionModel","_activeOptionIndex","_activeOption","_wrapperId","_dropdownContainerId","_selectAllId","_debounceTimeoutId","_dropdownHeight","_notch","_fakeValue","_isFakeValueActive","_customContent","_toggleButton","_elementToggle","_inputEl","_dropdownContainer","_container","_selectAllOption","_mutationObserver","_addMutationObserver","filterInput","hasSelectAll","hasSelection","_createOptionObject","_getNavigationOptions","_renderMaterialWrapper","_initOutlineInput","_setDefaultSelections","_updateInputValue","_appendFakeValue","_updateFakeLabelPosition","_updateLabelPosition","_updateClearButtonVisibility","_bindComponentEvents","_createSelectAllOption","_setFirstActiveOption","_listenToFocusChange","qy","cursor","_listenToComponentKeydown","_listenToWrapperClick","_listenToClearBtnClick","_listenToClearBtnKeydown","_handleOpenKeydown","_handleClosedKeydown","_handleAutoSelection","_setNextOptionActive","_scrollToOption","_setPreviousOptionActive","_setFirstOptionActive","_setLastOptionActive","_handleSelectAll","_handleSelection","_getNumberOfGroupsBeforeOption","_updateActiveOption","_handleClear","_deselectAllOptions","_updateSelectAllState","_emitValueChangeEvent","_emitNativeChangeEvent","_listenToOptionsClick","teId","_selectAllOptions","_handleMultiSelection","_handleSingleSelection","_singleOptionSelect","_isSelectionValid","_isLabelEmpty","ox","_updateLabelPositionWhileClosing","_updateDropdownWidth","_listenToSelectSearch","_listenToDropdownKeydown","_listenToWindowResize","_setInputActiveStyles","_handleWindowResize","_debounceFilter","_filterOptions","_filter","_updateOptionsListTemplate","_getNoResultTemplate","_outsideClick","_handleOutSideClick","_resetFilterState","_removeDropdownEvents","MutationObserver","_updateSelections","_updateDisabledState","_observeMutationObserver","observe","childList","characterData","subtree","_disconnectMutationObserver","mutationObserver","disconnect","_removeComponentEvents","_destroyMaterialSelect","_destroyMaterialTemplate","setValue","_selectByValue","wx","Constructor","noConflict","Ye","plugins","legend","Po","line","borderColor","borderWidth","tension","point","responsive","tooltips","intersect","mode","datasets","scales","stacked","grid","ticks","fontColor","borderDash","drawBorder","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","bar","pie","arc","doughnut","polarArea","radar","scatter","bubble","Ks","alert","isToggler","carousel","chips","chip","datepicker","scrollspy","sidenav","stepper","timepicker","toast","chart","advanced","parse","callback","collapse","EVENT_SHOW","EVENT_HIDDEN","OPEN_SELECTOR","offcanvas","tab","Px","Rx","Nx","Ia","$x","inputID","labelText","Input","chipsInputWrapper","chipsInput","chipsLabel","chipsNotchesWrapper","chipsNotchesLeading","chipsNotchesMiddle","chipsNotchesTrailing","Bx","text","chipElement","chipCloseIcon","Ro","Hx","Hd","La","zx","closeIcon","jx","path","alt","Yx","Kx","vi","_appendCloseIcon","_handleDelete","_handleTextChip","_handleClickOnChip","appendChip","insertAdjacentElement","tag","obj","Us","Xs","Fd","Ux","Bt","Vd","Wd","Xx","Pa","zd","jd","Gx","Ra","qx","Na","Zx","Qx","Jx","os","$a","Yd","Kd","cE","parentSelector","initialValues","editable","hE","dE","inputWrapperPadding","contentEditable","uE","Ud","_handleCreateChip","allChips","numberClicks","activeChip","_setChipsClass","_appendInputToElement","_handleInitialValue","_handleInputText","_handleChipsOnSelect","_handleEditable","_handleChipsFocus","_handleClicksOnChips","_handleDeleteEvents","_handleEvents","_handleActiveChipAfterRemove","_handleUpEvents","_handleRightKeyboardArrow","_handleDownEvents","_handleLeftKeyboardArrow","_keyboardEvents","_handleAddActiveClass","_handleRemoveActiveClass","_handleAddActiveClassWithKebyboard","_handleTextContent","arrOfObjects","activeObj","_handleKeysInputToElement","_handleBlurInput","fE","pE","$$typeof","mE","gE","for","Gs","clone","isMergeableObject","rs","yE","Xd","getOwnPropertySymbols","propertyIsEnumerable","Gd","arrayMerge","cloneUnlessOtherwiseSpecified","CE","xE","customMerge","Ba","qd","No","Zd","kE","darkTicksColor","darkLabelColor","darkGridLinesColor","darkmodeOff","darkBgColor","SE","Qd","Yp","_waitForCharts","_getChartjs","Chart","ArcElement","LineElement","BarElement","PointElement","BarController","BubbleController","DoughnutController","LineController","PieController","PolarAreaController","RadarController","ScatterController","CategoryScale","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","Decimation","Filler","Legend","Title","Tooltip","SubTitle","tk","register","_getChartDataLabels","ChartDataLabels","Ck","_Chartjs","_ChartDataLabels","_data","_type","_canvas","_chart","_darkOptions","_getDarkConfig","_darkModeClassContainer","_prevConfig","_observer","_chartConstructor","_handleMode","systemColorMode","_observerCallback","backdropColor","pointLabels","_createCanvas","dataLabelsPlugin","_changeDatasetBorderColor","Te","Animate","Alert","Button","ChipsInput","Chip","Dropdown","Carousel","Collapse","Offcanvas","Modal","Popover","ScrollSpy","Select","Tab","Toast","Ripple","Datepicker","Timepicker","Sidenav","Stepper","OE","N","Q","$","rt","isFinite","Ht","R","DE","endsWith","Jd","G","U","$o","datasetIndex","Bo","create","tu","ME","ge","merger","qs","IE","eu","Ke","LE","PE","Ha","Ft","Ue","iu","size","et","q","NE","Ho","POSITIVE_INFINITY","$E","nt","Zs","su","Vt","log10","me","sign","nu","Qs","pow","as","ou","Jt","ru","au","angle","distance","Va","FE","Nt","Js","ct","Ae","Wa","lo","we","WE","lu","cu","_chartjs","listeners","hu","du","requestAnimationFrame","uu","za","pt","KE","fu","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","count","pu","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","Fo","_u","gu","tn","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","en","Xe","sn","Ge","ke","mu","Wt","B","ja","UE","XE","Vo","GE","ZE","JE","bu","tC","eC","Ya","Ka","vu","yu","xu","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","hC","Xa","ls","zo","Eu","Cu","jo","qE","cC","lC","transparent","dC","exec","oC","_rgb","_valid","valid","rgb","rgbString","hexString","hslString","aC","mix","interpolate","fC","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","rC","Au","wu","Ga","Tu","yi","qa","nn","Za","getDevicePixelRatio","events","font","family","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","scale","showLine","drawActiveElementsOnTop","describe","override","route","_scriptable","_indexable","_fallback","Yo","measureText","xi","currentDevicePixelRatio","ku","getContext","save","resetTransform","clearRect","restore","Qa","Su","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","closePath","moveTo","lineTo","SQRT1_2","rect","stroke","Ko","clip","Uo","bC","vC","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Ei","strokeWidth","strokeColor","string","fillStyle","textAlign","textBaseline","strokeStyle","lineWidth","strokeText","maxWidth","fillText","xC","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","rn","EC","CC","AC","Ja","Ou","Ci","ht","lt","TC","tt","cacheable","qe","tl","Pu","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","Mu","PC","kC","el","il","getOwnPropertyDescriptor","Reflect","getPrototypeOf","Ru","ownKeys","_storage","cs","_proxy","_context","_subProxy","_stack","_descriptors","Du","setContext","SC","isScriptable","OC","DC","isIndexable","allKeys","scriptable","indexable","_allKeys","MC","Lu","LC","IC","RC","Nu","_parsing","NC","EPSILON","hs","skip","$u","Xo","Bu","sl","Go","qo","jC","Ti","YC","Ai","canvas","boxSizing","box","KC","nl","Hu","ctx","setTransform","GC","Fu","wi","qC","ZC","Vu","an","QC","Intl","NumberFormat","ds","setWidth","xPlus","leftForLtr","Wu","getPropertyPriority","setProperty","prevTextDirection","zu","ju","between","compare","normalize","Yu","loop","Ku","eT","Uu","segments","points","Xu","oT","Gu","_datasetIndex","spanGaps","p0","p1","p0DataIndex","p1DataIndex","borderCapStyle","borderDashOffset","borderJoinStyle","be","_request","_charts","_running","_lastDate","_notify","initial","numSteps","currentStep","_refresh","now","running","items","_active","_total","tick","pop","draw","_getAnims","complete","progress","listen","_duration","stop","cancel","qu","lT","boolean","number","Zu","_fn","_easing","_start","_loop","_target","_prop","_from","_to","_promises","wait","res","rej","dT","colors","properties","numbers","_properties","configure","_animateOptions","fT","$shared","$animations","_createAnimations","uT","Qu","reverse","Ju","_getSortedDatasetMetas","tf","ef","stack","sf","getMatchingVisibleMetas","nf","_cachedMeta","_stacks","vScale","vT","_top","_bottom","rl","shift","ln","controller","al","of","ET","_stacked","zt","_ctx","_cachedDataOpts","getMeta","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","addElements","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","getDatasetMeta","_getOtherScale","_destroy","_dataCheck","gT","isExtensible","jE","datasetElementType","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","xAxisKey","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","NEGATIVE_INFINITY","bT","getAllParsedValues","getMaxOverflow","getLabelAndValue","getLabelForValue","_clip","pT","chartArea","getStyle","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","parsed","raw","_resolveElementOptions","dataElementType","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_insertElements","_removeElements","updateElements","_sync","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","rf","kT","_custom","barStart","barEnd","af","ll","lf","cf","defaults","cn","getBasePixel","isHorizontal","_getRuler","_calculateBarValuePixels","_calculateBarIndexPixels","horizontal","enableBorderRadius","center","DT","borderSkipped","IT","inflateAmount","ratio","_getStacks","grouped","_getStackCount","_getStackIndex","barThickness","TT","CT","_cache","$bar","_length","getPixelForTick","pixels","_startPixel","_endPixel","stackCount","categoryPercentage","barPercentage","minBarLength","getDataVisibility","getPixelForDecimal","getLineWidthForValue","skipNull","maxBarThickness","wT","chunk","AT","overrides","_index_","_value_","beginAtZero","hn","tooltip","callbacks","ki","innerRadius","outerRadius","_getRotation","_getCircumference","circumference","_getRotationExtents","isDatasetVisible","getMaxBorderWidth","getMaxOffset","spacing","cutout","_getRingWeight","ratioX","ratioY","LT","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","animateRotate","calculateCircumference","animateScale","startAngle","endAngle","locale","borderAlign","hoverBorderWidth","hoverOffset","descriptors","aspectRatio","generateLabels","toggleDataVisibility","formattedValue","dn","_dataset","_decimated","segment","animated","updateControlPoints","un","_updateRadius","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","circular","Zo","_fullLoop","getPointPositionForValue","jt","tooltipPosition","getProps","hasValue","defaultRoutes","hf","numeric","notation","minimumFractionDigits","maximumFractionDigits","logarithmic","pn","formatters","Qo","ceil","bounds","grace","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","align","crossAlign","showLabelBackdrop","backdropPadding","VT","df","uf","_n","ff","Ze","_margins","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_reversePixels","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","getPadding","getTicks","xLabels","yLabels","beforeLayout","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","wC","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","RT","maxTicksLimit","NT","_tickSize","BT","HT","$T","FT","BE","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","last","_calculatePadding","_handleMargins","isFullSize","fullSize","_computeLabelSizes","_resolveTickFontOptions","widths","heights","getValueForPixel","getDecimalForPixel","getBaseValue","_computeGridLineItems","tickBorderDash","tickBorderDashOffset","WT","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_computeLabelItems","_getXAxisLabelAlignment","_getYAxisLabelAlignment","textOffset","_computeLabelArea","drawBackground","fillRect","drawGrid","setLineDash","lineDashOffset","drawLabels","drawTitle","titleX","titleY","UT","_layers","getSortedVisibleDatasetMetas","_maxDigits","Jo","scope","isForType","isPrototypeOf","qT","XT","GT","unregister","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","_getRegistryForType","_exec","gn","pf","Si","cl","formats","diff","startOf","endOf","_f","_date","mn","QT","getRange","hl","isPointInArea","inRange","dl","eA","JT","getCenterPoint","gf","mf","evaluateInteractionItems","modes","nearest","bf","bn","pos","vf","vn","yf","xf","yn","lA","maxPadding","same","other","rA","outerWidth","outerHeight","tr","Ef","placed","stackWeight","autoPadding","dt","addBox","boxes","removeBox","layout","oA","iA","leftAndTop","rightAndBottom","vertical","availableWidth","availableHeight","vBoxMaxWidth","hBoxMaxHeight","nA","sA","aA","acquireContext","releaseContext","getMaximumSize","isAttached","updateConfig","Cf","er","cA","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","Tf","Af","uA","ir","pA","addedNodes","removedNodes","_A","xn","wf","kf","bA","ResizeObserver","contentRect","fl","vA","fA","native","dA","Sf","hA","$proxies","attach","detach","XC","UC","isConnected","Of","OffscreenCanvas","yA","notify","_createDescriptors","plugin","invalidate","_oldCache","_notifyStateChanges","xA","localIds","CA","TA","local","pluginScopeKeys","pl","_l","Df","SA","Mf","If","Lf","sr","En","DA","_scopeCache","_resolverCache","clearCache","additionalOptionScopes","_cachedScopes","chartOptionScopes","resolver","subPrefixes","Pf","IA","MA","PA","Rf","Nf","$f","onComplete","RA","onProgress","Bf","nr","Hf","gl","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","order","_resetElements","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","_getUniformDataChanges","NA","_idx","_updateDataset","meta","_drawDatasets","_drawDataset","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","updateHoverStyle","getActiveElements","setActiveElements","replay","inChartArea","_handleEvent","changed","_getActiveElements","Ff","instances","Vf","pixelMargin","us","ml","outerStart","outerEnd","innerStart","innerEnd","HA","borderRadius","registry","getChart","fs","fullCircles","FA","WA","lineJoin","VA","Wf","lineCap","zA","zf","ilen","YA","stepped","cubicInterpolationMode","move","KA","bl","qA","Path2D","Se","_path","_points","_segments","_pointsUpdated","WC","FC","BC","HC","$C","previous","capBezierPoints","VC","nT","iT","sT","pathSegment","GA","jf","hitRadius","inXRange","inYRange","hoverRadius","Yf","Je","vl","iw","yl","_s","inner","outer","tw","QA","JA","ew","Kf","Uf","Xf","Gf","algorithm","beforeElementsUpdate","ow","sw","samples","nw","El","qf","Zf","aw","Qf","Jf","Cl","bw","vw","pw","_w","unshift","gw","mw","Ew","xw","above","below","Cw","tp","ep","rw","Tw","ip","sp","afterDatasetsUpdate","cw","fw","$filler","lw","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","np","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Aw","op","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_computeTitleHeight","_fitRows","_fitCols","row","adjustHitBoxes","_draw","lineDash","SQRT2","textDirection","_getLegendItemAt","handleEvent","onLeave","rp","afterEvent","Tl","_padding","_drawArgs","ap","kw","titleBlock","or","WeakMap","lp","Cn","average","ve","Oe","cp","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","hp","yAlign","Ow","xAlign","Mw","Dw","caretSize","caretPadding","dp","cornerRadius","Iw","rr","fp","Al","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","beforeTitle","afterTitle","getBeforeBody","getBody","beforeLabel","afterLabel","getAfterBody","getFooter","beforeFooter","afterFooter","_createItems","Sw","itemSort","labelColor","labelPointStyle","labelTextColor","external","drawCaret","getCaretPosition","x3","y3","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","bodyColor","drawFooter","footerAlign","footerColor","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_positionChanged","_ignoreReplayEvents","positioners","pp","afterInit","afterDraw","_p","Rw","$w","Tn","_startValue","_valueRange","_addedLabels","Nw","lastIndexOf","gp","ar","_endValue","handleTickRangeOptions","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getTickLimit","stepSize","computeTickLimit","maxTicks","precision","step","maxDigits","includeBounds","Bw","HE","lr","mp","cr","_zero","Hw","wl","bp","vp","getPointPosition","gs","drawingArea","_pointLabels","_pointLabelItems","Vw","centerPointLabels","getPointLabelContext","mC","garbageCollect","Ww","setCenterPoint","zw","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","Uw","Xw","millisecond","common","steps","day","week","month","quarter","year","kt","qw","yp","_adapter","parser","isoWeekday","_parseOpts","xp","Ep","Cp","Jw","ms","_unit","_majorUnit","_normalized","time","adapters","displayFormats","normalized","unit","_getLabelBounds","getLabelTimestamps","_generate","zE","minUnit","_getLabelCapacity","Zw","Qw","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","dr","ur","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","Tp","Animation","Animations","BasePlatform","BasicPlatform","DatasetController","DomPlatform","Interaction","Scale","Ticks","_adapters","_detectPlatform","animator","layouts","registerables","Ap","screen","deviceXDPI","logicalXDPI","An","toTextLines","textSize","bound","arrayDiff","rasterize","kl","fr","pr","anchor","clamp","sk","x0","y0","ek","vy","_r","origin","fallback","De","Dp","_index","_model","_rects","_el","_modelize","ok","positioner","textShadowBlur","textShadowColor","formatter","frame","geometry","model","ak","dk","shadowBlur","shadowColor","hk","stroked","filled","uk","fk","wn","Mp","gr","Ip","_rotation","_rect","Lp","intersects","kn","prepare","$layout","_box","_hidable","_visible","_set","_k","pk","lookup","St","Pp","Sl","$groups","_key","_dirty","beforeInit","_actives","_listened","_datasets","_labels","afterDatasetUpdate","datalabels","afterDatasetsDraw","beforeEvent","yk","enter","leave","_hovered","initTE","mapData","storeData","keyProperties","Data","MAX_UID","MILLISECONDS_MULTIPLIER","TRANSITION_END","toType","getUID","prefix","getSelector","hrefAttr","getSelectorFromElement","getElementFromSelector","getTransitionDurationFromElement","floatTransitionDuration","floatTransitionDelay","triggerTransitionEnd","isElement","typeCheckConfig","componentName","configTypes","expectedTypes","valueType","elementStyle","parentNodeStyle","isDisabled","findShadowRoot","root","noop","reflow","getjQuery","DOMContentLoadedCallbacks","onDOMContentLoaded","isRTL","array","collection","execute","executeAfterTransition","transitionElement","waitForTransition","durationPadding","emulatedDuration","called","getNextActiveElement","shouldGetNext","isCycleAllowed","listLength","namespaceRegex","stripNameRegex","stripUidRegex","eventRegistry","customEvents","customEventsRegex","nativeEvents","getUidEvent","uid","getEvent","bootstrapHandler","EventHandler","bootstrapDelegationHandler","domElements","findHandler","uidEventList","len","normalizeParams","originalTypeEvent","delegationFn","delegation","typeEvent","getTypeEvent","addHandler","wrapFn","previousFn","removeHandler","removeNamespacedHandlers","namespace","storeElementEvent","handlerKey","inNamespace","isNamespace","elementEvent","keyHandlers","args","isNative","jQueryEvent","nativeDispatch","evt","EventHandlerMulti","eventsName","BaseComponent","propertyName","CLASS_NAME_ACTIVE","acc","getNodeName","getWindow","OwnElement","isHTMLElement","isShadowRoot","_ref","_ref2","initialStyles","styleProperties","attribute","applyStyles$1","getBasePlacement","getUAString","uaData","item","isLayoutViewport","includeScale","isFixedStrategy","clientRect","scaleX","scaleY","addVisualOffsets","getLayoutRect","child","rootNode","isTableElement","getDocumentElement","getParentNode","getTrueOffsetParent","getContainingBlock","isFirefox","isIE","elementCss","currentNode","getOffsetParent","getMainAxisFromPlacement","within","mathMax","mathMin","withinMaxClamp","getFreshSideObject","mergePaddingObject","paddingObject","expandToHashMap","hashMap","toPaddingObject","_state$modifiersData$","arrowElement","basePlacement","isVertical","arrowRect","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","axisProp","_options$element","arrow$1","getVariation","unsetSides","roundOffsetsByDPR","win","dpr","mapToStyles","_Object$assign2","_offsets$x","_offsets$y","_ref3","hasX","hasY","sideX","sideY","heightProp","widthProp","commonStyles","_ref4","_Object$assign","_ref5","_options$gpuAccelerat","_options$adaptive","_options$roundOffsets","computeStyles$1","_options$scroll","_options$resize","scrollParent","hash","getOppositePlacement","matched","getOppositeVariationPlacement","getWindowScroll","getWindowScrollBarX","getViewportRect","layoutViewport","getDocumentRect","_element$ownerDocumen","winScroll","isScrollParent","_getComputedStyle","getScrollParent","listScrollParents","isBody","updatedList","rectToClientRect","getInnerBoundingClientRect","getClientRectFromMixedType","clippingParent","getClippingParents","canEscapeClipping","clipperElement","getClippingRect","mainClippingParents","firstClippingParent","clippingRect","accRect","computeOffsets","commonX","commonY","_options$placement","_options$strategy","_options$boundary","_options$rootBoundary","_options$elementConte","_options$altBoundary","_options$padding","altContext","clippingClientRect","referenceClientRect","popperClientRect","elementClientRect","overflowOffsets","offsetData","multiply","computeAutoPlacement","_options$allowedAutoP","allPlacements","allowedPlacements","overflows","getExpandedFallbackPlacements","oppositePlacement","_options$mainAxis","checkMainAxis","_options$altAxis","checkAltAxis","specifiedFallbackPlacements","_options$flipVariatio","preferredPlacement","isBasePlacement","referenceRect","checksMap","makeFallbackChecks","firstFittingPlacement","_basePlacement","isStartVariation","mainVariationSide","altVariationSide","checks","check","numberOfChecks","fittingPlacement","_ret","flip$1","getSideOffsets","preventedOffsets","isAnySideFullyClipped","side","referenceOverflow","popperAltOverflow","hide$1","distanceAndSkiddingToXY","invertDistance","skidding","_options$offset","_data$state$placement","offset$1","popperOffsets$1","getAltAxis","_options$tether","_options$tetherOffset","tetherOffsetValue","normalizedTetherOffsetValue","offsetModifierState","_offsetModifierState$","mainSide","altSide","additive","minLen","maxLen","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","clientOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_offsetModifierState$2","_mainSide","_altSide","_offset","_len","_min","_max","isOriginSide","_offsetModifierValue","_tetherMin","_tetherMax","_preventedOffset","preventOverflow$1","getHTMLElementScroll","getNodeScroll","isElementScaled","getCompositeRect","elementOrVirtualElement","isOffsetParentAnElement","offsetParentIsScaled","visited","result","modifier","dep","depModifier","orderModifiers","debounce","pending","str","INVALID_MODIFIER_ERROR","MISSING_DEPENDENCY_ERROR","VALID_PROPERTIES","validateModifiers","requirement","mod","uniqueBy","arr","identifiers","mergeByName","merged","current","existing","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","areValidElements","generatorOptions","_generatorOptions","_generatorOptions$def","_generatorOptions$def2","effectCleanupFns","isDestroyed","setOptionsAction","cleanupModifierEffects","flipModifier","runModifierEffects","_state$elements","__debug_loops__","_state$orderedModifie","_state$orderedModifie2","_ref3$options","cleanupFn","noopFn","normalizeData","val","normalizeDataKey","chr","Manipulator","pureKey","classNameOrList","_classNameOrListToArray","NODE_TEXT","SelectorEngine","ancestor","focusables","DATA_API_KEY","ESCAPE_KEY","SPACE_KEY","TAB_KEY","ARROW_UP_KEY","ARROW_DOWN_KEY","RIGHT_MOUSE_BUTTON","REGEXP_KEYDOWN","EVENT_HIDE","EVENT_SHOWN","EVENT_CLICK_DATA_API","EVENT_KEYDOWN_DATA_API","EVENT_KEYUP_DATA_API","CLASS_NAME_SHOW","CLASS_NAME_DROPUP","CLASS_NAME_DROPEND","CLASS_NAME_DROPSTART","SELECTOR_NAVBAR","SELECTOR_DATA_TOGGLE","SELECTOR_MENU","SELECTOR_NAVBAR_NAV","SELECTOR_VISIBLE_ITEMS","PLACEMENT_TOP","PLACEMENT_TOPEND","PLACEMENT_BOTTOM","PLACEMENT_BOTTOMEND","PLACEMENT_RIGHT","PLACEMENT_LEFT","ANIMATION_FADE_IN","ANIMATION_FADE_OUT","ANIMATION_TIMING","isPrefersReducedMotionSet","elem","Popper","referenceElement","isDisplayStatic","Popper.createPopper","parentDropdown","isEnd","popperData","defaultBsPopperConfig","toggles","context","isMenuTarget","isActive","getToggleButton","ATTR_SHOW","ATTR_COLLAPSED","ATTR_COLLAPSING","ATTR_HORIZONTAL","ATTR_COLLAPSE_ITEM","ATTR_COLLAPSE_DEEPER_CHILDREN","WIDTH","HEIGHT","SELECTOR_DATA_ACTIVES","SELECTOR_DATA_COLLAPSE_INIT","DefaultClasses","DefaultClassesType","classes","toggleList","filterElement","foundElem","actives","activesData","tempActiveData","elemActive","dimension","CLASS_NAME_TRANSITION","scrollSize","triggerArrayLength","dataAttributes","triggerArray","isOpen","SELECTOR_FIXED_CONTENT","SELECTOR_STICKY_CONTENT","ScrollBarHelper","documentWidth","calculatedValue","styleProp","scrollbarWidth","manipulationCallBack","actualValue","callBack","EVENT_MOUSEDOWN","Backdrop","FocusTrap","ancestors","enableDismissTrigger","component","EVENT_LOAD_DATA_API","EVENT_KEYDOWN_DISMISS","completeCallBack","completeCallback","EVENT_CLOSE","EVENT_CLOSED","SHOW_DATA_ATTRIBUTE","timeout","ARROW_LEFT_KEY","ARROW_RIGHT_KEY","TOUCHEVENT_COMPAT_WAIT","SWIPE_THRESHOLD","ORDER_NEXT","ORDER_PREV","DIRECTION_LEFT","DIRECTION_RIGHT","KEY_TO_DIRECTION","EVENT_SLIDE","EVENT_SLID","EVENT_KEYDOWN","EVENT_MOUSEENTER","EVENT_MOUSELEAVE","EVENT_TOUCHSTART","EVENT_TOUCHMOVE","EVENT_TOUCHEND","EVENT_POINTERDOWN","EVENT_POINTERUP","EVENT_DRAG_START","ATTR_CAROUSEL","ATTR_ACTIVE","ATTR_SLIDE","ATTR_END","ATTR_START","ATTR_NEXT","ATTR_PREV","ATTR_POINTER_EVENT","SELECTOR_DATA_CAROUSEL_INIT","SELECTOR_DATA_ACTIVE","SELECTOR_DATA_ITEM","SELECTOR_DATA_ACTIVE_ITEM","SELECTOR_DATA_ITEM_IMG","SELECTOR_DATA_NEXT_PREV","SELECTOR_DATA_INDICATORS","SELECTOR_INDICATOR","SELECTOR_DATA_SLIDE","POINTER_TYPE_TOUCH","POINTER_TYPE_PEN","activeIndex","carousels","absDeltax","hasPointerPenTouch","itemImg","isNext","eventDirectionName","targetIndex","fromIndex","activeIndicator","indicators","elementInterval","directionOrOrder","activeElementIndex","nextElement","nextElementIndex","isCycling","directionalAttr","orderAttr","activeClass","nextClass","triggerSlidEvent","action","slideIndex","EVENT_HIDE_PREVENTED","EVENT_RESIZE","EVENT_CLICK_DISMISS","EVENT_MOUSEUP_DISMISS","EVENT_MOUSEDOWN_DISMISS","OPEN_SELECTOR_BODY","SELECTOR_DIALOG","SELECTOR_MODAL_BODY","htmlElement","modalBody","modalDialog","transitionComplete","isModalOverflowing","isBodyOverflowing","uriAttributes","ARIA_ATTRIBUTE_PATTERN","SAFE_URL_PATTERN","DATA_URL_PATTERN","allowedAttribute","allowedAttributeList","attributeName","regExp","attributeRegex","DefaultAllowlist","sanitizeHtml","unsafeHtml","createdDocument","elementName","attributeList","allowedAttributes","CLASS_PREFIX","DISALLOWED_ATTRIBUTES","AttachmentMap","CLASS_NAME_FADE","CLASS_NAME_MODAL","HOVER_STATE_SHOW","HOVER_STATE_OUT","SELECTOR_TOOLTIP_INNER","SELECTOR_MODAL","EVENT_MODAL_HIDE","TRIGGER_HOVER","TRIGGER_FOCUS","TRIGGER_CLICK","TRIGGER_MANUAL","showEvent","isInTheDom","tipId","attachment","prevHoverState","templateElement","eventIn","eventOut","originalTitleType","dataAttr","basicClassPrefixRegex","tabClass","token","tClass","SELECTOR_TITLE","SELECTOR_CONTENT","EVENT_ACTIVATE","EVENT_SCROLL","LINK_ACTIVE","SELECTOR_DROPDOWN_ITEM","SELECTOR_DATA_SPY","SELECTOR_NAV_LIST_GROUP","SELECTOR_NAV_LINKS","SELECTOR_NAV_ITEMS","SELECTOR_LIST_ITEMS","SELECTOR_LINK_ITEMS","SELECTOR_DROPDOWN","SELECTOR_DROPDOWN_TOGGLE","METHOD_OFFSET","METHOD_POSITION","autoMethod","offsetMethod","offsetBase","targetSelector","targetBCR","spy","MDBManipulator","maxScroll","queries","link","listGroup","navItem","DATA_NAME_DROPDOWN_MENU","TAB_ACTIVE","NAV_ACTIVE","SELECTOR_NAV","SELECTOR_TAB_ACTIVE","SELECTOR_NAV_ACTIVE","SELECTOR_ACTIVE_UL","SELECTOR_DROPDOWN_ACTIVE_CHILD","listElement","activeNavElement","itemSelector","hideEvent","navElement","isTransitioning","dropdownChild","dropdownElement","EVENT_MOUSEOVER","EVENT_MOUSEOUT","EVENT_FOCUSIN","EVENT_FOCUSOUT","HIDE_DATA_ATTRIBUTE","SHOWING_DATA_ATTRIBUTE","isInteracting","DATA_WRAPPER","DATA_NOTCH","DATA_NOTCH_LEADING","DATA_NOTCH_MIDDLE","DATA_NOTCH_TRAILING","DATA_HELPER","DATA_PLACEHOLDER_ACTIVE","DATA_ACTIVE","DATA_FOCUSED","DATA_FORM_COUNTER","SELECTOR_OUTLINE_INPUT","SELECTOR_OUTLINE_TEXTAREA","SELECTOR_NOTCH","SELECTOR_NOTCH_LEADING","SELECTOR_NOTCH_MIDDLE","SELECTOR_HELPER","targetId","actualLength","shadowLeading","shadowMiddle","shadowTrailing","allNotchWrappers","notchWrapper","border","prevLabelWidth","elementOffsetTop","elementHeight","windowHeight","shouldBeVisible","isElementVisible","GRADIENT","SELECTOR_COMPONENT","DEFAULT_RIPPLE_COLOR","BOOTSTRAP_COLORS","TRANSITION_BREAK_OPACITY","diameterOptions","diameter","radiusValue","rippleHTML","rippleEl","classesToRemove","defaultRipple","initialClasses","pythagorean","sideA","sideB","positionCenter","quadrant","getCorner","IS_BOOTSTRAP_COLOR","rgbValue","gradientImage","hexToRgb","namedColorsToRgba","tempElem","flag","rgbaToRgb","getDayNumber","getYear","getFirstDayOfWeek","firstDayIndex","sundayIndex","getDaysInMonth","getMonthEnd","createDate","getToday","addYears","years","addMonths","months","dayOfPreviousMonth","dayOfNewMonth","addDays","days","convertStringToDate","dateString","dateArr","isValidDate","compareDates","date1","date2","isSameDate","getYearsOffset","activeDate","yearsInView","yearsDifference","getStartYear","modulo","minDate","maxDate","startYear","isDateDisabled","disabledPast","disabledFuture","currentDate","isBeforeMin","isAfterMax","isDisabledPast","isDisabledFuture","isMonthDisabled","maxYear","maxMonth","minYear","minMonth","currentYear","isMonthAndYearAfterMax","isMonthAndYearBeforeMin","isMonthAndYearDisabledPast","isMonthAndYearDisabledFuture","isYearDisabled","isNextDateDisabled","areDatesInSameView","isPreviousDateDisabled","MODAL_CONTAINER_REF","DROPDOWN_CONTAINER_REF","BACKDROP_REF","DATE_TEXT_REF","VIEW_REF","PREVIOUS_BUTTON_REF","NEXT_BUTTON_REF","OK_BUTTON_REF","CANCEL_BUTTON_REF","CLEAR_BUTTON_REF","VIEW_CHANGE_BUTTON_REF","getDatepickerTemplate","selectedDate","selectedYear","selectedMonth","monthsInRow","yearsInRow","inlineContent","createMainContent","modalContent","createHeader","getBackdropTemplate","mainContentTemplate","createControls","createViewTemplate","createFooter","viewTemplate","createDayViewTemplate","createMonthViewTemplate","createYearViewTemplate","createViewChangeButtonIcon","okBtn","headerDate","dates","getDatesArray","tableHeadContent","tableBodyContent","firstDay","daysInMonth","daysInPreviousMonth","daysInWeek","isCurrentMonth","previousMonthDay","daysLeft","getMonthsArray","monthIndex","monthsRow","getYearsArray","yearsOffset","yearsRow","getToggleButtonTemplate","toggleBtnClasses","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","HOME","END","PAGE_UP","PAGE_DOWN","ENTER","SPACE","ESCAPE","TAB","BACKSPACE","DELETE","YEARS_IN_VIEW","YEARS_IN_ROW","MONTHS_IN_ROW","EVENT_OPEN","EVENT_DATE_CHANGE","MODAL_CONTAINER_NAME","DROPDOWN_CONTAINER_NAME","DATEPICKER_TOGGLE_SELECTOR","MODAL_CONTAINER_SELECTOR","DROPDOWN_CONTAINER_SELECTOR","VIEW_CHANGE_BUTTON_SELECTOR","PREVIOUS_BUTTON_SELECTOR","NEXT_BUTTON_SELECTOR","OK_BUTTON_SELECTOR","CANCEL_BUTTON_SELECTOR","CLEAR_BUTTON_SELECTOR","VIEW_SELECTOR","TOGGLE_BUTTON_SELECTOR","DATE_TEXT_SELECTOR","BACKDROP_SELECTOR","FADE_IN_CLASSES","FADE_OUT_CLASSES","FADE_IN_SHORT_CLASSES","FADE_OUT_SHORT_CLASSES","MODAL_CONTAINER_CLASSES","DATEPICKER_BACKDROP_CLASSES","DATEPICKER_MAIN_CLASSES","DATEPICKER_HEADER_CLASSES","DATEPICKER_TITLE_CLASSES","DATEPICKER_TITLE_TEXT_CLASSES","DATEPICKER_DATE_CLASSES","DATEPICKER_DATE_TEXT_CLASSES","DATEPICKER_VIEW_CLASSES","DATEPICKER_DATE_CONTROLS_CLASSES","DATEPICKER_VIEW_CHANGE_BUTTON_CLASSES","DATEPICKER_ARROW_CONTROLS_CLASSES","DATEPICKER_PREVIOUS_BUTTON_CLASSES","DATEPICKER_NEXT_BUTTON_CLASSES","DATEPICKER_FOOTER_CLASSES","DATEPICKER_FOOTER_BTN_CLASSES","DATEPICKER_CLEAR_BTN_CLASSES","DATEPICKER_DAY_HEADING_CLASSES","DATEPICKER_CELL_CLASSES","DATEPICKER_CELL_SMALL_CLASSES","DATEPICKER_CELL_LARGE_CLASSES","DATEPICKER_CELL_CONTENT_CLASSES","DATEPICKER_CELL_CONTENT_SMALL_CLASSES","DATEPICKER_CELL_CONTENT_LARGE_CLASSES","DATEPICKER_TABLE_CLASSES","DATEPICKER_TOGGLE_BUTTON_CLASSES","DATEPICKER_VIEW_CHANGE_ICON_CLASSES","DATEPICKER_DROPDOWN_CONTAINER_CLASSES","sortedWeekdaysNarrow","openEvent","cell","monthNames","dayNames","headerDateEl","isContainer","isContainerContent","oldActiveDate","previousActiveCell","cells","cellDate","cellYear","cellMonth","yearsPerRow","yearsPerPage","closeEvent","generatedToggleButton","currentSelected","currentFocused","ddd","dddd","mm","mmm","mmmm","yyyy","preformatted","formatted","datePart","newDate","delimeters","delimeterPattern","dateParts","formatParts","isMonthString","datesArray","monthsNames","monthValue","monthLabels","monthLabel","getTimepickerTemplate","normalTemplate","inlineTemplate","ATTR_TIMEPICKER_DISABLED","ATTR_TIMEPICKER_ACTIVE","formatToAmPm","originalHours","takeValue","formatNormalHours","toggleClassHandler","findMousePosition","object","isMobile","checkBrowser","isInput","compareTimes","time1","time2","time1Hour","time1Minutes","time1maxTimeFormat","time2Hour","time2Minutes","time2maxTimeFormat","getCurrentTime","currentHours","currentMinutes","setMinTime","currentTime","setMaxTime","checkValueBeforeAccept","hourHeader","maxTimeHour","maxTimeMin","maxTimeFormat","minTimeHour","minTimeMin","minTimeFormat","_verifyMaxTimeHourAndAddDisabledClass","_verifyMinTimeHourAndAddDisabledClass","_isHourDisabled","selectedHour","timeHour","operator","hourChange","_verifyMaxTimeMinutesTipsAndAddDisabledClass","maxMinutes","maxHour","currHour","_verifyMinTimeMinutesTipsAndAddDisabledClass","minMinutes","minHour","_convertHourToNumber","ATTR_NAME","SELECTOR_DATA_TE_TOGGLE","EVENT_MOUSEDOWN_DATA_API","EVENT_MOUSEUP_DATA_API","EVENT_MOUSEMOVE_DATA_API","EVENT_MOUSELEAVE_DATA_API","EVENT_MOUSEOVER_DATA_API","EVENT_TOUCHMOVE_DATA_API","EVENT_TOUCHEND_DATA_API","EVENT_TOUCHSTART_DATA_API","SELECTOR_ATTR_TIMEPICKER_AM","SELECTOR_ATTR_TIMEPICKER_PM","SELECTOR_ATTR_TIMEPICKER_FORMAT24","SELECTOR_ATTR_TIMEPICKER_CURRENT","SELECTOR_ATTR_TIMEPICKER_HOUR_MODE","SELECTOR_ATTR_TIMEPICKER_TOGGLE_BUTTON","ATTR_TIMEPICKER_BUTTON_CANCEL","ATTR_TIMEPICKER_BUTTON_CLEAR","ATTR_TIMEPICKER_BUTTON_SUBMIT","ATTR_TIMEPICKER_ICON","ATTR_TIMEPICKER_ICON_UP","ATTR_TIMEPICKER_ICON_DOWN","ATTR_TIMEPICKER_ICON_INLINE_HOUR","ATTR_TIMEPICKER_ICON_INLINE_MINUTE","ATTR_TIMEPICKER_ICONS_HOUR_INLINE","ATTR_TIMEPICKER_CURRENT_INLINE","ATTR_READONLY","ATTR_TIMEPICKER_INVALID_FEEDBACK","ATTR_TIMEPICKER_IS_INVALID","ATTR_TIMEPICKER_INPUT","ATTR_TIMEPICKER_CLOCK","ATTR_TIMEPICKER_CLOCK_INNER","ATTR_TIMEPICKER_WRAPPER","ATTR_TIMEPICKER_CLOCK_WRAPPER","ATTR_TIMEPICKER_HOUR","ATTR_TIMEPICKER_MINUTE","ATTR_TIMEPICKER_TIPS_ELEMENT","ATTR_TIMEPICKER_TIPS_HOURS","ATTR_TIMEPICKER_TIPS_MINUTES","ATTR_TIMEPICKER_INNER_HOURS","ATTR_TIMEPICKER_TIPS_INNER_ELEMENT","ATTR_TIMEPICKER_MIDDLE_DOT","ATTR_TIMEPICKER_HAND_POINTER","ATTR_TIMEPICKER_CIRCLE","ATTR_TIMEPICKER_MODAL","__publicField","findInArray","clockClass","tipsClass","maxTimeMinutes","minTimeMinutes","clock","rad","clockWidth","clockHeight","currentFormat","spanToTips","itemWidth","zero","hoursFormat","_amOrPm","maxFormat","minFormat","_isMouseOnInnerClock","maxHourDegrees","minHourDegrees","_handleKeyboardEvents","innerTips","currentHour","nextHourTip","numberToAdd","nextHour","innerTip","_handle24FormatMouseEvents","minInnerHourDegrees","maxInnerHourDegrees","minFormatAndCurrentFormatEqual","maxFormatAndCurrentFormatEqual","isMinHourValid","minDegrees","isMaxHourValid","maxDegrees","innerHour","hoursView","innerHoursExist","allTipsMinutes","allTipsHours","allInnerTips","hourTime","hourObjDegrees","minHourMinutes","minObjDegrees","addMinDegrees","innerHourDegrees","cancelBtn","rest","rotateDegrees","fixForInput","checkInputValue","initActive","minuteNumber","countMinutes","countHours","incrementHours","counteredNumber","incrementMinutes","addHours","addMinutes","subHours","subMinutes","_clearAndSetThisInterval","addHoursOrAddMinutes","isEventTypeMousedownOrTouchstart","isHourBtnFocused","isMinuteBtnFocused","isBodyFocused","runRemoveFunction","_a","hourModeActive","currentValue","selectedHourContent","selectedMinutes","isHourLessThanMinHour","isHourGreaterThanMaxHour","hourEqualToMaxAndMinutesGreaterThanMax","hourEqualToMinAndMinutesLessThanMin","allIconsInlineHour","allIconsInlineMinute","modifyIcons","shouldAdd","iconElements","hourValue","minuteValue","switchTips","toggleActiveClass","allTipsInnerHours","selectedFormat","outerHoursTips","innerHoursTips","allTipsHour","clockWrapper","mouseClick","rds","touchClick","xPos","yPos","elFromPoint","isHourlessThanMinOrGreaterThanMax","submitBtn","minTimeObj","_degrees","minuteTimes","changeMinutes","makeDegrees","touchDegrees","touchHours","movedDegrees","movedHours","allTipsInner","maxMin","minMin","maxHourTimeValue","minHourTimeValue","minHourTime","maxHourTime","maxMinDegrees","minMinDegrees","isToRemove","inValidDiv","regexAMFormat","regexNormalFormat","testedAMRegex","allInvalid","elMatches","query","queryChildren","cls","scrollingClassTimeout","addScrollingClass","removeScrollingClass","setScrollingClassInstantly","EventElement","prototypeAccessors","eventName","this$1","EventManager","onceHandler","processScrollDiff","useScrollingClass","forceFireReachEvent","fields","processScrollDiff$1","ref","up","down","toInt","isEditable","env","updateGeometry","roundedScrollTop","getThumbSize","updateCss","thumbSize","xRailOffset","yRailOffset","clickRail","positionTop","positionLeft","dragThumb","bindMouseScrollHandler","startingScrollTop","startingMousePageY","scrollBy","mouseMoveHandler","mouseUpHandler","bindMoves","touchMode","elementHovered","scrollbarFocused","shouldPreventDefault","isTop","isBottom","isLeft","isRight","hitsBound","getDeltaFromEvent","shouldBeConsumedByChild","maxScrollTop","maxScrollLeft","mousewheelHandler","shouldPrevent","magnitudeX","magnitudeY","applyTouchMove","differenceX","differenceY","startOffset","startTime","speed","easingLoop","getTouch","shouldHandle","touchStart","touchMove","currentOffset","timeGap","touchEnd","defaultSettings","PerfectScrollbar","userSettings","originalScrollLeft","railXStyle","railYStyle","handlerName","Swipe","displacement","Touch","psClasses","railXClasses","railXThumbClasses","railYClasses","railYThumbClasses","addPerfectScrollbarStyles","ARROW_DATA","SELECTOR_TOGGLE","SELECTOR_TOGGLE_COLLAPSE","SELECTOR_SHOW_SLIM","SELECTOR_HIDE_SLIM","SELECTOR_NAVIGATION","SELECTOR_COLLAPSE","SELECTOR_LINK","TRANSLATION_LEFT","TRANSLATION_RIGHT","OPTIONS_TYPE","findContainer","containerStart","containerEnd","boundry","breakpointsList","overCalculated","sideCalculated","pushCalculated","sortAsc","closestPositive","initialValue","arg","inverseDirecion","collapsible","ID","searchFor","singleClass","siblingsHeight","wave","category","collapseToggler","optionColor","isSlimCollapsed","tabIndexValue","collapsed","slim","slimCollapsedElements","fullWidthElements","toggleElements","startEvent","completeEvent","paddingPosition","marginPosition","elementSelector","REF","STEPPER_HORIZONTAL","STEPPER_VERTICAL","EVENT_KEYUP","STEP_REF","HEAD_REF","HEAD_TEXT_REF","HEAD_ICON_REF","CONTENT_REF","stepperHeadText","stepperHeadIcon","stepHead","stepIndex","shouldBeHorizontal","shouldBeVertical","shouldBeMobile","stepContent","stepComputed","stepHeight","isActiveStep","stepContentHeight","focusedStep","prevStep","focusedStepHead","activeStepHead","nextStepHead","prevStepHead","firstStepHead","lastStep","lastStepHead","focusedElement","newTarget","stepperHead","stepElement","contentStyle","headStyle","stepHeadHeight","isForward","nextStepContent","activeStepContent","nextStepAnimation","activeStepAnimation","CLASS_NAME_SLIDE_RIGHT","CLASS_NAME_SLIDE_LEFT","CLASS_NAME_SLIDE_IN","DATA_SELECTED","DATA_MULTIPLE_ACTIVE","SELECTOR_FORM_CHECK_INPUT","SelectOption","checkbox","SelectionModel","option","optionIndex","allOptionsSelected","DATA_FORM_OUTLINE","DATA_SELECT_WRAPPER","DATA_SELECT_INPUT","DATA_CLEAR_BUTTON","DATA_SELECT_DROPDOWN_CONTAINER","DATA_DROPDOWN","DATA_OPTIONS_WRAPPER","DATA_OPTIONS_LIST","DATA_FILTER_INPUT","DATA_OPTION","DATA_OPTION_ALL","DATA_SELECT_OPTION_TEXT","DATA_FORM_CHECK_INPUT","DATA_SELECT_OPTION_GROUP","DATA_SELECT_OPTION_GROUP_LABEL","iconSVGTemplate","preventKeydown","_setSizeClasses","defaultSize","smSize","lgSize","getWrapperTemplate","role","multiselectable","validFeedback","validFeedBackText","invalidFeedback","invalidFeedBackText","clearBtn","getDropdownTemplate","selectAllOption","customContent","dropdownContainer","getOptionsListTemplate","getFilterTemplate","optionsNodes","getMultipleOptionsNodes","getSingleOptionsNodes","getOptionsNodes","selectAllNode","createSelectAllNode","nodes","group","createOptionGroupTemplate","createOptionTemplate","optionNode","getOptionContentTemplate","getOptionIconTemplate","getCheckboxTemplate","getSecondaryTextTemplate","image","optionGroup","getFakeValueTemplate","fakeValue","EVENT_SELECT","EVENT_DESELECT","EVENT_VALUE_CHANGE","EVENT_CHANGE","DATA_SELECT_INIT","DATA_NO_RESULT","DATA_OPEN","DATA_DISABLED","SELECTOR_LABEL","SELECTOR_INPUT","SELECTOR_FILTER_INPUT","SELECTOR_OPTIONS_WRAPPER","SELECTOR_OPTIONS_LIST","SELECTOR_OPTION","SELECTOR_CLEAR_BUTTON","SELECTOR_CUSTOM_CONTENT","SELECTOR_NO_RESULTS","SELECTOR_FORM_OUTLINE","ANIMATION_TRANSITION_TIME","optionsToRender","nestedOption","groupDisabled","availableOptions","containerSelector","inputWrapper","isCloseKey","visibleOptions","groupsNumber","scrollToIndex","listHeight","optionHeight","optionOffset","isBelow","groupsList","newActiveOption","currentActiveOption","isValueEmpty","selectAllSelected","allSelected","inputWidth","currentActive","firstSelected","searchTerm","debounceTime","filtered","isOptionGroup","isValidOption","hasNoResultsText","hasFilteredOptions","noResultsTemplate","optionsWrapperContent","optionsListTemplate","filterValue","isSelectContent","isDropdown","isDropdownContent","isButton","hasFilterValue","wrapperParent","selectionValue","correspondingOption","jqueryInit","JQUERY_NO_CONFLICT","dropdownCallback","initSelector","tabCallback","offcanvasCallback","allReadyOpen","buttonCallback","modalCallback","rippleCallback","collapseCallback","DEFAULT_LEGEND_COLOR","defaultInitSelectors","IS_COMPLEX","CONVERT_DATA_TYPE","PARSE_DATA","chartProperty","dataSet","getComponentData","initComponent","thisComponent","components","checkOtherImports","componentList","getInputField","getChip","ATTR_CHIP_CLOSE","ATTR_SELECTOR_CHIP_CLOSE","EVENT_DELETE","defaultIcon","createIcon","ATTR_CHIPS_INIT","ATTR_CHIPS_ACTIVE","ATTR_CHIPS_INITIAL","ATTR_CHIPS_PLACEHOLDER","ATTR_CHIPS_WRAPPER","ATTR_CHIP_INIT","ATTR_CHIP_TEXT","ATTR_SELECTOR_CHIPS_ACTIVE","ATTR_SELECTOR_CHIP_INIT","ATTR_SELECTOR_CHIP_ACTIVE","ATTR_SELECTOR_CLOSE","ATTR_SELECTOR_CHIPS_WRAPPER","ATTR_SELECTOR_CHIP_TEXT","ATTR_SELECTOR_CHIPS_PLACEHOLDER","ATTR_INPUT_STATE_ACTIVE","ATTR_SELECTOR_INPUT_NOTCH_REF","EVENT_ADD","EVENT_ARROW_DOWN","EVENT_ARROW_LEFT","EVENT_ARROW_RIGHT","EVENT_ARROW_UP","activeChipAfter","chipText","num","chipIndex","filterActive","attrList","inputField","divElement","divWithChips","isNonNullObject","isSpecial","stringValue","isReactElement","canUseSymbol","REACT_ELEMENT_TYPE","emptyTarget","deepmerge","defaultArrayMerge","getMergeFunction","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","deepmerge_1","cjs","CLASSNAME_CHARTS","GENERATE_DATA","defaultType","mergeObjects","merge","DEFAULT_DARK_OPTIONS","DARK_OPTIONS_TYPE","Chart$1","darkOptions","Chartjs","xyScale","opt","systemColor","mutationList","mutation","dark","chartData","chartOptions","isNullOrUndef","isObject","isNumberFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","toDimension","thisArg","loopable","_elementsEqual","a0","a1","v0","v1","clone$1","klen","isValidKey","_merger","tval","sval","sources","mergeIf","_mergerIf","keyResolvers","resolveObjectKey","_getKeyResolver","_splitKey","parts","tmp","part","_capitalize","defined","isFunction","setsEqual","_isClickEvent","TAU","PITAU","INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","niceNum","range","roundedRange","almostEquals","niceRange","fraction","_factorize","isNumber","epsilon","almostWhole","rounded","_setMinAndMaxByKey","toRadians","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_lookup","table","cmp","mid","_lookupByKey","_rlookupByKey","_filterBetween","arrayEvents","listenArrayEvents","listener","unlistenArrayEvents","stub","_arrayUnique","requestAnimFrame","throttled","updateFn","updateArgs","ticking","_toLeftRightCenter","_alignStartEnd","_textX","_getStartAndCountOfVisiblePoints","animationsDisabled","pointCount","_scaleRangesChanged","newRanges","atEdge","elasticIn","elasticOut","effects","lim","p2b","n2b","b2n","n2p","map$1","hex","eq","isShort","hexParse","ret","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","hueValue","rgb2hsl","calln","hsl2rgb","hwb2rgb","hsv2rgb","hue","hueParse","p2","deg","names$1","unpack","unpacked","tkeys","nk","names","nameParse","RGB_RE","rgbParse","rgb1","rgb2","modHSL","proto","fromObject","functionParse","Color","c1","c2","w2","w1","index_esm","isPatternOrGradient","getHoverColor","getScope$1","Defaults","targetScope","targetName","scopeObject","targetScopeObject","privateName","toFontString","_measureText","longest","textWidth","_longestText","arrayOfThings","cache","jlen","thing","nestedThing","gcLen","_alignPixel","pixel","halfWidth","clearCanvas","drawPoint","drawPointLegend","xOffset","yOffset","_isPointInArea","clipArea","unclipArea","_steppedLineTo","midpoint","_bezierCurveTo","renderText","opts","setRenderOpts","decorateText","metrics","yDecoration","addRoundedRectPath","LINE_HEIGHT","FONT_STYLE","toLineHeight","numberOrZero","_readValueToProps","props","objProps","prop","toTRBL","toTRBLCorners","toPadding","toFont","inputs","info","_addGrace","minmax","change","keepZero","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","getTarget","_resolve","_cached","_resolveWithPrefixes","getKeysFromAllScopes","storage","_attachContext","proxy","subProxy","descriptorDefaults","receiver","_resolveWithContext","readKey","needsSubResolver","_resolveScriptable","_resolveArray","createSubResolver","resolveFallback","getScope","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","getPoint","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","delta","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","inArea","inAreaPrev","inAreaNext","_updateBezierControlPoints","controlPoints","_isDomSupported","_getParentNode","domNode","parseMaxStyle","styleValue","parentProperty","valueInPixels","positions","getPositionedStyle","suffix","useOffsetPos","getCanvasPosition","getRelativePosition","borderBox","paddings","borders","getContainerSize","containerStyle","containerBorder","containerPadding","round1","bbWidth","bbHeight","margins","containerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","supportsEventListenerOptions","passiveSupported","readUsedSize","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","intlCache","getNumberFormat","cacheKey","formatNumber","getRightToLeftAdapter","rectX","getLeftToRightAdapter","_itemWidth","getRtlAdapter","overrideTextDirection","original","restoreTextDirection","propertyFn","normalizeSegment","getSegment","startBound","endBound","_boundSegment","inside","subStart","prevValue","startIsBefore","endIsBefore","shouldStart","shouldStop","_boundSegments","findStartAndEnd","solidSegments","cur","_computeSegments","segmentOptions","splitByStyles","completeLoop","doSplitByStyles","chartContext","baseStyle","readStyle","prevStyle","styleChanged","Animator","anims","remaining","charts","cb","interpolators","c0","cfg","elapsed","remain","promises","resolved","animationOptions","animatedProps","newOptions","resolveTargetOptions","awaitAll","anim","scaleClip","allowedOverflow","defaultClip","toClip","getSortedDatasetIndices","filterVisible","metasets","dsIndex","singleMode","otherValue","convertObjectDataToArray","adata","isStacked","getStackKey","indexScale","valueScale","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","positive","updateStacks","iAxis","vAxis","itemStacks","getFirstScaleId","createDatasetContext","createDataContext","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","createStack","canStack","chooseId","xid","yid","rid","iid","vid","scaleID","resetNewElements","stackChanged","oldStacked","scopeKeys","sorted","isNotInOrderComparedToPrev","singleScale","parsedValue","otherScale","otherMin","otherMax","elementType","sharing","firstOpts","previouslySharedOptions","arg1","arg2","numMeta","numData","removed","newCount","getAllScaleValues","visibleMetas","computeMinSampleSize","curr","updateMinAndPrev","computeFitCategoryTraits","ruler","thickness","computeFlexCategoryTraits","percent","parseFloatBar","entry","startValue","endValue","parseValue","parseArrayOrPrimitive","isFloatBar","custom","barSign","actualBase","borderProps","setBorderSkipped","edge","parseEdge","swap","startEnd","orig","v2","setInflateAmount","iAxisKey","vAxisKey","bars","vpixels","ipixels","baseValue","floating","startPixel","endPixel","halfGrid","stackIndex","getRatioAndOffset","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getter","arcs","maxSize","chartWeight","maxRadius","radiusLength","animationOpts","centerX","centerY","metaData","ringWeightOffset","legendItem","tooltipItem","dataLabel","maxGapLength","directUpdate","prevParsed","nullData","lastPoint","minSize","datasetStartAngle","defaultAngle","pointPosition","Element$1","useFinalPosition","final","tickValue","maxTick","calculateDelta","logDelta","numDecimal","defaults$1","tickOpts","ticksLimit","determineMaxTicks","majorIndices","getMajorIndices","numMajorIndices","newTicks","skipMajors","calculateSpacing","avgMajorSpacing","maxScale","maxChart","evenMajorSpacing","getEvenSpacing","factors","majorStart","majorEnd","reverseAlign","offsetFromEdge","sample","numItems","getPixelForGridLine","offsetGridLines","validIndex","lineValue","caches","getTickMarkLength","getTitleHeight","createScaleContext","createTickContext","titleArgs","positionAxisID","metas","samplingEnabled","reversePixels","numTicks","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetRight","widestLabelSize","highestLabelSize","tickFont","fontString","nestedLabel","valueAt","idx","decimal","optionTicks","rot","ticksLength","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","limit","optsAtIndex","lineColor","tickAndPadding","hTickAndPadding","lineCount","halfCount","tickTextAlign","labelPadding","drawLine","lastLineWidth","tz","gz","axisID","fontSize","TypedRegistry","parentScope","isIChartComponent","registerDefaults","itemDefaults","routeDefaults","routes","propertyParts","sourceName","sourceScope","Registry","typedRegistry","reg","itemReg","camelMethod","abstract","DateAdapter","timestamp","amount","weekday","members","binarySearch","metaset","lookupMethod","getDistanceMetricForAxis","useX","useY","getIntersectItems","getNearestRadialItems","evaluationFunc","getNearestCartesianItems","distanceMetric","minDistance","getNearestItems","getAxisItems","rangeMethod","intersectsItem","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","wrapBoxes","layoutBoxes","buildStacks","setLayoutDims","params","buildLayoutBoxes","centerHorizontal","centerVertical","getCombinedMax","updateMaxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","handleMaxPadding","updatePos","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","layoutItem","minPadding","verticalBoxes","horizontalBoxes","visibleVerticalBoxCount","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","initCanvas","renderHeight","renderWidth","displayWidth","displayHeight","eventListenerOptions","addListener","removeListener","fromNativeEvent","nodeListContains","nodeList","createAttachObserver","observer","entries","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","listenDevicePixelRatioChanges","unlistenDevicePixelRatioChanges","createResizeObserver","releaseObserver","createProxyAndListen","proxies","PluginService","hook","descriptor","allPlugins","createDescriptors","previousDescriptors","getOpts","pluginOpts","getIndexAxis","datasetDefaults","getAxisFromDefaultScaleID","getDefaultScaleIDFromAxis","axisFromPosition","determineAxis","scaleOptions","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","firstIDs","scaleConf","defaultId","defaultScaleOptions","defaultID","initOptions","initData","initConfig","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","datasetType","mainScope","resetCache","keyLists","getResolver","needContext","subResolver","resolverCache","hasFunction","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","moveNumericKeys","intKey","determineLastEvent","lastEvent","isClick","userConfig","initialCanvas","existingChart","newSize","newRatio","scalesOptions","axisOptions","scaleOpts","updated","isRadial","scaleType","scaleClass","hasUpdated","newControllers","ControllerClass","animsDisabled","existingEvents","newEvents","changes","datasetCount","makeSet","changeSet","noArea","layers","useClip","_add","_remove","detached","activeElements","lastActive","hoverOptions","deactivated","activated","eventFilter","invalidatePlugins","clipArc","angleMargin","toRadiusCorners","parseBorderRadius$1","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","rThetaToXY","theta","pathArc","innerR","spacingOffset","noSpacingInnerRadius","noSpacingOuterRadius","avNogSpacingRadius","adjustedAngle","beta","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","pCenter","p4","p8","outerStartX","outerStartY","outerEndX","outerEndY","drawArc","drawFullCircleBorders","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","setStyle","getLineMethod","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","lineMethod","fastPathSegment","avgX","countX","prevX","lastY","pointIndex","drawX","truncX","_getSegmentMethod","_getInterpolationMethod","strokePathWithCache","strokePathDirect","segmentMethod","usePath2D","_interpolate","interpolated","inRange$1","mouseX","mouseY","getBarBounds","half","skipOrLimit","parseBorderWidth","maxW","maxH","parseBorderRadius","maxR","enableBorder","boundingRects","skipX","skipY","hasRadius","addNormalRectPath","inflateRect","refRect","addRectPath","lttbDecimation","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","minMaxDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","cleanDecimatedDataset","cleanDecimatedData","getStartAndCountOfVisiblePointsSimplified","plugin_decimation","xAxis","tpoints","_findSegmentEnd","_getBounds","targetSegments","tgt","subBounds","fillSources","fillSource","_getEdge","_pointsFromSegments","linePoints","_createBoundaryLine","_shouldApplyFill","_resolveTarget","_decodeFill","parseFillOption","decodeTargetIndex","firstCh","_getTargetPixel","_getTargetValue","fillOption","_buildStackLine","sourcePoints","linesBelow","getLinesBelow","addPointsBelow","sourcePoint","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","computeBoundary","computeCircularBoundary","computeLinearBoundary","_drawfill","lineOpts","doFill","clipVertical","clipY","lineLoop","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","_args","getBoxSize","labelOpts","itemsEqual","labelFont","hitboxes","totalHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","rtlHelper","hitbox","defaultColor","halfFontSize","drawLegendBox","drawOptions","yBoxTop","xBoxLeft","realX","titlePadding","topPaddingPlusHalfFontSize","hitBox","isListened","hoveredItem","sameItem","plugin_legend","fontOpts","createTitle","plugin_title","plugin_subtitle","eventPosition","nearestElement","pushOrConcat","toPush","splitNewlines","createTooltipItem","getTooltipSize","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","bodyLineHeight","widthPadding","maxLineWidth","determineYAlign","doesNotFitWithAlign","caret","determineXAlign","chartWidth","determineAlignment","alignX","alignY","paddingAndSize","getBackgroundPoint","alignment","getAlignedX","getBeforeAfterBodyLines","createTooltipContext","overrideCallbacks","bodyItems","scoped","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","colorX","rtlColorX","yOffSet","colorY","outerX","innerX","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","hasTooltipContent","positionChanged","plugin_tooltip","labelCount","addIfString","addedLabels","findOrAddLabel","added","generateTicks$1","generationOptions","dataRange","maxSpaces","rmin","rmax","countDefined","minSpacing","niceMin","niceMax","numSpaces","decimalPlaces","relativeLabelSize","LinearScaleBase","setMin","setMax","minSign","maxSign","numericGeneratorOptions","isMajor","tickVal","generateTicks","endExp","endSignificand","exp","significand","lastTick","getTickBackdropHeight","measureLabelSize","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","additionalAngle","plFont","hLimits","vLimits","updateLimits","buildPointLabelItems","extra","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabels","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","drawRadiusLine","gridLineOpts","createPointLabelContext","leftMovement","rightMovement","topMovement","bottomMovement","angleMultiplier","scalingFactor","scaledDistance","pointLabel","distanceFromCenter","INTERVALS","UNITS","sorter","adapter","determineUnitForAutoTicks","capacity","determineUnitForFormatting","determineMajorUnit","addTick","timestamps","setMajorTicks","majorUnit","ticksFromTimestamps","_applyBounds","timeOpts","hasWeekday","minorFormat","majorFormat","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","utils","updates","orient","aligned","R_INSIDE","R_LEFT","R_RIGHT","R_BOTTOM","R_TOP","region","clipped","r0","r1","compute$1","ry","sy","ty","getScaleOrigin","getPositioner","drawRoundedRect","drawFrame","bgColor","textGeometry","drawTextLine","shadow","drawText","Label","MIN_INTEGER","MAX_INTEGER","rotated","cx","cy","projected","toAxis","HitBox","axes","pr0","pr1","coordinates","collide","collider","s0","s1","compute","h0","sb","dirty","DEFAULT_KEY","configs","groups","callback$1","dispatchMoveEvents","handleMoveEvents","expando","handleClickEvents"],"version":3,"file":"index.7d9b9be0.js.map"}